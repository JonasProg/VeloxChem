//
//                             VELOXCHEM
//      ---------------------------------------------------
//                     An Electronic Structure Code
//
//  Copyright Â© 2019 by VeloxChem developers. All rights reserved.
//  Contact: Zilvinas Rinkevicius (rinkevic@kth.se), KTH, Sweden.

#include "NuclearPotentialRecFuncForDX.hpp"

namespace npotrecfunc { // npotrecfunc namespace

    void
    compNuclearPotentialForDD(      CMemBlock2D<double>& primBuffer,
                              const CMemBlock2D<double>& auxBuffer,
                              const CMemBlock2D<double>& osFactors,
                              const CMemBlock2D<double>& paDistances,
                              const CMemBlock2D<double>& pbDistances,
                              const CMemBlock2D<double>& pcDistances,
                              const CGtoBlock&           braGtoBlock,
                              const CGtoBlock&           ketGtoBlock,
                              const int32_t              iContrGto)
    {
        npotrecfunc::compNuclearPotentialForDD_0_3(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_3_6(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_6_9(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_9_12(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                    braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_12_15(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_15_18(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_18_21(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_21_24(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_24_27(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_27_30(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_30_33(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDD_33_36(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 
    }

    void
    compNuclearPotentialForDD_0_3(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (0,3)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(34 * idx + 9);

            auto pc_xxy = pcDistances.data(34 * idx + 10);

            auto pc_xxz = pcDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(34 * idx + 19);

            auto pc_xxxy = pcDistances.data(34 * idx + 20);

            auto pc_xxxz = pcDistances.data(34 * idx + 21);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_xx_xx = primBuffer.data(36 * idx);

            auto t_xx_xy = primBuffer.data(36 * idx + 1);

            auto t_xx_xz = primBuffer.data(36 * idx + 2);

            // Batch of Integrals (0,3)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxy, pc_xxxz, pc_xxy, pc_xxz, pc_xy, pc_xz, pc_y, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, t_xx_xx, t_xx_xy, t_xx_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xx[j] = fl_s_0_0_0 * (0.75 * fl2_fx + 0.5 * pa_xx[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pb_xx[j] + pa_xx[j] * pb_xx[j]);

                t_xx_xx[j] += fl_s_0_0_1 * (-1.5 * fl2_fx - 0.5 * pa_xx[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pb_x[j] - 3.0 * pc_x[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pb_xx[j] - 2.0 * pa_xx[j] * pb_x[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xx[j]);

                t_xx_xx[j] += fl_s_0_0_2 * (0.75 * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl1_fx + 3.0 * pc_xx[j] * fl1_fx + 3.0 * pc_x[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xx[j] + 4.0 * pa_x[j] * pc_xx[j] * pb_x[j] + pc_xx[j] * pb_xx[j]);

                t_xx_xx[j] += fl_s_0_0_3 * (-3.0 * pc_xx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxx[j] - 2.0 * pc_xxx[j] * pb_x[j]);

                t_xx_xx[j] += fl_s_0_0_4 * pc_xxxx[j];

                t_xx_xy[j] = fl_s_0_0_0 * (pa_x[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pb_xy[j] + pa_xx[j] * pb_xy[j]);

                t_xx_xy[j] += fl_s_0_0_1 * (-pa_x[j] * fl1_fx * pc_y[j] - pa_x[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * fl1_fx * pb_xy[j] - pa_xx[j] * pb_x[j] * pc_y[j] - pa_xx[j] * pc_x[j] * pb_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xy[j]);

                t_xx_xy[j] += fl_s_0_0_2 * (pa_x[j] * fl1_fx * pc_y[j] + 1.5 * pc_xy[j] * fl1_fx + 1.5 * pc_x[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pb_x[j] * pc_y[j] + pa_xx[j] * pc_xy[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_y[j] + pc_xx[j] * pb_xy[j]);

                t_xx_xy[j] += fl_s_0_0_3 * (-1.5 * pc_xy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxy[j] - pc_xxy[j] * pb_x[j] - pc_xxx[j] * pb_y[j]);

                t_xx_xy[j] += fl_s_0_0_4 * pc_xxxy[j];

                t_xx_xz[j] = fl_s_0_0_0 * (pa_x[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_xz[j] + pa_xx[j] * pb_xz[j]);

                t_xx_xz[j] += fl_s_0_0_1 * (-pa_x[j] * fl1_fx * pc_z[j] - pa_x[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pb_xz[j] - pa_xx[j] * pb_x[j] * pc_z[j] - pa_xx[j] * pc_x[j] * pb_z[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xz[j]);

                t_xx_xz[j] += fl_s_0_0_2 * (pa_x[j] * fl1_fx * pc_z[j] + 1.5 * pc_xz[j] * fl1_fx + 1.5 * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_x[j] * pc_z[j] + pa_xx[j] * pc_xz[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_z[j] + pc_xx[j] * pb_xz[j]);

                t_xx_xz[j] += fl_s_0_0_3 * (-1.5 * pc_xz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxz[j] - pc_xxz[j] * pb_x[j] - pc_xxx[j] * pb_z[j]);

                t_xx_xz[j] += fl_s_0_0_4 * pc_xxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_3_6(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (3,6)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(34 * idx + 10);

            auto pc_xxz = pcDistances.data(34 * idx + 11);

            auto pc_xyy = pcDistances.data(34 * idx + 12);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_xzz = pcDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(34 * idx + 22);

            auto pc_xxyz = pcDistances.data(34 * idx + 23);

            auto pc_xxzz = pcDistances.data(34 * idx + 24);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_xx_yy = primBuffer.data(36 * idx + 3);

            auto t_xx_yz = primBuffer.data(36 * idx + 4);

            auto t_xx_zz = primBuffer.data(36 * idx + 5);

            // Batch of Integrals (3,6)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xx, pc_xxy, pc_xxyy, \
                                     pc_xxyz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yz, pc_z, \
                                     pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_xx_yy, t_xx_yz, t_xx_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_yy[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_xx[j] * fl1_fx + 0.5 * fl1_fx * pb_yy[j] + pa_xx[j] * pb_yy[j]);

                t_xx_yy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_xx[j] * fl1_fx - pa_x[j] * pc_x[j] * fl1_fx - fl1_fx * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pb_yy[j] - 2.0 * pa_xx[j] * pb_y[j] * pc_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yy[j]);

                t_xx_yy[j] += fl_s_0_0_2 * (0.25 * fl2_fx + pa_x[j] * pc_x[j] * fl1_fx + 0.5 * pc_xx[j] * fl1_fx + 0.5 * fl1_fx * pc_yy[j] + fl1_fx * pb_y[j] * pc_y[j] + pa_xx[j] * pc_yy[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_y[j] + pc_xx[j] * pb_yy[j]);

                t_xx_yy[j] += fl_s_0_0_3 * (-0.5 * pc_xx[j] * fl1_fx - 0.5 * fl1_fx * pc_yy[j] - 2.0 * pa_x[j] * pc_xyy[j] - 2.0 * pc_xxy[j] * pb_y[j]);

                t_xx_yy[j] += fl_s_0_0_4 * pc_xxyy[j];

                t_xx_yz[j] = fl_s_0_0_0 * (0.5 * fl1_fx * pb_yz[j] + pa_xx[j] * pb_yz[j]);

                t_xx_yz[j] += fl_s_0_0_1 * (-0.5 * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pb_yz[j] - pa_xx[j] * pb_y[j] * pc_z[j] - pa_xx[j] * pc_y[j] * pb_z[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yz[j]);

                t_xx_yz[j] += fl_s_0_0_2 * (0.5 * fl1_fx * pc_yz[j] + 0.5 * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_z[j] + pa_xx[j] * pc_yz[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_z[j] + pc_xx[j] * pb_yz[j]);

                t_xx_yz[j] += fl_s_0_0_3 * (-0.5 * fl1_fx * pc_yz[j] - 2.0 * pa_x[j] * pc_xyz[j] - pc_xxz[j] * pb_y[j] - pc_xxy[j] * pb_z[j]);

                t_xx_yz[j] += fl_s_0_0_4 * pc_xxyz[j];

                t_xx_zz[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_xx[j] * fl1_fx + 0.5 * fl1_fx * pb_zz[j] + pa_xx[j] * pb_zz[j]);

                t_xx_zz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_xx[j] * fl1_fx - pa_x[j] * pc_x[j] * fl1_fx - fl1_fx * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pb_zz[j] - 2.0 * pa_xx[j] * pb_z[j] * pc_z[j] - 2.0 * pa_x[j] * pc_x[j] * pb_zz[j]);

                t_xx_zz[j] += fl_s_0_0_2 * (0.25 * fl2_fx + pa_x[j] * pc_x[j] * fl1_fx + 0.5 * pc_xx[j] * fl1_fx + 0.5 * fl1_fx * pc_zz[j] + fl1_fx * pb_z[j] * pc_z[j] + pa_xx[j] * pc_zz[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_z[j] + pc_xx[j] * pb_zz[j]);

                t_xx_zz[j] += fl_s_0_0_3 * (-0.5 * pc_xx[j] * fl1_fx - 0.5 * fl1_fx * pc_zz[j] - 2.0 * pa_x[j] * pc_xzz[j] - 2.0 * pc_xxz[j] * pb_z[j]);

                t_xx_zz[j] += fl_s_0_0_4 * pc_xxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_6_9(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (6,9)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(34 * idx + 9);

            auto pc_xxy = pcDistances.data(34 * idx + 10);

            auto pc_xxz = pcDistances.data(34 * idx + 11);

            auto pc_xyy = pcDistances.data(34 * idx + 12);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(34 * idx + 20);

            auto pc_xxyy = pcDistances.data(34 * idx + 22);

            auto pc_xxyz = pcDistances.data(34 * idx + 23);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_xy_xx = primBuffer.data(36 * idx + 6);

            auto t_xy_xy = primBuffer.data(36 * idx + 7);

            auto t_xy_xz = primBuffer.data(36 * idx + 8);

            // Batch of Integrals (6,9)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxx, \
                                     pc_xxxy, pc_xxy, pc_xxyy, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyz, pc_xz, pc_y, pc_yy, \
                                     pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_xy_xx, t_xy_xy, t_xy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xx[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl1_fx + fl1_fx * pa_y[j] * pb_x[j] + pa_xy[j] * pb_xx[j]);

                t_xy_xx[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_y[j] * fl1_fx - fl1_fx * pc_y[j] * pb_x[j] - fl1_fx * pa_y[j] * pb_x[j] - 2.0 * pa_xy[j] * pb_x[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xx[j] - pc_x[j] * pa_y[j] * pb_xx[j]);

                t_xy_xx[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * pc_y[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx + fl1_fx * pc_y[j] * pb_x[j] + pa_xy[j] * pc_xx[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_x[j] + 2.0 * pc_xx[j] * pa_y[j] * pb_x[j] + pc_xy[j] * pb_xx[j]);

                t_xy_xx[j] += fl_s_0_0_3 * (-1.5 * pc_xy[j] * fl1_fx - pa_x[j] * pc_xxy[j] - pc_xxx[j] * pa_y[j] - 2.0 * pc_xxy[j] * pb_x[j]);

                t_xy_xx[j] += fl_s_0_0_4 * pc_xxxy[j];

                t_xy_xy[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_x[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_y[j] * pb_y[j] + pa_xy[j] * pb_xy[j]);

                t_xy_xy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_x[j] * fl1_fx * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] - 0.5 * pc_x[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_y[j] * pc_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_y[j] - 0.5 * fl1_fx * pa_y[j] * pb_y[j] - pa_xy[j] * pb_x[j] * pc_y[j] - pa_xy[j] * pc_x[j] * pb_y[j] - pa_x[j] * pc_y[j] * pb_xy[j] - pc_x[j] * pa_y[j] * pb_xy[j]);

                t_xy_xy[j] += fl_s_0_0_2 * (0.25 * fl2_fx + 0.5 * pa_x[j] * fl1_fx * pc_x[j] + 0.5 * pc_xx[j] * fl1_fx + 0.5 * pc_x[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_yy[j] + 0.5 * fl1_fx * pa_y[j] * pc_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_y[j] + pa_xy[j] * pc_xy[j] + pa_x[j] * pc_yy[j] * pb_x[j] + pa_x[j] * pc_xy[j] * pb_y[j] + pc_xy[j] * pa_y[j] * pb_x[j] + pc_xx[j] * pa_y[j] * pb_y[j] + pc_xy[j] * pb_xy[j]);

                t_xy_xy[j] += fl_s_0_0_3 * (-0.5 * pc_xx[j] * fl1_fx - 0.5 * fl1_fx * pc_yy[j] - pa_x[j] * pc_xyy[j] - pc_xxy[j] * pa_y[j] - pc_xyy[j] * pb_x[j] - pc_xxy[j] * pb_y[j]);

                t_xy_xy[j] += fl_s_0_0_4 * pc_xxyy[j];

                t_xy_xz[j] = fl_s_0_0_0 * (0.5 * fl1_fx * pa_y[j] * pb_z[j] + pa_xy[j] * pb_xz[j]);

                t_xy_xz[j] += fl_s_0_0_1 * (-0.5 * fl1_fx * pa_y[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pb_z[j] - pa_xy[j] * pb_x[j] * pc_z[j] - pa_xy[j] * pc_x[j] * pb_z[j] - pa_x[j] * pc_y[j] * pb_xz[j] - pc_x[j] * pa_y[j] * pb_xz[j]);

                t_xy_xz[j] += fl_s_0_0_2 * (0.5 * fl1_fx * pc_yz[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_z[j] + pa_xy[j] * pc_xz[j] + pa_x[j] * pc_yz[j] * pb_x[j] + pa_x[j] * pc_xy[j] * pb_z[j] + pc_xz[j] * pa_y[j] * pb_x[j] + pc_xx[j] * pa_y[j] * pb_z[j] + pc_xy[j] * pb_xz[j]);

                t_xy_xz[j] += fl_s_0_0_3 * (-0.5 * fl1_fx * pc_yz[j] - pa_x[j] * pc_xyz[j] - pc_xxz[j] * pa_y[j] - pc_xyz[j] * pb_x[j] - pc_xxy[j] * pb_z[j]);

                t_xy_xz[j] += fl_s_0_0_4 * pc_xxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_9_12(      CMemBlock2D<double>& primBuffer,
                                   const CMemBlock2D<double>& auxBuffer,
                                   const CMemBlock2D<double>& osFactors,
                                   const CMemBlock2D<double>& paDistances,
                                   const CMemBlock2D<double>& pbDistances,
                                   const CMemBlock2D<double>& pcDistances,
                                   const CGtoBlock&           braGtoBlock,
                                   const CGtoBlock&           ketGtoBlock,
                                   const int32_t              iContrGto)
    {
        // Batch of Integrals (9,12)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(34 * idx + 12);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_xzz = pcDistances.data(34 * idx + 14);

            auto pc_yyy = pcDistances.data(34 * idx + 15);

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(34 * idx + 25);

            auto pc_xyyz = pcDistances.data(34 * idx + 26);

            auto pc_xyzz = pcDistances.data(34 * idx + 27);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_xy_yy = primBuffer.data(36 * idx + 9);

            auto t_xy_yz = primBuffer.data(36 * idx + 10);

            auto t_xy_zz = primBuffer.data(36 * idx + 11);

            // Batch of Integrals (9,12)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xy, pc_xyy, pc_xyyy, \
                                     pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyz, pc_yz, pc_yzz, pc_z, \
                                     pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_xy_yy, t_xy_yz, t_xy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                t_xy_yy[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl1_fx + pa_x[j] * fl1_fx * pb_y[j] + pa_xy[j] * pb_yy[j]);

                t_xy_yy[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * fl1_fx - pa_x[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx - pc_x[j] * fl1_fx * pb_y[j] - 2.0 * pa_xy[j] * pb_y[j] * pc_y[j] - pa_x[j] * pc_y[j] * pb_yy[j] - pc_x[j] * pa_y[j] * pb_yy[j]);

                t_xy_yy[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * pc_y[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx + pc_x[j] * fl1_fx * pb_y[j] + pa_xy[j] * pc_yy[j] + 2.0 * pa_x[j] * pc_yy[j] * pb_y[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_y[j] + pc_xy[j] * pb_yy[j]);

                t_xy_yy[j] += fl_s_0_0_3 * (-1.5 * pc_xy[j] * fl1_fx - pa_x[j] * pc_yyy[j] - pc_xyy[j] * pa_y[j] - 2.0 * pc_xyy[j] * pb_y[j]);

                t_xy_yy[j] += fl_s_0_0_4 * pc_xyyy[j];

                t_xy_yz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl1_fx * pb_z[j] + pa_xy[j] * pb_yz[j]);

                t_xy_yz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * fl1_fx * pb_z[j] - pa_xy[j] * pb_y[j] * pc_z[j] - pa_xy[j] * pc_y[j] * pb_z[j] - pa_x[j] * pc_y[j] * pb_yz[j] - pc_x[j] * pa_y[j] * pb_yz[j]);

                t_xy_yz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl1_fx * pc_z[j] + 0.5 * pc_xz[j] * fl1_fx + 0.5 * pc_x[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_yz[j] + pa_x[j] * pc_yz[j] * pb_y[j] + pa_x[j] * pc_yy[j] * pb_z[j] + pc_xz[j] * pa_y[j] * pb_y[j] + pc_xy[j] * pa_y[j] * pb_z[j] + pc_xy[j] * pb_yz[j]);

                t_xy_yz[j] += fl_s_0_0_3 * (-0.5 * pc_xz[j] * fl1_fx - pa_x[j] * pc_yyz[j] - pc_xyz[j] * pa_y[j] - pc_xyz[j] * pb_y[j] - pc_xyy[j] * pb_z[j]);

                t_xy_yz[j] += fl_s_0_0_4 * pc_xyyz[j];

                t_xy_zz[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl1_fx + pa_xy[j] * pb_zz[j]);

                t_xy_zz[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * fl1_fx - 0.5 * pc_x[j] * pa_y[j] * fl1_fx - 2.0 * pa_xy[j] * pb_z[j] * pc_z[j] - pa_x[j] * pc_y[j] * pb_zz[j] - pc_x[j] * pa_y[j] * pb_zz[j]);

                t_xy_zz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * pc_y[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * fl1_fx + 0.5 * pc_xy[j] * fl1_fx + pa_xy[j] * pc_zz[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_y[j] * pb_z[j] + pc_xy[j] * pb_zz[j]);

                t_xy_zz[j] += fl_s_0_0_3 * (-0.5 * pc_xy[j] * fl1_fx - pa_x[j] * pc_yzz[j] - pc_xzz[j] * pa_y[j] - 2.0 * pc_xyz[j] * pb_z[j]);

                t_xy_zz[j] += fl_s_0_0_4 * pc_xyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_12_15(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (12,15)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(34 * idx + 9);

            auto pc_xxy = pcDistances.data(34 * idx + 10);

            auto pc_xxz = pcDistances.data(34 * idx + 11);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_xzz = pcDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(34 * idx + 21);

            auto pc_xxyz = pcDistances.data(34 * idx + 23);

            auto pc_xxzz = pcDistances.data(34 * idx + 24);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_xz_xx = primBuffer.data(36 * idx + 12);

            auto t_xz_xy = primBuffer.data(36 * idx + 13);

            auto t_xz_xz = primBuffer.data(36 * idx + 14);

            // Batch of Integrals (12,15)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxx, \
                                     pc_xxxz, pc_xxy, pc_xxyz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xz, pc_xzz, pc_y, pc_yz, \
                                     pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_xz_xx, t_xz_xy, \
                                     t_xz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xx[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * fl1_fx + fl1_fx * pa_z[j] * pb_x[j] + pa_xz[j] * pb_xx[j]);

                t_xz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl1_fx - 0.5 * pa_x[j] * pc_z[j] * fl1_fx - 1.5 * pc_x[j] * pa_z[j] * fl1_fx - fl1_fx * pc_z[j] * pb_x[j] - fl1_fx * pa_z[j] * pb_x[j] - 2.0 * pa_xz[j] * pb_x[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xx[j] - pc_x[j] * pa_z[j] * pb_xx[j]);

                t_xz_xx[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * pc_z[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx + fl1_fx * pc_z[j] * pb_x[j] + pa_xz[j] * pc_xx[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_x[j] + 2.0 * pc_xx[j] * pa_z[j] * pb_x[j] + pc_xz[j] * pb_xx[j]);

                t_xz_xx[j] += fl_s_0_0_3 * (-1.5 * pc_xz[j] * fl1_fx - pa_x[j] * pc_xxz[j] - pc_xxx[j] * pa_z[j] - 2.0 * pc_xxz[j] * pb_x[j]);

                t_xz_xx[j] += fl_s_0_0_4 * pc_xxxz[j];

                t_xz_xy[j] = fl_s_0_0_0 * (0.5 * fl1_fx * pa_z[j] * pb_y[j] + pa_xz[j] * pb_xy[j]);

                t_xz_xy[j] += fl_s_0_0_1 * (-0.5 * fl1_fx * pa_z[j] * pc_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_z[j] * pb_y[j] - pa_xz[j] * pb_x[j] * pc_y[j] - pa_xz[j] * pc_x[j] * pb_y[j] - pa_x[j] * pc_z[j] * pb_xy[j] - pc_x[j] * pa_z[j] * pb_xy[j]);

                t_xz_xy[j] += fl_s_0_0_2 * (0.5 * fl1_fx * pc_yz[j] + 0.5 * fl1_fx * pa_z[j] * pc_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_y[j] + pa_xz[j] * pc_xy[j] + pa_x[j] * pc_yz[j] * pb_x[j] + pa_x[j] * pc_xz[j] * pb_y[j] + pc_xy[j] * pa_z[j] * pb_x[j] + pc_xx[j] * pa_z[j] * pb_y[j] + pc_xz[j] * pb_xy[j]);

                t_xz_xy[j] += fl_s_0_0_3 * (-0.5 * fl1_fx * pc_yz[j] - pa_x[j] * pc_xyz[j] - pc_xxy[j] * pa_z[j] - pc_xyz[j] * pb_x[j] - pc_xxz[j] * pb_y[j]);

                t_xz_xy[j] += fl_s_0_0_4 * pc_xxyz[j];

                t_xz_xz[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_x[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pb_z[j] + pa_xz[j] * pb_xz[j]);

                t_xz_xz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_x[j] * fl1_fx * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] - 0.5 * pc_x[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_z[j] * pb_z[j] - pa_xz[j] * pb_x[j] * pc_z[j] - pa_xz[j] * pc_x[j] * pb_z[j] - pa_x[j] * pc_z[j] * pb_xz[j] - pc_x[j] * pa_z[j] * pb_xz[j]);

                t_xz_xz[j] += fl_s_0_0_2 * (0.25 * fl2_fx + 0.5 * pa_x[j] * fl1_fx * pc_x[j] + 0.5 * pc_xx[j] * fl1_fx + 0.5 * pc_x[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_zz[j] + 0.5 * fl1_fx * pa_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_z[j] + pa_xz[j] * pc_xz[j] + pa_x[j] * pc_zz[j] * pb_x[j] + pa_x[j] * pc_xz[j] * pb_z[j] + pc_xz[j] * pa_z[j] * pb_x[j] + pc_xx[j] * pa_z[j] * pb_z[j] + pc_xz[j] * pb_xz[j]);

                t_xz_xz[j] += fl_s_0_0_3 * (-0.5 * pc_xx[j] * fl1_fx - 0.5 * fl1_fx * pc_zz[j] - pa_x[j] * pc_xzz[j] - pc_xxz[j] * pa_z[j] - pc_xzz[j] * pb_x[j] - pc_xxz[j] * pb_z[j]);

                t_xz_xz[j] += fl_s_0_0_4 * pc_xxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_15_18(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (15,18)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(34 * idx + 12);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_xzz = pcDistances.data(34 * idx + 14);

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            auto pc_zzz = pcDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(34 * idx + 26);

            auto pc_xyzz = pcDistances.data(34 * idx + 27);

            auto pc_xzzz = pcDistances.data(34 * idx + 28);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_xz_yy = primBuffer.data(36 * idx + 15);

            auto t_xz_yz = primBuffer.data(36 * idx + 16);

            auto t_xz_zz = primBuffer.data(36 * idx + 17);

            // Batch of Integrals (15,18)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xy, pc_xyy, pc_xyyz, \
                                     pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_xz_yy, t_xz_yz, t_xz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                t_xz_yy[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * fl1_fx + pa_xz[j] * pb_yy[j]);

                t_xz_yy[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl1_fx - 0.5 * pa_x[j] * pc_z[j] * fl1_fx - 0.5 * pc_x[j] * pa_z[j] * fl1_fx - 2.0 * pa_xz[j] * pb_y[j] * pc_y[j] - pa_x[j] * pc_z[j] * pb_yy[j] - pc_x[j] * pa_z[j] * pb_yy[j]);

                t_xz_yy[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * pc_z[j] * fl1_fx + 0.5 * pc_x[j] * pa_z[j] * fl1_fx + 0.5 * pc_xz[j] * fl1_fx + pa_xz[j] * pc_yy[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_y[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_y[j] + pc_xz[j] * pb_yy[j]);

                t_xz_yy[j] += fl_s_0_0_3 * (-0.5 * pc_xz[j] * fl1_fx - pa_x[j] * pc_yyz[j] - pc_xyy[j] * pa_z[j] - 2.0 * pc_xyz[j] * pb_y[j]);

                t_xz_yy[j] += fl_s_0_0_4 * pc_xyyz[j];

                t_xz_yz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl1_fx * pb_y[j] + pa_xz[j] * pb_yz[j]);

                t_xz_yz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl1_fx * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * fl1_fx * pb_y[j] - pa_xz[j] * pb_y[j] * pc_z[j] - pa_xz[j] * pc_y[j] * pb_z[j] - pa_x[j] * pc_z[j] * pb_yz[j] - pc_x[j] * pa_z[j] * pb_yz[j]);

                t_xz_yz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl1_fx * pc_y[j] + 0.5 * pc_xy[j] * fl1_fx + 0.5 * pc_x[j] * fl1_fx * pb_y[j] + pa_xz[j] * pc_yz[j] + pa_x[j] * pc_zz[j] * pb_y[j] + pa_x[j] * pc_yz[j] * pb_z[j] + pc_xz[j] * pa_z[j] * pb_y[j] + pc_xy[j] * pa_z[j] * pb_z[j] + pc_xz[j] * pb_yz[j]);

                t_xz_yz[j] += fl_s_0_0_3 * (-0.5 * pc_xy[j] * fl1_fx - pa_x[j] * pc_yzz[j] - pc_xyz[j] * pa_z[j] - pc_xzz[j] * pb_y[j] - pc_xyz[j] * pb_z[j]);

                t_xz_yz[j] += fl_s_0_0_4 * pc_xyzz[j];

                t_xz_zz[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * fl1_fx + pa_x[j] * fl1_fx * pb_z[j] + pa_xz[j] * pb_zz[j]);

                t_xz_zz[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * fl1_fx - pa_x[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_z[j] * fl1_fx - pc_x[j] * fl1_fx * pb_z[j] - 2.0 * pa_xz[j] * pb_z[j] * pc_z[j] - pa_x[j] * pc_z[j] * pb_zz[j] - pc_x[j] * pa_z[j] * pb_zz[j]);

                t_xz_zz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * pc_z[j] * fl1_fx + 0.5 * pc_x[j] * pa_z[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx + pc_x[j] * fl1_fx * pb_z[j] + pa_xz[j] * pc_zz[j] + 2.0 * pa_x[j] * pc_zz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_z[j] + pc_xz[j] * pb_zz[j]);

                t_xz_zz[j] += fl_s_0_0_3 * (-1.5 * pc_xz[j] * fl1_fx - pa_x[j] * pc_zzz[j] - pc_xzz[j] * pa_z[j] - 2.0 * pc_xzz[j] * pb_z[j]);

                t_xz_zz[j] += fl_s_0_0_4 * pc_xzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_18_21(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (18,21)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(34 * idx + 10);

            auto pc_xyy = pcDistances.data(34 * idx + 12);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_yyy = pcDistances.data(34 * idx + 15);

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(34 * idx + 22);

            auto pc_xyyy = pcDistances.data(34 * idx + 25);

            auto pc_xyyz = pcDistances.data(34 * idx + 26);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_yy_xx = primBuffer.data(36 * idx + 18);

            auto t_yy_xy = primBuffer.data(36 * idx + 19);

            auto t_yy_xz = primBuffer.data(36 * idx + 20);

            // Batch of Integrals (18,21)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyz, pc_yz, \
                                     pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_yy_xx, t_yy_xy, t_yy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xx[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_yy[j] * fl1_fx + 0.5 * fl1_fx * pb_xx[j] + pa_yy[j] * pb_xx[j]);

                t_yy_xx[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_yy[j] * fl1_fx - pa_y[j] * pc_y[j] * fl1_fx - fl1_fx * pb_x[j] * pc_x[j] - 0.5 * fl1_fx * pb_xx[j] - 2.0 * pa_yy[j] * pb_x[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xx[j]);

                t_yy_xx[j] += fl_s_0_0_2 * (0.25 * fl2_fx + pa_y[j] * pc_y[j] * fl1_fx + 0.5 * pc_yy[j] * fl1_fx + 0.5 * fl1_fx * pc_xx[j] + fl1_fx * pb_x[j] * pc_x[j] + pa_yy[j] * pc_xx[j] + 4.0 * pa_y[j] * pc_xy[j] * pb_x[j] + pc_yy[j] * pb_xx[j]);

                t_yy_xx[j] += fl_s_0_0_3 * (-0.5 * pc_yy[j] * fl1_fx - 0.5 * fl1_fx * pc_xx[j] - 2.0 * pa_y[j] * pc_xxy[j] - 2.0 * pc_xyy[j] * pb_x[j]);

                t_yy_xx[j] += fl_s_0_0_4 * pc_xxyy[j];

                t_yy_xy[j] = fl_s_0_0_0 * (pa_y[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pb_xy[j] + pa_yy[j] * pb_xy[j]);

                t_yy_xy[j] += fl_s_0_0_1 * (-pa_y[j] * fl1_fx * pc_x[j] - pa_y[j] * fl1_fx * pb_x[j] - 1.5 * pc_y[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * fl1_fx * pb_xy[j] - pa_yy[j] * pb_x[j] * pc_y[j] - pa_yy[j] * pc_x[j] * pb_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xy[j]);

                t_yy_xy[j] += fl_s_0_0_2 * (pa_y[j] * fl1_fx * pc_x[j] + 1.5 * pc_xy[j] * fl1_fx + 1.5 * pc_y[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_x[j] * pb_y[j] + pa_yy[j] * pc_xy[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_y[j] + pc_yy[j] * pb_xy[j]);

                t_yy_xy[j] += fl_s_0_0_3 * (-1.5 * pc_xy[j] * fl1_fx - 2.0 * pa_y[j] * pc_xyy[j] - pc_yyy[j] * pb_x[j] - pc_xyy[j] * pb_y[j]);

                t_yy_xy[j] += fl_s_0_0_4 * pc_xyyy[j];

                t_yy_xz[j] = fl_s_0_0_0 * (0.5 * fl1_fx * pb_xz[j] + pa_yy[j] * pb_xz[j]);

                t_yy_xz[j] += fl_s_0_0_1 * (-0.5 * fl1_fx * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * fl1_fx * pb_xz[j] - pa_yy[j] * pb_x[j] * pc_z[j] - pa_yy[j] * pc_x[j] * pb_z[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xz[j]);

                t_yy_xz[j] += fl_s_0_0_2 * (0.5 * fl1_fx * pc_xz[j] + 0.5 * fl1_fx * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pc_x[j] * pb_z[j] + pa_yy[j] * pc_xz[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_z[j] + pc_yy[j] * pb_xz[j]);

                t_yy_xz[j] += fl_s_0_0_3 * (-0.5 * fl1_fx * pc_xz[j] - 2.0 * pa_y[j] * pc_xyz[j] - pc_yyz[j] * pb_x[j] - pc_xyy[j] * pb_z[j]);

                t_yy_xz[j] += fl_s_0_0_4 * pc_xyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_21_24(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (21,24)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(34 * idx + 15);

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(34 * idx + 29);

            auto pc_yyyz = pcDistances.data(34 * idx + 30);

            auto pc_yyzz = pcDistances.data(34 * idx + 31);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_yy_yy = primBuffer.data(36 * idx + 21);

            auto t_yy_yz = primBuffer.data(36 * idx + 22);

            auto t_yy_zz = primBuffer.data(36 * idx + 23);

            // Batch of Integrals (21,24)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, t_yy_yy, t_yy_yz, t_yy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_yy[j] = fl_s_0_0_0 * (0.75 * fl2_fx + 0.5 * pa_yy[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pb_yy[j] + pa_yy[j] * pb_yy[j]);

                t_yy_yy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx - 0.5 * pa_yy[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pb_y[j] - 3.0 * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pb_yy[j] - 2.0 * pa_yy[j] * pb_y[j] * pc_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yy[j]);

                t_yy_yy[j] += fl_s_0_0_2 * (0.75 * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl1_fx + 3.0 * pc_yy[j] * fl1_fx + 3.0 * pc_y[j] * fl1_fx * pb_y[j] + pa_yy[j] * pc_yy[j] + 4.0 * pa_y[j] * pc_yy[j] * pb_y[j] + pc_yy[j] * pb_yy[j]);

                t_yy_yy[j] += fl_s_0_0_3 * (-3.0 * pc_yy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyy[j] - 2.0 * pc_yyy[j] * pb_y[j]);

                t_yy_yy[j] += fl_s_0_0_4 * pc_yyyy[j];

                t_yy_yz[j] = fl_s_0_0_0 * (pa_y[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_yz[j] + pa_yy[j] * pb_yz[j]);

                t_yy_yz[j] += fl_s_0_0_1 * (-pa_y[j] * fl1_fx * pc_z[j] - pa_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pb_yz[j] - pa_yy[j] * pb_y[j] * pc_z[j] - pa_yy[j] * pc_y[j] * pb_z[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yz[j]);

                t_yy_yz[j] += fl_s_0_0_2 * (pa_y[j] * fl1_fx * pc_z[j] + 1.5 * pc_yz[j] * fl1_fx + 1.5 * pc_y[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_y[j] * pc_z[j] + pa_yy[j] * pc_yz[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_z[j] + pc_yy[j] * pb_yz[j]);

                t_yy_yz[j] += fl_s_0_0_3 * (-1.5 * pc_yz[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyz[j] - pc_yyz[j] * pb_y[j] - pc_yyy[j] * pb_z[j]);

                t_yy_yz[j] += fl_s_0_0_4 * pc_yyyz[j];

                t_yy_zz[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_yy[j] * fl1_fx + 0.5 * fl1_fx * pb_zz[j] + pa_yy[j] * pb_zz[j]);

                t_yy_zz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_yy[j] * fl1_fx - pa_y[j] * pc_y[j] * fl1_fx - fl1_fx * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pb_zz[j] - 2.0 * pa_yy[j] * pb_z[j] * pc_z[j] - 2.0 * pa_y[j] * pc_y[j] * pb_zz[j]);

                t_yy_zz[j] += fl_s_0_0_2 * (0.25 * fl2_fx + pa_y[j] * pc_y[j] * fl1_fx + 0.5 * pc_yy[j] * fl1_fx + 0.5 * fl1_fx * pc_zz[j] + fl1_fx * pb_z[j] * pc_z[j] + pa_yy[j] * pc_zz[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_z[j] + pc_yy[j] * pb_zz[j]);

                t_yy_zz[j] += fl_s_0_0_3 * (-0.5 * pc_yy[j] * fl1_fx - 0.5 * fl1_fx * pc_zz[j] - 2.0 * pa_y[j] * pc_yzz[j] - 2.0 * pc_yyz[j] * pb_z[j]);

                t_yy_zz[j] += fl_s_0_0_4 * pc_yyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_24_27(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (24,27)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(34 * idx + 10);

            auto pc_xxz = pcDistances.data(34 * idx + 11);

            auto pc_xyy = pcDistances.data(34 * idx + 12);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_xzz = pcDistances.data(34 * idx + 14);

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(34 * idx + 23);

            auto pc_xyyz = pcDistances.data(34 * idx + 26);

            auto pc_xyzz = pcDistances.data(34 * idx + 27);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_yz_xx = primBuffer.data(36 * idx + 24);

            auto t_yz_xy = primBuffer.data(36 * idx + 25);

            auto t_yz_xz = primBuffer.data(36 * idx + 26);

            // Batch of Integrals (24,27)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxy, \
                                     pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, \
                                     pc_yyz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     t_yz_xx, t_yz_xy, t_yz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                t_yz_xx[j] = fl_s_0_0_0 * (0.5 * pa_yz[j] * fl1_fx + pa_yz[j] * pb_xx[j]);

                t_yz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * fl1_fx - 0.5 * pa_y[j] * pc_z[j] * fl1_fx - 0.5 * pc_y[j] * pa_z[j] * fl1_fx - 2.0 * pa_yz[j] * pb_x[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xx[j] - pc_y[j] * pa_z[j] * pb_xx[j]);

                t_yz_xx[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * pc_z[j] * fl1_fx + 0.5 * pc_y[j] * pa_z[j] * fl1_fx + 0.5 * pc_yz[j] * fl1_fx + pa_yz[j] * pc_xx[j] + 2.0 * pa_y[j] * pc_xz[j] * pb_x[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_x[j] + pc_yz[j] * pb_xx[j]);

                t_yz_xx[j] += fl_s_0_0_3 * (-0.5 * pc_yz[j] * fl1_fx - pa_y[j] * pc_xxz[j] - pc_xxy[j] * pa_z[j] - 2.0 * pc_xyz[j] * pb_x[j]);

                t_yz_xx[j] += fl_s_0_0_4 * pc_xxyz[j];

                t_yz_xy[j] = fl_s_0_0_0 * (0.5 * fl1_fx * pa_z[j] * pb_x[j] + pa_yz[j] * pb_xy[j]);

                t_yz_xy[j] += fl_s_0_0_1 * (-0.5 * fl1_fx * pa_z[j] * pc_x[j] - 0.5 * fl1_fx * pc_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_z[j] * pb_x[j] - pa_yz[j] * pb_x[j] * pc_y[j] - pa_yz[j] * pc_x[j] * pb_y[j] - pa_y[j] * pc_z[j] * pb_xy[j] - pc_y[j] * pa_z[j] * pb_xy[j]);

                t_yz_xy[j] += fl_s_0_0_2 * (0.5 * fl1_fx * pc_xz[j] + 0.5 * fl1_fx * pa_z[j] * pc_x[j] + 0.5 * fl1_fx * pc_z[j] * pb_x[j] + pa_yz[j] * pc_xy[j] + pa_y[j] * pc_yz[j] * pb_x[j] + pa_y[j] * pc_xz[j] * pb_y[j] + pc_yy[j] * pa_z[j] * pb_x[j] + pc_xy[j] * pa_z[j] * pb_y[j] + pc_yz[j] * pb_xy[j]);

                t_yz_xy[j] += fl_s_0_0_3 * (-0.5 * fl1_fx * pc_xz[j] - pa_y[j] * pc_xyz[j] - pc_xyy[j] * pa_z[j] - pc_yyz[j] * pb_x[j] - pc_xyz[j] * pb_y[j]);

                t_yz_xy[j] += fl_s_0_0_4 * pc_xyyz[j];

                t_yz_xz[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl1_fx * pb_x[j] + pa_yz[j] * pb_xz[j]);

                t_yz_xz[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl1_fx * pc_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_x[j] - 0.5 * pc_y[j] * fl1_fx * pb_x[j] - pa_yz[j] * pb_x[j] * pc_z[j] - pa_yz[j] * pc_x[j] * pb_z[j] - pa_y[j] * pc_z[j] * pb_xz[j] - pc_y[j] * pa_z[j] * pb_xz[j]);

                t_yz_xz[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * fl1_fx * pc_x[j] + 0.5 * pc_xy[j] * fl1_fx + 0.5 * pc_y[j] * fl1_fx * pb_x[j] + pa_yz[j] * pc_xz[j] + pa_y[j] * pc_zz[j] * pb_x[j] + pa_y[j] * pc_xz[j] * pb_z[j] + pc_yz[j] * pa_z[j] * pb_x[j] + pc_xy[j] * pa_z[j] * pb_z[j] + pc_yz[j] * pb_xz[j]);

                t_yz_xz[j] += fl_s_0_0_3 * (-0.5 * pc_xy[j] * fl1_fx - pa_y[j] * pc_xzz[j] - pc_xyz[j] * pa_z[j] - pc_yzz[j] * pb_x[j] - pc_xyz[j] * pb_z[j]);

                t_yz_xz[j] += fl_s_0_0_4 * pc_xyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_27_30(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (27,30)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(34 * idx + 15);

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            auto pc_zzz = pcDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(34 * idx + 30);

            auto pc_yyzz = pcDistances.data(34 * idx + 31);

            auto pc_yzzz = pcDistances.data(34 * idx + 32);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_yz_yy = primBuffer.data(36 * idx + 27);

            auto t_yz_yz = primBuffer.data(36 * idx + 28);

            auto t_yz_zz = primBuffer.data(36 * idx + 29);

            // Batch of Integrals (27,30)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, pc_yyy, pc_yyyz, \
                                     pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, t_yz_yy, t_yz_yz, t_yz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_yy[j] = fl_s_0_0_0 * (0.5 * pa_yz[j] * fl1_fx + fl1_fx * pa_z[j] * pb_y[j] + pa_yz[j] * pb_yy[j]);

                t_yz_yy[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * fl1_fx - 0.5 * pa_y[j] * pc_z[j] * fl1_fx - 1.5 * pc_y[j] * pa_z[j] * fl1_fx - fl1_fx * pc_z[j] * pb_y[j] - fl1_fx * pa_z[j] * pb_y[j] - 2.0 * pa_yz[j] * pb_y[j] * pc_y[j] - pa_y[j] * pc_z[j] * pb_yy[j] - pc_y[j] * pa_z[j] * pb_yy[j]);

                t_yz_yy[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * pc_z[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * fl1_fx + 1.5 * pc_yz[j] * fl1_fx + fl1_fx * pc_z[j] * pb_y[j] + pa_yz[j] * pc_yy[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_y[j] + 2.0 * pc_yy[j] * pa_z[j] * pb_y[j] + pc_yz[j] * pb_yy[j]);

                t_yz_yy[j] += fl_s_0_0_3 * (-1.5 * pc_yz[j] * fl1_fx - pa_y[j] * pc_yyz[j] - pc_yyy[j] * pa_z[j] - 2.0 * pc_yyz[j] * pb_y[j]);

                t_yz_yy[j] += fl_s_0_0_4 * pc_yyyz[j];

                t_yz_yz[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_y[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pb_z[j] + pa_yz[j] * pb_yz[j]);

                t_yz_yz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_y[j] * fl1_fx * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pa_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_z[j] * pb_z[j] - pa_yz[j] * pb_y[j] * pc_z[j] - pa_yz[j] * pc_y[j] * pb_z[j] - pa_y[j] * pc_z[j] * pb_yz[j] - pc_y[j] * pa_z[j] * pb_yz[j]);

                t_yz_yz[j] += fl_s_0_0_2 * (0.25 * fl2_fx + 0.5 * pa_y[j] * fl1_fx * pc_y[j] + 0.5 * pc_yy[j] * fl1_fx + 0.5 * pc_y[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_zz[j] + 0.5 * fl1_fx * pa_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_z[j] + pa_yz[j] * pc_yz[j] + pa_y[j] * pc_zz[j] * pb_y[j] + pa_y[j] * pc_yz[j] * pb_z[j] + pc_yz[j] * pa_z[j] * pb_y[j] + pc_yy[j] * pa_z[j] * pb_z[j] + pc_yz[j] * pb_yz[j]);

                t_yz_yz[j] += fl_s_0_0_3 * (-0.5 * pc_yy[j] * fl1_fx - 0.5 * fl1_fx * pc_zz[j] - pa_y[j] * pc_yzz[j] - pc_yyz[j] * pa_z[j] - pc_yzz[j] * pb_y[j] - pc_yyz[j] * pb_z[j]);

                t_yz_yz[j] += fl_s_0_0_4 * pc_yyzz[j];

                t_yz_zz[j] = fl_s_0_0_0 * (0.5 * pa_yz[j] * fl1_fx + pa_y[j] * fl1_fx * pb_z[j] + pa_yz[j] * pb_zz[j]);

                t_yz_zz[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * fl1_fx - pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_y[j] * pa_z[j] * fl1_fx - pc_y[j] * fl1_fx * pb_z[j] - 2.0 * pa_yz[j] * pb_z[j] * pc_z[j] - pa_y[j] * pc_z[j] * pb_zz[j] - pc_y[j] * pa_z[j] * pb_zz[j]);

                t_yz_zz[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * pc_z[j] * fl1_fx + 0.5 * pc_y[j] * pa_z[j] * fl1_fx + 1.5 * pc_yz[j] * fl1_fx + pc_y[j] * fl1_fx * pb_z[j] + pa_yz[j] * pc_zz[j] + 2.0 * pa_y[j] * pc_zz[j] * pb_z[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_z[j] + pc_yz[j] * pb_zz[j]);

                t_yz_zz[j] += fl_s_0_0_3 * (-1.5 * pc_yz[j] * fl1_fx - pa_y[j] * pc_zzz[j] - pc_yzz[j] * pa_z[j] - 2.0 * pc_yzz[j] * pb_z[j]);

                t_yz_zz[j] += fl_s_0_0_4 * pc_yzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_30_33(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (30,33)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(34 * idx);

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(34 * idx + 3);

            auto pc_xy = pcDistances.data(34 * idx + 4);

            auto pc_xz = pcDistances.data(34 * idx + 5);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(34 * idx + 11);

            auto pc_xyz = pcDistances.data(34 * idx + 13);

            auto pc_xzz = pcDistances.data(34 * idx + 14);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            auto pc_zzz = pcDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(34 * idx + 24);

            auto pc_xyzz = pcDistances.data(34 * idx + 27);

            auto pc_xzzz = pcDistances.data(34 * idx + 28);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_zz_xx = primBuffer.data(36 * idx + 30);

            auto t_zz_xy = primBuffer.data(36 * idx + 31);

            auto t_zz_xz = primBuffer.data(36 * idx + 32);

            // Batch of Integrals (30,33)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, t_zz_xx, t_zz_xy, t_zz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xx[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_zz[j] * fl1_fx + 0.5 * fl1_fx * pb_xx[j] + pa_zz[j] * pb_xx[j]);

                t_zz_xx[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_zz[j] * fl1_fx - pa_z[j] * pc_z[j] * fl1_fx - fl1_fx * pb_x[j] * pc_x[j] - 0.5 * fl1_fx * pb_xx[j] - 2.0 * pa_zz[j] * pb_x[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xx[j]);

                t_zz_xx[j] += fl_s_0_0_2 * (0.25 * fl2_fx + pa_z[j] * pc_z[j] * fl1_fx + 0.5 * pc_zz[j] * fl1_fx + 0.5 * fl1_fx * pc_xx[j] + fl1_fx * pb_x[j] * pc_x[j] + pa_zz[j] * pc_xx[j] + 4.0 * pa_z[j] * pc_xz[j] * pb_x[j] + pc_zz[j] * pb_xx[j]);

                t_zz_xx[j] += fl_s_0_0_3 * (-0.5 * pc_zz[j] * fl1_fx - 0.5 * fl1_fx * pc_xx[j] - 2.0 * pa_z[j] * pc_xxz[j] - 2.0 * pc_xzz[j] * pb_x[j]);

                t_zz_xx[j] += fl_s_0_0_4 * pc_xxzz[j];

                t_zz_xy[j] = fl_s_0_0_0 * (0.5 * fl1_fx * pb_xy[j] + pa_zz[j] * pb_xy[j]);

                t_zz_xy[j] += fl_s_0_0_1 * (-0.5 * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * fl1_fx * pb_xy[j] - pa_zz[j] * pb_x[j] * pc_y[j] - pa_zz[j] * pc_x[j] * pb_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xy[j]);

                t_zz_xy[j] += fl_s_0_0_2 * (0.5 * fl1_fx * pc_xy[j] + 0.5 * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * fl1_fx * pc_x[j] * pb_y[j] + pa_zz[j] * pc_xy[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_y[j] + pc_zz[j] * pb_xy[j]);

                t_zz_xy[j] += fl_s_0_0_3 * (-0.5 * fl1_fx * pc_xy[j] - 2.0 * pa_z[j] * pc_xyz[j] - pc_yzz[j] * pb_x[j] - pc_xzz[j] * pb_y[j]);

                t_zz_xy[j] += fl_s_0_0_4 * pc_xyzz[j];

                t_zz_xz[j] = fl_s_0_0_0 * (pa_z[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pb_xz[j] + pa_zz[j] * pb_xz[j]);

                t_zz_xz[j] += fl_s_0_0_1 * (-pa_z[j] * fl1_fx * pc_x[j] - pa_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_z[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * fl1_fx * pb_xz[j] - pa_zz[j] * pb_x[j] * pc_z[j] - pa_zz[j] * pc_x[j] * pb_z[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xz[j]);

                t_zz_xz[j] += fl_s_0_0_2 * (pa_z[j] * fl1_fx * pc_x[j] + 1.5 * pc_xz[j] * fl1_fx + 1.5 * pc_z[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_x[j] * pb_z[j] + pa_zz[j] * pc_xz[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_x[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_z[j] + pc_zz[j] * pb_xz[j]);

                t_zz_xz[j] += fl_s_0_0_3 * (-1.5 * pc_xz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xzz[j] - pc_zzz[j] * pb_x[j] - pc_xzz[j] * pb_z[j]);

                t_zz_xz[j] += fl_s_0_0_4 * pc_xzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDD_33_36(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (33,36)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(34 * idx + 1);

            auto pc_z = pcDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(34 * idx + 6);

            auto pc_yz = pcDistances.data(34 * idx + 7);

            auto pc_zz = pcDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(34 * idx + 16);

            auto pc_yzz = pcDistances.data(34 * idx + 17);

            auto pc_zzz = pcDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(34 * idx + 31);

            auto pc_yzzz = pcDistances.data(34 * idx + 32);

            auto pc_zzzz = pcDistances.data(34 * idx + 33);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(5 * idx);

            auto s_0_0_1 = auxBuffer.data(5 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(5 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(5 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(5 * idx + 4);

            // set up pointers to integrals

            auto t_zz_yy = primBuffer.data(36 * idx + 33);

            auto t_zz_yz = primBuffer.data(36 * idx + 34);

            auto t_zz_zz = primBuffer.data(36 * idx + 35);

            // Batch of Integrals (33,36)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, t_zz_yy, t_zz_yz, t_zz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_yy[j] = fl_s_0_0_0 * (0.25 * fl2_fx + 0.5 * pa_zz[j] * fl1_fx + 0.5 * fl1_fx * pb_yy[j] + pa_zz[j] * pb_yy[j]);

                t_zz_yy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx - 0.5 * pa_zz[j] * fl1_fx - pa_z[j] * pc_z[j] * fl1_fx - fl1_fx * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pb_yy[j] - 2.0 * pa_zz[j] * pb_y[j] * pc_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yy[j]);

                t_zz_yy[j] += fl_s_0_0_2 * (0.25 * fl2_fx + pa_z[j] * pc_z[j] * fl1_fx + 0.5 * pc_zz[j] * fl1_fx + 0.5 * fl1_fx * pc_yy[j] + fl1_fx * pb_y[j] * pc_y[j] + pa_zz[j] * pc_yy[j] + 4.0 * pa_z[j] * pc_yz[j] * pb_y[j] + pc_zz[j] * pb_yy[j]);

                t_zz_yy[j] += fl_s_0_0_3 * (-0.5 * pc_zz[j] * fl1_fx - 0.5 * fl1_fx * pc_yy[j] - 2.0 * pa_z[j] * pc_yyz[j] - 2.0 * pc_yzz[j] * pb_y[j]);

                t_zz_yy[j] += fl_s_0_0_4 * pc_yyzz[j];

                t_zz_yz[j] = fl_s_0_0_0 * (pa_z[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pb_yz[j] + pa_zz[j] * pb_yz[j]);

                t_zz_yz[j] += fl_s_0_0_1 * (-pa_z[j] * fl1_fx * pc_y[j] - pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_z[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pb_yz[j] - pa_zz[j] * pb_y[j] * pc_z[j] - pa_zz[j] * pc_y[j] * pb_z[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yz[j]);

                t_zz_yz[j] += fl_s_0_0_2 * (pa_z[j] * fl1_fx * pc_y[j] + 1.5 * pc_yz[j] * fl1_fx + 1.5 * pc_z[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_z[j] + pa_zz[j] * pc_yz[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_y[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_z[j] + pc_zz[j] * pb_yz[j]);

                t_zz_yz[j] += fl_s_0_0_3 * (-1.5 * pc_yz[j] * fl1_fx - 2.0 * pa_z[j] * pc_yzz[j] - pc_zzz[j] * pb_y[j] - pc_yzz[j] * pb_z[j]);

                t_zz_yz[j] += fl_s_0_0_4 * pc_yzzz[j];

                t_zz_zz[j] = fl_s_0_0_0 * (0.75 * fl2_fx + 0.5 * pa_zz[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_zz[j] + pa_zz[j] * pb_zz[j]);

                t_zz_zz[j] += fl_s_0_0_1 * (-1.5 * fl2_fx - 0.5 * pa_zz[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * fl1_fx - 2.0 * pa_z[j] * fl1_fx * pb_z[j] - 3.0 * pc_z[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_zz[j] - 2.0 * pa_zz[j] * pb_z[j] * pc_z[j] - 2.0 * pa_z[j] * pc_z[j] * pb_zz[j]);

                t_zz_zz[j] += fl_s_0_0_2 * (0.75 * fl2_fx + 3.0 * pa_z[j] * pc_z[j] * fl1_fx + 3.0 * pc_zz[j] * fl1_fx + 3.0 * pc_z[j] * fl1_fx * pb_z[j] + pa_zz[j] * pc_zz[j] + 4.0 * pa_z[j] * pc_zz[j] * pb_z[j] + pc_zz[j] * pb_zz[j]);

                t_zz_zz[j] += fl_s_0_0_3 * (-3.0 * pc_zz[j] * fl1_fx - 2.0 * pa_z[j] * pc_zzz[j] - 2.0 * pc_zzz[j] * pb_z[j]);

                t_zz_zz[j] += fl_s_0_0_4 * pc_zzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF(      CMemBlock2D<double>& primBuffer,
                              const CMemBlock2D<double>& auxBuffer,
                              const CMemBlock2D<double>& osFactors,
                              const CMemBlock2D<double>& paDistances,
                              const CMemBlock2D<double>& pbDistances,
                              const CMemBlock2D<double>& pcDistances,
                              const CGtoBlock&           braGtoBlock,
                              const CGtoBlock&           ketGtoBlock,
                              const int32_t              iContrGto)
    {
        npotrecfunc::compNuclearPotentialForDF_0_3(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_3_6(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_6_9(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_9_12(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                    braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_12_15(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_15_18(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_18_21(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_21_24(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_24_27(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_27_30(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_30_33(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_33_36(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_36_39(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_39_42(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_42_45(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_45_48(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_48_51(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_51_54(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_54_57(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDF_57_60(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 
    }

    void
    compNuclearPotentialForDF_0_3(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (0,3)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(19 * idx + 9);

            auto pb_xxy = pbDistances.data(19 * idx + 10);

            auto pb_xxz = pbDistances.data(19 * idx + 11);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(55 * idx + 19);

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(55 * idx + 34);

            auto pc_xxxxy = pcDistances.data(55 * idx + 35);

            auto pc_xxxxz = pcDistances.data(55 * idx + 36);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xx_xxx = primBuffer.data(60 * idx);

            auto t_xx_xxy = primBuffer.data(60 * idx + 1);

            auto t_xx_xxz = primBuffer.data(60 * idx + 2);

            // Batch of Integrals (0,3)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxx, pb_xxy, pb_xxz, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxx, pc_xxxxy, pc_xxxxz, pc_xxxy, pc_xxxz, pc_xxy, \
                                     pc_xxz, pc_xy, pc_xz, pc_y, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_xx_xxx, t_xx_xxy, t_xx_xxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xxx[j] = fl_s_0_0_0 * (1.5 * pa_x[j] * fl2_fx + 2.25 * fl2_fx * pb_x[j] + 1.5 * pa_xx[j] * pb_x[j] * fl1_fx + 3.0 * pa_x[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pb_xxx[j] + pa_xx[j] * pb_xxx[j]);

                t_xx_xxx[j] += fl_s_0_0_1 * (-3.0 * pa_x[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx - 4.5 * fl2_fx * pb_x[j] - 1.5 * pa_xx[j] * pb_x[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx - 9.0 * pa_x[j] * pc_x[j] * pb_x[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_xx[j] - 4.5 * pc_x[j] * fl1_fx * pb_xx[j] - 0.5 * fl1_fx * pb_xxx[j] - 3.0 * pa_xx[j] * pb_xx[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxx[j]);

                t_xx_xxx[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx + 2.25 * fl2_fx * pb_x[j] + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx + 9.0 * pa_x[j] * pc_x[j] * pb_x[j] * fl1_fx + 6.0 * pa_x[j] * pc_xx[j] * fl1_fx + 9.0 * pc_xx[j] * pb_x[j] * fl1_fx + 4.5 * pc_x[j] * fl1_fx * pb_xx[j] + 3.0 * pa_xx[j] * pb_x[j] * pc_xx[j] + 6.0 * pa_x[j] * pc_xx[j] * pb_xx[j] + pc_xx[j] * pb_xxx[j]);

                t_xx_xxx[j] += fl_s_0_0_3 * (-3.75 * pc_x[j] * fl2_fx - 6.0 * pa_x[j] * pc_xx[j] * fl1_fx - 9.0 * pc_xx[j] * pb_x[j] * fl1_fx - 5.0 * pc_xxx[j] * fl1_fx - pa_xx[j] * pc_xxx[j] - 6.0 * pa_x[j] * pc_xxx[j] * pb_x[j] - 3.0 * pc_xxx[j] * pb_xx[j]);

                t_xx_xxx[j] += fl_s_0_0_4 * (5.0 * pc_xxx[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxxx[j] + 3.0 * pc_xxxx[j] * pb_x[j]);

                t_xx_xxx[j] += -fl_s_0_0_5 * pc_xxxxx[j];

                t_xx_xxy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_y[j] + 0.5 * pa_xx[j] * fl1_fx * pb_y[j] + 2.0 * pa_x[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pb_xxy[j] + pa_xx[j] * pb_xxy[j]);

                t_xx_xxy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * fl2_fx * pb_y[j] - 0.5 * pa_xx[j] * fl1_fx * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pb_y[j] - 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] - 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] - 2.0 * pa_x[j] * fl1_fx * pb_xy[j] - 3.0 * pc_x[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pb_xx[j] * pc_y[j] - 0.5 * fl1_fx * pb_xxy[j] - pa_xx[j] * pb_xx[j] * pc_y[j] - 2.0 * pa_xx[j] * pb_xy[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxy[j]);

                t_xx_xxy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pb_y[j] + 0.5 * pa_xx[j] * fl1_fx * pc_y[j] + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] + 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] + 3.0 * pc_xx[j] * fl1_fx * pb_y[j] + 3.0 * pc_xy[j] * fl1_fx * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pb_xx[j] * pc_y[j] + 2.0 * pa_xx[j] * pb_x[j] * pc_xy[j] + pa_xx[j] * pc_xx[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xx[j] + 4.0 * pa_x[j] * pc_xx[j] * pb_xy[j] + pc_xx[j] * pb_xxy[j]);

                t_xx_xxy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx - 3.0 * pc_xxy[j] * fl1_fx - 3.0 * pc_xx[j] * fl1_fx * pb_y[j] - 3.0 * pc_xy[j] * fl1_fx * pb_x[j] - pa_xx[j] * pc_xxy[j] - 4.0 * pa_x[j] * pc_xxy[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxx[j] * pb_y[j] - pc_xxy[j] * pb_xx[j] - 2.0 * pc_xxx[j] * pb_xy[j]);

                t_xx_xxy[j] += fl_s_0_0_4 * (3.0 * pc_xxy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxxy[j] + 2.0 * pc_xxxy[j] * pb_x[j] + pc_xxxx[j] * pb_y[j]);

                t_xx_xxy[j] += -fl_s_0_0_5 * pc_xxxxy[j];

                t_xx_xxz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_z[j] + 0.5 * pa_xx[j] * fl1_fx * pb_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pb_xxz[j] + pa_xx[j] * pb_xxz[j]);

                t_xx_xxz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * fl2_fx * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_z[j] - 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_xz[j] - 3.0 * pc_x[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pb_xx[j] * pc_z[j] - 0.5 * fl1_fx * pb_xxz[j] - pa_xx[j] * pb_xx[j] * pc_z[j] - 2.0 * pa_xx[j] * pb_xz[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxz[j]);

                t_xx_xxz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pb_z[j] + 0.5 * pa_xx[j] * fl1_fx * pc_z[j] + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] + 3.0 * pc_xx[j] * fl1_fx * pb_z[j] + 3.0 * pc_xz[j] * fl1_fx * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pb_xx[j] * pc_z[j] + 2.0 * pa_xx[j] * pb_x[j] * pc_xz[j] + pa_xx[j] * pc_xx[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xx[j] + 4.0 * pa_x[j] * pc_xx[j] * pb_xz[j] + pc_xx[j] * pb_xxz[j]);

                t_xx_xxz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx - 3.0 * pc_xxz[j] * fl1_fx - 3.0 * pc_xx[j] * fl1_fx * pb_z[j] - 3.0 * pc_xz[j] * fl1_fx * pb_x[j] - pa_xx[j] * pc_xxz[j] - 4.0 * pa_x[j] * pc_xxz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxx[j] * pb_z[j] - pc_xxz[j] * pb_xx[j] - 2.0 * pc_xxx[j] * pb_xz[j]);

                t_xx_xxz[j] += fl_s_0_0_4 * (3.0 * pc_xxz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxxz[j] + 2.0 * pc_xxxz[j] * pb_x[j] + pc_xxxx[j] * pb_z[j]);

                t_xx_xxz[j] += -fl_s_0_0_5 * pc_xxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_3_6(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (3,6)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(19 * idx + 12);

            auto pb_xyz = pbDistances.data(19 * idx + 13);

            auto pb_xzz = pbDistances.data(19 * idx + 14);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(55 * idx + 37);

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxxzz = pcDistances.data(55 * idx + 39);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xx_xyy = primBuffer.data(60 * idx + 3);

            auto t_xx_xyz = primBuffer.data(60 * idx + 4);

            auto t_xx_xzz = primBuffer.data(60 * idx + 5);

            // Batch of Integrals (3,6)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xy, pb_xyy, pb_xyz, pb_xz, pb_xzz, pb_y, pb_yy, pb_yz, \
                                     pb_z, pb_zz, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyz, pc_xxxz, pc_xxxzz, \
                                     pc_xxy, pc_xxyy, pc_xxyz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyz, pc_xz, pc_xzz, pc_y, \
                                     pc_yy, pc_yz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_xx_xyy, t_xx_xyz, t_xx_xzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xyy[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * pb_x[j] * fl1_fx + pa_x[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pb_xyy[j] + pa_xx[j] * pb_xyy[j]);

                t_xx_xyy[j] += fl_s_0_0_1 * (-pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pb_x[j] - 0.5 * pa_xx[j] * pb_x[j] * fl1_fx - 0.5 * pa_xx[j] * pc_x[j] * fl1_fx - pa_x[j] * pc_x[j] * pb_x[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] - pa_x[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * fl1_fx * pb_yy[j] - fl1_fx * pb_xy[j] * pc_y[j] - 0.5 * fl1_fx * pb_xyy[j] - 2.0 * pa_xx[j] * pb_xy[j] * pc_y[j] - pa_xx[j] * pc_x[j] * pb_yy[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xyy[j]);

                t_xx_xyy[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * pc_x[j] * fl1_fx + pa_x[j] * pc_x[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_xx[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yy[j] + 2.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] + 0.5 * pc_xx[j] * pb_x[j] * fl1_fx + 3.0 * pc_xy[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pb_x[j] * pc_yy[j] + fl1_fx * pb_xy[j] * pc_y[j] + pa_xx[j] * pb_x[j] * pc_yy[j] + 2.0 * pa_xx[j] * pc_xy[j] * pb_y[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_xy[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_yy[j] + pc_xx[j] * pb_xyy[j]);

                t_xx_xyy[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - pa_x[j] * pc_xx[j] * fl1_fx - pa_x[j] * fl1_fx * pc_yy[j] - 0.5 * pc_xx[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * fl1_fx - 1.5 * pc_xyy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pb_x[j] * pc_yy[j] - pa_xx[j] * pc_xyy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_x[j] - 4.0 * pa_x[j] * pc_xxy[j] * pb_y[j] - 2.0 * pc_xxy[j] * pb_xy[j] - pc_xxx[j] * pb_yy[j]);

                t_xx_xyy[j] += fl_s_0_0_4 * (0.5 * pc_xxx[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxyy[j] + pc_xxyy[j] * pb_x[j] + 2.0 * pc_xxxy[j] * pb_y[j]);

                t_xx_xyy[j] += -fl_s_0_0_5 * pc_xxxyy[j];

                t_xx_xyz[j] = fl_s_0_0_0 * (pa_x[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pb_xyz[j] + pa_xx[j] * pb_xyz[j]);

                t_xx_xyz[j] += fl_s_0_0_1 * (-pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] - pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] - pa_x[j] * fl1_fx * pb_yz[j] - 1.5 * pc_x[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pb_xy[j] * pc_z[j] - 0.5 * fl1_fx * pb_xz[j] * pc_y[j] - 0.5 * fl1_fx * pb_xyz[j] - pa_xx[j] * pb_xy[j] * pc_z[j] - pa_xx[j] * pb_xz[j] * pc_y[j] - pa_xx[j] * pc_x[j] * pb_yz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xyz[j]);

                t_xx_xyz[j] += fl_s_0_0_2 * (pa_x[j] * fl1_fx * pc_yz[j] + pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] + pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pb_x[j] * pc_yz[j] + 0.5 * fl1_fx * pb_xy[j] * pc_z[j] + 0.5 * fl1_fx * pb_xz[j] * pc_y[j] + pa_xx[j] * pb_x[j] * pc_yz[j] + pa_xx[j] * pc_xz[j] * pb_y[j] + pa_xx[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xy[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xz[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_yz[j] + pc_xx[j] * pb_xyz[j]);

                t_xx_xyz[j] += fl_s_0_0_3 * (-pa_x[j] * fl1_fx * pc_yz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_x[j] * pc_yz[j] - pa_xx[j] * pc_xyz[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xxy[j] * pb_z[j] - pc_xxz[j] * pb_xy[j] - pc_xxy[j] * pb_xz[j] - pc_xxx[j] * pb_yz[j]);

                t_xx_xyz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxyz[j] + pc_xxyz[j] * pb_x[j] + pc_xxxz[j] * pb_y[j] + pc_xxxy[j] * pb_z[j]);

                t_xx_xyz[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_xx_xzz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * pb_x[j] * fl1_fx + pa_x[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_xzz[j] + pa_xx[j] * pb_xzz[j]);

                t_xx_xzz[j] += fl_s_0_0_1 * (-pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pb_x[j] - 0.5 * pa_xx[j] * pb_x[j] * fl1_fx - 0.5 * pa_xx[j] * pc_x[j] * fl1_fx - pa_x[j] * pc_x[j] * pb_x[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] - pa_x[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * fl1_fx * pb_zz[j] - fl1_fx * pb_xz[j] * pc_z[j] - 0.5 * fl1_fx * pb_xzz[j] - 2.0 * pa_xx[j] * pb_xz[j] * pc_z[j] - pa_xx[j] * pc_x[j] * pb_zz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xzz[j]);

                t_xx_xzz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * pc_x[j] * fl1_fx + pa_x[j] * pc_x[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_xx[j] * fl1_fx + pa_x[j] * fl1_fx * pc_zz[j] + 2.0 * pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] + 0.5 * pc_xx[j] * pb_x[j] * fl1_fx + 3.0 * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_x[j] * pc_zz[j] + fl1_fx * pb_xz[j] * pc_z[j] + pa_xx[j] * pb_x[j] * pc_zz[j] + 2.0 * pa_xx[j] * pc_xz[j] * pb_z[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_xz[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_zz[j] + pc_xx[j] * pb_xzz[j]);

                t_xx_xzz[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - pa_x[j] * pc_xx[j] * fl1_fx - pa_x[j] * fl1_fx * pc_zz[j] - 0.5 * pc_xx[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_x[j] * pc_zz[j] - pa_xx[j] * pc_xzz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_x[j] - 4.0 * pa_x[j] * pc_xxz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pb_xz[j] - pc_xxx[j] * pb_zz[j]);

                t_xx_xzz[j] += fl_s_0_0_4 * (0.5 * pc_xxx[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxzz[j] + pc_xxzz[j] * pb_x[j] + 2.0 * pc_xxxz[j] * pb_z[j]);

                t_xx_xzz[j] += -fl_s_0_0_5 * pc_xxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_6_9(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (6,9)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(19 * idx + 15);

            auto pb_yyz = pbDistances.data(19 * idx + 16);

            auto pb_yzz = pbDistances.data(19 * idx + 17);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(55 * idx + 40);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xx_yyy = primBuffer.data(60 * idx + 6);

            auto t_xx_yyz = primBuffer.data(60 * idx + 7);

            auto t_xx_yzz = primBuffer.data(60 * idx + 8);

            // Batch of Integrals (6,9)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_y, pb_yy, pb_yyy, pb_yyz, pb_yz, pb_yzz, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, \
                                     pc_yyz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_xx_yyy, t_xx_yyz, t_xx_yzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_yyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_y[j] + 1.5 * pa_xx[j] * pb_y[j] * fl1_fx + 0.5 * fl1_fx * pb_yyy[j] + pa_xx[j] * pb_yyy[j]);

                t_xx_yyy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pc_y[j] - 1.5 * pa_xx[j] * pb_y[j] * fl1_fx - 1.5 * pa_xx[j] * pc_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * pb_y[j] * fl1_fx - 1.5 * fl1_fx * pb_yy[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyy[j] - 3.0 * pa_xx[j] * pb_yy[j] * pc_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yyy[j]);

                t_xx_yyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pb_y[j] + 1.5 * pa_xx[j] * pc_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * pb_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx + 1.5 * pc_xx[j] * pb_y[j] * fl1_fx + 1.5 * fl1_fx * pb_y[j] * pc_yy[j] + 1.5 * fl1_fx * pb_yy[j] * pc_y[j] + 3.0 * pa_xx[j] * pb_y[j] * pc_yy[j] + 6.0 * pa_x[j] * pc_xy[j] * pb_yy[j] + pc_xx[j] * pb_yyy[j]);

                t_xx_yyy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx - 1.5 * pc_xx[j] * pb_y[j] * fl1_fx - 1.5 * pc_xxy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyy[j] - 1.5 * fl1_fx * pb_y[j] * pc_yy[j] - pa_xx[j] * pc_yyy[j] - 6.0 * pa_x[j] * pc_xyy[j] * pb_y[j] - 3.0 * pc_xxy[j] * pb_yy[j]);

                t_xx_yyy[j] += fl_s_0_0_4 * (1.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yyy[j] + 2.0 * pa_x[j] * pc_xyyy[j] + 3.0 * pc_xxyy[j] * pb_y[j]);

                t_xx_yyy[j] += -fl_s_0_0_5 * pc_xxyyy[j];

                t_xx_yyz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_z[j] + 0.5 * pa_xx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_yyz[j] + pa_xx[j] * pb_yyz[j]);

                t_xx_yyz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_z[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_yy[j] * pc_z[j] - fl1_fx * pb_yz[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyz[j] - pa_xx[j] * pb_yy[j] * pc_z[j] - 2.0 * pa_xx[j] * pb_yz[j] * pc_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yyz[j]);

                t_xx_yyz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_xx[j] * fl1_fx * pc_z[j] + pa_x[j] * pc_xz[j] * fl1_fx + pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * pc_xx[j] * fl1_fx * pb_z[j] + fl1_fx * pb_y[j] * pc_yz[j] + 0.5 * fl1_fx * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pb_yy[j] * pc_z[j] + fl1_fx * pb_yz[j] * pc_y[j] + 2.0 * pa_xx[j] * pb_y[j] * pc_yz[j] + pa_xx[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_yy[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_yz[j] + pc_xx[j] * pb_yyz[j]);

                t_xx_yyz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - pa_x[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_yyz[j] - fl1_fx * pb_y[j] * pc_yz[j] - 0.5 * fl1_fx * pc_yy[j] * pb_z[j] - pa_xx[j] * pc_yyz[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_z[j] - pc_xxz[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pb_yz[j]);

                t_xx_yyz[j] += fl_s_0_0_4 * (0.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] + 2.0 * pc_xxyz[j] * pb_y[j] + pc_xxyy[j] * pb_z[j]);

                t_xx_yyz[j] += -fl_s_0_0_5 * pc_xxyyz[j];

                t_xx_yzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_y[j] + 0.5 * pa_xx[j] * pb_y[j] * fl1_fx + 0.5 * fl1_fx * pb_yzz[j] + pa_xx[j] * pb_yzz[j]);

                t_xx_yzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pb_y[j] - 0.25 * fl2_fx * pc_y[j] - 0.5 * pa_xx[j] * pb_y[j] * fl1_fx - 0.5 * pa_xx[j] * pc_y[j] * fl1_fx - pa_x[j] * pc_x[j] * pb_y[j] * fl1_fx - fl1_fx * pb_yz[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pb_yzz[j] - 2.0 * pa_xx[j] * pb_yz[j] * pc_z[j] - pa_xx[j] * pc_y[j] * pb_zz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yzz[j]);

                t_xx_yzz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_xx[j] * pc_y[j] * fl1_fx + pa_x[j] * pc_x[j] * pb_y[j] * fl1_fx + pa_x[j] * pc_xy[j] * fl1_fx + 0.5 * pc_xx[j] * pb_y[j] * fl1_fx + 0.5 * fl1_fx * pb_y[j] * pc_zz[j] + fl1_fx * pc_yz[j] * pb_z[j] + fl1_fx * pb_yz[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_zz[j] + pa_xx[j] * pb_y[j] * pc_zz[j] + 2.0 * pa_xx[j] * pc_yz[j] * pb_z[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_yz[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_zz[j] + pc_xx[j] * pb_yzz[j]);

                t_xx_yzz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xx[j] * pb_y[j] * fl1_fx - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * fl1_fx * pc_yzz[j] - 0.5 * fl1_fx * pb_y[j] * pc_zz[j] - fl1_fx * pc_yz[j] * pb_z[j] - pa_xx[j] * pc_yzz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_y[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pb_yz[j] - pc_xxy[j] * pb_zz[j]);

                t_xx_yzz[j] += fl_s_0_0_4 * (0.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yzz[j] + 2.0 * pa_x[j] * pc_xyzz[j] + pc_xxzz[j] * pb_y[j] + 2.0 * pc_xxyz[j] * pb_z[j]);

                t_xx_yzz[j] += -fl_s_0_0_5 * pc_xxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_9_12(      CMemBlock2D<double>& primBuffer,
                                   const CMemBlock2D<double>& auxBuffer,
                                   const CMemBlock2D<double>& osFactors,
                                   const CMemBlock2D<double>& paDistances,
                                   const CMemBlock2D<double>& pbDistances,
                                   const CMemBlock2D<double>& pcDistances,
                                   const CGtoBlock&           braGtoBlock,
                                   const CGtoBlock&           ketGtoBlock,
                                   const int32_t              iContrGto)
    {
        // Batch of Integrals (9,12)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(19 * idx + 9);

            auto pb_xxy = pbDistances.data(19 * idx + 10);

            auto pb_zzz = pbDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(55 * idx + 19);

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(55 * idx + 35);

            auto pc_xxxyy = pcDistances.data(55 * idx + 37);

            auto pc_xxzzz = pcDistances.data(55 * idx + 43);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xx_zzz = primBuffer.data(60 * idx + 9);

            auto t_xy_xxx = primBuffer.data(60 * idx + 10);

            auto t_xy_xxy = primBuffer.data(60 * idx + 11);

            // Batch of Integrals (9,12)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xy, pa_y, pb_x, pb_xx, pb_xxx, pb_xxy, pb_xy, pb_y, pb_z, pb_zz, \
                                     pb_zzz, pc_x, pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, \
                                     pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, pc_xyy, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_z, \
                                     pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xx_zzz, \
                                     t_xy_xxx, t_xy_xxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_zzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_z[j] + 1.5 * pa_xx[j] * pb_z[j] * fl1_fx + 0.5 * fl1_fx * pb_zzz[j] + pa_xx[j] * pb_zzz[j]);

                t_xx_zzz[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_z[j] - 0.75 * fl2_fx * pc_z[j] - 1.5 * pa_xx[j] * pb_z[j] * fl1_fx - 1.5 * pa_xx[j] * pc_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * pb_z[j] * fl1_fx - 1.5 * fl1_fx * pb_zz[j] * pc_z[j] - 0.5 * fl1_fx * pb_zzz[j] - 3.0 * pa_xx[j] * pb_zz[j] * pc_z[j] - 2.0 * pa_x[j] * pc_x[j] * pb_zzz[j]);

                t_xx_zzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pb_z[j] + 1.5 * pa_xx[j] * pc_z[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * pb_z[j] * fl1_fx + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx + 1.5 * pc_xx[j] * pb_z[j] * fl1_fx + 1.5 * fl1_fx * pb_z[j] * pc_zz[j] + 1.5 * fl1_fx * pb_zz[j] * pc_z[j] + 3.0 * pa_xx[j] * pb_z[j] * pc_zz[j] + 6.0 * pa_x[j] * pc_xz[j] * pb_zz[j] + pc_xx[j] * pb_zzz[j]);

                t_xx_zzz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx - 1.5 * pc_xx[j] * pb_z[j] * fl1_fx - 1.5 * pc_xxz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzz[j] - 1.5 * fl1_fx * pb_z[j] * pc_zz[j] - pa_xx[j] * pc_zzz[j] - 6.0 * pa_x[j] * pc_xzz[j] * pb_z[j] - 3.0 * pc_xxz[j] * pb_zz[j]);

                t_xx_zzz[j] += fl_s_0_0_4 * (1.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] + 3.0 * pc_xxzz[j] * pb_z[j]);

                t_xx_zzz[j] += -fl_s_0_0_5 * pc_xxzzz[j];

                t_xy_xxx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_y[j] + 1.5 * pa_xy[j] * pb_x[j] * fl1_fx + 1.5 * fl1_fx * pa_y[j] * pb_xx[j] + pa_xy[j] * pb_xxx[j]);

                t_xy_xxx[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_y[j] - 0.75 * fl2_fx * pc_y[j] - 1.5 * pa_xy[j] * pb_x[j] * fl1_fx - 1.5 * pa_xy[j] * pc_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * pb_x[j] * fl1_fx - 4.5 * pc_x[j] * pa_y[j] * pb_x[j] * fl1_fx - 1.5 * fl1_fx * pc_y[j] * pb_xx[j] - 1.5 * fl1_fx * pa_y[j] * pb_xx[j] - 3.0 * pa_xy[j] * pb_xx[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxx[j] - pc_x[j] * pa_y[j] * pb_xxx[j]);

                t_xy_xxx[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pa_y[j] + 1.5 * pa_xy[j] * pc_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx + 4.5 * pc_x[j] * pa_y[j] * pb_x[j] * fl1_fx + 3.0 * pc_xx[j] * pa_y[j] * fl1_fx + 4.5 * pc_xy[j] * pb_x[j] * fl1_fx + 1.5 * fl1_fx * pc_y[j] * pb_xx[j] + 3.0 * pa_xy[j] * pb_x[j] * pc_xx[j] + 3.0 * pa_x[j] * pc_xy[j] * pb_xx[j] + 3.0 * pc_xx[j] * pa_y[j] * pb_xx[j] + pc_xy[j] * pb_xxx[j]);

                t_xy_xxx[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx - 3.0 * pc_xx[j] * pa_y[j] * fl1_fx - 4.5 * pc_xy[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxy[j] * fl1_fx - pa_xy[j] * pc_xxx[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_x[j] - 3.0 * pc_xxx[j] * pa_y[j] * pb_x[j] - 3.0 * pc_xxy[j] * pb_xx[j]);

                t_xy_xxx[j] += fl_s_0_0_4 * (3.0 * pc_xxy[j] * fl1_fx + pa_x[j] * pc_xxxy[j] + pc_xxxx[j] * pa_y[j] + 3.0 * pc_xxxy[j] * pb_x[j]);

                t_xy_xxx[j] += -fl_s_0_0_5 * pc_xxxxy[j];

                t_xy_xxy[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + 0.5 * pa_xy[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_xx[j] + fl1_fx * pa_y[j] * pb_xy[j] + pa_xy[j] * pb_xxy[j]);

                t_xy_xxy[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - fl2_fx * pb_x[j] - 0.5 * pa_xy[j] * fl1_fx * pc_y[j] - 0.5 * pa_xy[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_y[j] - pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * fl1_fx * pb_xx[j] - fl1_fx * pa_y[j] * pb_x[j] * pc_y[j] - fl1_fx * pc_y[j] * pb_xy[j] - fl1_fx * pa_y[j] * pb_xy[j] - pa_xy[j] * pb_xx[j] * pc_y[j] - 2.0 * pa_xy[j] * pb_xy[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxy[j] - pc_x[j] * pa_y[j] * pb_xxy[j]);

                t_xy_xxy[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + 0.5 * pa_xy[j] * fl1_fx * pc_y[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_xx[j] + pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] + 1.5 * pc_xy[j] * pa_y[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_y[j] + pc_xx[j] * fl1_fx * pb_x[j] + 0.5 * pc_x[j] * fl1_fx * pb_xx[j] + fl1_fx * pc_yy[j] * pb_x[j] + fl1_fx * pa_y[j] * pb_x[j] * pc_y[j] + fl1_fx * pc_y[j] * pb_xy[j] + 2.0 * pa_xy[j] * pb_x[j] * pc_xy[j] + pa_xy[j] * pc_xx[j] * pb_y[j] + pa_x[j] * pc_yy[j] * pb_xx[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xy[j] + pc_xy[j] * pa_y[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_y[j] * pb_xy[j] + pc_xy[j] * pb_xxy[j]);

                t_xy_xxy[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_xx[j] - 1.5 * pc_xy[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyy[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxx[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_x[j] - fl1_fx * pc_yy[j] * pb_x[j] - pa_xy[j] * pc_xxy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_x[j] - pa_x[j] * pc_xxy[j] * pb_y[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_x[j] - pc_xxx[j] * pa_y[j] * pb_y[j] - pc_xyy[j] * pb_xx[j] - 2.0 * pc_xxy[j] * pb_xy[j]);

                t_xy_xxy[j] += fl_s_0_0_4 * (1.5 * pc_xyy[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx + pa_x[j] * pc_xxyy[j] + pc_xxxy[j] * pa_y[j] + 2.0 * pc_xxyy[j] * pb_x[j] + pc_xxxy[j] * pb_y[j]);

                t_xy_xxy[j] += -fl_s_0_0_5 * pc_xxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_12_15(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (12,15)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(19 * idx + 11);

            auto pb_xyy = pbDistances.data(19 * idx + 12);

            auto pb_xyz = pbDistances.data(19 * idx + 13);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxyyy = pcDistances.data(55 * idx + 40);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xy_xxz = primBuffer.data(60 * idx + 12);

            auto t_xy_xyy = primBuffer.data(60 * idx + 13);

            auto t_xy_xyz = primBuffer.data(60 * idx + 14);

            // Batch of Integrals (12,15)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxz, pb_xy, pb_xyy, pb_xyz, pb_xz, pb_y, \
                                     pb_yy, pb_yz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, \
                                     pc_xxyyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyz, pc_xyz, pc_xz, \
                                     pc_y, pc_yy, pc_yyy, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, t_xy_xxz, t_xy_xyy, t_xy_xyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xxz[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl1_fx * pb_z[j] + fl1_fx * pa_y[j] * pb_xz[j] + pa_xy[j] * pb_xxz[j]);

                t_xy_xxz[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl1_fx * pc_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] - fl1_fx * pa_y[j] * pb_x[j] * pc_z[j] - fl1_fx * pc_y[j] * pb_xz[j] - fl1_fx * pa_y[j] * pb_xz[j] - pa_xy[j] * pb_xx[j] * pc_z[j] - 2.0 * pa_xy[j] * pb_xz[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxz[j] - pc_x[j] * pa_y[j] * pb_xxz[j]);

                t_xy_xxz[j] += fl_s_0_0_2 * (0.5 * pa_xy[j] * fl1_fx * pc_z[j] + 0.5 * pa_x[j] * pc_yz[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + fl1_fx * pc_yz[j] * pb_x[j] + fl1_fx * pa_y[j] * pb_x[j] * pc_z[j] + fl1_fx * pc_y[j] * pb_xz[j] + 2.0 * pa_xy[j] * pb_x[j] * pc_xz[j] + pa_xy[j] * pc_xx[j] * pb_z[j] + pa_x[j] * pc_yz[j] * pb_xx[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xz[j] + pc_xz[j] * pa_y[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_y[j] * pb_xz[j] + pc_xy[j] * pb_xxz[j]);

                t_xy_xxz[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * pc_yz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - fl1_fx * pc_yz[j] * pb_x[j] - pa_xy[j] * pc_xxz[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_x[j] - pa_x[j] * pc_xxy[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_y[j] * pb_x[j] - pc_xxx[j] * pa_y[j] * pb_z[j] - pc_xyz[j] * pb_xx[j] - 2.0 * pc_xxy[j] * pb_xz[j]);

                t_xy_xxz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_xxyz[j] + pc_xxxz[j] * pa_y[j] + 2.0 * pc_xxyz[j] * pb_x[j] + pc_xxxy[j] * pb_z[j]);

                t_xy_xxz[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_xy_xyy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_y[j] + 0.5 * fl2_fx * pb_y[j] + 0.5 * pa_xy[j] * pb_x[j] * fl1_fx + pa_x[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_y[j] * pb_yy[j] + pa_xy[j] * pb_xyy[j]);

                t_xy_xyy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] - 0.75 * fl2_fx * pc_y[j] - fl2_fx * pb_y[j] - 0.5 * pa_xy[j] * pb_x[j] * fl1_fx - 0.5 * pa_xy[j] * pc_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * pb_x[j] * fl1_fx - pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] - pa_x[j] * fl1_fx * pb_xy[j] - 0.5 * pc_x[j] * pa_y[j] * pb_x[j] * fl1_fx - pc_x[j] * fl1_fx * pb_xy[j] - fl1_fx * pa_y[j] * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_yy[j] - 0.5 * fl1_fx * pa_y[j] * pb_yy[j] - 2.0 * pa_xy[j] * pb_xy[j] * pc_y[j] - pa_xy[j] * pc_x[j] * pb_yy[j] - pa_x[j] * pc_y[j] * pb_xyy[j] - pc_x[j] * pa_y[j] * pb_xyy[j]);

                t_xy_xyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pa_y[j] + 0.5 * fl2_fx * pb_y[j] + 0.5 * pa_xy[j] * pc_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx + pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pc_x[j] * pa_y[j] * pb_x[j] * fl1_fx + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx + 1.5 * pc_xy[j] * pb_x[j] * fl1_fx + pc_xx[j] * fl1_fx * pb_y[j] + pc_x[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_y[j] * pc_yy[j] + fl1_fx * pc_yy[j] * pb_y[j] + fl1_fx * pa_y[j] * pb_y[j] * pc_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_yy[j] + pa_xy[j] * pb_x[j] * pc_yy[j] + 2.0 * pa_xy[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_x[j] * pc_yy[j] * pb_xy[j] + pa_x[j] * pc_xy[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_xy[j] + pc_xx[j] * pa_y[j] * pb_yy[j] + pc_xy[j] * pb_xyy[j]);

                t_xy_xyy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxy[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yyy[j] - 0.5 * fl1_fx * pa_y[j] * pc_yy[j] - fl1_fx * pc_yy[j] * pb_y[j] - pa_xy[j] * pc_xyy[j] - pa_x[j] * pc_yyy[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_y[j] - pc_xyy[j] * pa_y[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_y[j] - 2.0 * pc_xyy[j] * pb_xy[j] - pc_xxy[j] * pb_yy[j]);

                t_xy_xyy[j] += fl_s_0_0_4 * (1.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yyy[j] + pa_x[j] * pc_xyyy[j] + pc_xxyy[j] * pa_y[j] + pc_xyyy[j] * pb_x[j] + 2.0 * pc_xxyy[j] * pb_y[j]);

                t_xy_xyy[j] += -fl_s_0_0_5 * pc_xxyyy[j];

                t_xy_xyz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_y[j] * pb_yz[j] + pa_xy[j] * pb_xyz[j]);

                t_xy_xyz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_xz[j] - 0.5 * pc_x[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_yz[j] - 0.5 * fl1_fx * pa_y[j] * pb_yz[j] - pa_xy[j] * pb_xy[j] * pc_z[j] - pa_xy[j] * pb_xz[j] * pc_y[j] - pa_xy[j] * pc_x[j] * pb_yz[j] - pa_x[j] * pc_y[j] * pb_xyz[j] - pc_x[j] * pa_y[j] * pb_xyz[j]);

                t_xy_xyz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_xz[j] + 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yz[j] + 0.5 * fl1_fx * pc_yz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_y[j] * pb_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_yz[j] + pa_xy[j] * pb_x[j] * pc_yz[j] + pa_xy[j] * pc_xz[j] * pb_y[j] + pa_xy[j] * pc_xy[j] * pb_z[j] + pa_x[j] * pc_yz[j] * pb_xy[j] + pa_x[j] * pc_yy[j] * pb_xz[j] + pa_x[j] * pc_xy[j] * pb_yz[j] + pc_xz[j] * pa_y[j] * pb_xy[j] + pc_xy[j] * pa_y[j] * pb_xz[j] + pc_xx[j] * pa_y[j] * pb_yz[j] + pc_xy[j] * pb_xyz[j]);

                t_xy_xyz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xz[j] - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * pc_xz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_yyz[j] - 0.5 * fl1_fx * pa_y[j] * pc_yz[j] - 0.5 * fl1_fx * pc_yz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pb_z[j] - pa_xy[j] * pc_xyz[j] - pa_x[j] * pc_yyz[j] * pb_x[j] - pa_x[j] * pc_xyz[j] * pb_y[j] - pa_x[j] * pc_xyy[j] * pb_z[j] - pc_xyz[j] * pa_y[j] * pb_x[j] - pc_xxz[j] * pa_y[j] * pb_y[j] - pc_xxy[j] * pa_y[j] * pb_z[j] - pc_xyz[j] * pb_xy[j] - pc_xyy[j] * pb_xz[j] - pc_xxy[j] * pb_yz[j]);

                t_xy_xyz[j] += fl_s_0_0_4 * (0.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyz[j] + pa_x[j] * pc_xyyz[j] + pc_xxyz[j] * pa_y[j] + pc_xyyz[j] * pb_x[j] + pc_xxyz[j] * pb_y[j] + pc_xxyy[j] * pb_z[j]);

                t_xy_xyz[j] += -fl_s_0_0_5 * pc_xxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_15_18(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (15,18)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(19 * idx + 14);

            auto pb_yyy = pbDistances.data(19 * idx + 15);

            auto pb_yyz = pbDistances.data(19 * idx + 16);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xyyyy = pcDistances.data(55 * idx + 44);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xy_xzz = primBuffer.data(60 * idx + 15);

            auto t_xy_yyy = primBuffer.data(60 * idx + 16);

            auto t_xy_yyz = primBuffer.data(60 * idx + 17);

            // Batch of Integrals (15,18)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xz, pb_xzz, pb_y, pb_yy, pb_yyy, pb_yyz, pb_yz, pb_z, \
                                     pb_zz, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_xyyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyy, pc_yyyz, pc_yyz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xy_xzz, t_xy_yyy, t_xy_yyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_y[j] + 0.5 * pa_xy[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pa_y[j] * pb_zz[j] + pa_xy[j] * pb_xzz[j]);

                t_xy_xzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] - 0.25 * fl2_fx * pc_y[j] - 0.5 * pa_xy[j] * pb_x[j] * fl1_fx - 0.5 * pa_xy[j] * pc_x[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * pb_x[j] * fl1_fx - 0.5 * pc_x[j] * pa_y[j] * pb_x[j] * fl1_fx - fl1_fx * pa_y[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pa_y[j] * pb_zz[j] - 2.0 * pa_xy[j] * pb_xz[j] * pc_z[j] - pa_xy[j] * pc_x[j] * pb_zz[j] - pa_x[j] * pc_y[j] * pb_xzz[j] - pc_x[j] * pa_y[j] * pb_xzz[j]);

                t_xy_xzz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pa_y[j] + 0.5 * pa_xy[j] * pc_x[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * pb_x[j] * fl1_fx + 0.5 * pa_x[j] * pc_xy[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * pb_x[j] * fl1_fx + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx + 0.5 * pc_xy[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] + fl1_fx * pc_yz[j] * pb_z[j] + fl1_fx * pa_y[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_zz[j] + pa_xy[j] * pb_x[j] * pc_zz[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_xz[j] + pa_x[j] * pc_xy[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_y[j] * pb_xz[j] + pc_xx[j] * pa_y[j] * pb_zz[j] + pc_xy[j] * pb_xzz[j]);

                t_xy_xzz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx - 0.5 * pc_xy[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * fl1_fx * pc_yzz[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] - fl1_fx * pc_yz[j] * pb_z[j] - pa_xy[j] * pc_xzz[j] - pa_x[j] * pc_yzz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_z[j] - pc_xzz[j] * pa_y[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_y[j] * pb_z[j] - 2.0 * pc_xyz[j] * pb_xz[j] - pc_xxy[j] * pb_zz[j]);

                t_xy_xzz[j] += fl_s_0_0_4 * (0.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yzz[j] + pa_x[j] * pc_xyzz[j] + pc_xxzz[j] * pa_y[j] + pc_xyzz[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pb_z[j]);

                t_xy_xzz[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_xy_yyy[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pa_xy[j] * pb_y[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_yy[j] + pa_xy[j] * pb_yyy[j]);

                t_xy_yyy[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 1.5 * pa_xy[j] * pb_y[j] * fl1_fx - 1.5 * pa_xy[j] * pc_y[j] * fl1_fx - 4.5 * pa_x[j] * pc_y[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * pa_y[j] * pb_y[j] * fl1_fx - 1.5 * pc_x[j] * fl1_fx * pb_yy[j] - 3.0 * pa_xy[j] * pb_yy[j] * pc_y[j] - pa_x[j] * pc_y[j] * pb_yyy[j] - pc_x[j] * pa_y[j] * pb_yyy[j]);

                t_xy_yyy[j] += fl_s_0_0_2 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 1.5 * pa_xy[j] * pc_y[j] * fl1_fx + 4.5 * pa_x[j] * pc_y[j] * pb_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_yy[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * pb_y[j] * fl1_fx + 1.5 * pc_xy[j] * pa_y[j] * fl1_fx + 4.5 * pc_xy[j] * pb_y[j] * fl1_fx + 1.5 * pc_x[j] * fl1_fx * pb_yy[j] + 3.0 * pa_xy[j] * pb_y[j] * pc_yy[j] + 3.0 * pa_x[j] * pc_yy[j] * pb_yy[j] + 3.0 * pc_xy[j] * pa_y[j] * pb_yy[j] + pc_xy[j] * pb_yyy[j]);

                t_xy_yyy[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 3.0 * pa_x[j] * pc_yy[j] * fl1_fx - 1.5 * pc_xy[j] * pa_y[j] * fl1_fx - 4.5 * pc_xy[j] * pb_y[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx - pa_xy[j] * pc_yyy[j] - 3.0 * pa_x[j] * pc_yyy[j] * pb_y[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_y[j] - 3.0 * pc_xyy[j] * pb_yy[j]);

                t_xy_yyy[j] += fl_s_0_0_4 * (3.0 * pc_xyy[j] * fl1_fx + pa_x[j] * pc_yyyy[j] + pc_xyyy[j] * pa_y[j] + 3.0 * pc_xyyy[j] * pb_y[j]);

                t_xy_yyy[j] += -fl_s_0_0_5 * pc_xyyyy[j];

                t_xy_yyz[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl1_fx * pb_z[j] + pa_x[j] * fl1_fx * pb_yz[j] + pa_xy[j] * pb_yyz[j]);

                t_xy_yyz[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl1_fx * pc_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] - pa_x[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] - pc_x[j] * fl1_fx * pb_yz[j] - pa_xy[j] * pb_yy[j] * pc_z[j] - 2.0 * pa_xy[j] * pb_yz[j] * pc_y[j] - pa_x[j] * pc_y[j] * pb_yyz[j] - pc_x[j] * pa_y[j] * pb_yyz[j]);

                t_xy_yyz[j] += fl_s_0_0_2 * (0.5 * pa_xy[j] * fl1_fx * pc_z[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] + pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pc_xz[j] * pa_y[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + pc_xz[j] * fl1_fx * pb_y[j] + pc_x[j] * fl1_fx * pb_yz[j] + 2.0 * pa_xy[j] * pb_y[j] * pc_yz[j] + pa_xy[j] * pc_yy[j] * pb_z[j] + pa_x[j] * pc_yz[j] * pb_yy[j] + 2.0 * pa_x[j] * pc_yy[j] * pb_yz[j] + pc_xz[j] * pa_y[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_yz[j] + pc_xy[j] * pb_yyz[j]);

                t_xy_yyz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - 0.5 * pc_xz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - pc_xz[j] * fl1_fx * pb_y[j] - pa_xy[j] * pc_yyz[j] - 2.0 * pa_x[j] * pc_yyz[j] * pb_y[j] - pa_x[j] * pc_yyy[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_y[j] - pc_xyy[j] * pa_y[j] * pb_z[j] - pc_xyz[j] * pb_yy[j] - 2.0 * pc_xyy[j] * pb_yz[j]);

                t_xy_yyz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yyyz[j] + pc_xyyz[j] * pa_y[j] + 2.0 * pc_xyyz[j] * pb_y[j] + pc_xyyy[j] * pb_z[j]);

                t_xy_yyz[j] += -fl_s_0_0_5 * pc_xyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_18_21(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (18,21)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(19 * idx + 9);

            auto pb_yzz = pbDistances.data(19 * idx + 17);

            auto pb_zzz = pbDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(55 * idx + 19);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(55 * idx + 36);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xy_yzz = primBuffer.data(60 * idx + 18);

            auto t_xy_zzz = primBuffer.data(60 * idx + 19);

            auto t_xz_xxx = primBuffer.data(60 * idx + 20);

            // Batch of Integrals (18,21)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xz, pa_y, pa_z, pb_x, pb_xx, pb_xxx, pb_y, pb_yz, pb_yzz, pb_z, \
                                     pb_zz, pb_zzz, pc_x, pc_xx, pc_xxx, pc_xxxx, pc_xxxxz, pc_xxxz, pc_xxz, pc_xy, pc_xyy, \
                                     pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, \
                                     pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xy_yzz, t_xy_zzz, t_xz_xxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_yzz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pa_xy[j] * pb_y[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_zz[j] + pa_xy[j] * pb_yzz[j]);

                t_xy_yzz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx - 0.5 * pa_xy[j] * pb_y[j] * fl1_fx - 0.5 * pa_xy[j] * pc_y[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * pb_y[j] * fl1_fx - pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_zz[j] - 0.5 * pc_x[j] * pa_y[j] * pb_y[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xy[j] * pb_yz[j] * pc_z[j] - pa_xy[j] * pc_y[j] * pb_zz[j] - pa_x[j] * pc_y[j] * pb_yzz[j] - pc_x[j] * pa_y[j] * pb_yzz[j]);

                t_xy_yzz[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx + 0.5 * pa_xy[j] * pc_y[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * pb_y[j] * fl1_fx + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] + pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] + 0.5 * pc_x[j] * pa_y[j] * pb_y[j] * fl1_fx + 0.5 * pc_xy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xy[j] * pb_y[j] * fl1_fx + pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_zz[j] + pa_xy[j] * pb_y[j] * pc_zz[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_yz[j] + pa_x[j] * pc_yy[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_y[j] * pb_yz[j] + pc_xy[j] * pa_y[j] * pb_zz[j] + pc_xy[j] * pb_yzz[j]);

                t_xy_yzz[j] += fl_s_0_0_3 * (-0.25 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] - 0.5 * pc_xy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xy[j] * pb_y[j] * fl1_fx - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * pc_xzz[j] * fl1_fx - pc_xz[j] * fl1_fx * pb_z[j] - pa_xy[j] * pc_yzz[j] - pa_x[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_yyz[j] * pb_z[j] - pc_xzz[j] * pa_y[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_z[j] - 2.0 * pc_xyz[j] * pb_yz[j] - pc_xyy[j] * pb_zz[j]);

                t_xy_yzz[j] += fl_s_0_0_4 * (0.5 * pc_xyy[j] * fl1_fx + 0.5 * pc_xzz[j] * fl1_fx + pa_x[j] * pc_yyzz[j] + pc_xyzz[j] * pa_y[j] + pc_xyzz[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pb_z[j]);

                t_xy_yzz[j] += -fl_s_0_0_5 * pc_xyyzz[j];

                t_xy_zzz[j] = fl_s_0_0_0 * (1.5 * pa_xy[j] * pb_z[j] * fl1_fx + pa_xy[j] * pb_zzz[j]);

                t_xy_zzz[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * pb_z[j] * fl1_fx - 1.5 * pa_xy[j] * pc_z[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * pb_z[j] * fl1_fx - 1.5 * pc_x[j] * pa_y[j] * pb_z[j] * fl1_fx - 3.0 * pa_xy[j] * pb_zz[j] * pc_z[j] - pa_x[j] * pc_y[j] * pb_zzz[j] - pc_x[j] * pa_y[j] * pb_zzz[j]);

                t_xy_zzz[j] += fl_s_0_0_2 * (1.5 * pa_xy[j] * pc_z[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * pb_z[j] * fl1_fx + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xy[j] * pb_z[j] * fl1_fx + 3.0 * pa_xy[j] * pb_z[j] * pc_zz[j] + 3.0 * pa_x[j] * pc_yz[j] * pb_zz[j] + 3.0 * pc_xz[j] * pa_y[j] * pb_zz[j] + pc_xy[j] * pb_zzz[j]);

                t_xy_zzz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pb_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pa_xy[j] * pc_zzz[j] - 3.0 * pa_x[j] * pc_yzz[j] * pb_z[j] - 3.0 * pc_xzz[j] * pa_y[j] * pb_z[j] - 3.0 * pc_xyz[j] * pb_zz[j]);

                t_xy_zzz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yzzz[j] + pc_xzzz[j] * pa_y[j] + 3.0 * pc_xyzz[j] * pb_z[j]);

                t_xy_zzz[j] += -fl_s_0_0_5 * pc_xyzzz[j];

                t_xz_xxx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] + 1.5 * pa_xz[j] * pb_x[j] * fl1_fx + 1.5 * fl1_fx * pa_z[j] * pb_xx[j] + pa_xz[j] * pb_xxx[j]);

                t_xz_xxx[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - 1.5 * pa_xz[j] * pb_x[j] * fl1_fx - 1.5 * pa_xz[j] * pc_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * pb_x[j] * fl1_fx - 4.5 * pc_x[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * fl1_fx * pc_z[j] * pb_xx[j] - 1.5 * fl1_fx * pa_z[j] * pb_xx[j] - 3.0 * pa_xz[j] * pb_xx[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxx[j] - pc_x[j] * pa_z[j] * pb_xxx[j]);

                t_xz_xxx[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pa_z[j] + 1.5 * pa_xz[j] * pc_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx + 4.5 * pc_x[j] * pa_z[j] * pb_x[j] * fl1_fx + 3.0 * pc_xx[j] * pa_z[j] * fl1_fx + 4.5 * pc_xz[j] * pb_x[j] * fl1_fx + 1.5 * fl1_fx * pc_z[j] * pb_xx[j] + 3.0 * pa_xz[j] * pb_x[j] * pc_xx[j] + 3.0 * pa_x[j] * pc_xz[j] * pb_xx[j] + 3.0 * pc_xx[j] * pa_z[j] * pb_xx[j] + pc_xz[j] * pb_xxx[j]);

                t_xz_xxx[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx - 3.0 * pc_xx[j] * pa_z[j] * fl1_fx - 4.5 * pc_xz[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxz[j] * fl1_fx - pa_xz[j] * pc_xxx[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_x[j] - 3.0 * pc_xxx[j] * pa_z[j] * pb_x[j] - 3.0 * pc_xxz[j] * pb_xx[j]);

                t_xz_xxx[j] += fl_s_0_0_4 * (3.0 * pc_xxz[j] * fl1_fx + pa_x[j] * pc_xxxz[j] + pc_xxxx[j] * pa_z[j] + 3.0 * pc_xxxz[j] * pb_x[j]);

                t_xz_xxx[j] += -fl_s_0_0_5 * pc_xxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_21_24(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (21,24)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(19 * idx + 10);

            auto pb_xxz = pbDistances.data(19 * idx + 11);

            auto pb_xyy = pbDistances.data(19 * idx + 12);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxxzz = pcDistances.data(55 * idx + 39);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xz_xxy = primBuffer.data(60 * idx + 21);

            auto t_xz_xxz = primBuffer.data(60 * idx + 22);

            auto t_xz_xyy = primBuffer.data(60 * idx + 23);

            // Batch of Integrals (21,24)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxy, pb_xxz, pb_xy, pb_xyy, pb_xz, pb_y, \
                                     pb_yy, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxxzz, pc_xxy, \
                                     pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, t_xz_xxy, t_xz_xxz, t_xz_xyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xxy[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * fl1_fx * pb_y[j] + fl1_fx * pa_z[j] * pb_xy[j] + pa_xz[j] * pb_xxy[j]);

                t_xz_xxy[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl1_fx * pc_y[j] - 0.5 * pa_xz[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_y[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_y[j] - fl1_fx * pc_z[j] * pb_xy[j] - fl1_fx * pa_z[j] * pb_xy[j] - pa_xz[j] * pb_xx[j] * pc_y[j] - 2.0 * pa_xz[j] * pb_xy[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxy[j] - pc_x[j] * pa_z[j] * pb_xxy[j]);

                t_xz_xxy[j] += fl_s_0_0_2 * (0.5 * pa_xz[j] * fl1_fx * pc_y[j] + 0.5 * pa_x[j] * pc_yz[j] * fl1_fx + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + fl1_fx * pc_yz[j] * pb_x[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_y[j] + fl1_fx * pc_z[j] * pb_xy[j] + 2.0 * pa_xz[j] * pb_x[j] * pc_xy[j] + pa_xz[j] * pc_xx[j] * pb_y[j] + pa_x[j] * pc_yz[j] * pb_xx[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xy[j] + pc_xy[j] * pa_z[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_z[j] * pb_xy[j] + pc_xz[j] * pb_xxy[j]);

                t_xz_xxy[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * pc_yz[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - fl1_fx * pc_yz[j] * pb_x[j] - pa_xz[j] * pc_xxy[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_x[j] - pa_x[j] * pc_xxz[j] * pb_y[j] - 2.0 * pc_xxy[j] * pa_z[j] * pb_x[j] - pc_xxx[j] * pa_z[j] * pb_y[j] - pc_xyz[j] * pb_xx[j] - 2.0 * pc_xxz[j] * pb_xy[j]);

                t_xz_xxy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_xxyz[j] + pc_xxxy[j] * pa_z[j] + 2.0 * pc_xxyz[j] * pb_x[j] + pc_xxxz[j] * pb_y[j]);

                t_xz_xxy[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_xz_xxz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + 0.5 * pa_xz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_xx[j] + fl1_fx * pa_z[j] * pb_xz[j] + pa_xz[j] * pb_xxz[j]);

                t_xz_xxz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - fl2_fx * pb_x[j] - 0.5 * pa_xz[j] * fl1_fx * pc_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * fl1_fx * pb_xx[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] - fl1_fx * pc_z[j] * pb_xz[j] - fl1_fx * pa_z[j] * pb_xz[j] - pa_xz[j] * pb_xx[j] * pc_z[j] - 2.0 * pa_xz[j] * pb_xz[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxz[j] - pc_x[j] * pa_z[j] * pb_xxz[j]);

                t_xz_xxz[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + 0.5 * pa_xz[j] * fl1_fx * pc_z[j] + 0.5 * pa_x[j] * pc_zz[j] * fl1_fx + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_xx[j] + pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] + 1.5 * pc_xz[j] * pa_z[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_z[j] + pc_xx[j] * fl1_fx * pb_x[j] + 0.5 * pc_x[j] * fl1_fx * pb_xx[j] + fl1_fx * pc_zz[j] * pb_x[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] + fl1_fx * pc_z[j] * pb_xz[j] + 2.0 * pa_xz[j] * pb_x[j] * pc_xz[j] + pa_xz[j] * pc_xx[j] * pb_z[j] + pa_x[j] * pc_zz[j] * pb_xx[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xz[j] + pc_xz[j] * pa_z[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_z[j] * pb_xz[j] + pc_xz[j] * pb_xxz[j]);

                t_xz_xxz[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_zz[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_xx[j] - 1.5 * pc_xz[j] * pa_z[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxx[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_x[j] - fl1_fx * pc_zz[j] * pb_x[j] - pa_xz[j] * pc_xxz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_x[j] - pa_x[j] * pc_xxz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_x[j] - pc_xxx[j] * pa_z[j] * pb_z[j] - pc_xzz[j] * pb_xx[j] - 2.0 * pc_xxz[j] * pb_xz[j]);

                t_xz_xxz[j] += fl_s_0_0_4 * (1.5 * pc_xzz[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx + pa_x[j] * pc_xxzz[j] + pc_xxxz[j] * pa_z[j] + 2.0 * pc_xxzz[j] * pb_x[j] + pc_xxxz[j] * pb_z[j]);

                t_xz_xxz[j] += -fl_s_0_0_5 * pc_xxxzz[j];

                t_xz_xyy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * pa_xz[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pb_yy[j] + pa_xz[j] * pb_xyy[j]);

                t_xz_xyy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.25 * fl2_fx * pc_z[j] - 0.5 * pa_xz[j] * pb_x[j] * fl1_fx - 0.5 * pa_xz[j] * pc_x[j] * fl1_fx - 0.5 * pa_x[j] * pc_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_x[j] * pa_z[j] * pb_x[j] * fl1_fx - fl1_fx * pa_z[j] * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_yy[j] - 0.5 * fl1_fx * pa_z[j] * pb_yy[j] - 2.0 * pa_xz[j] * pb_xy[j] * pc_y[j] - pa_xz[j] * pc_x[j] * pb_yy[j] - pa_x[j] * pc_z[j] * pb_xyy[j] - pc_x[j] * pa_z[j] * pb_xyy[j]);

                t_xz_xyy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * pa_xz[j] * pc_x[j] * fl1_fx + 0.5 * pa_x[j] * pc_z[j] * pb_x[j] * fl1_fx + 0.5 * pa_x[j] * pc_xz[j] * fl1_fx + 0.5 * pc_x[j] * pa_z[j] * pb_x[j] * fl1_fx + 0.5 * pc_xx[j] * pa_z[j] * fl1_fx + 0.5 * pc_xz[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pc_yy[j] + fl1_fx * pc_yz[j] * pb_y[j] + fl1_fx * pa_z[j] * pb_y[j] * pc_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_yy[j] + pa_xz[j] * pb_x[j] * pc_yy[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_xy[j] + pa_x[j] * pc_xz[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xy[j] + pc_xx[j] * pa_z[j] * pb_yy[j] + pc_xz[j] * pb_xyy[j]);

                t_xz_xyy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * pa_x[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xx[j] * pa_z[j] * fl1_fx - 0.5 * pc_xz[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyz[j] - 0.5 * fl1_fx * pa_z[j] * pc_yy[j] - fl1_fx * pc_yz[j] * pb_y[j] - pa_xz[j] * pc_xyy[j] - pa_x[j] * pc_yyz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_y[j] - pc_xyy[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_z[j] * pb_y[j] - 2.0 * pc_xyz[j] * pb_xy[j] - pc_xxz[j] * pb_yy[j]);

                t_xz_xyy[j] += fl_s_0_0_4 * (0.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyz[j] + pa_x[j] * pc_xyyz[j] + pc_xxyy[j] * pa_z[j] + pc_xyyz[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pb_y[j]);

                t_xz_xyy[j] += -fl_s_0_0_5 * pc_xxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_24_27(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (24,27)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(19 * idx + 13);

            auto pb_xzz = pbDistances.data(19 * idx + 14);

            auto pb_yyy = pbDistances.data(19 * idx + 15);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xxzzz = pcDistances.data(55 * idx + 43);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xz_xyz = primBuffer.data(60 * idx + 24);

            auto t_xz_xzz = primBuffer.data(60 * idx + 25);

            auto t_xz_yyy = primBuffer.data(60 * idx + 26);

            // Batch of Integrals (24,27)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xy, pb_xyz, pb_xz, pb_xzz, pb_y, pb_yy, pb_yyy, \
                                     pb_yz, pb_z, pb_zz, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xxzzz, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_xzzz, \
                                     pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyz, pc_yz, pc_yzz, pc_z, pc_zz, pc_zzz, s_0_0_0, \
                                     s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xz_xyz, t_xz_xzz, t_xz_yyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xyz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_z[j] * pb_yz[j] + pa_xz[j] * pb_xyz[j]);

                t_xz_xyz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * fl2_fx * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_xy[j] - 0.5 * pc_x[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_z[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_yz[j] - 0.5 * fl1_fx * pa_z[j] * pb_yz[j] - pa_xz[j] * pb_xy[j] * pc_z[j] - pa_xz[j] * pb_xz[j] * pc_y[j] - pa_xz[j] * pc_x[j] * pb_yz[j] - pa_x[j] * pc_z[j] * pb_xyz[j] - pc_x[j] * pa_z[j] * pb_xyz[j]);

                t_xz_xyz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_xy[j] + 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pc_xy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_z[j] * pc_yz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_y[j] * pb_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_yz[j] + pa_xz[j] * pb_x[j] * pc_yz[j] + pa_xz[j] * pc_xz[j] * pb_y[j] + pa_xz[j] * pc_xy[j] * pb_z[j] + pa_x[j] * pc_zz[j] * pb_xy[j] + pa_x[j] * pc_yz[j] * pb_xz[j] + pa_x[j] * pc_xz[j] * pb_yz[j] + pc_xz[j] * pa_z[j] * pb_xy[j] + pc_xy[j] * pa_z[j] * pb_xz[j] + pc_xx[j] * pa_z[j] * pb_yz[j] + pc_xz[j] * pb_xyz[j]);

                t_xz_xyz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_xy[j] - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * pc_xy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_yz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yz[j] * pb_z[j] - pa_xz[j] * pc_xyz[j] - pa_x[j] * pc_yzz[j] * pb_x[j] - pa_x[j] * pc_xzz[j] * pb_y[j] - pa_x[j] * pc_xyz[j] * pb_z[j] - pc_xyz[j] * pa_z[j] * pb_x[j] - pc_xxz[j] * pa_z[j] * pb_y[j] - pc_xxy[j] * pa_z[j] * pb_z[j] - pc_xzz[j] * pb_xy[j] - pc_xyz[j] * pb_xz[j] - pc_xxz[j] * pb_yz[j]);

                t_xz_xyz[j] += fl_s_0_0_4 * (0.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yzz[j] + pa_x[j] * pc_xyzz[j] + pc_xxyz[j] * pa_z[j] + pc_xyzz[j] * pb_x[j] + pc_xxzz[j] * pb_y[j] + pc_xxyz[j] * pb_z[j]);

                t_xz_xyz[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_xz_xzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 0.5 * pa_xz[j] * pb_x[j] * fl1_fx + pa_x[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_z[j] * pb_zz[j] + pa_xz[j] * pb_xzz[j]);

                t_xz_xzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - fl2_fx * pb_z[j] - 0.5 * pa_xz[j] * pb_x[j] * fl1_fx - 0.5 * pa_xz[j] * pc_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * pb_x[j] * fl1_fx - pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] - pa_x[j] * fl1_fx * pb_xz[j] - 0.5 * pc_x[j] * pa_z[j] * pb_x[j] * fl1_fx - pc_x[j] * fl1_fx * pb_xz[j] - fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_xz[j] * pb_xz[j] * pc_z[j] - pa_xz[j] * pc_x[j] * pb_zz[j] - pa_x[j] * pc_z[j] * pb_xzz[j] - pc_x[j] * pa_z[j] * pb_xzz[j]);

                t_xz_xzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 0.5 * pa_xz[j] * pc_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pc_x[j] * pa_z[j] * pb_x[j] * fl1_fx + 0.5 * pc_xx[j] * pa_z[j] * fl1_fx + 1.5 * pc_xz[j] * pb_x[j] * fl1_fx + pc_xx[j] * fl1_fx * pb_z[j] + pc_x[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_z[j] * pc_zz[j] + fl1_fx * pc_zz[j] * pb_z[j] + fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_zz[j] + pa_xz[j] * pb_x[j] * pc_zz[j] + 2.0 * pa_xz[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_x[j] * pc_zz[j] * pb_xz[j] + pa_x[j] * pc_xz[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_xz[j] + pc_xx[j] * pa_z[j] * pb_zz[j] + pc_xz[j] * pb_xzz[j]);

                t_xz_xzz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xx[j] * pa_z[j] * fl1_fx - 1.5 * pc_xz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxz[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_zzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_zz[j] - fl1_fx * pc_zz[j] * pb_z[j] - pa_xz[j] * pc_xzz[j] - pa_x[j] * pc_zzz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_z[j] - pc_xzz[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_z[j] - 2.0 * pc_xzz[j] * pb_xz[j] - pc_xxz[j] * pb_zz[j]);

                t_xz_xzz[j] += fl_s_0_0_4 * (1.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + pa_x[j] * pc_xzzz[j] + pc_xxzz[j] * pa_z[j] + pc_xzzz[j] * pb_x[j] + 2.0 * pc_xxzz[j] * pb_z[j]);

                t_xz_xzz[j] += -fl_s_0_0_5 * pc_xxzzz[j];

                t_xz_yyy[j] = fl_s_0_0_0 * (1.5 * pa_xz[j] * pb_y[j] * fl1_fx + pa_xz[j] * pb_yyy[j]);

                t_xz_yyy[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * pb_y[j] * fl1_fx - 1.5 * pa_xz[j] * pc_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * pb_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_z[j] * pb_y[j] * fl1_fx - 3.0 * pa_xz[j] * pb_yy[j] * pc_y[j] - pa_x[j] * pc_z[j] * pb_yyy[j] - pc_x[j] * pa_z[j] * pb_yyy[j]);

                t_xz_yyy[j] += fl_s_0_0_2 * (1.5 * pa_xz[j] * pc_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xz[j] * pb_y[j] * fl1_fx + 3.0 * pa_xz[j] * pb_y[j] * pc_yy[j] + 3.0 * pa_x[j] * pc_yz[j] * pb_yy[j] + 3.0 * pc_xy[j] * pa_z[j] * pb_yy[j] + pc_xz[j] * pb_yyy[j]);

                t_xz_yyy[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xz[j] * pb_y[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pa_xz[j] * pc_yyy[j] - 3.0 * pa_x[j] * pc_yyz[j] * pb_y[j] - 3.0 * pc_xyy[j] * pa_z[j] * pb_y[j] - 3.0 * pc_xyz[j] * pb_yy[j]);

                t_xz_yyy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yyyz[j] + pc_xyyy[j] * pa_z[j] + 3.0 * pc_xyyz[j] * pb_y[j]);

                t_xz_yyy[j] += -fl_s_0_0_5 * pc_xyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_27_30(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (27,30)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(19 * idx + 16);

            auto pb_yzz = pbDistances.data(19 * idx + 17);

            auto pb_zzz = pbDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            auto pc_xzzzz = pcDistances.data(55 * idx + 48);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xz_yyz = primBuffer.data(60 * idx + 27);

            auto t_xz_yzz = primBuffer.data(60 * idx + 28);

            auto t_xz_zzz = primBuffer.data(60 * idx + 29);

            // Batch of Integrals (27,30)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_y, pb_yy, pb_yyz, pb_yz, pb_yzz, pb_z, pb_zz, pb_zzz, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, \
                                     pc_xzzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, \
                                     pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xz_yyz, t_xz_yzz, \
                                     t_xz_zzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_yyz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pa_xz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_yy[j] + pa_xz[j] * pb_yyz[j]);

                t_xz_yyz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx - 0.5 * pa_xz[j] * fl1_fx * pc_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_yy[j] - 0.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * fl1_fx * pb_yy[j] - pa_xz[j] * pb_yy[j] * pc_z[j] - 2.0 * pa_xz[j] * pb_yz[j] * pc_y[j] - pa_x[j] * pc_z[j] * pb_yyz[j] - pc_x[j] * pa_z[j] * pb_yyz[j]);

                t_xz_yyz[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx + 0.5 * pa_xz[j] * fl1_fx * pc_z[j] + 0.5 * pa_x[j] * pc_zz[j] * fl1_fx + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_yy[j] + pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] + 0.5 * pc_xz[j] * pa_z[j] * fl1_fx + 0.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_z[j] + pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_yy[j] + 2.0 * pa_xz[j] * pb_y[j] * pc_yz[j] + pa_xz[j] * pc_yy[j] * pb_z[j] + pa_x[j] * pc_zz[j] * pb_yy[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_yz[j] + pc_xz[j] * pa_z[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_yz[j] + pc_xz[j] * pb_yyz[j]);

                t_xz_yyz[j] += fl_s_0_0_3 * (-0.25 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_zz[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_yy[j] - 0.5 * pc_xz[j] * pa_z[j] * fl1_fx - 0.5 * pc_xzz[j] * fl1_fx - 0.5 * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xyy[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_y[j] - pa_xz[j] * pc_yyz[j] - 2.0 * pa_x[j] * pc_yzz[j] * pb_y[j] - pa_x[j] * pc_yyz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_y[j] - pc_xyy[j] * pa_z[j] * pb_z[j] - pc_xzz[j] * pb_yy[j] - 2.0 * pc_xyz[j] * pb_yz[j]);

                t_xz_yyz[j] += fl_s_0_0_4 * (0.5 * pc_xzz[j] * fl1_fx + 0.5 * pc_xyy[j] * fl1_fx + pa_x[j] * pc_yyzz[j] + pc_xyyz[j] * pa_z[j] + 2.0 * pc_xyzz[j] * pb_y[j] + pc_xyyz[j] * pb_z[j]);

                t_xz_yyz[j] += -fl_s_0_0_5 * pc_xyyzz[j];

                t_xz_yzz[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * pb_y[j] * fl1_fx + pa_x[j] * fl1_fx * pb_yz[j] + pa_xz[j] * pb_yzz[j]);

                t_xz_yzz[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * pb_y[j] * fl1_fx - 0.5 * pa_xz[j] * pc_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * pb_y[j] * fl1_fx - pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] - pa_x[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * pa_z[j] * pb_y[j] * fl1_fx - pc_x[j] * fl1_fx * pb_yz[j] - 2.0 * pa_xz[j] * pb_yz[j] * pc_z[j] - pa_xz[j] * pc_y[j] * pb_zz[j] - pa_x[j] * pc_z[j] * pb_yzz[j] - pc_x[j] * pa_z[j] * pb_yzz[j]);

                t_xz_yzz[j] += fl_s_0_0_2 * (0.5 * pa_xz[j] * pc_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pc_x[j] * pa_z[j] * pb_y[j] * fl1_fx + 0.5 * pc_xy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xz[j] * pb_y[j] * fl1_fx + pc_xy[j] * fl1_fx * pb_z[j] + pc_x[j] * fl1_fx * pb_yz[j] + pa_xz[j] * pb_y[j] * pc_zz[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_x[j] * pc_zz[j] * pb_yz[j] + pa_x[j] * pc_yz[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_yz[j] + pc_xy[j] * pa_z[j] * pb_zz[j] + pc_xz[j] * pb_yzz[j]);

                t_xz_yzz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - 0.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xz[j] * pb_y[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_z[j] - pa_xz[j] * pc_yzz[j] - pa_x[j] * pc_zzz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_yzz[j] * pb_z[j] - pc_xzz[j] * pa_z[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_z[j] - 2.0 * pc_xzz[j] * pb_yz[j] - pc_xyz[j] * pb_zz[j]);

                t_xz_yzz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yzzz[j] + pc_xyzz[j] * pa_z[j] + pc_xzzz[j] * pb_y[j] + 2.0 * pc_xyzz[j] * pb_z[j]);

                t_xz_yzz[j] += -fl_s_0_0_5 * pc_xyzzz[j];

                t_xz_zzz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pa_xz[j] * pb_z[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_zz[j] + pa_xz[j] * pb_zzz[j]);

                t_xz_zzz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 1.5 * pa_xz[j] * pb_z[j] * fl1_fx - 1.5 * pa_xz[j] * pc_z[j] * fl1_fx - 4.5 * pa_x[j] * pc_z[j] * pb_z[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * pa_z[j] * pb_z[j] * fl1_fx - 1.5 * pc_x[j] * fl1_fx * pb_zz[j] - 3.0 * pa_xz[j] * pb_zz[j] * pc_z[j] - pa_x[j] * pc_z[j] * pb_zzz[j] - pc_x[j] * pa_z[j] * pb_zzz[j]);

                t_xz_zzz[j] += fl_s_0_0_2 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 1.5 * pa_xz[j] * pc_z[j] * fl1_fx + 4.5 * pa_x[j] * pc_z[j] * pb_z[j] * fl1_fx + 3.0 * pa_x[j] * pc_zz[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * pb_z[j] * fl1_fx + 1.5 * pc_xz[j] * pa_z[j] * fl1_fx + 4.5 * pc_xz[j] * pb_z[j] * fl1_fx + 1.5 * pc_x[j] * fl1_fx * pb_zz[j] + 3.0 * pa_xz[j] * pb_z[j] * pc_zz[j] + 3.0 * pa_x[j] * pc_zz[j] * pb_zz[j] + 3.0 * pc_xz[j] * pa_z[j] * pb_zz[j] + pc_xz[j] * pb_zzz[j]);

                t_xz_zzz[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 3.0 * pa_x[j] * pc_zz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_z[j] * fl1_fx - 4.5 * pc_xz[j] * pb_z[j] * fl1_fx - 3.0 * pc_xzz[j] * fl1_fx - pa_xz[j] * pc_zzz[j] - 3.0 * pa_x[j] * pc_zzz[j] * pb_z[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_z[j] - 3.0 * pc_xzz[j] * pb_zz[j]);

                t_xz_zzz[j] += fl_s_0_0_4 * (3.0 * pc_xzz[j] * fl1_fx + pa_x[j] * pc_zzzz[j] + pc_xzzz[j] * pa_z[j] + 3.0 * pc_xzzz[j] * pb_z[j]);

                t_xz_zzz[j] += -fl_s_0_0_5 * pc_xzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_30_33(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (30,33)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(19 * idx + 9);

            auto pb_xxy = pbDistances.data(19 * idx + 10);

            auto pb_xxz = pbDistances.data(19 * idx + 11);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(55 * idx + 37);

            auto pc_xxyyy = pcDistances.data(55 * idx + 40);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yy_xxx = primBuffer.data(60 * idx + 30);

            auto t_yy_xxy = primBuffer.data(60 * idx + 31);

            auto t_yy_xxz = primBuffer.data(60 * idx + 32);

            // Batch of Integrals (30,33)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxx, pb_xxy, pb_xxz, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyz, pc_xxyz, \
                                     pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyz, \
                                     pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_yy_xxx, \
                                     t_yy_xxy, t_yy_xxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xxx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_x[j] + 1.5 * pa_yy[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pb_xxx[j] + pa_yy[j] * pb_xxx[j]);

                t_yy_xxx[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] - 1.5 * pa_yy[j] * pb_x[j] * fl1_fx - 1.5 * pa_yy[j] * pc_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * pb_x[j] * fl1_fx - 1.5 * fl1_fx * pb_xx[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxx[j] - 3.0 * pa_yy[j] * pb_xx[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxx[j]);

                t_yy_xxx[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_x[j] + 0.75 * fl2_fx * pb_x[j] + 1.5 * pa_yy[j] * pc_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_xy[j] * fl1_fx + 1.5 * pc_yy[j] * pb_x[j] * fl1_fx + 1.5 * fl1_fx * pb_x[j] * pc_xx[j] + 1.5 * fl1_fx * pb_xx[j] * pc_x[j] + 3.0 * pa_yy[j] * pb_x[j] * pc_xx[j] + 6.0 * pa_y[j] * pc_xy[j] * pb_xx[j] + pc_yy[j] * pb_xxx[j]);

                t_yy_xxx[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_x[j] - 3.0 * pa_y[j] * pc_xy[j] * fl1_fx - 1.5 * pc_yy[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyy[j] * fl1_fx - 0.5 * fl1_fx * pc_xxx[j] - 1.5 * fl1_fx * pb_x[j] * pc_xx[j] - pa_yy[j] * pc_xxx[j] - 6.0 * pa_y[j] * pc_xxy[j] * pb_x[j] - 3.0 * pc_xyy[j] * pb_xx[j]);

                t_yy_xxx[j] += fl_s_0_0_4 * (1.5 * pc_xyy[j] * fl1_fx + 0.5 * fl1_fx * pc_xxx[j] + 2.0 * pa_y[j] * pc_xxxy[j] + 3.0 * pc_xxyy[j] * pb_x[j]);

                t_yy_xxx[j] += -fl_s_0_0_5 * pc_xxxyy[j];

                t_yy_xxy[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl2_fx + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_yy[j] * fl1_fx * pb_y[j] + pa_y[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pb_xxy[j] + pa_yy[j] * pb_xxy[j]);

                t_yy_xxy[j] += fl_s_0_0_1 * (-pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 0.5 * fl2_fx * pb_y[j] - 0.5 * pa_yy[j] * fl1_fx * pc_y[j] - 0.5 * pa_yy[j] * fl1_fx * pb_y[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_y[j] - 2.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] - pa_y[j] * fl1_fx * pb_xx[j] - 1.5 * pc_y[j] * fl1_fx * pb_xx[j] - fl1_fx * pb_xy[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxy[j] - pa_yy[j] * pb_xx[j] * pc_y[j] - 2.0 * pa_yy[j] * pb_xy[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxy[j]);

                t_yy_xxy[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_yy[j] * fl1_fx * pc_y[j] + pa_y[j] * pc_yy[j] * fl1_fx + pa_y[j] * pc_y[j] * fl1_fx * pb_y[j] + pa_y[j] * fl1_fx * pc_xx[j] + 2.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] + 0.5 * pc_yy[j] * fl1_fx * pb_y[j] + 3.0 * pc_xy[j] * fl1_fx * pb_x[j] + 1.5 * pc_y[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pc_xx[j] * pb_y[j] + fl1_fx * pb_xy[j] * pc_x[j] + 2.0 * pa_yy[j] * pb_x[j] * pc_xy[j] + pa_yy[j] * pc_xx[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_xx[j] + 4.0 * pa_y[j] * pc_xy[j] * pb_xy[j] + pc_yy[j] * pb_xxy[j]);

                t_yy_xxy[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - pa_y[j] * pc_yy[j] * fl1_fx - pa_y[j] * fl1_fx * pc_xx[j] - 0.5 * pc_yyy[j] * fl1_fx - 0.5 * pc_yy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xxy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_xx[j] * pb_y[j] - pa_yy[j] * pc_xxy[j] - 4.0 * pa_y[j] * pc_xyy[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xxy[j] * pb_y[j] - pc_yyy[j] * pb_xx[j] - 2.0 * pc_xyy[j] * pb_xy[j]);

                t_yy_xxy[j] += fl_s_0_0_4 * (0.5 * pc_yyy[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx + 2.0 * pa_y[j] * pc_xxyy[j] + 2.0 * pc_xyyy[j] * pb_x[j] + pc_xxyy[j] * pb_y[j]);

                t_yy_xxy[j] += -fl_s_0_0_5 * pc_xxyyy[j];

                t_yy_xxz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_z[j] + 0.5 * pa_yy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_xxz[j] + pa_yy[j] * pb_xxz[j]);

                t_yy_xxz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - 0.5 * pa_yy[j] * fl1_fx * pc_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_z[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_xx[j] * pc_z[j] - fl1_fx * pb_xz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxz[j] - pa_yy[j] * pb_xx[j] * pc_z[j] - 2.0 * pa_yy[j] * pb_xz[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxz[j]);

                t_yy_xxz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_yy[j] * fl1_fx * pc_z[j] + pa_y[j] * pc_yz[j] * fl1_fx + pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_yy[j] * fl1_fx * pb_z[j] + fl1_fx * pb_x[j] * pc_xz[j] + 0.5 * fl1_fx * pc_xx[j] * pb_z[j] + 0.5 * fl1_fx * pb_xx[j] * pc_z[j] + fl1_fx * pb_xz[j] * pc_x[j] + 2.0 * pa_yy[j] * pb_x[j] * pc_xz[j] + pa_yy[j] * pc_xx[j] * pb_z[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xx[j] + 4.0 * pa_y[j] * pc_xy[j] * pb_xz[j] + pc_yy[j] * pb_xxz[j]);

                t_yy_xxz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - pa_y[j] * pc_yz[j] * fl1_fx - 0.5 * pc_yyz[j] * fl1_fx - 0.5 * pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_xxz[j] - fl1_fx * pb_x[j] * pc_xz[j] - 0.5 * fl1_fx * pc_xx[j] * pb_z[j] - pa_yy[j] * pc_xxz[j] - 4.0 * pa_y[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xxy[j] * pb_z[j] - pc_yyz[j] * pb_xx[j] - 2.0 * pc_xyy[j] * pb_xz[j]);

                t_yy_xxz[j] += fl_s_0_0_4 * (0.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_xxz[j] + 2.0 * pa_y[j] * pc_xxyz[j] + 2.0 * pc_xyyz[j] * pb_x[j] + pc_xxyy[j] * pb_z[j]);

                t_yy_xxz[j] += -fl_s_0_0_5 * pc_xxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_33_36(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (33,36)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(19 * idx + 12);

            auto pb_xyz = pbDistances.data(19 * idx + 13);

            auto pb_xzz = pbDistances.data(19 * idx + 14);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(55 * idx + 44);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yy_xyy = primBuffer.data(60 * idx + 33);

            auto t_yy_xyz = primBuffer.data(60 * idx + 34);

            auto t_yy_xzz = primBuffer.data(60 * idx + 35);

            // Batch of Integrals (33,36)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xy, pb_xyy, pb_xyz, pb_xz, pb_xzz, pb_y, pb_yy, pb_yz, \
                                     pb_z, pb_zz, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyz, pc_xyyz, pc_xyyzz, \
                                     pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyz, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_yy_xyy, t_yy_xyz, t_yy_xzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_x[j] + 0.5 * pa_yy[j] * pb_x[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pb_xyy[j] + pa_yy[j] * pb_xyy[j]);

                t_yy_xyy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_x[j] - 1.5 * fl2_fx * pb_x[j] - 0.5 * pa_yy[j] * pb_x[j] * fl1_fx - 0.5 * pa_yy[j] * pc_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * pb_x[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] - 2.0 * pa_y[j] * fl1_fx * pb_xy[j] - 3.0 * pc_y[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pc_x[j] * pb_yy[j] - 0.5 * fl1_fx * pb_xyy[j] - 2.0 * pa_yy[j] * pb_xy[j] * pc_y[j] - pa_yy[j] * pc_x[j] * pb_yy[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xyy[j]);

                t_yy_xyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_x[j] + 0.75 * fl2_fx * pb_x[j] + 0.5 * pa_yy[j] * pc_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_xy[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] + 3.0 * pc_yy[j] * pb_x[j] * fl1_fx + 3.0 * pc_xy[j] * fl1_fx * pb_y[j] + 3.0 * pc_y[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pc_x[j] * pb_yy[j] + pa_yy[j] * pb_x[j] * pc_yy[j] + 2.0 * pa_yy[j] * pc_xy[j] * pb_y[j] + 4.0 * pa_y[j] * pc_yy[j] * pb_xy[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_yy[j] + pc_yy[j] * pb_xyy[j]);

                t_yy_xyy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_x[j] - 3.0 * pa_y[j] * pc_xy[j] * fl1_fx - 3.0 * pc_yy[j] * pb_x[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_y[j] - pa_yy[j] * pc_xyy[j] - 2.0 * pa_y[j] * pc_yyy[j] * pb_x[j] - 4.0 * pa_y[j] * pc_xyy[j] * pb_y[j] - 2.0 * pc_yyy[j] * pb_xy[j] - pc_xyy[j] * pb_yy[j]);

                t_yy_xyy[j] += fl_s_0_0_4 * (3.0 * pc_xyy[j] * fl1_fx + 2.0 * pa_y[j] * pc_xyyy[j] + pc_yyyy[j] * pb_x[j] + 2.0 * pc_xyyy[j] * pb_y[j]);

                t_yy_xyy[j] += -fl_s_0_0_5 * pc_xyyyy[j];

                t_yy_xyz[j] = fl_s_0_0_0 * (pa_y[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pb_xyz[j] + pa_yy[j] * pb_xyz[j]);

                t_yy_xyz[j] += fl_s_0_0_1 * (-pa_y[j] * fl1_fx * pb_x[j] * pc_z[j] - pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] - pa_y[j] * fl1_fx * pb_xz[j] - 1.5 * pc_y[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pb_xy[j] * pc_z[j] - 0.5 * fl1_fx * pc_x[j] * pb_yz[j] - 0.5 * fl1_fx * pb_xyz[j] - pa_yy[j] * pb_xy[j] * pc_z[j] - pa_yy[j] * pb_xz[j] * pc_y[j] - pa_yy[j] * pc_x[j] * pb_yz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xyz[j]);

                t_yy_xyz[j] += fl_s_0_0_2 * (pa_y[j] * fl1_fx * pc_xz[j] + pa_y[j] * fl1_fx * pb_x[j] * pc_z[j] + pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pc_xz[j] * pb_y[j] + 0.5 * fl1_fx * pb_xy[j] * pc_z[j] + 0.5 * fl1_fx * pc_x[j] * pb_yz[j] + pa_yy[j] * pb_x[j] * pc_yz[j] + pa_yy[j] * pc_xz[j] * pb_y[j] + pa_yy[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xy[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_xz[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_yz[j] + pc_yy[j] * pb_xyz[j]);

                t_yy_xyz[j] += fl_s_0_0_3 * (-pa_y[j] * fl1_fx * pc_xz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_xz[j] * pb_y[j] - pa_yy[j] * pc_xyz[j] - 2.0 * pa_y[j] * pc_yyz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_y[j] * pc_xyy[j] * pb_z[j] - pc_yyz[j] * pb_xy[j] - pc_yyy[j] * pb_xz[j] - pc_xyy[j] * pb_yz[j]);

                t_yy_xyz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 2.0 * pa_y[j] * pc_xyyz[j] + pc_yyyz[j] * pb_x[j] + pc_xyyz[j] * pb_y[j] + pc_xyyy[j] * pb_z[j]);

                t_yy_xyz[j] += -fl_s_0_0_5 * pc_xyyyz[j];

                t_yy_xzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_x[j] + 0.5 * pa_yy[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pb_xzz[j] + pa_yy[j] * pb_xzz[j]);

                t_yy_xzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pc_x[j] - 0.5 * pa_yy[j] * pb_x[j] * fl1_fx - 0.5 * pa_yy[j] * pc_x[j] * fl1_fx - pa_y[j] * pc_y[j] * pb_x[j] * fl1_fx - fl1_fx * pb_xz[j] * pc_z[j] - 0.5 * fl1_fx * pc_x[j] * pb_zz[j] - 0.5 * fl1_fx * pb_xzz[j] - 2.0 * pa_yy[j] * pb_xz[j] * pc_z[j] - pa_yy[j] * pc_x[j] * pb_zz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xzz[j]);

                t_yy_xzz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_x[j] + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_yy[j] * pc_x[j] * fl1_fx + pa_y[j] * pc_y[j] * pb_x[j] * fl1_fx + pa_y[j] * pc_xy[j] * fl1_fx + 0.5 * pc_yy[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pb_x[j] * pc_zz[j] + fl1_fx * pc_xz[j] * pb_z[j] + fl1_fx * pb_xz[j] * pc_z[j] + 0.5 * fl1_fx * pc_x[j] * pb_zz[j] + pa_yy[j] * pb_x[j] * pc_zz[j] + 2.0 * pa_yy[j] * pc_xz[j] * pb_z[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_xz[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_zz[j] + pc_yy[j] * pb_xzz[j]);

                t_yy_xzz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_x[j] - pa_y[j] * pc_xy[j] * fl1_fx - 0.5 * pc_yy[j] * pb_x[j] * fl1_fx - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * fl1_fx * pc_xzz[j] - 0.5 * fl1_fx * pb_x[j] * pc_zz[j] - fl1_fx * pc_xz[j] * pb_z[j] - pa_yy[j] * pc_xzz[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_x[j] - 4.0 * pa_y[j] * pc_xyz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pb_xz[j] - pc_xyy[j] * pb_zz[j]);

                t_yy_xzz[j] += fl_s_0_0_4 * (0.5 * pc_xyy[j] * fl1_fx + 0.5 * fl1_fx * pc_xzz[j] + 2.0 * pa_y[j] * pc_xyzz[j] + pc_yyzz[j] * pb_x[j] + 2.0 * pc_xyyz[j] * pb_z[j]);

                t_yy_xzz[j] += -fl_s_0_0_5 * pc_xyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_36_39(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (36,39)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(19 * idx + 15);

            auto pb_yyz = pbDistances.data(19 * idx + 16);

            auto pb_yzz = pbDistances.data(19 * idx + 17);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(55 * idx + 49);

            auto pc_yyyyz = pcDistances.data(55 * idx + 50);

            auto pc_yyyzz = pcDistances.data(55 * idx + 51);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yy_yyy = primBuffer.data(60 * idx + 36);

            auto t_yy_yyz = primBuffer.data(60 * idx + 37);

            auto t_yy_yzz = primBuffer.data(60 * idx + 38);

            // Batch of Integrals (36,39)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_y, pb_yy, pb_yyy, pb_yyz, pb_yz, pb_yzz, pb_z, pb_zz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyy, pc_yyyyz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_yy_yyy, t_yy_yyz, t_yy_yzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_yyy[j] = fl_s_0_0_0 * (1.5 * pa_y[j] * fl2_fx + 2.25 * fl2_fx * pb_y[j] + 1.5 * pa_yy[j] * pb_y[j] * fl1_fx + 3.0 * pa_y[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pb_yyy[j] + pa_yy[j] * pb_yyy[j]);

                t_yy_yyy[j] += fl_s_0_0_1 * (-3.0 * pa_y[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx - 4.5 * fl2_fx * pb_y[j] - 1.5 * pa_yy[j] * pb_y[j] * fl1_fx - 1.5 * pa_yy[j] * pc_y[j] * fl1_fx - 9.0 * pa_y[j] * pc_y[j] * pb_y[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pb_yy[j] - 4.5 * pc_y[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pb_yyy[j] - 3.0 * pa_yy[j] * pb_yy[j] * pc_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yyy[j]);

                t_yy_yyy[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl2_fx + 7.5 * pc_y[j] * fl2_fx + 2.25 * fl2_fx * pb_y[j] + 1.5 * pa_yy[j] * pc_y[j] * fl1_fx + 9.0 * pa_y[j] * pc_y[j] * pb_y[j] * fl1_fx + 6.0 * pa_y[j] * pc_yy[j] * fl1_fx + 9.0 * pc_yy[j] * pb_y[j] * fl1_fx + 4.5 * pc_y[j] * fl1_fx * pb_yy[j] + 3.0 * pa_yy[j] * pb_y[j] * pc_yy[j] + 6.0 * pa_y[j] * pc_yy[j] * pb_yy[j] + pc_yy[j] * pb_yyy[j]);

                t_yy_yyy[j] += fl_s_0_0_3 * (-3.75 * pc_y[j] * fl2_fx - 6.0 * pa_y[j] * pc_yy[j] * fl1_fx - 9.0 * pc_yy[j] * pb_y[j] * fl1_fx - 5.0 * pc_yyy[j] * fl1_fx - pa_yy[j] * pc_yyy[j] - 6.0 * pa_y[j] * pc_yyy[j] * pb_y[j] - 3.0 * pc_yyy[j] * pb_yy[j]);

                t_yy_yyy[j] += fl_s_0_0_4 * (5.0 * pc_yyy[j] * fl1_fx + 2.0 * pa_y[j] * pc_yyyy[j] + 3.0 * pc_yyyy[j] * pb_y[j]);

                t_yy_yyy[j] += -fl_s_0_0_5 * pc_yyyyy[j];

                t_yy_yyz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_z[j] + 0.5 * pa_yy[j] * fl1_fx * pb_z[j] + 2.0 * pa_y[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pb_yyz[j] + pa_yy[j] * pb_yyz[j]);

                t_yy_yyz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * fl2_fx * pb_z[j] - 0.5 * pa_yy[j] * fl1_fx * pc_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_z[j] - 3.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] - 2.0 * pa_y[j] * fl1_fx * pb_y[j] * pc_z[j] - 2.0 * pa_y[j] * fl1_fx * pb_yz[j] - 3.0 * pc_y[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pb_yy[j] * pc_z[j] - 0.5 * fl1_fx * pb_yyz[j] - pa_yy[j] * pb_yy[j] * pc_z[j] - 2.0 * pa_yy[j] * pb_yz[j] * pc_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yyz[j]);

                t_yy_yyz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pb_z[j] + 0.5 * pa_yy[j] * fl1_fx * pc_z[j] + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] + 2.0 * pa_y[j] * fl1_fx * pb_y[j] * pc_z[j] + 3.0 * pc_yy[j] * fl1_fx * pb_z[j] + 3.0 * pc_yz[j] * fl1_fx * pb_y[j] + 3.0 * pc_y[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pb_yy[j] * pc_z[j] + 2.0 * pa_yy[j] * pb_y[j] * pc_yz[j] + pa_yy[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_yy[j] + 4.0 * pa_y[j] * pc_yy[j] * pb_yz[j] + pc_yy[j] * pb_yyz[j]);

                t_yy_yyz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx - 3.0 * pc_yyz[j] * fl1_fx - 3.0 * pc_yy[j] * fl1_fx * pb_z[j] - 3.0 * pc_yz[j] * fl1_fx * pb_y[j] - pa_yy[j] * pc_yyz[j] - 4.0 * pa_y[j] * pc_yyz[j] * pb_y[j] - 2.0 * pa_y[j] * pc_yyy[j] * pb_z[j] - pc_yyz[j] * pb_yy[j] - 2.0 * pc_yyy[j] * pb_yz[j]);

                t_yy_yyz[j] += fl_s_0_0_4 * (3.0 * pc_yyz[j] * fl1_fx + 2.0 * pa_y[j] * pc_yyyz[j] + 2.0 * pc_yyyz[j] * pb_y[j] + pc_yyyy[j] * pb_z[j]);

                t_yy_yyz[j] += -fl_s_0_0_5 * pc_yyyyz[j];

                t_yy_yzz[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl2_fx + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_yy[j] * pb_y[j] * fl1_fx + pa_y[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_yzz[j] + pa_yy[j] * pb_yzz[j]);

                t_yy_yzz[j] += fl_s_0_0_1 * (-pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 0.5 * fl2_fx * pb_y[j] - 0.5 * pa_yy[j] * pb_y[j] * fl1_fx - 0.5 * pa_yy[j] * pc_y[j] * fl1_fx - pa_y[j] * pc_y[j] * pb_y[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pb_z[j] * pc_z[j] - pa_y[j] * fl1_fx * pb_zz[j] - 1.5 * pc_y[j] * fl1_fx * pb_zz[j] - fl1_fx * pb_yz[j] * pc_z[j] - 0.5 * fl1_fx * pb_yzz[j] - 2.0 * pa_yy[j] * pb_yz[j] * pc_z[j] - pa_yy[j] * pc_y[j] * pb_zz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yzz[j]);

                t_yy_yzz[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_yy[j] * pc_y[j] * fl1_fx + pa_y[j] * pc_y[j] * pb_y[j] * fl1_fx + pa_y[j] * pc_yy[j] * fl1_fx + pa_y[j] * fl1_fx * pc_zz[j] + 2.0 * pa_y[j] * fl1_fx * pb_z[j] * pc_z[j] + 0.5 * pc_yy[j] * pb_y[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_y[j] * pc_zz[j] + fl1_fx * pb_yz[j] * pc_z[j] + pa_yy[j] * pb_y[j] * pc_zz[j] + 2.0 * pa_yy[j] * pc_yz[j] * pb_z[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_yz[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_zz[j] + pc_yy[j] * pb_yzz[j]);

                t_yy_yzz[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - pa_y[j] * pc_yy[j] * fl1_fx - pa_y[j] * fl1_fx * pc_zz[j] - 0.5 * pc_yy[j] * pb_y[j] * fl1_fx - 0.5 * pc_yyy[j] * fl1_fx - 1.5 * pc_yzz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pb_y[j] * pc_zz[j] - pa_yy[j] * pc_yzz[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_y[j] - 4.0 * pa_y[j] * pc_yyz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pb_yz[j] - pc_yyy[j] * pb_zz[j]);

                t_yy_yzz[j] += fl_s_0_0_4 * (0.5 * pc_yyy[j] * fl1_fx + 1.5 * pc_yzz[j] * fl1_fx + 2.0 * pa_y[j] * pc_yyzz[j] + pc_yyzz[j] * pb_y[j] + 2.0 * pc_yyyz[j] * pb_z[j]);

                t_yy_yzz[j] += -fl_s_0_0_5 * pc_yyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_39_42(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (39,42)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(19 * idx + 9);

            auto pb_xxy = pbDistances.data(19 * idx + 10);

            auto pb_zzz = pbDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            auto pc_yyzzz = pcDistances.data(55 * idx + 52);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yy_zzz = primBuffer.data(60 * idx + 39);

            auto t_yz_xxx = primBuffer.data(60 * idx + 40);

            auto t_yz_xxy = primBuffer.data(60 * idx + 41);

            // Batch of Integrals (39,42)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxy, pb_xy, pb_y, pb_z, pb_zz, \
                                     pb_zzz, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, pc_xxyyz, \
                                     pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyz, pc_yyzz, \
                                     pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, t_yy_zzz, t_yz_xxx, t_yz_xxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_zzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_z[j] + 1.5 * pa_yy[j] * pb_z[j] * fl1_fx + 0.5 * fl1_fx * pb_zzz[j] + pa_yy[j] * pb_zzz[j]);

                t_yy_zzz[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_z[j] - 0.75 * fl2_fx * pc_z[j] - 1.5 * pa_yy[j] * pb_z[j] * fl1_fx - 1.5 * pa_yy[j] * pc_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * pb_z[j] * fl1_fx - 1.5 * fl1_fx * pb_zz[j] * pc_z[j] - 0.5 * fl1_fx * pb_zzz[j] - 3.0 * pa_yy[j] * pb_zz[j] * pc_z[j] - 2.0 * pa_y[j] * pc_y[j] * pb_zzz[j]);

                t_yy_zzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pb_z[j] + 1.5 * pa_yy[j] * pc_z[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_z[j] * fl1_fx + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx + 1.5 * pc_yy[j] * pb_z[j] * fl1_fx + 1.5 * fl1_fx * pb_z[j] * pc_zz[j] + 1.5 * fl1_fx * pb_zz[j] * pc_z[j] + 3.0 * pa_yy[j] * pb_z[j] * pc_zz[j] + 6.0 * pa_y[j] * pc_yz[j] * pb_zz[j] + pc_yy[j] * pb_zzz[j]);

                t_yy_zzz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx - 1.5 * pc_yy[j] * pb_z[j] * fl1_fx - 1.5 * pc_yyz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzz[j] - 1.5 * fl1_fx * pb_z[j] * pc_zz[j] - pa_yy[j] * pc_zzz[j] - 6.0 * pa_y[j] * pc_yzz[j] * pb_z[j] - 3.0 * pc_yyz[j] * pb_zz[j]);

                t_yy_zzz[j] += fl_s_0_0_4 * (1.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] + 3.0 * pc_yyzz[j] * pb_z[j]);

                t_yy_zzz[j] += -fl_s_0_0_5 * pc_yyzzz[j];

                t_yz_xxx[j] = fl_s_0_0_0 * (1.5 * pa_yz[j] * pb_x[j] * fl1_fx + pa_yz[j] * pb_xxx[j]);

                t_yz_xxx[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_yz[j] * pc_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_y[j] * pa_z[j] * pb_x[j] * fl1_fx - 3.0 * pa_yz[j] * pb_xx[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxx[j] - pc_y[j] * pa_z[j] * pb_xxx[j]);

                t_yz_xxx[j] += fl_s_0_0_2 * (1.5 * pa_yz[j] * pc_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_yz[j] * pb_x[j] * pc_xx[j] + 3.0 * pa_y[j] * pc_xz[j] * pb_xx[j] + 3.0 * pc_xy[j] * pa_z[j] * pb_xx[j] + pc_yz[j] * pb_xxx[j]);

                t_yz_xxx[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * pc_xz[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pa_yz[j] * pc_xxx[j] - 3.0 * pa_y[j] * pc_xxz[j] * pb_x[j] - 3.0 * pc_xxy[j] * pa_z[j] * pb_x[j] - 3.0 * pc_xyz[j] * pb_xx[j]);

                t_yz_xxx[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_y[j] * pc_xxxz[j] + pc_xxxy[j] * pa_z[j] + 3.0 * pc_xxyz[j] * pb_x[j]);

                t_yz_xxx[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_yz_xxy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * pa_yz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pb_xx[j] + pa_yz[j] * pb_xxy[j]);

                t_yz_xxy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.25 * fl2_fx * pc_z[j] - 0.5 * pa_yz[j] * fl1_fx * pc_y[j] - 0.5 * pa_yz[j] * fl1_fx * pb_y[j] - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_y[j] - 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_y[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_x[j] - 0.5 * fl1_fx * pc_z[j] * pb_xx[j] - 0.5 * fl1_fx * pa_z[j] * pb_xx[j] - pa_yz[j] * pb_xx[j] * pc_y[j] - 2.0 * pa_yz[j] * pb_xy[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxy[j] - pc_y[j] * pa_z[j] * pb_xxy[j]);

                t_yz_xxy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * pa_yz[j] * fl1_fx * pc_y[j] + 0.5 * pa_y[j] * pc_yz[j] * fl1_fx + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_y[j] + 0.5 * pc_yy[j] * pa_z[j] * fl1_fx + 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_y[j] + 0.5 * pc_yz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pc_xx[j] + fl1_fx * pc_xz[j] * pb_x[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_x[j] + 0.5 * fl1_fx * pc_z[j] * pb_xx[j] + 2.0 * pa_yz[j] * pb_x[j] * pc_xy[j] + pa_yz[j] * pc_xx[j] * pb_y[j] + pa_y[j] * pc_yz[j] * pb_xx[j] + 2.0 * pa_y[j] * pc_xz[j] * pb_xy[j] + pc_yy[j] * pa_z[j] * pb_xx[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xy[j] + pc_yz[j] * pb_xxy[j]);

                t_yz_xxy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * pa_y[j] * pc_yz[j] * fl1_fx - 0.5 * pc_yy[j] * pa_z[j] * fl1_fx - 0.5 * pc_yyz[j] * fl1_fx - 0.5 * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_xxz[j] - 0.5 * fl1_fx * pa_z[j] * pc_xx[j] - fl1_fx * pc_xz[j] * pb_x[j] - pa_yz[j] * pc_xxy[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_x[j] - pa_y[j] * pc_xxz[j] * pb_y[j] - 2.0 * pc_xyy[j] * pa_z[j] * pb_x[j] - pc_xxy[j] * pa_z[j] * pb_y[j] - pc_yyz[j] * pb_xx[j] - 2.0 * pc_xyz[j] * pb_xy[j]);

                t_yz_xxy[j] += fl_s_0_0_4 * (0.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_xxz[j] + pa_y[j] * pc_xxyz[j] + pc_xxyy[j] * pa_z[j] + 2.0 * pc_xyyz[j] * pb_x[j] + pc_xxyz[j] * pb_y[j]);

                t_yz_xxy[j] += -fl_s_0_0_5 * pc_xxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_42_45(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (42,45)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(19 * idx + 11);

            auto pb_xyy = pbDistances.data(19 * idx + 12);

            auto pb_xyz = pbDistances.data(19 * idx + 13);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yz_xxz = primBuffer.data(60 * idx + 42);

            auto t_yz_xyy = primBuffer.data(60 * idx + 43);

            auto t_yz_xyz = primBuffer.data(60 * idx + 44);

            // Batch of Integrals (42,45)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxz, pb_xy, pb_xyy, pb_xyz, pb_xz, pb_y, \
                                     pb_yy, pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_yz_xxz, t_yz_xyy, t_yz_xyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xxz[j] = fl_s_0_0_0 * (0.25 * pa_y[j] * fl2_fx + 0.5 * pa_yz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pb_xx[j] + pa_yz[j] * pb_xxz[j]);

                t_yz_xxz[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx - 0.25 * pc_y[j] * fl2_fx - 0.5 * pa_yz[j] * fl1_fx * pc_z[j] - 0.5 * pa_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_z[j] - pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_xx[j] - 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_y[j] * fl1_fx * pb_xx[j] - pa_yz[j] * pb_xx[j] * pc_z[j] - 2.0 * pa_yz[j] * pb_xz[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxz[j] - pc_y[j] * pa_z[j] * pb_xxz[j]);

                t_yz_xxz[j] += fl_s_0_0_2 * (0.25 * pa_y[j] * fl2_fx + 0.5 * pc_y[j] * fl2_fx + 0.5 * pa_yz[j] * fl1_fx * pc_z[j] + 0.5 * pa_y[j] * pc_zz[j] * fl1_fx + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pc_xx[j] + pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] + 0.5 * pc_yz[j] * pa_z[j] * fl1_fx + 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_yz[j] * fl1_fx * pb_z[j] + pc_xy[j] * fl1_fx * pb_x[j] + 0.5 * pc_y[j] * fl1_fx * pb_xx[j] + 2.0 * pa_yz[j] * pb_x[j] * pc_xz[j] + pa_yz[j] * pc_xx[j] * pb_z[j] + pa_y[j] * pc_zz[j] * pb_xx[j] + 2.0 * pa_y[j] * pc_xz[j] * pb_xz[j] + pc_yz[j] * pa_z[j] * pb_xx[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xz[j] + pc_yz[j] * pb_xxz[j]);

                t_yz_xxz[j] += fl_s_0_0_3 * (-0.25 * pc_y[j] * fl2_fx - 0.5 * pa_y[j] * pc_zz[j] * fl1_fx - 0.5 * pa_y[j] * fl1_fx * pc_xx[j] - 0.5 * pc_yz[j] * pa_z[j] * fl1_fx - 0.5 * pc_yzz[j] * fl1_fx - 0.5 * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxy[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_x[j] - pa_yz[j] * pc_xxz[j] - 2.0 * pa_y[j] * pc_xzz[j] * pb_x[j] - pa_y[j] * pc_xxz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_x[j] - pc_xxy[j] * pa_z[j] * pb_z[j] - pc_yzz[j] * pb_xx[j] - 2.0 * pc_xyz[j] * pb_xz[j]);

                t_yz_xxz[j] += fl_s_0_0_4 * (0.5 * pc_yzz[j] * fl1_fx + 0.5 * pc_xxy[j] * fl1_fx + pa_y[j] * pc_xxzz[j] + pc_xxyz[j] * pa_z[j] + 2.0 * pc_xyzz[j] * pb_x[j] + pc_xxyz[j] * pb_z[j]);

                t_yz_xxz[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_yz_xyy[j] = fl_s_0_0_0 * (0.5 * pa_yz[j] * pb_x[j] * fl1_fx + fl1_fx * pa_z[j] * pb_xy[j] + pa_yz[j] * pb_xyy[j]);

                t_yz_xyy[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * pb_x[j] * fl1_fx - 0.5 * pa_yz[j] * pc_x[j] * fl1_fx - 0.5 * pa_y[j] * pc_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_y[j] * pa_z[j] * pb_x[j] * fl1_fx - fl1_fx * pa_z[j] * pc_x[j] * pb_y[j] - fl1_fx * pc_z[j] * pb_xy[j] - fl1_fx * pa_z[j] * pb_xy[j] - 2.0 * pa_yz[j] * pb_xy[j] * pc_y[j] - pa_yz[j] * pc_x[j] * pb_yy[j] - pa_y[j] * pc_z[j] * pb_xyy[j] - pc_y[j] * pa_z[j] * pb_xyy[j]);

                t_yz_xyy[j] += fl_s_0_0_2 * (0.5 * pa_yz[j] * pc_x[j] * fl1_fx + 0.5 * pa_y[j] * pc_z[j] * pb_x[j] * fl1_fx + 0.5 * pa_y[j] * pc_xz[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yz[j] * pb_x[j] * fl1_fx + fl1_fx * pc_xz[j] * pb_y[j] + fl1_fx * pa_z[j] * pc_x[j] * pb_y[j] + fl1_fx * pc_z[j] * pb_xy[j] + pa_yz[j] * pb_x[j] * pc_yy[j] + 2.0 * pa_yz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xy[j] + pa_y[j] * pc_xz[j] * pb_yy[j] + 2.0 * pc_yy[j] * pa_z[j] * pb_xy[j] + pc_xy[j] * pa_z[j] * pb_yy[j] + pc_yz[j] * pb_xyy[j]);

                t_yz_xyy[j] += fl_s_0_0_3 * (-0.5 * pa_y[j] * pc_xz[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - fl1_fx * pc_xz[j] * pb_y[j] - pa_yz[j] * pc_xyy[j] - pa_y[j] * pc_yyz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_y[j] - pc_yyy[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xyy[j] * pa_z[j] * pb_y[j] - 2.0 * pc_yyz[j] * pb_xy[j] - pc_xyz[j] * pb_yy[j]);

                t_yz_xyy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_y[j] * pc_xyyz[j] + pc_xyyy[j] * pa_z[j] + pc_yyyz[j] * pb_x[j] + 2.0 * pc_xyyz[j] * pb_y[j]);

                t_yz_xyy[j] += -fl_s_0_0_5 * pc_xyyyz[j];

                t_yz_xyz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_x[j] + 0.5 * pa_y[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_z[j] * pb_xz[j] + pa_yz[j] * pb_xyz[j]);

                t_yz_xyz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_x[j] - 0.5 * fl2_fx * pb_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_y[j] * fl1_fx * pb_xy[j] - 0.5 * pc_y[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_xz[j] - 0.5 * fl1_fx * pa_z[j] * pb_xz[j] - pa_yz[j] * pb_xy[j] * pc_z[j] - pa_yz[j] * pb_xz[j] * pc_y[j] - pa_yz[j] * pc_x[j] * pb_yz[j] - pa_y[j] * pc_z[j] * pb_xyz[j] - pc_y[j] * pa_z[j] * pb_xyz[j]);

                t_yz_xyz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_x[j] + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_y[j] * fl1_fx * pc_xy[j] + 0.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pc_yy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_y[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_z[j] * pc_xz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pc_xz[j] * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_xz[j] + pa_yz[j] * pb_x[j] * pc_yz[j] + pa_yz[j] * pc_xz[j] * pb_y[j] + pa_yz[j] * pc_xy[j] * pb_z[j] + pa_y[j] * pc_zz[j] * pb_xy[j] + pa_y[j] * pc_yz[j] * pb_xz[j] + pa_y[j] * pc_xz[j] * pb_yz[j] + pc_yz[j] * pa_z[j] * pb_xy[j] + pc_yy[j] * pa_z[j] * pb_xz[j] + pc_xy[j] * pa_z[j] * pb_yz[j] + pc_yz[j] * pb_xyz[j]);

                t_yz_xyz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_x[j] - 0.5 * pa_y[j] * fl1_fx * pc_xy[j] - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * pc_yy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_xzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_xz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_x[j] - 0.5 * fl1_fx * pc_xz[j] * pb_z[j] - pa_yz[j] * pc_xyz[j] - pa_y[j] * pc_yzz[j] * pb_x[j] - pa_y[j] * pc_xzz[j] * pb_y[j] - pa_y[j] * pc_xyz[j] * pb_z[j] - pc_yyz[j] * pa_z[j] * pb_x[j] - pc_xyz[j] * pa_z[j] * pb_y[j] - pc_xyy[j] * pa_z[j] * pb_z[j] - pc_yzz[j] * pb_xy[j] - pc_yyz[j] * pb_xz[j] - pc_xyz[j] * pb_yz[j]);

                t_yz_xyz[j] += fl_s_0_0_4 * (0.5 * pc_xyy[j] * fl1_fx + 0.5 * fl1_fx * pc_xzz[j] + pa_y[j] * pc_xyzz[j] + pc_xyyz[j] * pa_z[j] + pc_yyzz[j] * pb_x[j] + pc_xyzz[j] * pb_y[j] + pc_xyyz[j] * pb_z[j]);

                t_yz_xyz[j] += -fl_s_0_0_5 * pc_xyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_45_48(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (45,48)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(19 * idx + 14);

            auto pb_yyy = pbDistances.data(19 * idx + 15);

            auto pb_yyz = pbDistances.data(19 * idx + 16);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            auto pc_yyyyz = pcDistances.data(55 * idx + 50);

            auto pc_yyyzz = pcDistances.data(55 * idx + 51);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yz_xzz = primBuffer.data(60 * idx + 45);

            auto t_yz_yyy = primBuffer.data(60 * idx + 46);

            auto t_yz_yyz = primBuffer.data(60 * idx + 47);

            // Batch of Integrals (45,48)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xz, pb_xzz, pb_y, pb_yy, pb_yyy, pb_yyz, pb_yz, pb_z, \
                                     pb_zz, pc_x, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_yz_xzz, t_yz_yyy, t_yz_yyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xzz[j] = fl_s_0_0_0 * (0.5 * pa_yz[j] * pb_x[j] * fl1_fx + pa_y[j] * fl1_fx * pb_xz[j] + pa_yz[j] * pb_xzz[j]);

                t_yz_xzz[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * pb_x[j] * fl1_fx - 0.5 * pa_yz[j] * pc_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * pb_x[j] * fl1_fx - pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] - pa_y[j] * fl1_fx * pb_xz[j] - 0.5 * pc_y[j] * pa_z[j] * pb_x[j] * fl1_fx - pc_y[j] * fl1_fx * pb_xz[j] - 2.0 * pa_yz[j] * pb_xz[j] * pc_z[j] - pa_yz[j] * pc_x[j] * pb_zz[j] - pa_y[j] * pc_z[j] * pb_xzz[j] - pc_y[j] * pa_z[j] * pb_xzz[j]);

                t_yz_xzz[j] += fl_s_0_0_2 * (0.5 * pa_yz[j] * pc_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx + pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pc_y[j] * pa_z[j] * pb_x[j] * fl1_fx + 0.5 * pc_xy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yz[j] * pb_x[j] * fl1_fx + pc_xy[j] * fl1_fx * pb_z[j] + pc_y[j] * fl1_fx * pb_xz[j] + pa_yz[j] * pb_x[j] * pc_zz[j] + 2.0 * pa_yz[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_y[j] * pc_zz[j] * pb_xz[j] + pa_y[j] * pc_xz[j] * pb_zz[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_xz[j] + pc_xy[j] * pa_z[j] * pb_zz[j] + pc_yz[j] * pb_xzz[j]);

                t_yz_xzz[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_z[j] - pa_yz[j] * pc_xzz[j] - pa_y[j] * pc_zzz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xzz[j] * pb_z[j] - pc_yzz[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_z[j] - 2.0 * pc_yzz[j] * pb_xz[j] - pc_xyz[j] * pb_zz[j]);

                t_yz_xzz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_y[j] * pc_xzzz[j] + pc_xyzz[j] * pa_z[j] + pc_yzzz[j] * pb_x[j] + 2.0 * pc_xyzz[j] * pb_z[j]);

                t_yz_xzz[j] += -fl_s_0_0_5 * pc_xyzzz[j];

                t_yz_yyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] + 1.5 * pa_yz[j] * pb_y[j] * fl1_fx + 1.5 * fl1_fx * pa_z[j] * pb_yy[j] + pa_yz[j] * pb_yyy[j]);

                t_yz_yyy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - 1.5 * pa_yz[j] * pb_y[j] * fl1_fx - 1.5 * pa_yz[j] * pc_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * pb_y[j] * fl1_fx - 4.5 * pc_y[j] * pa_z[j] * pb_y[j] * fl1_fx - 1.5 * fl1_fx * pc_z[j] * pb_yy[j] - 1.5 * fl1_fx * pa_z[j] * pb_yy[j] - 3.0 * pa_yz[j] * pb_yy[j] * pc_y[j] - pa_y[j] * pc_z[j] * pb_yyy[j] - pc_y[j] * pa_z[j] * pb_yyy[j]);

                t_yz_yyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pa_z[j] + 1.5 * pa_yz[j] * pc_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_yz[j] * fl1_fx + 4.5 * pc_y[j] * pa_z[j] * pb_y[j] * fl1_fx + 3.0 * pc_yy[j] * pa_z[j] * fl1_fx + 4.5 * pc_yz[j] * pb_y[j] * fl1_fx + 1.5 * fl1_fx * pc_z[j] * pb_yy[j] + 3.0 * pa_yz[j] * pb_y[j] * pc_yy[j] + 3.0 * pa_y[j] * pc_yz[j] * pb_yy[j] + 3.0 * pc_yy[j] * pa_z[j] * pb_yy[j] + pc_yz[j] * pb_yyy[j]);

                t_yz_yyy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * pa_y[j] * pc_yz[j] * fl1_fx - 3.0 * pc_yy[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pb_y[j] * fl1_fx - 3.0 * pc_yyz[j] * fl1_fx - pa_yz[j] * pc_yyy[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_y[j] - 3.0 * pc_yyy[j] * pa_z[j] * pb_y[j] - 3.0 * pc_yyz[j] * pb_yy[j]);

                t_yz_yyy[j] += fl_s_0_0_4 * (3.0 * pc_yyz[j] * fl1_fx + pa_y[j] * pc_yyyz[j] + pc_yyyy[j] * pa_z[j] + 3.0 * pc_yyyz[j] * pb_y[j]);

                t_yz_yyy[j] += -fl_s_0_0_5 * pc_yyyyz[j];

                t_yz_yyz[j] = fl_s_0_0_0 * (0.25 * pa_y[j] * fl2_fx + 0.5 * fl2_fx * pb_y[j] + 0.5 * pa_yz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pb_yy[j] + fl1_fx * pa_z[j] * pb_yz[j] + pa_yz[j] * pb_yyz[j]);

                t_yz_yyz[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - fl2_fx * pb_y[j] - 0.5 * pa_yz[j] * fl1_fx * pc_z[j] - 0.5 * pa_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_z[j] - pa_y[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pb_yy[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_y[j] * fl1_fx * pb_yy[j] - fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] - fl1_fx * pc_z[j] * pb_yz[j] - fl1_fx * pa_z[j] * pb_yz[j] - pa_yz[j] * pb_yy[j] * pc_z[j] - 2.0 * pa_yz[j] * pb_yz[j] * pc_y[j] - pa_y[j] * pc_z[j] * pb_yyz[j] - pc_y[j] * pa_z[j] * pb_yyz[j]);

                t_yz_yyz[j] += fl_s_0_0_2 * (0.25 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 0.5 * fl2_fx * pb_y[j] + 0.5 * pa_yz[j] * fl1_fx * pc_z[j] + 0.5 * pa_y[j] * pc_zz[j] * fl1_fx + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pc_yy[j] + pa_y[j] * fl1_fx * pb_y[j] * pc_y[j] + 1.5 * pc_yz[j] * pa_z[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_z[j] + pc_yy[j] * fl1_fx * pb_y[j] + 0.5 * pc_y[j] * fl1_fx * pb_yy[j] + fl1_fx * pc_zz[j] * pb_y[j] + fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] + fl1_fx * pc_z[j] * pb_yz[j] + 2.0 * pa_yz[j] * pb_y[j] * pc_yz[j] + pa_yz[j] * pc_yy[j] * pb_z[j] + pa_y[j] * pc_zz[j] * pb_yy[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_yz[j] + pc_yz[j] * pa_z[j] * pb_yy[j] + 2.0 * pc_yy[j] * pa_z[j] * pb_yz[j] + pc_yz[j] * pb_yyz[j]);

                t_yz_yyz[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - 0.5 * pa_y[j] * pc_zz[j] * fl1_fx - 0.5 * pa_y[j] * fl1_fx * pc_yy[j] - 1.5 * pc_yz[j] * pa_z[j] * fl1_fx - 1.5 * pc_yzz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yyy[j] * fl1_fx - pc_yy[j] * fl1_fx * pb_y[j] - fl1_fx * pc_zz[j] * pb_y[j] - pa_yz[j] * pc_yyz[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_y[j] - pa_y[j] * pc_yyz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_y[j] - pc_yyy[j] * pa_z[j] * pb_z[j] - pc_yzz[j] * pb_yy[j] - 2.0 * pc_yyz[j] * pb_yz[j]);

                t_yz_yyz[j] += fl_s_0_0_4 * (1.5 * pc_yzz[j] * fl1_fx + 0.5 * pc_yyy[j] * fl1_fx + pa_y[j] * pc_yyzz[j] + pc_yyyz[j] * pa_z[j] + 2.0 * pc_yyzz[j] * pb_y[j] + pc_yyyz[j] * pb_z[j]);

                t_yz_yyz[j] += -fl_s_0_0_5 * pc_yyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_48_51(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (48,51)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(19 * idx + 9);

            auto pb_yzz = pbDistances.data(19 * idx + 17);

            auto pb_zzz = pbDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(55 * idx + 39);

            auto pc_yyzzz = pcDistances.data(55 * idx + 52);

            auto pc_yzzzz = pcDistances.data(55 * idx + 53);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yz_yzz = primBuffer.data(60 * idx + 48);

            auto t_yz_zzz = primBuffer.data(60 * idx + 49);

            auto t_zz_xxx = primBuffer.data(60 * idx + 50);

            // Batch of Integrals (48,51)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pa_zz, pb_x, pb_xx, pb_xxx, pb_y, pb_yz, pb_yzz, pb_z, pb_zz, \
                                     pb_zzz, pc_x, pc_xx, pc_xxx, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, pc_xz, pc_xzz, pc_y, \
                                     pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, \
                                     pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_yz_yzz, \
                                     t_yz_zzz, t_zz_xxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_yzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 0.5 * pa_yz[j] * pb_y[j] * fl1_fx + pa_y[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_z[j] * pb_zz[j] + pa_yz[j] * pb_yzz[j]);

                t_yz_yzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - fl2_fx * pb_z[j] - 0.5 * pa_yz[j] * pb_y[j] * fl1_fx - 0.5 * pa_yz[j] * pc_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * pb_y[j] * fl1_fx - pa_y[j] * fl1_fx * pc_y[j] * pb_z[j] - pa_y[j] * fl1_fx * pb_yz[j] - 0.5 * pc_y[j] * pa_z[j] * pb_y[j] * fl1_fx - pc_y[j] * fl1_fx * pb_yz[j] - fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_yz[j] * pb_yz[j] * pc_z[j] - pa_yz[j] * pc_y[j] * pb_zz[j] - pa_y[j] * pc_z[j] * pb_yzz[j] - pc_y[j] * pa_z[j] * pb_yzz[j]);

                t_yz_yzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 0.5 * pa_yz[j] * pc_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_yz[j] * fl1_fx + pa_y[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pc_y[j] * pa_z[j] * pb_y[j] * fl1_fx + 0.5 * pc_yy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yz[j] * pb_y[j] * fl1_fx + pc_yy[j] * fl1_fx * pb_z[j] + pc_y[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_z[j] * pc_zz[j] + fl1_fx * pc_zz[j] * pb_z[j] + fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_zz[j] + pa_yz[j] * pb_y[j] * pc_zz[j] + 2.0 * pa_yz[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_y[j] * pc_zz[j] * pb_yz[j] + pa_y[j] * pc_yz[j] * pb_zz[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_yz[j] + pc_yy[j] * pa_z[j] * pb_zz[j] + pc_yz[j] * pb_yzz[j]);

                t_yz_yzz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * pa_y[j] * pc_yz[j] * fl1_fx - 0.5 * pc_yy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yz[j] * pb_y[j] * fl1_fx - 1.5 * pc_yyz[j] * fl1_fx - pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_zzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_zz[j] - fl1_fx * pc_zz[j] * pb_z[j] - pa_yz[j] * pc_yzz[j] - pa_y[j] * pc_zzz[j] * pb_y[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_z[j] - pc_yzz[j] * pa_z[j] * pb_y[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_z[j] - 2.0 * pc_yzz[j] * pb_yz[j] - pc_yyz[j] * pb_zz[j]);

                t_yz_yzz[j] += fl_s_0_0_4 * (1.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + pa_y[j] * pc_yzzz[j] + pc_yyzz[j] * pa_z[j] + pc_yzzz[j] * pb_y[j] + 2.0 * pc_yyzz[j] * pb_z[j]);

                t_yz_yzz[j] += -fl_s_0_0_5 * pc_yyzzz[j];

                t_yz_zzz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx + 1.5 * pa_yz[j] * pb_z[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pb_zz[j] + pa_yz[j] * pb_zzz[j]);

                t_yz_zzz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 1.5 * pa_yz[j] * pb_z[j] * fl1_fx - 1.5 * pa_yz[j] * pc_z[j] * fl1_fx - 4.5 * pa_y[j] * pc_z[j] * pb_z[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pb_zz[j] - 1.5 * pc_y[j] * pa_z[j] * pb_z[j] * fl1_fx - 1.5 * pc_y[j] * fl1_fx * pb_zz[j] - 3.0 * pa_yz[j] * pb_zz[j] * pc_z[j] - pa_y[j] * pc_z[j] * pb_zzz[j] - pc_y[j] * pa_z[j] * pb_zzz[j]);

                t_yz_zzz[j] += fl_s_0_0_2 * (0.75 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 1.5 * pa_yz[j] * pc_z[j] * fl1_fx + 4.5 * pa_y[j] * pc_z[j] * pb_z[j] * fl1_fx + 3.0 * pa_y[j] * pc_zz[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * pb_z[j] * fl1_fx + 1.5 * pc_yz[j] * pa_z[j] * fl1_fx + 4.5 * pc_yz[j] * pb_z[j] * fl1_fx + 1.5 * pc_y[j] * fl1_fx * pb_zz[j] + 3.0 * pa_yz[j] * pb_z[j] * pc_zz[j] + 3.0 * pa_y[j] * pc_zz[j] * pb_zz[j] + 3.0 * pc_yz[j] * pa_z[j] * pb_zz[j] + pc_yz[j] * pb_zzz[j]);

                t_yz_zzz[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - 3.0 * pa_y[j] * pc_zz[j] * fl1_fx - 1.5 * pc_yz[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pb_z[j] * fl1_fx - 3.0 * pc_yzz[j] * fl1_fx - pa_yz[j] * pc_zzz[j] - 3.0 * pa_y[j] * pc_zzz[j] * pb_z[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_z[j] - 3.0 * pc_yzz[j] * pb_zz[j]);

                t_yz_zzz[j] += fl_s_0_0_4 * (3.0 * pc_yzz[j] * fl1_fx + pa_y[j] * pc_zzzz[j] + pc_yzzz[j] * pa_z[j] + 3.0 * pc_yzzz[j] * pb_z[j]);

                t_yz_zzz[j] += -fl_s_0_0_5 * pc_yzzzz[j];

                t_zz_xxx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_x[j] + 1.5 * pa_zz[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pb_xxx[j] + pa_zz[j] * pb_xxx[j]);

                t_zz_xxx[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] - 1.5 * pa_zz[j] * pb_x[j] * fl1_fx - 1.5 * pa_zz[j] * pc_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * pb_x[j] * fl1_fx - 1.5 * fl1_fx * pb_xx[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxx[j] - 3.0 * pa_zz[j] * pb_xx[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxx[j]);

                t_zz_xxx[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_x[j] + 0.75 * fl2_fx * pb_x[j] + 1.5 * pa_zz[j] * pc_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_xz[j] * fl1_fx + 1.5 * pc_zz[j] * pb_x[j] * fl1_fx + 1.5 * fl1_fx * pb_x[j] * pc_xx[j] + 1.5 * fl1_fx * pb_xx[j] * pc_x[j] + 3.0 * pa_zz[j] * pb_x[j] * pc_xx[j] + 6.0 * pa_z[j] * pc_xz[j] * pb_xx[j] + pc_zz[j] * pb_xxx[j]);

                t_zz_xxx[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_x[j] - 3.0 * pa_z[j] * pc_xz[j] * fl1_fx - 1.5 * pc_zz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxx[j] - 1.5 * fl1_fx * pb_x[j] * pc_xx[j] - pa_zz[j] * pc_xxx[j] - 6.0 * pa_z[j] * pc_xxz[j] * pb_x[j] - 3.0 * pc_xzz[j] * pb_xx[j]);

                t_zz_xxx[j] += fl_s_0_0_4 * (1.5 * pc_xzz[j] * fl1_fx + 0.5 * fl1_fx * pc_xxx[j] + 2.0 * pa_z[j] * pc_xxxz[j] + 3.0 * pc_xxzz[j] * pb_x[j]);

                t_zz_xxx[j] += -fl_s_0_0_5 * pc_xxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_51_54(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (51,54)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(19 * idx + 3);

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(19 * idx + 10);

            auto pb_xxz = pbDistances.data(19 * idx + 11);

            auto pb_xyy = pbDistances.data(19 * idx + 12);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xxzzz = pcDistances.data(55 * idx + 43);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_zz_xxy = primBuffer.data(60 * idx + 51);

            auto t_zz_xxz = primBuffer.data(60 * idx + 52);

            auto t_zz_xyy = primBuffer.data(60 * idx + 53);

            // Batch of Integrals (51,54)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxy, pb_xxz, pb_xy, pb_xyy, pb_xz, pb_y, pb_yy, \
                                     pb_z, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, \
                                     pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, \
                                     pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, t_zz_xxy, t_zz_xxz, t_zz_xyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xxy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_y[j] + 0.5 * pa_zz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pb_xxy[j] + pa_zz[j] * pb_xxy[j]);

                t_zz_xxy[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * fl2_fx * pb_y[j] - 0.5 * pa_zz[j] * fl1_fx * pc_y[j] - 0.5 * pa_zz[j] * fl1_fx * pb_y[j] - pa_z[j] * pc_z[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pb_xx[j] * pc_y[j] - fl1_fx * pb_xy[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxy[j] - pa_zz[j] * pb_xx[j] * pc_y[j] - 2.0 * pa_zz[j] * pb_xy[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxy[j]);

                t_zz_xxy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_zz[j] * fl1_fx * pc_y[j] + pa_z[j] * pc_yz[j] * fl1_fx + pa_z[j] * pc_z[j] * fl1_fx * pb_y[j] + 0.5 * pc_zz[j] * fl1_fx * pb_y[j] + fl1_fx * pb_x[j] * pc_xy[j] + 0.5 * fl1_fx * pc_xx[j] * pb_y[j] + 0.5 * fl1_fx * pb_xx[j] * pc_y[j] + fl1_fx * pb_xy[j] * pc_x[j] + 2.0 * pa_zz[j] * pb_x[j] * pc_xy[j] + pa_zz[j] * pc_xx[j] * pb_y[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_xx[j] + 4.0 * pa_z[j] * pc_xz[j] * pb_xy[j] + pc_zz[j] * pb_xxy[j]);

                t_zz_xxy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - pa_z[j] * pc_yz[j] * fl1_fx - 0.5 * pc_yzz[j] * fl1_fx - 0.5 * pc_zz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_xxy[j] - fl1_fx * pb_x[j] * pc_xy[j] - 0.5 * fl1_fx * pc_xx[j] * pb_y[j] - pa_zz[j] * pc_xxy[j] - 4.0 * pa_z[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_z[j] * pc_xxz[j] * pb_y[j] - pc_yzz[j] * pb_xx[j] - 2.0 * pc_xzz[j] * pb_xy[j]);

                t_zz_xxy[j] += fl_s_0_0_4 * (0.5 * pc_yzz[j] * fl1_fx + 0.5 * fl1_fx * pc_xxy[j] + 2.0 * pa_z[j] * pc_xxyz[j] + 2.0 * pc_xyzz[j] * pb_x[j] + pc_xxzz[j] * pb_y[j]);

                t_zz_xxy[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_zz_xxz[j] = fl_s_0_0_0 * (0.5 * pa_z[j] * fl2_fx + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_zz[j] * fl1_fx * pb_z[j] + pa_z[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pb_xxz[j] + pa_zz[j] * pb_xxz[j]);

                t_zz_xxz[j] += fl_s_0_0_1 * (-pa_z[j] * fl2_fx - 0.75 * pc_z[j] * fl2_fx - 0.5 * fl2_fx * pb_z[j] - 0.5 * pa_zz[j] * fl1_fx * pc_z[j] - 0.5 * pa_zz[j] * fl1_fx * pb_z[j] - pa_z[j] * pc_z[j] * fl1_fx * pb_z[j] - 2.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_x[j] - pa_z[j] * fl1_fx * pb_xx[j] - 1.5 * pc_z[j] * fl1_fx * pb_xx[j] - fl1_fx * pb_xz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxz[j] - pa_zz[j] * pb_xx[j] * pc_z[j] - 2.0 * pa_zz[j] * pb_xz[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxz[j]);

                t_zz_xxz[j] += fl_s_0_0_2 * (0.5 * pa_z[j] * fl2_fx + 1.5 * pc_z[j] * fl2_fx + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_zz[j] * fl1_fx * pc_z[j] + pa_z[j] * pc_zz[j] * fl1_fx + pa_z[j] * pc_z[j] * fl1_fx * pb_z[j] + pa_z[j] * fl1_fx * pc_xx[j] + 2.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_x[j] + 0.5 * pc_zz[j] * fl1_fx * pb_z[j] + 3.0 * pc_xz[j] * fl1_fx * pb_x[j] + 1.5 * pc_z[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pc_xx[j] * pb_z[j] + fl1_fx * pb_xz[j] * pc_x[j] + 2.0 * pa_zz[j] * pb_x[j] * pc_xz[j] + pa_zz[j] * pc_xx[j] * pb_z[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_xx[j] + 4.0 * pa_z[j] * pc_xz[j] * pb_xz[j] + pc_zz[j] * pb_xxz[j]);

                t_zz_xxz[j] += fl_s_0_0_3 * (-0.75 * pc_z[j] * fl2_fx - pa_z[j] * pc_zz[j] * fl1_fx - pa_z[j] * fl1_fx * pc_xx[j] - 0.5 * pc_zzz[j] * fl1_fx - 0.5 * pc_zz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_xx[j] * pb_z[j] - pa_zz[j] * pc_xxz[j] - 4.0 * pa_z[j] * pc_xzz[j] * pb_x[j] - 2.0 * pa_z[j] * pc_xxz[j] * pb_z[j] - pc_zzz[j] * pb_xx[j] - 2.0 * pc_xzz[j] * pb_xz[j]);

                t_zz_xxz[j] += fl_s_0_0_4 * (0.5 * pc_zzz[j] * fl1_fx + 1.5 * pc_xxz[j] * fl1_fx + 2.0 * pa_z[j] * pc_xxzz[j] + 2.0 * pc_xzzz[j] * pb_x[j] + pc_xxzz[j] * pb_z[j]);

                t_zz_xxz[j] += -fl_s_0_0_5 * pc_xxzzz[j];

                t_zz_xyy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_x[j] + 0.5 * pa_zz[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pb_xyy[j] + pa_zz[j] * pb_xyy[j]);

                t_zz_xyy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pc_x[j] - 0.5 * pa_zz[j] * pb_x[j] * fl1_fx - 0.5 * pa_zz[j] * pc_x[j] * fl1_fx - pa_z[j] * pc_z[j] * pb_x[j] * fl1_fx - fl1_fx * pb_xy[j] * pc_y[j] - 0.5 * fl1_fx * pc_x[j] * pb_yy[j] - 0.5 * fl1_fx * pb_xyy[j] - 2.0 * pa_zz[j] * pb_xy[j] * pc_y[j] - pa_zz[j] * pc_x[j] * pb_yy[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xyy[j]);

                t_zz_xyy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_x[j] + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_zz[j] * pc_x[j] * fl1_fx + pa_z[j] * pc_z[j] * pb_x[j] * fl1_fx + pa_z[j] * pc_xz[j] * fl1_fx + 0.5 * pc_zz[j] * pb_x[j] * fl1_fx + 0.5 * fl1_fx * pb_x[j] * pc_yy[j] + fl1_fx * pc_xy[j] * pb_y[j] + fl1_fx * pb_xy[j] * pc_y[j] + 0.5 * fl1_fx * pc_x[j] * pb_yy[j] + pa_zz[j] * pb_x[j] * pc_yy[j] + 2.0 * pa_zz[j] * pc_xy[j] * pb_y[j] + 4.0 * pa_z[j] * pc_yz[j] * pb_xy[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_yy[j] + pc_zz[j] * pb_xyy[j]);

                t_zz_xyy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_x[j] - pa_z[j] * pc_xz[j] * fl1_fx - 0.5 * pc_zz[j] * pb_x[j] * fl1_fx - 0.5 * pc_xzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xyy[j] - 0.5 * fl1_fx * pb_x[j] * pc_yy[j] - fl1_fx * pc_xy[j] * pb_y[j] - pa_zz[j] * pc_xyy[j] - 2.0 * pa_z[j] * pc_yyz[j] * pb_x[j] - 4.0 * pa_z[j] * pc_xyz[j] * pb_y[j] - 2.0 * pc_yzz[j] * pb_xy[j] - pc_xzz[j] * pb_yy[j]);

                t_zz_xyy[j] += fl_s_0_0_4 * (0.5 * pc_xzz[j] * fl1_fx + 0.5 * fl1_fx * pc_xyy[j] + 2.0 * pa_z[j] * pc_xyyz[j] + pc_yyzz[j] * pb_x[j] + 2.0 * pc_xyzz[j] * pb_y[j]);

                t_zz_xyy[j] += -fl_s_0_0_5 * pc_xyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_54_57(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (54,57)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(19 * idx);

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(19 * idx + 4);

            auto pb_xz = pbDistances.data(19 * idx + 5);

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(19 * idx + 13);

            auto pb_xzz = pbDistances.data(19 * idx + 14);

            auto pb_yyy = pbDistances.data(19 * idx + 15);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            auto pc_xzzzz = pcDistances.data(55 * idx + 48);

            auto pc_yyyzz = pcDistances.data(55 * idx + 51);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_zz_xyz = primBuffer.data(60 * idx + 54);

            auto t_zz_xzz = primBuffer.data(60 * idx + 55);

            auto t_zz_yyy = primBuffer.data(60 * idx + 56);

            // Batch of Integrals (54,57)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xy, pb_xyz, pb_xz, pb_xzz, pb_y, pb_yy, pb_yyy, pb_yz, \
                                     pb_z, pb_zz, pc_x, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, \
                                     pc_xzzzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_zz_xyz, t_zz_xzz, t_zz_yyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xyz[j] = fl_s_0_0_0 * (pa_z[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pb_xyz[j] + pa_zz[j] * pb_xyz[j]);

                t_zz_xyz[j] += fl_s_0_0_1 * (-pa_z[j] * fl1_fx * pb_x[j] * pc_y[j] - pa_z[j] * fl1_fx * pc_x[j] * pb_y[j] - pa_z[j] * fl1_fx * pb_xy[j] - 1.5 * pc_z[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pb_xz[j] * pc_y[j] - 0.5 * fl1_fx * pc_x[j] * pb_yz[j] - 0.5 * fl1_fx * pb_xyz[j] - pa_zz[j] * pb_xy[j] * pc_z[j] - pa_zz[j] * pb_xz[j] * pc_y[j] - pa_zz[j] * pc_x[j] * pb_yz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xyz[j]);

                t_zz_xyz[j] += fl_s_0_0_2 * (pa_z[j] * fl1_fx * pc_xy[j] + pa_z[j] * fl1_fx * pb_x[j] * pc_y[j] + pa_z[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_z[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pc_xy[j] * pb_z[j] + 0.5 * fl1_fx * pb_xz[j] * pc_y[j] + 0.5 * fl1_fx * pc_x[j] * pb_yz[j] + pa_zz[j] * pb_x[j] * pc_yz[j] + pa_zz[j] * pc_xz[j] * pb_y[j] + pa_zz[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_xy[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_xz[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_yz[j] + pc_zz[j] * pb_xyz[j]);

                t_zz_xyz[j] += fl_s_0_0_3 * (-pa_z[j] * fl1_fx * pc_xy[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_xy[j] * pb_z[j] - pa_zz[j] * pc_xyz[j] - 2.0 * pa_z[j] * pc_yzz[j] * pb_x[j] - 2.0 * pa_z[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_z[j] * pc_xyz[j] * pb_z[j] - pc_zzz[j] * pb_xy[j] - pc_yzz[j] * pb_xz[j] - pc_xzz[j] * pb_yz[j]);

                t_zz_xyz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 2.0 * pa_z[j] * pc_xyzz[j] + pc_yzzz[j] * pb_x[j] + pc_xzzz[j] * pb_y[j] + pc_xyzz[j] * pb_z[j]);

                t_zz_xyz[j] += -fl_s_0_0_5 * pc_xyzzz[j];

                t_zz_xzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_x[j] + 0.5 * pa_zz[j] * pb_x[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pb_xzz[j] + pa_zz[j] * pb_xzz[j]);

                t_zz_xzz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_x[j] - 1.5 * fl2_fx * pb_x[j] - 0.5 * pa_zz[j] * pb_x[j] * fl1_fx - 0.5 * pa_zz[j] * pc_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * pb_x[j] * fl1_fx - 2.0 * pa_z[j] * fl1_fx * pc_x[j] * pb_z[j] - 2.0 * pa_z[j] * fl1_fx * pb_xz[j] - 3.0 * pc_z[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pc_x[j] * pb_zz[j] - 0.5 * fl1_fx * pb_xzz[j] - 2.0 * pa_zz[j] * pb_xz[j] * pc_z[j] - pa_zz[j] * pc_x[j] * pb_zz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xzz[j]);

                t_zz_xzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_x[j] + 0.75 * fl2_fx * pb_x[j] + 0.5 * pa_zz[j] * pc_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_xz[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pc_x[j] * pb_z[j] + 3.0 * pc_zz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xz[j] * fl1_fx * pb_z[j] + 3.0 * pc_z[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pc_x[j] * pb_zz[j] + pa_zz[j] * pb_x[j] * pc_zz[j] + 2.0 * pa_zz[j] * pc_xz[j] * pb_z[j] + 4.0 * pa_z[j] * pc_zz[j] * pb_xz[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_zz[j] + pc_zz[j] * pb_xzz[j]);

                t_zz_xzz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_x[j] - 3.0 * pa_z[j] * pc_xz[j] * fl1_fx - 3.0 * pc_zz[j] * pb_x[j] * fl1_fx - 3.0 * pc_xzz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_z[j] - pa_zz[j] * pc_xzz[j] - 2.0 * pa_z[j] * pc_zzz[j] * pb_x[j] - 4.0 * pa_z[j] * pc_xzz[j] * pb_z[j] - 2.0 * pc_zzz[j] * pb_xz[j] - pc_xzz[j] * pb_zz[j]);

                t_zz_xzz[j] += fl_s_0_0_4 * (3.0 * pc_xzz[j] * fl1_fx + 2.0 * pa_z[j] * pc_xzzz[j] + pc_zzzz[j] * pb_x[j] + 2.0 * pc_xzzz[j] * pb_z[j]);

                t_zz_xzz[j] += -fl_s_0_0_5 * pc_xzzzz[j];

                t_zz_yyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_y[j] + 1.5 * pa_zz[j] * pb_y[j] * fl1_fx + 0.5 * fl1_fx * pb_yyy[j] + pa_zz[j] * pb_yyy[j]);

                t_zz_yyy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pc_y[j] - 1.5 * pa_zz[j] * pb_y[j] * fl1_fx - 1.5 * pa_zz[j] * pc_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * pb_y[j] * fl1_fx - 1.5 * fl1_fx * pb_yy[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyy[j] - 3.0 * pa_zz[j] * pb_yy[j] * pc_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yyy[j]);

                t_zz_yyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pb_y[j] + 1.5 * pa_zz[j] * pc_y[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_y[j] * fl1_fx + 3.0 * pa_z[j] * pc_yz[j] * fl1_fx + 1.5 * pc_zz[j] * pb_y[j] * fl1_fx + 1.5 * fl1_fx * pb_y[j] * pc_yy[j] + 1.5 * fl1_fx * pb_yy[j] * pc_y[j] + 3.0 * pa_zz[j] * pb_y[j] * pc_yy[j] + 6.0 * pa_z[j] * pc_yz[j] * pb_yy[j] + pc_zz[j] * pb_yyy[j]);

                t_zz_yyy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 3.0 * pa_z[j] * pc_yz[j] * fl1_fx - 1.5 * pc_zz[j] * pb_y[j] * fl1_fx - 1.5 * pc_yzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyy[j] - 1.5 * fl1_fx * pb_y[j] * pc_yy[j] - pa_zz[j] * pc_yyy[j] - 6.0 * pa_z[j] * pc_yyz[j] * pb_y[j] - 3.0 * pc_yzz[j] * pb_yy[j]);

                t_zz_yyy[j] += fl_s_0_0_4 * (1.5 * pc_yzz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyy[j] + 2.0 * pa_z[j] * pc_yyyz[j] + 3.0 * pc_yyzz[j] * pb_y[j]);

                t_zz_yyy[j] += -fl_s_0_0_5 * pc_yyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDF_57_60(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (57,60)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(19 * idx + 1);

            auto pb_z = pbDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(19 * idx + 6);

            auto pb_yz = pbDistances.data(19 * idx + 7);

            auto pb_zz = pbDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(19 * idx + 16);

            auto pb_yzz = pbDistances.data(19 * idx + 17);

            auto pb_zzz = pbDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(55 * idx + 52);

            auto pc_yzzzz = pcDistances.data(55 * idx + 53);

            auto pc_zzzzz = pcDistances.data(55 * idx + 54);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_zz_yyz = primBuffer.data(60 * idx + 57);

            auto t_zz_yzz = primBuffer.data(60 * idx + 58);

            auto t_zz_zzz = primBuffer.data(60 * idx + 59);

            // Batch of Integrals (57,60)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_y, pb_yy, pb_yyz, pb_yz, pb_yzz, pb_z, pb_zz, pb_zzz, pc_y, \
                                     pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, \
                                     pc_zzz, pc_zzzz, pc_zzzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_zz_yyz, t_zz_yzz, t_zz_zzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_yyz[j] = fl_s_0_0_0 * (0.5 * pa_z[j] * fl2_fx + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_zz[j] * fl1_fx * pb_z[j] + pa_z[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pb_yyz[j] + pa_zz[j] * pb_yyz[j]);

                t_zz_yyz[j] += fl_s_0_0_1 * (-pa_z[j] * fl2_fx - 0.75 * pc_z[j] * fl2_fx - 0.5 * fl2_fx * pb_z[j] - 0.5 * pa_zz[j] * fl1_fx * pc_z[j] - 0.5 * pa_zz[j] * fl1_fx * pb_z[j] - pa_z[j] * pc_z[j] * fl1_fx * pb_z[j] - 2.0 * pa_z[j] * fl1_fx * pb_y[j] * pc_y[j] - pa_z[j] * fl1_fx * pb_yy[j] - 1.5 * pc_z[j] * fl1_fx * pb_yy[j] - fl1_fx * pb_yz[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyz[j] - pa_zz[j] * pb_yy[j] * pc_z[j] - 2.0 * pa_zz[j] * pb_yz[j] * pc_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yyz[j]);

                t_zz_yyz[j] += fl_s_0_0_2 * (0.5 * pa_z[j] * fl2_fx + 1.5 * pc_z[j] * fl2_fx + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_zz[j] * fl1_fx * pc_z[j] + pa_z[j] * pc_zz[j] * fl1_fx + pa_z[j] * pc_z[j] * fl1_fx * pb_z[j] + pa_z[j] * fl1_fx * pc_yy[j] + 2.0 * pa_z[j] * fl1_fx * pb_y[j] * pc_y[j] + 0.5 * pc_zz[j] * fl1_fx * pb_z[j] + 3.0 * pc_yz[j] * fl1_fx * pb_y[j] + 1.5 * pc_z[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pc_yy[j] * pb_z[j] + fl1_fx * pb_yz[j] * pc_y[j] + 2.0 * pa_zz[j] * pb_y[j] * pc_yz[j] + pa_zz[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_yy[j] + 4.0 * pa_z[j] * pc_yz[j] * pb_yz[j] + pc_zz[j] * pb_yyz[j]);

                t_zz_yyz[j] += fl_s_0_0_3 * (-0.75 * pc_z[j] * fl2_fx - pa_z[j] * pc_zz[j] * fl1_fx - pa_z[j] * fl1_fx * pc_yy[j] - 0.5 * pc_zzz[j] * fl1_fx - 0.5 * pc_zz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yyz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pb_z[j] - pa_zz[j] * pc_yyz[j] - 4.0 * pa_z[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_z[j] * pc_yyz[j] * pb_z[j] - pc_zzz[j] * pb_yy[j] - 2.0 * pc_yzz[j] * pb_yz[j]);

                t_zz_yyz[j] += fl_s_0_0_4 * (0.5 * pc_zzz[j] * fl1_fx + 1.5 * pc_yyz[j] * fl1_fx + 2.0 * pa_z[j] * pc_yyzz[j] + 2.0 * pc_yzzz[j] * pb_y[j] + pc_yyzz[j] * pb_z[j]);

                t_zz_yyz[j] += -fl_s_0_0_5 * pc_yyzzz[j];

                t_zz_yzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_y[j] + 0.5 * pa_zz[j] * pb_y[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pb_yzz[j] + pa_zz[j] * pb_yzz[j]);

                t_zz_yzz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * fl2_fx * pb_y[j] - 0.5 * pa_zz[j] * pb_y[j] * fl1_fx - 0.5 * pa_zz[j] * pc_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * pb_y[j] * fl1_fx - 2.0 * pa_z[j] * fl1_fx * pc_y[j] * pb_z[j] - 2.0 * pa_z[j] * fl1_fx * pb_yz[j] - 3.0 * pc_z[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pb_yzz[j] - 2.0 * pa_zz[j] * pb_yz[j] * pc_z[j] - pa_zz[j] * pc_y[j] * pb_zz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yzz[j]);

                t_zz_yzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pb_y[j] + 0.5 * pa_zz[j] * pc_y[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_y[j] * fl1_fx + 3.0 * pa_z[j] * pc_yz[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pc_y[j] * pb_z[j] + 3.0 * pc_zz[j] * pb_y[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_z[j] + 3.0 * pc_z[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pc_y[j] * pb_zz[j] + pa_zz[j] * pb_y[j] * pc_zz[j] + 2.0 * pa_zz[j] * pc_yz[j] * pb_z[j] + 4.0 * pa_z[j] * pc_zz[j] * pb_yz[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_zz[j] + pc_zz[j] * pb_yzz[j]);

                t_zz_yzz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 3.0 * pa_z[j] * pc_yz[j] * fl1_fx - 3.0 * pc_zz[j] * pb_y[j] * fl1_fx - 3.0 * pc_yzz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_z[j] - pa_zz[j] * pc_yzz[j] - 2.0 * pa_z[j] * pc_zzz[j] * pb_y[j] - 4.0 * pa_z[j] * pc_yzz[j] * pb_z[j] - 2.0 * pc_zzz[j] * pb_yz[j] - pc_yzz[j] * pb_zz[j]);

                t_zz_yzz[j] += fl_s_0_0_4 * (3.0 * pc_yzz[j] * fl1_fx + 2.0 * pa_z[j] * pc_yzzz[j] + pc_zzzz[j] * pb_y[j] + 2.0 * pc_yzzz[j] * pb_z[j]);

                t_zz_yzz[j] += -fl_s_0_0_5 * pc_yzzzz[j];

                t_zz_zzz[j] = fl_s_0_0_0 * (1.5 * pa_z[j] * fl2_fx + 2.25 * fl2_fx * pb_z[j] + 1.5 * pa_zz[j] * pb_z[j] * fl1_fx + 3.0 * pa_z[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_zzz[j] + pa_zz[j] * pb_zzz[j]);

                t_zz_zzz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx - 3.75 * pc_z[j] * fl2_fx - 4.5 * fl2_fx * pb_z[j] - 1.5 * pa_zz[j] * pb_z[j] * fl1_fx - 1.5 * pa_zz[j] * pc_z[j] * fl1_fx - 9.0 * pa_z[j] * pc_z[j] * pb_z[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pb_zz[j] - 4.5 * pc_z[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pb_zzz[j] - 3.0 * pa_zz[j] * pb_zz[j] * pc_z[j] - 2.0 * pa_z[j] * pc_z[j] * pb_zzz[j]);

                t_zz_zzz[j] += fl_s_0_0_2 * (1.5 * pa_z[j] * fl2_fx + 7.5 * pc_z[j] * fl2_fx + 2.25 * fl2_fx * pb_z[j] + 1.5 * pa_zz[j] * pc_z[j] * fl1_fx + 9.0 * pa_z[j] * pc_z[j] * pb_z[j] * fl1_fx + 6.0 * pa_z[j] * pc_zz[j] * fl1_fx + 9.0 * pc_zz[j] * pb_z[j] * fl1_fx + 4.5 * pc_z[j] * fl1_fx * pb_zz[j] + 3.0 * pa_zz[j] * pb_z[j] * pc_zz[j] + 6.0 * pa_z[j] * pc_zz[j] * pb_zz[j] + pc_zz[j] * pb_zzz[j]);

                t_zz_zzz[j] += fl_s_0_0_3 * (-3.75 * pc_z[j] * fl2_fx - 6.0 * pa_z[j] * pc_zz[j] * fl1_fx - 9.0 * pc_zz[j] * pb_z[j] * fl1_fx - 5.0 * pc_zzz[j] * fl1_fx - pa_zz[j] * pc_zzz[j] - 6.0 * pa_z[j] * pc_zzz[j] * pb_z[j] - 3.0 * pc_zzz[j] * pb_zz[j]);

                t_zz_zzz[j] += fl_s_0_0_4 * (5.0 * pc_zzz[j] * fl1_fx + 2.0 * pa_z[j] * pc_zzzz[j] + 3.0 * pc_zzzz[j] * pb_z[j]);

                t_zz_zzz[j] += -fl_s_0_0_5 * pc_zzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD(      CMemBlock2D<double>& primBuffer,
                              const CMemBlock2D<double>& auxBuffer,
                              const CMemBlock2D<double>& osFactors,
                              const CMemBlock2D<double>& paDistances,
                              const CMemBlock2D<double>& pbDistances,
                              const CMemBlock2D<double>& pcDistances,
                              const CGtoBlock&           braGtoBlock,
                              const CGtoBlock&           ketGtoBlock,
                              const int32_t              iContrGto)
    {
        npotrecfunc::compNuclearPotentialForFD_0_3(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_3_6(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_6_9(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_9_12(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                    braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_12_15(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_15_18(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_18_21(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_21_24(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_24_27(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_27_30(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_30_33(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_33_36(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_36_39(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_39_42(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_42_45(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_45_48(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_48_51(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_51_54(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_54_57(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForFD_57_60(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 
    }

    void
    compNuclearPotentialForFD_0_3(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (0,3)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(19 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(19 * idx + 9);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(55 * idx + 19);

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(55 * idx + 34);

            auto pc_xxxxy = pcDistances.data(55 * idx + 35);

            auto pc_xxxxz = pcDistances.data(55 * idx + 36);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xxx_xx = primBuffer.data(60 * idx);

            auto t_xxx_xy = primBuffer.data(60 * idx + 1);

            auto t_xxx_xz = primBuffer.data(60 * idx + 2);

            // Batch of Integrals (0,3)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxx, \
                                     pc_xxxx, pc_xxxxx, pc_xxxxy, pc_xxxxz, pc_xxxy, pc_xxxz, pc_xxy, pc_xxz, pc_xy, pc_xz, \
                                     pc_y, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xxx_xx, \
                                     t_xxx_xy, t_xxx_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxx_xx[j] = fl_s_0_0_0 * (2.25 * pa_x[j] * fl2_fx + 1.5 * fl2_fx * pb_x[j] + 0.5 * pa_xxx[j] * fl1_fx + 3.0 * pa_xx[j] * fl1_fx * pb_x[j] + 1.5 * pa_x[j] * fl1_fx * pb_xx[j] + pa_xxx[j] * pb_xx[j]);

                t_xxx_xx[j] += fl_s_0_0_1 * (-4.5 * pa_x[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx - 3.0 * fl2_fx * pb_x[j] - 0.5 * pa_xxx[j] * fl1_fx - 4.5 * pa_xx[j] * pc_x[j] * fl1_fx - 3.0 * pa_xx[j] * fl1_fx * pb_x[j] - 9.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xxx[j] * pb_x[j] * pc_x[j] - 3.0 * pa_xx[j] * pc_x[j] * pb_xx[j]);

                t_xxx_xx[j] += fl_s_0_0_2 * (2.25 * pa_x[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx + 1.5 * fl2_fx * pb_x[j] + 4.5 * pa_xx[j] * pc_x[j] * fl1_fx + 9.0 * pa_x[j] * pc_xx[j] * fl1_fx + 9.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_x[j] + 6.0 * pc_xx[j] * fl1_fx * pb_x[j] + 1.5 * pc_x[j] * fl1_fx * pb_xx[j] + pa_xxx[j] * pc_xx[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xx[j] * pb_xx[j]);

                t_xxx_xx[j] += fl_s_0_0_3 * (-3.75 * pc_x[j] * fl2_fx - 9.0 * pa_x[j] * pc_xx[j] * fl1_fx - 5.0 * pc_xxx[j] * fl1_fx - 6.0 * pc_xx[j] * fl1_fx * pb_x[j] - 3.0 * pa_xx[j] * pc_xxx[j] - 6.0 * pa_x[j] * pc_xxx[j] * pb_x[j] - pc_xxx[j] * pb_xx[j]);

                t_xxx_xx[j] += fl_s_0_0_4 * (5.0 * pc_xxx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xxxx[j] + 2.0 * pc_xxxx[j] * pb_x[j]);

                t_xxx_xx[j] += -fl_s_0_0_5 * pc_xxxxx[j];

                t_xxx_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_y[j] + 1.5 * pa_xx[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pb_xy[j] + pa_xxx[j] * pb_xy[j]);

                t_xxx_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * fl2_fx * pb_y[j] - 1.5 * pa_xx[j] * fl1_fx * pc_y[j] - 1.5 * pa_xx[j] * fl1_fx * pb_y[j] - 4.5 * pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] - 1.5 * pa_x[j] * fl1_fx * pb_xy[j] - 1.5 * pc_x[j] * fl1_fx * pb_xy[j] - pa_xxx[j] * pb_x[j] * pc_y[j] - pa_xxx[j] * pc_x[j] * pb_y[j] - 3.0 * pa_xx[j] * pc_x[j] * pb_xy[j]);

                t_xxx_xy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pb_y[j] + 1.5 * pa_xx[j] * fl1_fx * pc_y[j] + 4.5 * pa_x[j] * pc_xy[j] * fl1_fx + 4.5 * pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] + 3.0 * pc_xx[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_x[j] + 1.5 * pc_x[j] * fl1_fx * pb_xy[j] + pa_xxx[j] * pc_xy[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_x[j] + 3.0 * pa_xx[j] * pc_xx[j] * pb_y[j] + 3.0 * pa_x[j] * pc_xx[j] * pb_xy[j]);

                t_xxx_xy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 4.5 * pa_x[j] * pc_xy[j] * fl1_fx - 3.0 * pc_xxy[j] * fl1_fx - 3.0 * pc_xx[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_x[j] - 3.0 * pa_xx[j] * pc_xxy[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_x[j] - 3.0 * pa_x[j] * pc_xxx[j] * pb_y[j] - pc_xxx[j] * pb_xy[j]);

                t_xxx_xy[j] += fl_s_0_0_4 * (3.0 * pc_xxy[j] * fl1_fx + 3.0 * pa_x[j] * pc_xxxy[j] + pc_xxxy[j] * pb_x[j] + pc_xxxx[j] * pb_y[j]);

                t_xxx_xy[j] += -fl_s_0_0_5 * pc_xxxxy[j];

                t_xxx_xz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_z[j] + 1.5 * pa_xx[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pb_xz[j] + pa_xxx[j] * pb_xz[j]);

                t_xxx_xz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * fl2_fx * pb_z[j] - 1.5 * pa_xx[j] * fl1_fx * pc_z[j] - 1.5 * pa_xx[j] * fl1_fx * pb_z[j] - 4.5 * pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pb_xz[j] - 1.5 * pc_x[j] * fl1_fx * pb_xz[j] - pa_xxx[j] * pb_x[j] * pc_z[j] - pa_xxx[j] * pc_x[j] * pb_z[j] - 3.0 * pa_xx[j] * pc_x[j] * pb_xz[j]);

                t_xxx_xz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pb_z[j] + 1.5 * pa_xx[j] * fl1_fx * pc_z[j] + 4.5 * pa_x[j] * pc_xz[j] * fl1_fx + 4.5 * pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pc_xx[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_x[j] + 1.5 * pc_x[j] * fl1_fx * pb_xz[j] + pa_xxx[j] * pc_xz[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_x[j] + 3.0 * pa_xx[j] * pc_xx[j] * pb_z[j] + 3.0 * pa_x[j] * pc_xx[j] * pb_xz[j]);

                t_xxx_xz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 4.5 * pa_x[j] * pc_xz[j] * fl1_fx - 3.0 * pc_xxz[j] * fl1_fx - 3.0 * pc_xx[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_x[j] - 3.0 * pa_xx[j] * pc_xxz[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_x[j] - 3.0 * pa_x[j] * pc_xxx[j] * pb_z[j] - pc_xxx[j] * pb_xz[j]);

                t_xxx_xz[j] += fl_s_0_0_4 * (3.0 * pc_xxz[j] * fl1_fx + 3.0 * pa_x[j] * pc_xxxz[j] + pc_xxxz[j] * pb_x[j] + pc_xxxx[j] * pb_z[j]);

                t_xxx_xz[j] += -fl_s_0_0_5 * pc_xxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_3_6(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (3,6)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(19 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(19 * idx + 9);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(55 * idx + 37);

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxxzz = pcDistances.data(55 * idx + 39);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xxx_yy = primBuffer.data(60 * idx + 3);

            auto t_xxx_yz = primBuffer.data(60 * idx + 4);

            auto t_xxx_zz = primBuffer.data(60 * idx + 5);

            // Batch of Integrals (3,6)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xx, pc_xxx, \
                                     pc_xxxy, pc_xxxyy, pc_xxxyz, pc_xxxz, pc_xxxzz, pc_xxy, pc_xxyy, pc_xxyz, pc_xxz, \
                                     pc_xxzz, pc_xy, pc_xyy, pc_xyz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yz, pc_z, pc_zz, s_0_0_0, \
                                     s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xxx_yy, t_xxx_yz, t_xxx_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxx_yy[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx + 0.5 * pa_xxx[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_yy[j] + pa_xxx[j] * pb_yy[j]);

                t_xxx_yy[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * pa_xxx[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] - 1.5 * pa_x[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xxx[j] * pb_y[j] * pc_y[j] - 3.0 * pa_xx[j] * pc_x[j] * pb_yy[j]);

                t_xxx_yy[j] += fl_s_0_0_2 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xx[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_yy[j] + 3.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] + 3.0 * pc_xy[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pb_yy[j] + pa_xxx[j] * pc_yy[j] + 6.0 * pa_xx[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_x[j] * pc_xx[j] * pb_yy[j]);

                t_xxx_yy[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 1.5 * pa_x[j] * pc_xx[j] * fl1_fx - 0.5 * pc_xxx[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_yy[j] - 1.5 * pc_xyy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_y[j] - 3.0 * pa_xx[j] * pc_xyy[j] - 6.0 * pa_x[j] * pc_xxy[j] * pb_y[j] - pc_xxx[j] * pb_yy[j]);

                t_xxx_yy[j] += fl_s_0_0_4 * (0.5 * pc_xxx[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx + 3.0 * pa_x[j] * pc_xxyy[j] + 2.0 * pc_xxxy[j] * pb_y[j]);

                t_xxx_yy[j] += -fl_s_0_0_5 * pc_xxxyy[j];

                t_xxx_yz[j] = fl_s_0_0_0 * (1.5 * pa_x[j] * fl1_fx * pb_yz[j] + pa_xxx[j] * pb_yz[j]);

                t_xxx_yz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pb_yz[j] - 1.5 * pc_x[j] * fl1_fx * pb_yz[j] - pa_xxx[j] * pb_y[j] * pc_z[j] - pa_xxx[j] * pc_y[j] * pb_z[j] - 3.0 * pa_xx[j] * pc_x[j] * pb_yz[j]);

                t_xxx_yz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl1_fx * pc_yz[j] + 1.5 * pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pb_yz[j] + pa_xxx[j] * pc_yz[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_x[j] * pc_xx[j] * pb_yz[j]);

                t_xxx_yz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl1_fx * pc_yz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - 3.0 * pa_xx[j] * pc_xyz[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_z[j] - pc_xxx[j] * pb_yz[j]);

                t_xxx_yz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 3.0 * pa_x[j] * pc_xxyz[j] + pc_xxxz[j] * pb_y[j] + pc_xxxy[j] * pb_z[j]);

                t_xxx_yz[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_xxx_zz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx + 0.5 * pa_xxx[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_zz[j] + pa_xxx[j] * pb_zz[j]);

                t_xxx_zz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * pa_xxx[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xxx[j] * pb_z[j] * pc_z[j] - 3.0 * pa_xx[j] * pc_x[j] * pb_zz[j]);

                t_xxx_zz[j] += fl_s_0_0_2 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xx[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_zz[j] + 3.0 * pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] + 3.0 * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pb_zz[j] + pa_xxx[j] * pc_zz[j] + 6.0 * pa_xx[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_x[j] * pc_xx[j] * pb_zz[j]);

                t_xxx_zz[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 1.5 * pa_x[j] * pc_xx[j] * fl1_fx - 0.5 * pc_xxx[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_zz[j] - 1.5 * pc_xzz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_z[j] - 3.0 * pa_xx[j] * pc_xzz[j] - 6.0 * pa_x[j] * pc_xxz[j] * pb_z[j] - pc_xxx[j] * pb_zz[j]);

                t_xxx_zz[j] += fl_s_0_0_4 * (0.5 * pc_xxx[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx + 3.0 * pa_x[j] * pc_xxzz[j] + 2.0 * pc_xxxz[j] * pb_z[j]);

                t_xxx_zz[j] += -fl_s_0_0_5 * pc_xxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_6_9(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (6,9)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_y = paDistances.data(19 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(19 * idx + 3);

            auto pa_xy = paDistances.data(19 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(19 * idx + 10);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(55 * idx + 19);

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(55 * idx + 35);

            auto pc_xxxyy = pcDistances.data(55 * idx + 37);

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xxy_xx = primBuffer.data(60 * idx + 6);

            auto t_xxy_xy = primBuffer.data(60 * idx + 7);

            auto t_xxy_xz = primBuffer.data(60 * idx + 8);

            // Batch of Integrals (6,9)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xy, pa_y, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxy, pc_xxxyy, pc_xxxyz, pc_xxxz, pc_xxy, \
                                     pc_xxyy, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyz, pc_xz, pc_y, pc_yy, pc_yz, pc_z, s_0_0_0, \
                                     s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xxy_xx, t_xxy_xy, t_xxy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxy_xx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_y[j] + 0.5 * pa_xxy[j] * fl1_fx + 2.0 * pa_xy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_y[j] * pb_xx[j] + pa_xxy[j] * pb_xx[j]);

                t_xxy_xx[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * fl2_fx * pa_y[j] - 0.5 * pa_xxy[j] * fl1_fx - 0.5 * pa_xx[j] * pc_y[j] * fl1_fx - 3.0 * pa_xy[j] * pc_x[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pc_y[j] * pb_x[j] - 2.0 * pa_xy[j] * fl1_fx * pb_x[j] - 3.0 * pc_x[j] * fl1_fx * pa_y[j] * pb_x[j] - 0.5 * fl1_fx * pc_y[j] * pb_xx[j] - 0.5 * fl1_fx * pa_y[j] * pb_xx[j] - 2.0 * pa_xxy[j] * pb_x[j] * pc_x[j] - pa_xx[j] * pc_y[j] * pb_xx[j] - 2.0 * pa_xy[j] * pc_x[j] * pb_xx[j]);

                t_xxy_xx[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pa_y[j] + 0.5 * pa_xx[j] * pc_y[j] * fl1_fx + 3.0 * pa_xy[j] * pc_x[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pc_y[j] * pb_x[j] + 3.0 * pc_xx[j] * pa_y[j] * fl1_fx + 3.0 * pc_xy[j] * fl1_fx * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pa_y[j] * pb_x[j] + 0.5 * fl1_fx * pc_y[j] * pb_xx[j] + pa_xxy[j] * pc_xx[j] + 2.0 * pa_xx[j] * pc_xy[j] * pb_x[j] + 4.0 * pa_xy[j] * pc_xx[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xx[j] + pc_xx[j] * pa_y[j] * pb_xx[j]);

                t_xxy_xx[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx - 3.0 * pc_xx[j] * pa_y[j] * fl1_fx - 3.0 * pc_xxy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_x[j] - pa_xx[j] * pc_xxy[j] - 2.0 * pa_xy[j] * pc_xxx[j] - 4.0 * pa_x[j] * pc_xxy[j] * pb_x[j] - 2.0 * pc_xxx[j] * pa_y[j] * pb_x[j] - pc_xxy[j] * pb_xx[j]);

                t_xxy_xx[j] += fl_s_0_0_4 * (3.0 * pc_xxy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxxy[j] + pc_xxxx[j] * pa_y[j] + 2.0 * pc_xxxy[j] * pb_x[j]);

                t_xxy_xx[j] += -fl_s_0_0_5 * pc_xxxxy[j];

                t_xxy_xy[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * fl1_fx * pb_x[j] + pa_xy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_y[j] * pb_xy[j] + pa_xxy[j] * pb_xy[j]);

                t_xxy_xy[j] += fl_s_0_0_1 * (-pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pb_x[j] - 0.5 * pa_xx[j] * fl1_fx * pc_x[j] - 0.5 * pa_xx[j] * fl1_fx * pb_x[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_x[j] - pa_xy[j] * fl1_fx * pc_y[j] - pa_x[j] * fl1_fx * pc_y[j] * pb_y[j] - pa_xy[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_y[j] - 0.5 * fl1_fx * pa_y[j] * pb_x[j] * pc_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_xy[j] - 0.5 * fl1_fx * pa_y[j] * pb_xy[j] - pa_xxy[j] * pb_x[j] * pc_y[j] - pa_xxy[j] * pc_x[j] * pb_y[j] - pa_xx[j] * pc_y[j] * pb_xy[j] - 2.0 * pa_xy[j] * pc_x[j] * pb_xy[j]);

                t_xxy_xy[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * fl1_fx * pc_x[j] + pa_x[j] * pc_xx[j] * fl1_fx + pa_x[j] * pc_x[j] * fl1_fx * pb_x[j] + pa_x[j] * fl1_fx * pc_yy[j] + pa_xy[j] * fl1_fx * pc_y[j] + pa_x[j] * fl1_fx * pc_y[j] * pb_y[j] + 0.5 * pc_xx[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pb_x[j] + 0.5 * fl1_fx * pa_y[j] * pb_x[j] * pc_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_xy[j] + pa_xxy[j] * pc_xy[j] + pa_xx[j] * pc_yy[j] * pb_x[j] + pa_xx[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xy[j] * pc_xx[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xy[j] + pc_xx[j] * pa_y[j] * pb_xy[j]);

                t_xxy_xy[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - pa_x[j] * pc_xx[j] * fl1_fx - pa_x[j] * fl1_fx * pc_yy[j] - 0.5 * pc_xxx[j] * fl1_fx - 0.5 * pc_xx[j] * fl1_fx * pb_x[j] - 1.5 * pc_xyy[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pa_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pb_x[j] - pa_xx[j] * pc_xyy[j] - 2.0 * pa_xy[j] * pc_xxy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxy[j] * pb_y[j] - pc_xxy[j] * pa_y[j] * pb_x[j] - pc_xxx[j] * pa_y[j] * pb_y[j] - pc_xxy[j] * pb_xy[j]);

                t_xxy_xy[j] += fl_s_0_0_4 * (0.5 * pc_xxx[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxyy[j] + pc_xxxy[j] * pa_y[j] + pc_xxyy[j] * pb_x[j] + pc_xxxy[j] * pb_y[j]);

                t_xxy_xy[j] += -fl_s_0_0_5 * pc_xxxyy[j];

                t_xxy_xz[j] = fl_s_0_0_0 * (pa_xy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pb_xz[j] + pa_xxy[j] * pb_xz[j]);

                t_xxy_xz[j] += fl_s_0_0_1 * (-pa_xy[j] * fl1_fx * pc_z[j] - pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] - pa_xy[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_xz[j] - 0.5 * fl1_fx * pa_y[j] * pb_xz[j] - pa_xxy[j] * pb_x[j] * pc_z[j] - pa_xxy[j] * pc_x[j] * pb_z[j] - pa_xx[j] * pc_y[j] * pb_xz[j] - 2.0 * pa_xy[j] * pc_x[j] * pb_xz[j]);

                t_xxy_xz[j] += fl_s_0_0_2 * (pa_x[j] * fl1_fx * pc_yz[j] + pa_xy[j] * fl1_fx * pc_z[j] + pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pa_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_z[j] + 0.5 * fl1_fx * pc_yz[j] * pb_x[j] + 0.5 * fl1_fx * pa_y[j] * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_xz[j] + pa_xxy[j] * pc_xz[j] + pa_xx[j] * pc_yz[j] * pb_x[j] + pa_xx[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xy[j] * pc_xx[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xz[j] + pc_xx[j] * pa_y[j] * pb_xz[j]);

                t_xxy_xz[j] += fl_s_0_0_3 * (-pa_x[j] * fl1_fx * pc_yz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pa_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_yz[j] * pb_x[j] - pa_xx[j] * pc_xyz[j] - 2.0 * pa_xy[j] * pc_xxz[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxy[j] * pb_z[j] - pc_xxz[j] * pa_y[j] * pb_x[j] - pc_xxx[j] * pa_y[j] * pb_z[j] - pc_xxy[j] * pb_xz[j]);

                t_xxy_xz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxyz[j] + pc_xxxz[j] * pa_y[j] + pc_xxyz[j] * pb_x[j] + pc_xxxy[j] * pb_z[j]);

                t_xxy_xz[j] += -fl_s_0_0_5 * pc_xxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_9_12(      CMemBlock2D<double>& primBuffer,
                                   const CMemBlock2D<double>& auxBuffer,
                                   const CMemBlock2D<double>& osFactors,
                                   const CMemBlock2D<double>& paDistances,
                                   const CMemBlock2D<double>& pbDistances,
                                   const CMemBlock2D<double>& pcDistances,
                                   const CGtoBlock&           braGtoBlock,
                                   const CGtoBlock&           ketGtoBlock,
                                   const int32_t              iContrGto)
    {
        // Batch of Integrals (9,12)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_y = paDistances.data(19 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(19 * idx + 3);

            auto pa_xy = paDistances.data(19 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(19 * idx + 10);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(55 * idx + 40);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xxy_yy = primBuffer.data(60 * idx + 9);

            auto t_xxy_yz = primBuffer.data(60 * idx + 10);

            auto t_xxy_zz = primBuffer.data(60 * idx + 11);

            // Batch of Integrals (9,12)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xy, pa_y, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xx, \
                                     pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_xxy_yy, t_xxy_yz, t_xxy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxy_yy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_y[j] + 0.5 * fl2_fx * pb_y[j] + 0.5 * pa_xxy[j] * fl1_fx + pa_xx[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_y[j] * pb_yy[j] + pa_xxy[j] * pb_yy[j]);

                t_xxy_yy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] - 0.75 * fl2_fx * pc_y[j] - fl2_fx * pb_y[j] - 0.5 * pa_xxy[j] * fl1_fx - 1.5 * pa_xx[j] * pc_y[j] * fl1_fx - pa_xx[j] * fl1_fx * pb_y[j] - pa_xy[j] * pc_x[j] * fl1_fx - 2.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] - fl1_fx * pa_y[j] * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_yy[j] - 0.5 * fl1_fx * pa_y[j] * pb_yy[j] - 2.0 * pa_xxy[j] * pb_y[j] * pc_y[j] - pa_xx[j] * pc_y[j] * pb_yy[j] - 2.0 * pa_xy[j] * pc_x[j] * pb_yy[j]);

                t_xxy_yy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pa_y[j] + 0.5 * fl2_fx * pb_y[j] + 1.5 * pa_xx[j] * pc_y[j] * fl1_fx + pa_xy[j] * pc_x[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx + 2.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx + pc_xx[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_y[j] * pc_yy[j] + fl1_fx * pc_yy[j] * pb_y[j] + fl1_fx * pa_y[j] * pb_y[j] * pc_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_yy[j] + pa_xxy[j] * pc_yy[j] + 2.0 * pa_xx[j] * pc_yy[j] * pb_y[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_yy[j] + pc_xx[j] * pa_y[j] * pb_yy[j]);

                t_xxy_yy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx - 1.5 * pc_xxy[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yyy[j] - 0.5 * fl1_fx * pa_y[j] * pc_yy[j] - fl1_fx * pc_yy[j] * pb_y[j] - pa_xx[j] * pc_yyy[j] - 2.0 * pa_xy[j] * pc_xyy[j] - 4.0 * pa_x[j] * pc_xyy[j] * pb_y[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_y[j] - pc_xxy[j] * pb_yy[j]);

                t_xxy_yy[j] += fl_s_0_0_4 * (1.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yyy[j] + 2.0 * pa_x[j] * pc_xyyy[j] + pc_xxyy[j] * pa_y[j] + 2.0 * pc_xxyy[j] * pb_y[j]);

                t_xxy_yy[j] += -fl_s_0_0_5 * pc_xxyyy[j];

                t_xxy_yz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_z[j] + 0.5 * pa_xx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pb_yz[j] + pa_xxy[j] * pb_yz[j]);

                t_xxy_yz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_z[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_yz[j] - 0.5 * fl1_fx * pa_y[j] * pb_yz[j] - pa_xxy[j] * pb_y[j] * pc_z[j] - pa_xxy[j] * pc_y[j] * pb_z[j] - pa_xx[j] * pc_y[j] * pb_yz[j] - 2.0 * pa_xy[j] * pc_x[j] * pb_yz[j]);

                t_xxy_yz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pb_z[j] + 0.5 * pa_xx[j] * fl1_fx * pc_z[j] + pa_x[j] * pc_xz[j] * fl1_fx + pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * pc_xx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_yz[j] + 0.5 * fl1_fx * pc_yz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_y[j] * pb_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_yz[j] + pa_xxy[j] * pc_yz[j] + pa_xx[j] * pc_yz[j] * pb_y[j] + pa_xx[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_yz[j] + pc_xx[j] * pa_y[j] * pb_yz[j]);

                t_xxy_yz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - pa_x[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_yyz[j] - 0.5 * fl1_fx * pa_y[j] * pc_yz[j] - 0.5 * fl1_fx * pc_yz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pb_z[j] - pa_xx[j] * pc_yyz[j] - 2.0 * pa_xy[j] * pc_xyz[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_z[j] - pc_xxz[j] * pa_y[j] * pb_y[j] - pc_xxy[j] * pa_y[j] * pb_z[j] - pc_xxy[j] * pb_yz[j]);

                t_xxy_yz[j] += fl_s_0_0_4 * (0.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] + pc_xxyz[j] * pa_y[j] + pc_xxyz[j] * pb_y[j] + pc_xxyy[j] * pb_z[j]);

                t_xxy_yz[j] += -fl_s_0_0_5 * pc_xxyyz[j];

                t_xxy_zz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_y[j] + 0.5 * pa_xxy[j] * fl1_fx + 0.5 * fl1_fx * pa_y[j] * pb_zz[j] + pa_xxy[j] * pb_zz[j]);

                t_xxy_zz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] - 0.25 * fl2_fx * pc_y[j] - 0.5 * pa_xxy[j] * fl1_fx - 0.5 * pa_xx[j] * pc_y[j] * fl1_fx - pa_xy[j] * pc_x[j] * fl1_fx - fl1_fx * pa_y[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pa_y[j] * pb_zz[j] - 2.0 * pa_xxy[j] * pb_z[j] * pc_z[j] - pa_xx[j] * pc_y[j] * pb_zz[j] - 2.0 * pa_xy[j] * pc_x[j] * pb_zz[j]);

                t_xxy_zz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pa_y[j] + 0.5 * pa_xx[j] * pc_y[j] * fl1_fx + pa_xy[j] * pc_x[j] * fl1_fx + pa_x[j] * pc_xy[j] * fl1_fx + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] + fl1_fx * pc_yz[j] * pb_z[j] + fl1_fx * pa_y[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_zz[j] + pa_xxy[j] * pc_zz[j] + 2.0 * pa_xx[j] * pc_yz[j] * pb_z[j] + 4.0 * pa_xy[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_zz[j] + pc_xx[j] * pa_y[j] * pb_zz[j]);

                t_xxy_zz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * fl1_fx * pc_yzz[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] - fl1_fx * pc_yz[j] * pb_z[j] - pa_xx[j] * pc_yzz[j] - 2.0 * pa_xy[j] * pc_xzz[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_y[j] * pb_z[j] - pc_xxy[j] * pb_zz[j]);

                t_xxy_zz[j] += fl_s_0_0_4 * (0.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yzz[j] + 2.0 * pa_x[j] * pc_xyzz[j] + pc_xxzz[j] * pa_y[j] + 2.0 * pc_xxyz[j] * pb_z[j]);

                t_xxy_zz[j] += -fl_s_0_0_5 * pc_xxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_12_15(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (12,15)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(19 * idx + 3);

            auto pa_xz = paDistances.data(19 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(19 * idx + 11);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(55 * idx + 19);

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(55 * idx + 36);

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxxzz = pcDistances.data(55 * idx + 39);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xxz_xx = primBuffer.data(60 * idx + 12);

            auto t_xxz_xy = primBuffer.data(60 * idx + 13);

            auto t_xxz_xz = primBuffer.data(60 * idx + 14);

            // Batch of Integrals (12,15)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xz, pa_z, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxxzz, pc_xxy, \
                                     pc_xxyz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xz, pc_xzz, pc_y, pc_yz, pc_z, pc_zz, s_0_0_0, \
                                     s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xxz_xx, t_xxz_xy, t_xxz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxz_xx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] + 0.5 * pa_xxz[j] * fl1_fx + 2.0 * pa_xz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pb_xx[j] + pa_xxz[j] * pb_xx[j]);

                t_xxz_xx[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * fl2_fx * pa_z[j] - 0.5 * pa_xxz[j] * fl1_fx - 0.5 * pa_xx[j] * pc_z[j] * fl1_fx - 3.0 * pa_xz[j] * pc_x[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pc_z[j] * pb_x[j] - 2.0 * pa_xz[j] * fl1_fx * pb_x[j] - 3.0 * pc_x[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pc_z[j] * pb_xx[j] - 0.5 * fl1_fx * pa_z[j] * pb_xx[j] - 2.0 * pa_xxz[j] * pb_x[j] * pc_x[j] - pa_xx[j] * pc_z[j] * pb_xx[j] - 2.0 * pa_xz[j] * pc_x[j] * pb_xx[j]);

                t_xxz_xx[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pa_z[j] + 0.5 * pa_xx[j] * pc_z[j] * fl1_fx + 3.0 * pa_xz[j] * pc_x[j] * fl1_fx + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pc_z[j] * pb_x[j] + 3.0 * pc_xx[j] * pa_z[j] * fl1_fx + 3.0 * pc_xz[j] * fl1_fx * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pc_z[j] * pb_xx[j] + pa_xxz[j] * pc_xx[j] + 2.0 * pa_xx[j] * pc_xz[j] * pb_x[j] + 4.0 * pa_xz[j] * pc_xx[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xx[j] + pc_xx[j] * pa_z[j] * pb_xx[j]);

                t_xxz_xx[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx - 3.0 * pc_xx[j] * pa_z[j] * fl1_fx - 3.0 * pc_xxz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_x[j] - pa_xx[j] * pc_xxz[j] - 2.0 * pa_xz[j] * pc_xxx[j] - 4.0 * pa_x[j] * pc_xxz[j] * pb_x[j] - 2.0 * pc_xxx[j] * pa_z[j] * pb_x[j] - pc_xxz[j] * pb_xx[j]);

                t_xxz_xx[j] += fl_s_0_0_4 * (3.0 * pc_xxz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxxz[j] + pc_xxxx[j] * pa_z[j] + 2.0 * pc_xxxz[j] * pb_x[j]);

                t_xxz_xx[j] += -fl_s_0_0_5 * pc_xxxxz[j];

                t_xxz_xy[j] = fl_s_0_0_0 * (pa_xz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pb_xy[j] + pa_xxz[j] * pb_xy[j]);

                t_xxz_xy[j] += fl_s_0_0_1 * (-pa_xz[j] * fl1_fx * pc_y[j] - pa_x[j] * fl1_fx * pc_z[j] * pb_y[j] - pa_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_xy[j] - 0.5 * fl1_fx * pa_z[j] * pb_xy[j] - pa_xxz[j] * pb_x[j] * pc_y[j] - pa_xxz[j] * pc_x[j] * pb_y[j] - pa_xx[j] * pc_z[j] * pb_xy[j] - 2.0 * pa_xz[j] * pc_x[j] * pb_xy[j]);

                t_xxz_xy[j] += fl_s_0_0_2 * (pa_x[j] * fl1_fx * pc_yz[j] + pa_xz[j] * fl1_fx * pc_y[j] + pa_x[j] * fl1_fx * pc_z[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pc_yz[j] * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_xy[j] + pa_xxz[j] * pc_xy[j] + pa_xx[j] * pc_yz[j] * pb_x[j] + pa_xx[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xz[j] * pc_xx[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xy[j] + pc_xx[j] * pa_z[j] * pb_xy[j]);

                t_xxz_xy[j] += fl_s_0_0_3 * (-pa_x[j] * fl1_fx * pc_yz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yz[j] * pb_x[j] - pa_xx[j] * pc_xyz[j] - 2.0 * pa_xz[j] * pc_xxy[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxz[j] * pb_y[j] - pc_xxy[j] * pa_z[j] * pb_x[j] - pc_xxx[j] * pa_z[j] * pb_y[j] - pc_xxz[j] * pb_xy[j]);

                t_xxz_xy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxyz[j] + pc_xxxy[j] * pa_z[j] + pc_xxyz[j] * pb_x[j] + pc_xxxz[j] * pb_y[j]);

                t_xxz_xy[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_xxz_xz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * fl1_fx * pb_x[j] + pa_xz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_xz[j] + pa_xxz[j] * pb_xz[j]);

                t_xxz_xz[j] += fl_s_0_0_1 * (-pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pb_x[j] - 0.5 * pa_xx[j] * fl1_fx * pc_x[j] - 0.5 * pa_xx[j] * fl1_fx * pb_x[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_x[j] - pa_xz[j] * fl1_fx * pc_z[j] - pa_x[j] * fl1_fx * pc_z[j] * pb_z[j] - pa_xz[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_xz[j] - 0.5 * fl1_fx * pa_z[j] * pb_xz[j] - pa_xxz[j] * pb_x[j] * pc_z[j] - pa_xxz[j] * pc_x[j] * pb_z[j] - pa_xx[j] * pc_z[j] * pb_xz[j] - 2.0 * pa_xz[j] * pc_x[j] * pb_xz[j]);

                t_xxz_xz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_xx[j] * fl1_fx * pc_x[j] + pa_x[j] * pc_xx[j] * fl1_fx + pa_x[j] * pc_x[j] * fl1_fx * pb_x[j] + pa_x[j] * fl1_fx * pc_zz[j] + pa_xz[j] * fl1_fx * pc_z[j] + pa_x[j] * fl1_fx * pc_z[j] * pb_z[j] + 0.5 * pc_xx[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pa_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_xz[j] + pa_xxz[j] * pc_xz[j] + pa_xx[j] * pc_zz[j] * pb_x[j] + pa_xx[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_xz[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xz[j] * pc_xx[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xz[j] + pc_xx[j] * pa_z[j] * pb_xz[j]);

                t_xxz_xz[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - pa_x[j] * pc_xx[j] * fl1_fx - pa_x[j] * fl1_fx * pc_zz[j] - 0.5 * pc_xxx[j] * fl1_fx - 0.5 * pc_xx[j] * fl1_fx * pb_x[j] - 1.5 * pc_xzz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pa_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_x[j] - pa_xx[j] * pc_xzz[j] - 2.0 * pa_xz[j] * pc_xxz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xxz[j] * pb_z[j] - pc_xxz[j] * pa_z[j] * pb_x[j] - pc_xxx[j] * pa_z[j] * pb_z[j] - pc_xxz[j] * pb_xz[j]);

                t_xxz_xz[j] += fl_s_0_0_4 * (0.5 * pc_xxx[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx + 2.0 * pa_x[j] * pc_xxzz[j] + pc_xxxz[j] * pa_z[j] + pc_xxzz[j] * pb_x[j] + pc_xxxz[j] * pb_z[j]);

                t_xxz_xz[j] += -fl_s_0_0_5 * pc_xxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_15_18(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (15,18)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(19 * idx + 3);

            auto pa_xz = paDistances.data(19 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(19 * idx + 11);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xxzzz = pcDistances.data(55 * idx + 43);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xxz_yy = primBuffer.data(60 * idx + 15);

            auto t_xxz_yz = primBuffer.data(60 * idx + 16);

            auto t_xxz_zz = primBuffer.data(60 * idx + 17);

            // Batch of Integrals (15,18)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xz, pa_z, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xx, \
                                     pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, \
                                     pc_xyy, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yz, \
                                     pc_yzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     t_xxz_yy, t_xxz_yz, t_xxz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxz_yy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * pa_xxz[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pb_yy[j] + pa_xxz[j] * pb_yy[j]);

                t_xxz_yy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.25 * fl2_fx * pc_z[j] - 0.5 * pa_xxz[j] * fl1_fx - 0.5 * pa_xx[j] * pc_z[j] * fl1_fx - pa_xz[j] * pc_x[j] * fl1_fx - fl1_fx * pa_z[j] * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_yy[j] - 0.5 * fl1_fx * pa_z[j] * pb_yy[j] - 2.0 * pa_xxz[j] * pb_y[j] * pc_y[j] - pa_xx[j] * pc_z[j] * pb_yy[j] - 2.0 * pa_xz[j] * pc_x[j] * pb_yy[j]);

                t_xxz_yy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * pa_xx[j] * pc_z[j] * fl1_fx + pa_xz[j] * pc_x[j] * fl1_fx + pa_x[j] * pc_xz[j] * fl1_fx + 0.5 * pc_xx[j] * pa_z[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pc_yy[j] + fl1_fx * pc_yz[j] * pb_y[j] + fl1_fx * pa_z[j] * pb_y[j] * pc_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_yy[j] + pa_xxz[j] * pc_yy[j] + 2.0 * pa_xx[j] * pc_yz[j] * pb_y[j] + 4.0 * pa_xz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_yy[j] + pc_xx[j] * pa_z[j] * pb_yy[j]);

                t_xxz_yy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - pa_x[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xx[j] * pa_z[j] * fl1_fx - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyz[j] - 0.5 * fl1_fx * pa_z[j] * pc_yy[j] - fl1_fx * pc_yz[j] * pb_y[j] - pa_xx[j] * pc_yyz[j] - 2.0 * pa_xz[j] * pc_xyy[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_y[j] - 2.0 * pc_xxy[j] * pa_z[j] * pb_y[j] - pc_xxz[j] * pb_yy[j]);

                t_xxz_yy[j] += fl_s_0_0_4 * (0.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] + pc_xxyy[j] * pa_z[j] + 2.0 * pc_xxyz[j] * pb_y[j]);

                t_xxz_yy[j] += -fl_s_0_0_5 * pc_xxyyz[j];

                t_xxz_yz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_y[j] + 0.5 * pa_xx[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pb_yz[j] + pa_xxz[j] * pb_yz[j]);

                t_xxz_yz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * fl2_fx * pb_y[j] - 0.5 * pa_xx[j] * fl1_fx * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pb_y[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_z[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_yz[j] - 0.5 * fl1_fx * pa_z[j] * pb_yz[j] - pa_xxz[j] * pb_y[j] * pc_z[j] - pa_xxz[j] * pc_y[j] * pb_z[j] - pa_xx[j] * pc_z[j] * pb_yz[j] - 2.0 * pa_xz[j] * pc_x[j] * pb_yz[j]);

                t_xxz_yz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_xx[j] * fl1_fx * pc_y[j] + pa_x[j] * pc_xy[j] * fl1_fx + pa_x[j] * pc_x[j] * fl1_fx * pb_y[j] + 0.5 * pc_xx[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pc_yz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_y[j] * pb_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_yz[j] + pa_xxz[j] * pc_yz[j] + pa_xx[j] * pc_zz[j] * pb_y[j] + pa_xx[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_xz[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_yz[j] + pc_xx[j] * pa_z[j] * pb_yz[j]);

                t_xxz_yz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_yzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_yz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yz[j] * pb_z[j] - pa_xx[j] * pc_yzz[j] - 2.0 * pa_xz[j] * pc_xyz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_z[j] - pc_xxz[j] * pa_z[j] * pb_y[j] - pc_xxy[j] * pa_z[j] * pb_z[j] - pc_xxz[j] * pb_yz[j]);

                t_xxz_yz[j] += fl_s_0_0_4 * (0.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yzz[j] + 2.0 * pa_x[j] * pc_xyzz[j] + pc_xxyz[j] * pa_z[j] + pc_xxzz[j] * pb_y[j] + pc_xxyz[j] * pb_z[j]);

                t_xxz_yz[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_xxz_zz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 0.5 * pa_xxz[j] * fl1_fx + pa_xx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_zz[j] + pa_xxz[j] * pb_zz[j]);

                t_xxz_zz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - fl2_fx * pb_z[j] - 0.5 * pa_xxz[j] * fl1_fx - 1.5 * pa_xx[j] * pc_z[j] * fl1_fx - pa_xx[j] * fl1_fx * pb_z[j] - pa_xz[j] * pc_x[j] * fl1_fx - 2.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] - fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_xxz[j] * pb_z[j] * pc_z[j] - pa_xx[j] * pc_z[j] * pb_zz[j] - 2.0 * pa_xz[j] * pc_x[j] * pb_zz[j]);

                t_xxz_zz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 1.5 * pa_xx[j] * pc_z[j] * fl1_fx + pa_xz[j] * pc_x[j] * fl1_fx + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx + 2.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * pc_xx[j] * pa_z[j] * fl1_fx + pc_xx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_zz[j] + fl1_fx * pc_zz[j] * pb_z[j] + fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_zz[j] + pa_xxz[j] * pc_zz[j] + 2.0 * pa_xx[j] * pc_zz[j] * pb_z[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_zz[j] + pc_xx[j] * pa_z[j] * pb_zz[j]);

                t_xxz_zz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx - 0.5 * pc_xx[j] * pa_z[j] * fl1_fx - 1.5 * pc_xxz[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_zzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_zz[j] - fl1_fx * pc_zz[j] * pb_z[j] - pa_xx[j] * pc_zzz[j] - 2.0 * pa_xz[j] * pc_xzz[j] - 4.0 * pa_x[j] * pc_xzz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_z[j] - pc_xxz[j] * pb_zz[j]);

                t_xxz_zz[j] += fl_s_0_0_4 * (1.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] + pc_xxzz[j] * pa_z[j] + 2.0 * pc_xxzz[j] * pb_z[j]);

                t_xxz_zz[j] += -fl_s_0_0_5 * pc_xxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_18_21(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (18,21)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_y = paDistances.data(19 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(19 * idx + 4);

            auto pa_yy = paDistances.data(19 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(19 * idx + 12);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(55 * idx + 37);

            auto pc_xxyyy = pcDistances.data(55 * idx + 40);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xyy_xx = primBuffer.data(60 * idx + 18);

            auto t_xyy_xy = primBuffer.data(60 * idx + 19);

            auto t_xyy_xz = primBuffer.data(60 * idx + 20);

            // Batch of Integrals (18,21)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_y, pa_yy, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyz, pc_xxyz, \
                                     pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyz, \
                                     pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xyy_xx, \
                                     t_xyy_xy, t_xyy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyy_xx[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + 0.5 * pa_xyy[j] * fl1_fx + fl1_fx * pa_yy[j] * pb_x[j] + 0.5 * pa_x[j] * fl1_fx * pb_xx[j] + pa_xyy[j] * pb_xx[j]);

                t_xyy_xx[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - fl2_fx * pb_x[j] - 0.5 * pa_xyy[j] * fl1_fx - pa_xy[j] * pc_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_yy[j] * fl1_fx - 2.0 * fl1_fx * pa_y[j] * pc_y[j] * pb_x[j] - fl1_fx * pa_yy[j] * pb_x[j] - pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xx[j] - 0.5 * pc_x[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xyy[j] * pb_x[j] * pc_x[j] - 2.0 * pa_xy[j] * pc_y[j] * pb_xx[j] - pc_x[j] * pa_yy[j] * pb_xx[j]);

                t_xyy_xx[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + pa_xy[j] * pc_y[j] * fl1_fx + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx + 1.5 * pc_x[j] * pa_yy[j] * fl1_fx + 3.0 * pc_xy[j] * pa_y[j] * fl1_fx + fl1_fx * pc_yy[j] * pb_x[j] + 2.0 * fl1_fx * pa_y[j] * pc_y[j] * pb_x[j] + 0.5 * pa_x[j] * fl1_fx * pc_xx[j] + pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] + pc_xx[j] * fl1_fx * pb_x[j] + 0.5 * pc_x[j] * fl1_fx * pb_xx[j] + pa_xyy[j] * pc_xx[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_x[j] + pa_x[j] * pc_yy[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_yy[j] * pb_x[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_xx[j]);

                t_xyy_xx[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx - 3.0 * pc_xy[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyy[j] * fl1_fx - fl1_fx * pc_yy[j] * pb_x[j] - 0.5 * pa_x[j] * fl1_fx * pc_xx[j] - 0.5 * pc_xxx[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_x[j] - 2.0 * pa_xy[j] * pc_xxy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_x[j] - pc_xxx[j] * pa_yy[j] - 4.0 * pc_xxy[j] * pa_y[j] * pb_x[j] - pc_xyy[j] * pb_xx[j]);

                t_xyy_xx[j] += fl_s_0_0_4 * (1.5 * pc_xyy[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx + pa_x[j] * pc_xxyy[j] + 2.0 * pc_xxxy[j] * pa_y[j] + 2.0 * pc_xxyy[j] * pb_x[j]);

                t_xyy_xx[j] += -fl_s_0_0_5 * pc_xxxyy[j];

                t_xyy_xy[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_y[j] + 0.25 * fl2_fx * pb_y[j] + pa_xy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yy[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_xy[j] + pa_xyy[j] * pb_xy[j]);

                t_xyy_xy[j] += fl_s_0_0_1 * (-fl2_fx * pa_y[j] - 0.75 * fl2_fx * pc_y[j] - 0.5 * fl2_fx * pb_y[j] - pa_xy[j] * fl1_fx * pc_x[j] - pa_xy[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_x[j] - pc_x[j] * pa_y[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_yy[j] * pc_y[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_y[j] - 0.5 * fl1_fx * pa_yy[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_xy[j] - 0.5 * pc_x[j] * fl1_fx * pb_xy[j] - pa_xyy[j] * pb_x[j] * pc_y[j] - pa_xyy[j] * pc_x[j] * pb_y[j] - 2.0 * pa_xy[j] * pc_y[j] * pb_xy[j] - pc_x[j] * pa_yy[j] * pb_xy[j]);

                t_xyy_xy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.5 * fl2_fx * pa_y[j] + 0.25 * fl2_fx * pb_y[j] + pa_xy[j] * fl1_fx * pc_x[j] + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_x[j] + pc_xx[j] * pa_y[j] * fl1_fx + pc_x[j] * pa_y[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pb_x[j] + fl1_fx * pa_y[j] * pc_yy[j] + 0.5 * fl1_fx * pc_yy[j] * pb_y[j] + 0.5 * fl1_fx * pa_yy[j] * pc_y[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pc_xx[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_xy[j] + pa_xyy[j] * pc_xy[j] + 2.0 * pa_xy[j] * pc_yy[j] * pb_x[j] + 2.0 * pa_xy[j] * pc_xy[j] * pb_y[j] + pa_x[j] * pc_yy[j] * pb_xy[j] + pc_xy[j] * pa_yy[j] * pb_x[j] + pc_xx[j] * pa_yy[j] * pb_y[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_xy[j]);

                t_xyy_xy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx - pc_xx[j] * pa_y[j] * fl1_fx - 1.5 * pc_xxy[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_yyy[j] - fl1_fx * pa_y[j] * pc_yy[j] - 0.5 * fl1_fx * pc_yy[j] * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pb_y[j] - 2.0 * pa_xy[j] * pc_xyy[j] - pa_x[j] * pc_yyy[j] * pb_x[j] - pa_x[j] * pc_xyy[j] * pb_y[j] - pc_xxy[j] * pa_yy[j] - 2.0 * pc_xyy[j] * pa_y[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_y[j] - pc_xyy[j] * pb_xy[j]);

                t_xyy_xy[j] += fl_s_0_0_4 * (1.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yyy[j] + pa_x[j] * pc_xyyy[j] + 2.0 * pc_xxyy[j] * pa_y[j] + pc_xyyy[j] * pb_x[j] + pc_xxyy[j] * pb_y[j]);

                t_xyy_xy[j] += -fl_s_0_0_5 * pc_xxyyy[j];

                t_xyy_xz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_z[j] + 0.5 * fl1_fx * pa_yy[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_xz[j] + pa_xyy[j] * pb_xz[j]);

                t_xyy_xz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - 0.5 * fl1_fx * pa_yy[j] * pc_z[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_yy[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_xz[j] - 0.5 * pc_x[j] * fl1_fx * pb_xz[j] - pa_xyy[j] * pb_x[j] * pc_z[j] - pa_xyy[j] * pc_x[j] * pb_z[j] - 2.0 * pa_xy[j] * pc_y[j] * pb_xz[j] - pc_x[j] * pa_yy[j] * pb_xz[j]);

                t_xyy_xz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pb_z[j] + fl1_fx * pa_y[j] * pc_yz[j] + 0.5 * fl1_fx * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pa_yy[j] * pc_z[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_xz[j] + 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_xz[j] + pa_xyy[j] * pc_xz[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_xy[j] * pc_xy[j] * pb_z[j] + pa_x[j] * pc_yy[j] * pb_xz[j] + pc_xz[j] * pa_yy[j] * pb_x[j] + pc_xx[j] * pa_yy[j] * pb_z[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_xz[j]);

                t_xyy_xz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl1_fx * pc_yyz[j] - fl1_fx * pa_y[j] * pc_yz[j] - 0.5 * fl1_fx * pc_yy[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xz[j] - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * pc_xz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pb_z[j] - 2.0 * pa_xy[j] * pc_xyz[j] - pa_x[j] * pc_yyz[j] * pb_x[j] - pa_x[j] * pc_xyy[j] * pb_z[j] - pc_xxz[j] * pa_yy[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_z[j] - pc_xyy[j] * pb_xz[j]);

                t_xyy_xz[j] += fl_s_0_0_4 * (0.5 * fl1_fx * pc_yyz[j] + 0.5 * pc_xxz[j] * fl1_fx + pa_x[j] * pc_xyyz[j] + 2.0 * pc_xxyz[j] * pa_y[j] + pc_xyyz[j] * pb_x[j] + pc_xxyy[j] * pb_z[j]);

                t_xyy_xz[j] += -fl_s_0_0_5 * pc_xxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_21_24(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (21,24)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_y = paDistances.data(19 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(19 * idx + 4);

            auto pa_yy = paDistances.data(19 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(19 * idx + 12);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(55 * idx + 44);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xyy_yy = primBuffer.data(60 * idx + 21);

            auto t_xyy_yz = primBuffer.data(60 * idx + 22);

            auto t_xyy_zz = primBuffer.data(60 * idx + 23);

            // Batch of Integrals (21,24)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_y, pa_yy, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, \
                                     pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xyy_yy, t_xyy_yz, \
                                     t_xyy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyy_yy[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx + 0.5 * pa_xyy[j] * fl1_fx + 2.0 * pa_xy[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_yy[j] + pa_xyy[j] * pb_yy[j]);

                t_xyy_yy[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * pa_xyy[j] * fl1_fx - 3.0 * pa_xy[j] * pc_y[j] * fl1_fx - 2.0 * pa_xy[j] * fl1_fx * pb_y[j] - 3.0 * pa_x[j] * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * pa_yy[j] * fl1_fx - 2.0 * pc_x[j] * pa_y[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_yy[j] - 0.5 * pc_x[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xyy[j] * pb_y[j] * pc_y[j] - 2.0 * pa_xy[j] * pc_y[j] * pb_yy[j] - pc_x[j] * pa_yy[j] * pb_yy[j]);

                t_xyy_yy[j] += fl_s_0_0_2 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 3.0 * pa_xy[j] * pc_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_yy[j] * fl1_fx + 3.0 * pa_x[j] * pc_y[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * pa_yy[j] * fl1_fx + 3.0 * pc_xy[j] * pa_y[j] * fl1_fx + 2.0 * pc_x[j] * pa_y[j] * fl1_fx * pb_y[j] + 3.0 * pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_yy[j] + pa_xyy[j] * pc_yy[j] + 4.0 * pa_xy[j] * pc_yy[j] * pb_y[j] + pa_x[j] * pc_yy[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_yy[j] * pb_y[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_yy[j]);

                t_xyy_yy[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 3.0 * pa_x[j] * pc_yy[j] * fl1_fx - 3.0 * pc_xy[j] * pa_y[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_y[j] - 2.0 * pa_xy[j] * pc_yyy[j] - 2.0 * pa_x[j] * pc_yyy[j] * pb_y[j] - pc_xyy[j] * pa_yy[j] - 4.0 * pc_xyy[j] * pa_y[j] * pb_y[j] - pc_xyy[j] * pb_yy[j]);

                t_xyy_yy[j] += fl_s_0_0_4 * (3.0 * pc_xyy[j] * fl1_fx + pa_x[j] * pc_yyyy[j] + 2.0 * pc_xyyy[j] * pa_y[j] + 2.0 * pc_xyyy[j] * pb_y[j]);

                t_xyy_yy[j] += -fl_s_0_0_5 * pc_xyyyy[j];

                t_xyy_yz[j] = fl_s_0_0_0 * (pa_xy[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_yz[j] + pa_xyy[j] * pb_yz[j]);

                t_xyy_yz[j] += fl_s_0_0_1 * (-pa_xy[j] * fl1_fx * pc_z[j] - pa_xy[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] - pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * fl1_fx * pb_yz[j] - pa_xyy[j] * pb_y[j] * pc_z[j] - pa_xyy[j] * pc_y[j] * pb_z[j] - 2.0 * pa_xy[j] * pc_y[j] * pb_yz[j] - pc_x[j] * pa_yy[j] * pb_yz[j]);

                t_xyy_yz[j] += fl_s_0_0_2 * (pa_xy[j] * fl1_fx * pc_z[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] + pc_xz[j] * pa_y[j] * fl1_fx + pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_yz[j] + pa_xyy[j] * pc_yz[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_yy[j] * pb_z[j] + pa_x[j] * pc_yy[j] * pb_yz[j] + pc_xz[j] * pa_yy[j] * pb_y[j] + pc_xy[j] * pa_yy[j] * pb_z[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_yz[j]);

                t_xyy_yz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - pc_xz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_y[j] - 2.0 * pa_xy[j] * pc_yyz[j] - pa_x[j] * pc_yyz[j] * pb_y[j] - pa_x[j] * pc_yyy[j] * pb_z[j] - pc_xyz[j] * pa_yy[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_y[j] - 2.0 * pc_xyy[j] * pa_y[j] * pb_z[j] - pc_xyy[j] * pb_yz[j]);

                t_xyy_yz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yyyz[j] + 2.0 * pc_xyyz[j] * pa_y[j] + pc_xyyz[j] * pb_y[j] + pc_xyyy[j] * pb_z[j]);

                t_xyy_yz[j] += -fl_s_0_0_5 * pc_xyyyz[j];

                t_xyy_zz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pa_xyy[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_zz[j] + pa_xyy[j] * pb_zz[j]);

                t_xyy_zz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx - 0.5 * pa_xyy[j] * fl1_fx - pa_xy[j] * pc_y[j] * fl1_fx - 0.5 * pc_x[j] * pa_yy[j] * fl1_fx - pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_zz[j] - 0.5 * pc_x[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xyy[j] * pb_z[j] * pc_z[j] - 2.0 * pa_xy[j] * pc_y[j] * pb_zz[j] - pc_x[j] * pa_yy[j] * pb_zz[j]);

                t_xyy_zz[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx + pa_xy[j] * pc_y[j] * fl1_fx + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx + 0.5 * pc_x[j] * pa_yy[j] * fl1_fx + pc_xy[j] * pa_y[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] + pa_x[j] * fl1_fx * pb_z[j] * pc_z[j] + pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_zz[j] + pa_xyy[j] * pc_zz[j] + 4.0 * pa_xy[j] * pc_yz[j] * pb_z[j] + pa_x[j] * pc_yy[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_yy[j] * pb_z[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_zz[j]);

                t_xyy_zz[j] += fl_s_0_0_3 * (-0.25 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx - pc_xy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] - 0.5 * pc_xzz[j] * fl1_fx - pc_xz[j] * fl1_fx * pb_z[j] - 2.0 * pa_xy[j] * pc_yzz[j] - 2.0 * pa_x[j] * pc_yyz[j] * pb_z[j] - pc_xzz[j] * pa_yy[j] - 4.0 * pc_xyz[j] * pa_y[j] * pb_z[j] - pc_xyy[j] * pb_zz[j]);

                t_xyy_zz[j] += fl_s_0_0_4 * (0.5 * pc_xyy[j] * fl1_fx + 0.5 * pc_xzz[j] * fl1_fx + pa_x[j] * pc_yyzz[j] + 2.0 * pc_xyzz[j] * pa_y[j] + 2.0 * pc_xyyz[j] * pb_z[j]);

                t_xyy_zz[j] += -fl_s_0_0_5 * pc_xyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_24_27(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (24,27)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_y = paDistances.data(19 * idx + 1);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(19 * idx + 4);

            auto pa_xz = paDistances.data(19 * idx + 5);

            auto pa_yz = paDistances.data(19 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(19 * idx + 13);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(55 * idx + 20);

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(55 * idx + 38);

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xyz_xx = primBuffer.data(60 * idx + 24);

            auto t_xyz_xy = primBuffer.data(60 * idx + 25);

            auto t_xyz_xz = primBuffer.data(60 * idx + 26);

            // Batch of Integrals (24,27)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xy, pb_xz, pb_y, \
                                     pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, pc_xxyyz, \
                                     pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, t_xyz_xx, t_xyz_xy, t_xyz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyz_xx[j] = fl_s_0_0_0 * (0.5 * pa_xyz[j] * fl1_fx + fl1_fx * pa_yz[j] * pb_x[j] + pa_xyz[j] * pb_xx[j]);

                t_xyz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_xyz[j] * fl1_fx - 0.5 * pa_xy[j] * pc_z[j] * fl1_fx - 0.5 * pa_xz[j] * pc_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_yz[j] * fl1_fx - fl1_fx * pa_y[j] * pc_z[j] * pb_x[j] - fl1_fx * pc_y[j] * pa_z[j] * pb_x[j] - fl1_fx * pa_yz[j] * pb_x[j] - 2.0 * pa_xyz[j] * pb_x[j] * pc_x[j] - pa_xy[j] * pc_z[j] * pb_xx[j] - pa_xz[j] * pc_y[j] * pb_xx[j] - pc_x[j] * pa_yz[j] * pb_xx[j]);

                t_xyz_xx[j] += fl_s_0_0_2 * (0.5 * pa_xy[j] * pc_z[j] * fl1_fx + 0.5 * pa_xz[j] * pc_y[j] * fl1_fx + 0.5 * pa_x[j] * pc_yz[j] * fl1_fx + 1.5 * pc_x[j] * pa_yz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx + fl1_fx * pc_yz[j] * pb_x[j] + fl1_fx * pa_y[j] * pc_z[j] * pb_x[j] + fl1_fx * pc_y[j] * pa_z[j] * pb_x[j] + pa_xyz[j] * pc_xx[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_x[j] + pa_x[j] * pc_yz[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_yz[j] * pb_x[j] + pc_xz[j] * pa_y[j] * pb_xx[j] + pc_xy[j] * pa_z[j] * pb_xx[j]);

                t_xyz_xx[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * pc_yz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - fl1_fx * pc_yz[j] * pb_x[j] - pa_xy[j] * pc_xxz[j] - pa_xz[j] * pc_xxy[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_x[j] - pc_xxx[j] * pa_yz[j] - 2.0 * pc_xxz[j] * pa_y[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_z[j] * pb_x[j] - pc_xyz[j] * pb_xx[j]);

                t_xyz_xx[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_xxyz[j] + pc_xxxz[j] * pa_y[j] + pc_xxxy[j] * pa_z[j] + 2.0 * pc_xxyz[j] * pb_x[j]);

                t_xyz_xx[j] += -fl_s_0_0_5 * pc_xxxyz[j];

                t_xyz_xy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * pa_xz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yz[j] * pb_y[j] + pa_xyz[j] * pb_xy[j]);

                t_xyz_xy[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pa_z[j] - 0.5 * pa_xz[j] * fl1_fx * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xz[j] * fl1_fx * pb_x[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_yz[j] * pc_y[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_y[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_yz[j] * pb_y[j] - pa_xyz[j] * pb_x[j] * pc_y[j] - pa_xyz[j] * pc_x[j] * pb_y[j] - pa_xy[j] * pc_z[j] * pb_xy[j] - pa_xz[j] * pc_y[j] * pb_xy[j] - pc_x[j] * pa_yz[j] * pb_xy[j]);

                t_xyz_xy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_xz[j] + 0.5 * pa_xz[j] * fl1_fx * pc_x[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pa_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_x[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pa_y[j] * pc_yz[j] + 0.5 * fl1_fx * pc_yy[j] * pa_z[j] + 0.5 * fl1_fx * pc_yz[j] * pb_y[j] + 0.5 * fl1_fx * pa_yz[j] * pc_y[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_y[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_y[j] + pa_xyz[j] * pc_xy[j] + pa_xy[j] * pc_yz[j] * pb_x[j] + pa_xy[j] * pc_xz[j] * pb_y[j] + pa_xz[j] * pc_yy[j] * pb_x[j] + pa_xz[j] * pc_xy[j] * pb_y[j] + pa_x[j] * pc_yz[j] * pb_xy[j] + pc_xy[j] * pa_yz[j] * pb_x[j] + pc_xx[j] * pa_yz[j] * pb_y[j] + pc_xz[j] * pa_y[j] * pb_xy[j] + pc_xy[j] * pa_z[j] * pb_xy[j]);

                t_xyz_xy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xz[j] - 0.5 * pc_xxz[j] * fl1_fx - 0.5 * pc_xx[j] * fl1_fx * pa_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_yyz[j] - 0.5 * fl1_fx * pa_y[j] * pc_yz[j] - 0.5 * fl1_fx * pc_yy[j] * pa_z[j] - 0.5 * fl1_fx * pc_yz[j] * pb_y[j] - pa_xy[j] * pc_xyz[j] - pa_xz[j] * pc_xyy[j] - pa_x[j] * pc_yyz[j] * pb_x[j] - pa_x[j] * pc_xyz[j] * pb_y[j] - pc_xxy[j] * pa_yz[j] - pc_xyz[j] * pa_y[j] * pb_x[j] - pc_xxz[j] * pa_y[j] * pb_y[j] - pc_xyy[j] * pa_z[j] * pb_x[j] - pc_xxy[j] * pa_z[j] * pb_y[j] - pc_xyz[j] * pb_xy[j]);

                t_xyz_xy[j] += fl_s_0_0_4 * (0.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyz[j] + pa_x[j] * pc_xyyz[j] + pc_xxyz[j] * pa_y[j] + pc_xxyy[j] * pa_z[j] + pc_xyyz[j] * pb_x[j] + pc_xxyz[j] * pb_y[j]);

                t_xyz_xy[j] += -fl_s_0_0_5 * pc_xxyyz[j];

                t_xyz_xz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_y[j] + 0.5 * pa_xy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yz[j] * pb_z[j] + pa_xyz[j] * pb_xz[j]);

                t_xyz_xz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] - 0.25 * fl2_fx * pc_y[j] - 0.5 * pa_xy[j] * fl1_fx * pc_x[j] - 0.5 * pa_xy[j] * fl1_fx * pb_x[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_x[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_yz[j] * pc_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_yz[j] * pb_z[j] - pa_xyz[j] * pb_x[j] * pc_z[j] - pa_xyz[j] * pc_x[j] * pb_z[j] - pa_xy[j] * pc_z[j] * pb_xz[j] - pa_xz[j] * pc_y[j] * pb_xz[j] - pc_x[j] * pa_yz[j] * pb_xz[j]);

                t_xyz_xz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pa_y[j] + 0.5 * pa_xy[j] * fl1_fx * pc_x[j] + 0.5 * pa_x[j] * pc_xy[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_x[j] + 0.5 * pc_xy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] + 0.5 * fl1_fx * pc_yz[j] * pa_z[j] + 0.5 * fl1_fx * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pa_yz[j] * pc_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_z[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_z[j] + pa_xyz[j] * pc_xz[j] + pa_xy[j] * pc_zz[j] * pb_x[j] + pa_xy[j] * pc_xz[j] * pb_z[j] + pa_xz[j] * pc_yz[j] * pb_x[j] + pa_xz[j] * pc_xy[j] * pb_z[j] + pa_x[j] * pc_yz[j] * pb_xz[j] + pc_xz[j] * pa_yz[j] * pb_x[j] + pc_xx[j] * pa_yz[j] * pb_z[j] + pc_xz[j] * pa_y[j] * pb_xz[j] + pc_xy[j] * pa_z[j] * pb_xz[j]);

                t_xyz_xz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * pa_x[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * pc_xy[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_yzz[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] - 0.5 * fl1_fx * pc_yz[j] * pa_z[j] - 0.5 * fl1_fx * pc_yz[j] * pb_z[j] - pa_xy[j] * pc_xzz[j] - pa_xz[j] * pc_xyz[j] - pa_x[j] * pc_yzz[j] * pb_x[j] - pa_x[j] * pc_xyz[j] * pb_z[j] - pc_xxz[j] * pa_yz[j] - pc_xzz[j] * pa_y[j] * pb_x[j] - pc_xxz[j] * pa_y[j] * pb_z[j] - pc_xyz[j] * pa_z[j] * pb_x[j] - pc_xxy[j] * pa_z[j] * pb_z[j] - pc_xyz[j] * pb_xz[j]);

                t_xyz_xz[j] += fl_s_0_0_4 * (0.5 * pc_xxy[j] * fl1_fx + 0.5 * fl1_fx * pc_yzz[j] + pa_x[j] * pc_xyzz[j] + pc_xxzz[j] * pa_y[j] + pc_xxyz[j] * pa_z[j] + pc_xyzz[j] * pb_x[j] + pc_xxyz[j] * pb_z[j]);

                t_xyz_xz[j] += -fl_s_0_0_5 * pc_xxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_27_30(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (27,30)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_y = paDistances.data(19 * idx + 1);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(19 * idx + 4);

            auto pa_xz = paDistances.data(19 * idx + 5);

            auto pa_yz = paDistances.data(19 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(19 * idx + 13);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xyz_yy = primBuffer.data(60 * idx + 27);

            auto t_xyz_yz = primBuffer.data(60 * idx + 28);

            auto t_xyz_zz = primBuffer.data(60 * idx + 29);

            // Batch of Integrals (27,30)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, pb_y, pb_yy, pb_yz, pb_z, pb_zz, \
                                     pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, \
                                     pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyz, pc_yyzz, pc_yz, \
                                     pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_xyz_yy, t_xyz_yz, t_xyz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyz_yy[j] = fl_s_0_0_0 * (0.5 * pa_xyz[j] * fl1_fx + pa_xz[j] * fl1_fx * pb_y[j] + pa_xyz[j] * pb_yy[j]);

                t_xyz_yy[j] += fl_s_0_0_1 * (-0.5 * pa_xyz[j] * fl1_fx - 0.5 * pa_xy[j] * pc_z[j] * fl1_fx - 1.5 * pa_xz[j] * pc_y[j] * fl1_fx - pa_x[j] * fl1_fx * pc_z[j] * pb_y[j] - pa_xz[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * pa_yz[j] * fl1_fx - pc_x[j] * fl1_fx * pa_z[j] * pb_y[j] - 2.0 * pa_xyz[j] * pb_y[j] * pc_y[j] - pa_xy[j] * pc_z[j] * pb_yy[j] - pa_xz[j] * pc_y[j] * pb_yy[j] - pc_x[j] * pa_yz[j] * pb_yy[j]);

                t_xyz_yy[j] += fl_s_0_0_2 * (0.5 * pa_xy[j] * pc_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_z[j] * pb_y[j] + 0.5 * pc_x[j] * pa_yz[j] * fl1_fx + 0.5 * pc_xz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx + pc_xz[j] * fl1_fx * pb_y[j] + pc_x[j] * fl1_fx * pa_z[j] * pb_y[j] + pa_xyz[j] * pc_yy[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_xz[j] * pc_yy[j] * pb_y[j] + pa_x[j] * pc_yz[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_y[j] + pc_xz[j] * pa_y[j] * pb_yy[j] + pc_xy[j] * pa_z[j] * pb_yy[j]);

                t_xyz_yy[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - 0.5 * pc_xz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pc_xz[j] * fl1_fx * pb_y[j] - pa_xy[j] * pc_yyz[j] - pa_xz[j] * pc_yyy[j] - 2.0 * pa_x[j] * pc_yyz[j] * pb_y[j] - pc_xyy[j] * pa_yz[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_y[j] - 2.0 * pc_xyy[j] * pa_z[j] * pb_y[j] - pc_xyz[j] * pb_yy[j]);

                t_xyz_yy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yyyz[j] + pc_xyyz[j] * pa_y[j] + pc_xyyy[j] * pa_z[j] + 2.0 * pc_xyyz[j] * pb_y[j]);

                t_xyz_yy[j] += -fl_s_0_0_5 * pc_xyyyz[j];

                t_xyz_yz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pa_xy[j] * fl1_fx * pb_y[j] + 0.5 * pa_xz[j] * fl1_fx * pb_z[j] + pa_xyz[j] * pb_yz[j]);

                t_xyz_yz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx - 0.5 * pa_xy[j] * fl1_fx * pc_y[j] - 0.5 * pa_xy[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * pa_xz[j] * fl1_fx * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_z[j] - pa_xyz[j] * pb_y[j] * pc_z[j] - pa_xyz[j] * pc_y[j] * pb_z[j] - pa_xy[j] * pc_z[j] * pb_yz[j] - pa_xz[j] * pc_y[j] * pb_yz[j] - pc_x[j] * pa_yz[j] * pb_yz[j]);

                t_xyz_yz[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx + 0.5 * pa_xy[j] * fl1_fx * pc_y[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] + 0.5 * pa_xz[j] * fl1_fx * pc_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_z[j] + 0.5 * pc_xy[j] * pa_y[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_y[j] + 0.5 * pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_xz[j] * fl1_fx * pa_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_z[j] + pa_xyz[j] * pc_yz[j] + pa_xy[j] * pc_zz[j] * pb_y[j] + pa_xy[j] * pc_yz[j] * pb_z[j] + pa_xz[j] * pc_yz[j] * pb_y[j] + pa_xz[j] * pc_yy[j] * pb_z[j] + pa_x[j] * pc_yz[j] * pb_yz[j] + pc_xz[j] * pa_yz[j] * pb_y[j] + pc_xy[j] * pa_yz[j] * pb_z[j] + pc_xz[j] * pa_y[j] * pb_yz[j] + pc_xy[j] * pa_z[j] * pb_yz[j]);

                t_xyz_yz[j] += fl_s_0_0_3 * (-0.25 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] - 0.5 * pc_xy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xzz[j] * fl1_fx - 0.5 * pc_xz[j] * fl1_fx * pa_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_z[j] - pa_xy[j] * pc_yzz[j] - pa_xz[j] * pc_yyz[j] - pa_x[j] * pc_yzz[j] * pb_y[j] - pa_x[j] * pc_yyz[j] * pb_z[j] - pc_xyz[j] * pa_yz[j] - pc_xzz[j] * pa_y[j] * pb_y[j] - pc_xyz[j] * pa_y[j] * pb_z[j] - pc_xyz[j] * pa_z[j] * pb_y[j] - pc_xyy[j] * pa_z[j] * pb_z[j] - pc_xyz[j] * pb_yz[j]);

                t_xyz_yz[j] += fl_s_0_0_4 * (0.5 * pc_xyy[j] * fl1_fx + 0.5 * pc_xzz[j] * fl1_fx + pa_x[j] * pc_yyzz[j] + pc_xyzz[j] * pa_y[j] + pc_xyyz[j] * pa_z[j] + pc_xyzz[j] * pb_y[j] + pc_xyyz[j] * pb_z[j]);

                t_xyz_yz[j] += -fl_s_0_0_5 * pc_xyyzz[j];

                t_xyz_zz[j] = fl_s_0_0_0 * (0.5 * pa_xyz[j] * fl1_fx + pa_xy[j] * fl1_fx * pb_z[j] + pa_xyz[j] * pb_zz[j]);

                t_xyz_zz[j] += fl_s_0_0_1 * (-0.5 * pa_xyz[j] * fl1_fx - 1.5 * pa_xy[j] * pc_z[j] * fl1_fx - pa_xy[j] * fl1_fx * pb_z[j] - 0.5 * pa_xz[j] * pc_y[j] * fl1_fx - pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_yz[j] * fl1_fx - pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] - 2.0 * pa_xyz[j] * pb_z[j] * pc_z[j] - pa_xy[j] * pc_z[j] * pb_zz[j] - pa_xz[j] * pc_y[j] * pb_zz[j] - pc_x[j] * pa_yz[j] * pb_zz[j]);

                t_xyz_zz[j] += fl_s_0_0_2 * (1.5 * pa_xy[j] * pc_z[j] * fl1_fx + 0.5 * pa_xz[j] * pc_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + pa_x[j] * pc_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_yz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx + pc_x[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_xy[j] * pa_z[j] * fl1_fx + pc_xy[j] * fl1_fx * pb_z[j] + pa_xyz[j] * pc_zz[j] + 2.0 * pa_xy[j] * pc_zz[j] * pb_z[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_z[j] + pa_x[j] * pc_yz[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_z[j] + pc_xz[j] * pa_y[j] * pb_zz[j] + pc_xy[j] * pa_z[j] * pb_zz[j]);

                t_xyz_zz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx - 0.5 * pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_z[j] - pa_xy[j] * pc_zzz[j] - pa_xz[j] * pc_yzz[j] - 2.0 * pa_x[j] * pc_yzz[j] * pb_z[j] - pc_xzz[j] * pa_yz[j] - 2.0 * pc_xzz[j] * pa_y[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_z[j] - pc_xyz[j] * pb_zz[j]);

                t_xyz_zz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yzzz[j] + pc_xzzz[j] * pa_y[j] + pc_xyzz[j] * pa_z[j] + 2.0 * pc_xyzz[j] * pb_z[j]);

                t_xyz_zz[j] += -fl_s_0_0_5 * pc_xyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_30_33(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (30,33)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(19 * idx + 5);

            auto pa_zz = paDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(19 * idx + 14);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(55 * idx + 9);

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(55 * idx + 21);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(55 * idx + 39);

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xxzzz = pcDistances.data(55 * idx + 43);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xzz_xx = primBuffer.data(60 * idx + 30);

            auto t_xzz_xy = primBuffer.data(60 * idx + 31);

            auto t_xzz_xz = primBuffer.data(60 * idx + 32);

            // Batch of Integrals (30,33)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_z, pa_zz, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxz, pc_xxxzz, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xxzzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xzz_xx, t_xzz_xy, \
                                     t_xzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzz_xx[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + 0.5 * pa_xzz[j] * fl1_fx + fl1_fx * pa_zz[j] * pb_x[j] + 0.5 * pa_x[j] * fl1_fx * pb_xx[j] + pa_xzz[j] * pb_xx[j]);

                t_xzz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - fl2_fx * pb_x[j] - 0.5 * pa_xzz[j] * fl1_fx - pa_xz[j] * pc_z[j] * fl1_fx - 1.5 * pc_x[j] * pa_zz[j] * fl1_fx - 2.0 * fl1_fx * pa_z[j] * pc_z[j] * pb_x[j] - fl1_fx * pa_zz[j] * pb_x[j] - pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xx[j] - 0.5 * pc_x[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xzz[j] * pb_x[j] * pc_x[j] - 2.0 * pa_xz[j] * pc_z[j] * pb_xx[j] - pc_x[j] * pa_zz[j] * pb_xx[j]);

                t_xzz_xx[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] + pa_xz[j] * pc_z[j] * fl1_fx + 0.5 * pa_x[j] * pc_zz[j] * fl1_fx + 1.5 * pc_x[j] * pa_zz[j] * fl1_fx + 3.0 * pc_xz[j] * pa_z[j] * fl1_fx + fl1_fx * pc_zz[j] * pb_x[j] + 2.0 * fl1_fx * pa_z[j] * pc_z[j] * pb_x[j] + 0.5 * pa_x[j] * fl1_fx * pc_xx[j] + pa_x[j] * fl1_fx * pb_x[j] * pc_x[j] + pc_xx[j] * fl1_fx * pb_x[j] + 0.5 * pc_x[j] * fl1_fx * pb_xx[j] + pa_xzz[j] * pc_xx[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_x[j] + pa_x[j] * pc_zz[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_zz[j] * pb_x[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_xx[j]);

                t_xzz_xx[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_zz[j] * fl1_fx - 3.0 * pc_xz[j] * pa_z[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx - fl1_fx * pc_zz[j] * pb_x[j] - 0.5 * pa_x[j] * fl1_fx * pc_xx[j] - 0.5 * pc_xxx[j] * fl1_fx - pc_xx[j] * fl1_fx * pb_x[j] - 2.0 * pa_xz[j] * pc_xxz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_x[j] - pc_xxx[j] * pa_zz[j] - 4.0 * pc_xxz[j] * pa_z[j] * pb_x[j] - pc_xzz[j] * pb_xx[j]);

                t_xzz_xx[j] += fl_s_0_0_4 * (1.5 * pc_xzz[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx + pa_x[j] * pc_xxzz[j] + 2.0 * pc_xxxz[j] * pa_z[j] + 2.0 * pc_xxzz[j] * pb_x[j]);

                t_xzz_xx[j] += -fl_s_0_0_5 * pc_xxxzz[j];

                t_xzz_xy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_y[j] + 0.5 * fl1_fx * pa_zz[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_xy[j] + pa_xzz[j] * pb_xy[j]);

                t_xzz_xy[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * fl2_fx * pb_y[j] - 0.5 * fl1_fx * pa_zz[j] * pc_y[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_zz[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_xy[j] - 0.5 * pc_x[j] * fl1_fx * pb_xy[j] - pa_xzz[j] * pb_x[j] * pc_y[j] - pa_xzz[j] * pc_x[j] * pb_y[j] - 2.0 * pa_xz[j] * pc_z[j] * pb_xy[j] - pc_x[j] * pa_zz[j] * pb_xy[j]);

                t_xzz_xy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_y[j] + 0.25 * fl2_fx * pb_y[j] + fl1_fx * pa_z[j] * pc_yz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pa_zz[j] * pc_y[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_xy[j] + 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pc_xy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_xy[j] + pa_xzz[j] * pc_xy[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_xz[j] * pc_xz[j] * pb_y[j] + pa_x[j] * pc_zz[j] * pb_xy[j] + pc_xy[j] * pa_zz[j] * pb_x[j] + pc_xx[j] * pa_zz[j] * pb_y[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_xy[j]);

                t_xzz_xy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_y[j] - 0.5 * fl1_fx * pc_yzz[j] - fl1_fx * pa_z[j] * pc_yz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_xy[j] - 0.5 * pc_xxy[j] * fl1_fx - 0.5 * pc_xy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pb_y[j] - 2.0 * pa_xz[j] * pc_xyz[j] - pa_x[j] * pc_yzz[j] * pb_x[j] - pa_x[j] * pc_xzz[j] * pb_y[j] - pc_xxy[j] * pa_zz[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_y[j] - pc_xzz[j] * pb_xy[j]);

                t_xzz_xy[j] += fl_s_0_0_4 * (0.5 * fl1_fx * pc_yzz[j] + 0.5 * pc_xxy[j] * fl1_fx + pa_x[j] * pc_xyzz[j] + 2.0 * pc_xxyz[j] * pa_z[j] + pc_xyzz[j] * pb_x[j] + pc_xxzz[j] * pb_y[j]);

                t_xzz_xy[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_xzz_xz[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_z[j] + 0.25 * fl2_fx * pb_z[j] + pa_xz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_zz[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_xz[j] + pa_xzz[j] * pb_xz[j]);

                t_xzz_xz[j] += fl_s_0_0_1 * (-fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - pa_xz[j] * fl1_fx * pc_x[j] - pa_xz[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_x[j] - pc_x[j] * pa_z[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_zz[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_zz[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_xz[j] - 0.5 * pc_x[j] * fl1_fx * pb_xz[j] - pa_xzz[j] * pb_x[j] * pc_z[j] - pa_xzz[j] * pc_x[j] * pb_z[j] - 2.0 * pa_xz[j] * pc_z[j] * pb_xz[j] - pc_x[j] * pa_zz[j] * pb_xz[j]);

                t_xzz_xz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.5 * fl2_fx * pa_z[j] + 0.25 * fl2_fx * pb_z[j] + pa_xz[j] * fl1_fx * pc_x[j] + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_x[j] + pc_xx[j] * pa_z[j] * fl1_fx + pc_x[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pb_x[j] + fl1_fx * pa_z[j] * pc_zz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pa_zz[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pc_xx[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_xz[j] + pa_xzz[j] * pc_xz[j] + 2.0 * pa_xz[j] * pc_zz[j] * pb_x[j] + 2.0 * pa_xz[j] * pc_xz[j] * pb_z[j] + pa_x[j] * pc_zz[j] * pb_xz[j] + pc_xz[j] * pa_zz[j] * pb_x[j] + pc_xx[j] * pa_zz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_xz[j]);

                t_xzz_xz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx - pc_xx[j] * pa_z[j] * fl1_fx - 1.5 * pc_xxz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_zzz[j] - fl1_fx * pa_z[j] * pc_zz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_z[j] - 2.0 * pa_xz[j] * pc_xzz[j] - pa_x[j] * pc_zzz[j] * pb_x[j] - pa_x[j] * pc_xzz[j] * pb_z[j] - pc_xxz[j] * pa_zz[j] - 2.0 * pc_xzz[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_z[j] - pc_xzz[j] * pb_xz[j]);

                t_xzz_xz[j] += fl_s_0_0_4 * (1.5 * pc_xxz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + pa_x[j] * pc_xzzz[j] + 2.0 * pc_xxzz[j] * pa_z[j] + pc_xzzz[j] * pb_x[j] + pc_xxzz[j] * pb_z[j]);

                t_xzz_xz[j] += -fl_s_0_0_5 * pc_xxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_33_36(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (33,36)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(19 * idx);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(19 * idx + 5);

            auto pa_zz = paDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(19 * idx + 14);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            auto pc_xzzzz = pcDistances.data(55 * idx + 48);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_xzz_yy = primBuffer.data(60 * idx + 33);

            auto t_xzz_yz = primBuffer.data(60 * idx + 34);

            auto t_xzz_zz = primBuffer.data(60 * idx + 35);

            // Batch of Integrals (33,36)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_z, pa_zz, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, \
                                     pc_xzzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, \
                                     pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_xzz_yy, t_xzz_yz, \
                                     t_xzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzz_yy[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pa_xzz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_yy[j] + pa_xzz[j] * pb_yy[j]);

                t_xzz_yy[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx - 0.5 * pa_xzz[j] * fl1_fx - pa_xz[j] * pc_z[j] * fl1_fx - 0.5 * pc_x[j] * pa_zz[j] * fl1_fx - pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_yy[j] - 0.5 * pc_x[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xzz[j] * pb_y[j] * pc_y[j] - 2.0 * pa_xz[j] * pc_z[j] * pb_yy[j] - pc_x[j] * pa_zz[j] * pb_yy[j]);

                t_xzz_yy[j] += fl_s_0_0_2 * (0.25 * pa_x[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx + pa_xz[j] * pc_z[j] * fl1_fx + 0.5 * pa_x[j] * pc_zz[j] * fl1_fx + 0.5 * pc_x[j] * pa_zz[j] * fl1_fx + pc_xz[j] * pa_z[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_yy[j] + pa_x[j] * fl1_fx * pb_y[j] * pc_y[j] + pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * fl1_fx * pb_yy[j] + pa_xzz[j] * pc_yy[j] + 4.0 * pa_xz[j] * pc_yz[j] * pb_y[j] + pa_x[j] * pc_zz[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_zz[j] * pb_y[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_yy[j]);

                t_xzz_yy[j] += fl_s_0_0_3 * (-0.25 * pc_x[j] * fl2_fx - 0.5 * pa_x[j] * pc_zz[j] * fl1_fx - pc_xz[j] * pa_z[j] * fl1_fx - 0.5 * pc_xzz[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_yy[j] - 0.5 * pc_xyy[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_y[j] - 2.0 * pa_xz[j] * pc_yyz[j] - 2.0 * pa_x[j] * pc_yzz[j] * pb_y[j] - pc_xyy[j] * pa_zz[j] - 4.0 * pc_xyz[j] * pa_z[j] * pb_y[j] - pc_xzz[j] * pb_yy[j]);

                t_xzz_yy[j] += fl_s_0_0_4 * (0.5 * pc_xzz[j] * fl1_fx + 0.5 * pc_xyy[j] * fl1_fx + pa_x[j] * pc_yyzz[j] + 2.0 * pc_xyyz[j] * pa_z[j] + 2.0 * pc_xyzz[j] * pb_y[j]);

                t_xzz_yy[j] += -fl_s_0_0_5 * pc_xyyzz[j];

                t_xzz_yz[j] = fl_s_0_0_0 * (pa_xz[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_yz[j] + pa_xzz[j] * pb_yz[j]);

                t_xzz_yz[j] += fl_s_0_0_1 * (-pa_xz[j] * fl1_fx * pc_y[j] - pa_xz[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_y[j] - pc_x[j] * pa_z[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * fl1_fx * pb_yz[j] - pa_xzz[j] * pb_y[j] * pc_z[j] - pa_xzz[j] * pc_y[j] * pb_z[j] - 2.0 * pa_xz[j] * pc_z[j] * pb_yz[j] - pc_x[j] * pa_zz[j] * pb_yz[j]);

                t_xzz_yz[j] += fl_s_0_0_2 * (pa_xz[j] * fl1_fx * pc_y[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_y[j] + pc_xy[j] * pa_z[j] * fl1_fx + pc_x[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pc_xy[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_yz[j] + pa_xzz[j] * pc_yz[j] + 2.0 * pa_xz[j] * pc_zz[j] * pb_y[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_z[j] + pa_x[j] * pc_zz[j] * pb_yz[j] + pc_xz[j] * pa_zz[j] * pb_y[j] + pc_xy[j] * pa_zz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_yz[j]);

                t_xzz_yz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * pc_yz[j] * fl1_fx - pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xy[j] * fl1_fx * pb_z[j] - 2.0 * pa_xz[j] * pc_yzz[j] - pa_x[j] * pc_zzz[j] * pb_y[j] - pa_x[j] * pc_yzz[j] * pb_z[j] - pc_xyz[j] * pa_zz[j] - 2.0 * pc_xzz[j] * pa_z[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_z[j] - pc_xzz[j] * pb_yz[j]);

                t_xzz_yz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_x[j] * pc_yzzz[j] + 2.0 * pc_xyzz[j] * pa_z[j] + pc_xzzz[j] * pb_y[j] + pc_xyzz[j] * pb_z[j]);

                t_xzz_yz[j] += -fl_s_0_0_5 * pc_xyzzz[j];

                t_xzz_zz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx + 0.5 * pa_xzz[j] * fl1_fx + 2.0 * pa_xz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_zz[j] + pa_xzz[j] * pb_zz[j]);

                t_xzz_zz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx - 0.5 * pa_xzz[j] * fl1_fx - 3.0 * pa_xz[j] * pc_z[j] * fl1_fx - 2.0 * pa_xz[j] * fl1_fx * pb_z[j] - 3.0 * pa_x[j] * pc_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_zz[j] * fl1_fx - 2.0 * pc_x[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_zz[j] - 0.5 * pc_x[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xzz[j] * pb_z[j] * pc_z[j] - 2.0 * pa_xz[j] * pc_z[j] * pb_zz[j] - pc_x[j] * pa_zz[j] * pb_zz[j]);

                t_xzz_zz[j] += fl_s_0_0_2 * (0.75 * pa_x[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx + 3.0 * pa_xz[j] * pc_z[j] * fl1_fx + 3.0 * pa_x[j] * pc_zz[j] * fl1_fx + 3.0 * pa_x[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_zz[j] * fl1_fx + 3.0 * pc_xz[j] * pa_z[j] * fl1_fx + 2.0 * pc_x[j] * pa_z[j] * fl1_fx * pb_z[j] + 3.0 * pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pb_zz[j] + pa_xzz[j] * pc_zz[j] + 4.0 * pa_xz[j] * pc_zz[j] * pb_z[j] + pa_x[j] * pc_zz[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_zz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_zz[j]);

                t_xzz_zz[j] += fl_s_0_0_3 * (-0.75 * pc_x[j] * fl2_fx - 3.0 * pa_x[j] * pc_zz[j] * fl1_fx - 3.0 * pc_xz[j] * pa_z[j] * fl1_fx - 3.0 * pc_xzz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_z[j] - 2.0 * pa_xz[j] * pc_zzz[j] - 2.0 * pa_x[j] * pc_zzz[j] * pb_z[j] - pc_xzz[j] * pa_zz[j] - 4.0 * pc_xzz[j] * pa_z[j] * pb_z[j] - pc_xzz[j] * pb_zz[j]);

                t_xzz_zz[j] += fl_s_0_0_4 * (3.0 * pc_xzz[j] * fl1_fx + pa_x[j] * pc_zzzz[j] + 2.0 * pc_xzzz[j] * pa_z[j] + 2.0 * pc_xzzz[j] * pb_z[j]);

                t_xzz_zz[j] += -fl_s_0_0_5 * pc_xzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_36_39(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (36,39)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(19 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(19 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(19 * idx + 15);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(55 * idx + 40);

            auto pc_xyyyy = pcDistances.data(55 * idx + 44);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yyy_xx = primBuffer.data(60 * idx + 36);

            auto t_yyy_xy = primBuffer.data(60 * idx + 37);

            auto t_yyy_xz = primBuffer.data(60 * idx + 38);

            // Batch of Integrals (36,39)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxy, \
                                     pc_xxyy, pc_xxyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, \
                                     pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_yyy_xx, t_yyy_xy, t_yyy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyy_xx[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx + 0.5 * pa_yyy[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pb_xx[j] + pa_yyy[j] * pb_xx[j]);

                t_yyy_xx[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 0.5 * pa_yyy[j] * fl1_fx - 1.5 * pa_yy[j] * pc_y[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] - 1.5 * pa_y[j] * fl1_fx * pb_xx[j] - 1.5 * pc_y[j] * fl1_fx * pb_xx[j] - 2.0 * pa_yyy[j] * pb_x[j] * pc_x[j] - 3.0 * pa_yy[j] * pc_y[j] * pb_xx[j]);

                t_yyy_xx[j] += fl_s_0_0_2 * (0.75 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 1.5 * pa_yy[j] * pc_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_yy[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pc_xx[j] + 3.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] + 3.0 * pc_xy[j] * fl1_fx * pb_x[j] + 1.5 * pc_y[j] * fl1_fx * pb_xx[j] + pa_yyy[j] * pc_xx[j] + 6.0 * pa_yy[j] * pc_xy[j] * pb_x[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_xx[j]);

                t_yyy_xx[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - 1.5 * pa_y[j] * pc_yy[j] * fl1_fx - 0.5 * pc_yyy[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pc_xx[j] - 1.5 * pc_xxy[j] * fl1_fx - 3.0 * pc_xy[j] * fl1_fx * pb_x[j] - 3.0 * pa_yy[j] * pc_xxy[j] - 6.0 * pa_y[j] * pc_xyy[j] * pb_x[j] - pc_yyy[j] * pb_xx[j]);

                t_yyy_xx[j] += fl_s_0_0_4 * (0.5 * pc_yyy[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx + 3.0 * pa_y[j] * pc_xxyy[j] + 2.0 * pc_xyyy[j] * pb_x[j]);

                t_yyy_xx[j] += -fl_s_0_0_5 * pc_xxyyy[j];

                t_yyy_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_x[j] + 1.5 * pa_yy[j] * fl1_fx * pb_x[j] + 1.5 * pa_y[j] * fl1_fx * pb_xy[j] + pa_yyy[j] * pb_xy[j]);

                t_yyy_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_x[j] - 1.5 * fl2_fx * pb_x[j] - 1.5 * pa_yy[j] * fl1_fx * pc_x[j] - 1.5 * pa_yy[j] * fl1_fx * pb_x[j] - 4.5 * pa_y[j] * pc_y[j] * fl1_fx * pb_x[j] - 1.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] - 1.5 * pa_y[j] * fl1_fx * pb_xy[j] - 1.5 * pc_y[j] * fl1_fx * pb_xy[j] - pa_yyy[j] * pb_x[j] * pc_y[j] - pa_yyy[j] * pc_x[j] * pb_y[j] - 3.0 * pa_yy[j] * pc_y[j] * pb_xy[j]);

                t_yyy_xy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_x[j] + 0.75 * fl2_fx * pb_x[j] + 1.5 * pa_yy[j] * fl1_fx * pc_x[j] + 4.5 * pa_y[j] * pc_xy[j] * fl1_fx + 4.5 * pa_y[j] * pc_y[j] * fl1_fx * pb_x[j] + 3.0 * pc_yy[j] * fl1_fx * pb_x[j] + 1.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_y[j] + 1.5 * pc_y[j] * fl1_fx * pb_xy[j] + pa_yyy[j] * pc_xy[j] + 3.0 * pa_yy[j] * pc_yy[j] * pb_x[j] + 3.0 * pa_yy[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_xy[j]);

                t_yyy_xy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_x[j] - 4.5 * pa_y[j] * pc_xy[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx - 3.0 * pc_yy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_y[j] - 3.0 * pa_yy[j] * pc_xyy[j] - 3.0 * pa_y[j] * pc_yyy[j] * pb_x[j] - 3.0 * pa_y[j] * pc_xyy[j] * pb_y[j] - pc_yyy[j] * pb_xy[j]);

                t_yyy_xy[j] += fl_s_0_0_4 * (3.0 * pc_xyy[j] * fl1_fx + 3.0 * pa_y[j] * pc_xyyy[j] + pc_yyyy[j] * pb_x[j] + pc_xyyy[j] * pb_y[j]);

                t_yyy_xy[j] += -fl_s_0_0_5 * pc_xyyyy[j];

                t_yyy_xz[j] = fl_s_0_0_0 * (1.5 * pa_y[j] * fl1_fx * pb_xz[j] + pa_yyy[j] * pb_xz[j]);

                t_yyy_xz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_z[j] - 1.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] - 1.5 * pa_y[j] * fl1_fx * pb_xz[j] - 1.5 * pc_y[j] * fl1_fx * pb_xz[j] - pa_yyy[j] * pb_x[j] * pc_z[j] - pa_yyy[j] * pc_x[j] * pb_z[j] - 3.0 * pa_yy[j] * pc_y[j] * pb_xz[j]);

                t_yyy_xz[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl1_fx * pc_xz[j] + 1.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_z[j] + 1.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * fl1_fx * pb_xz[j] + pa_yyy[j] * pc_xz[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_x[j] + 3.0 * pa_yy[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_xz[j]);

                t_yyy_xz[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * fl1_fx * pc_xz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_z[j] - 3.0 * pa_yy[j] * pc_xyz[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_x[j] - 3.0 * pa_y[j] * pc_xyy[j] * pb_z[j] - pc_yyy[j] * pb_xz[j]);

                t_yyy_xz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 3.0 * pa_y[j] * pc_xyyz[j] + pc_yyyz[j] * pb_x[j] + pc_xyyy[j] * pb_z[j]);

                t_yyy_xz[j] += -fl_s_0_0_5 * pc_xyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_39_42(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (39,42)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(19 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(19 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(19 * idx + 15);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(55 * idx + 49);

            auto pc_yyyyz = pcDistances.data(55 * idx + 50);

            auto pc_yyyzz = pcDistances.data(55 * idx + 51);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yyy_yy = primBuffer.data(60 * idx + 39);

            auto t_yyy_yz = primBuffer.data(60 * idx + 40);

            auto t_yyy_zz = primBuffer.data(60 * idx + 41);

            // Batch of Integrals (39,42)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, pc_yyy, \
                                     pc_yyyy, pc_yyyyy, pc_yyyyz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, \
                                     pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_yyy_yy, t_yyy_yz, \
                                     t_yyy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyy_yy[j] = fl_s_0_0_0 * (2.25 * pa_y[j] * fl2_fx + 1.5 * fl2_fx * pb_y[j] + 0.5 * pa_yyy[j] * fl1_fx + 3.0 * pa_yy[j] * fl1_fx * pb_y[j] + 1.5 * pa_y[j] * fl1_fx * pb_yy[j] + pa_yyy[j] * pb_yy[j]);

                t_yyy_yy[j] += fl_s_0_0_1 * (-4.5 * pa_y[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx - 3.0 * fl2_fx * pb_y[j] - 0.5 * pa_yyy[j] * fl1_fx - 4.5 * pa_yy[j] * pc_y[j] * fl1_fx - 3.0 * pa_yy[j] * fl1_fx * pb_y[j] - 9.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_y[j] - 1.5 * pa_y[j] * fl1_fx * pb_yy[j] - 1.5 * pc_y[j] * fl1_fx * pb_yy[j] - 2.0 * pa_yyy[j] * pb_y[j] * pc_y[j] - 3.0 * pa_yy[j] * pc_y[j] * pb_yy[j]);

                t_yyy_yy[j] += fl_s_0_0_2 * (2.25 * pa_y[j] * fl2_fx + 7.5 * pc_y[j] * fl2_fx + 1.5 * fl2_fx * pb_y[j] + 4.5 * pa_yy[j] * pc_y[j] * fl1_fx + 9.0 * pa_y[j] * pc_yy[j] * fl1_fx + 9.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_y[j] + 6.0 * pc_yy[j] * fl1_fx * pb_y[j] + 1.5 * pc_y[j] * fl1_fx * pb_yy[j] + pa_yyy[j] * pc_yy[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_y[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_yy[j]);

                t_yyy_yy[j] += fl_s_0_0_3 * (-3.75 * pc_y[j] * fl2_fx - 9.0 * pa_y[j] * pc_yy[j] * fl1_fx - 5.0 * pc_yyy[j] * fl1_fx - 6.0 * pc_yy[j] * fl1_fx * pb_y[j] - 3.0 * pa_yy[j] * pc_yyy[j] - 6.0 * pa_y[j] * pc_yyy[j] * pb_y[j] - pc_yyy[j] * pb_yy[j]);

                t_yyy_yy[j] += fl_s_0_0_4 * (5.0 * pc_yyy[j] * fl1_fx + 3.0 * pa_y[j] * pc_yyyy[j] + 2.0 * pc_yyyy[j] * pb_y[j]);

                t_yyy_yy[j] += -fl_s_0_0_5 * pc_yyyyy[j];

                t_yyy_yz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_z[j] + 1.5 * pa_yy[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pb_yz[j] + pa_yyy[j] * pb_yz[j]);

                t_yyy_yz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * fl2_fx * pb_z[j] - 1.5 * pa_yy[j] * fl1_fx * pc_z[j] - 1.5 * pa_yy[j] * fl1_fx * pb_z[j] - 4.5 * pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] - 1.5 * pa_y[j] * fl1_fx * pb_y[j] * pc_z[j] - 1.5 * pa_y[j] * fl1_fx * pb_yz[j] - 1.5 * pc_y[j] * fl1_fx * pb_yz[j] - pa_yyy[j] * pb_y[j] * pc_z[j] - pa_yyy[j] * pc_y[j] * pb_z[j] - 3.0 * pa_yy[j] * pc_y[j] * pb_yz[j]);

                t_yyy_yz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pb_z[j] + 1.5 * pa_yy[j] * fl1_fx * pc_z[j] + 4.5 * pa_y[j] * pc_yz[j] * fl1_fx + 4.5 * pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] + 3.0 * pc_yy[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pb_y[j] * pc_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_y[j] + 1.5 * pc_y[j] * fl1_fx * pb_yz[j] + pa_yyy[j] * pc_yz[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_y[j] + 3.0 * pa_yy[j] * pc_yy[j] * pb_z[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_yz[j]);

                t_yyy_yz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 4.5 * pa_y[j] * pc_yz[j] * fl1_fx - 3.0 * pc_yyz[j] * fl1_fx - 3.0 * pc_yy[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_y[j] - 3.0 * pa_yy[j] * pc_yyz[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_y[j] - 3.0 * pa_y[j] * pc_yyy[j] * pb_z[j] - pc_yyy[j] * pb_yz[j]);

                t_yyy_yz[j] += fl_s_0_0_4 * (3.0 * pc_yyz[j] * fl1_fx + 3.0 * pa_y[j] * pc_yyyz[j] + pc_yyyz[j] * pb_y[j] + pc_yyyy[j] * pb_z[j]);

                t_yyy_yz[j] += -fl_s_0_0_5 * pc_yyyyz[j];

                t_yyy_zz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx + 0.5 * pa_yyy[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pb_zz[j] + pa_yyy[j] * pb_zz[j]);

                t_yyy_zz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 0.5 * pa_yyy[j] * fl1_fx - 1.5 * pa_yy[j] * pc_y[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pb_z[j] * pc_z[j] - 1.5 * pa_y[j] * fl1_fx * pb_zz[j] - 1.5 * pc_y[j] * fl1_fx * pb_zz[j] - 2.0 * pa_yyy[j] * pb_z[j] * pc_z[j] - 3.0 * pa_yy[j] * pc_y[j] * pb_zz[j]);

                t_yyy_zz[j] += fl_s_0_0_2 * (0.75 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 1.5 * pa_yy[j] * pc_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_yy[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pc_zz[j] + 3.0 * pa_y[j] * fl1_fx * pb_z[j] * pc_z[j] + 3.0 * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * fl1_fx * pb_zz[j] + pa_yyy[j] * pc_zz[j] + 6.0 * pa_yy[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_zz[j]);

                t_yyy_zz[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - 1.5 * pa_y[j] * pc_yy[j] * fl1_fx - 0.5 * pc_yyy[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pc_zz[j] - 1.5 * pc_yzz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_z[j] - 3.0 * pa_yy[j] * pc_yzz[j] - 6.0 * pa_y[j] * pc_yyz[j] * pb_z[j] - pc_yyy[j] * pb_zz[j]);

                t_yyy_zz[j] += fl_s_0_0_4 * (0.5 * pc_yyy[j] * fl1_fx + 1.5 * pc_yzz[j] * fl1_fx + 3.0 * pa_y[j] * pc_yyzz[j] + 2.0 * pc_yyyz[j] * pb_z[j]);

                t_yyy_zz[j] += -fl_s_0_0_5 * pc_yyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_42_45(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (42,45)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(19 * idx + 1);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(19 * idx + 6);

            auto pa_yz = paDistances.data(19 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(19 * idx + 16);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(55 * idx + 22);

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xyyy = pcDistances.data(55 * idx + 25);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(55 * idx + 41);

            auto pc_xyyyz = pcDistances.data(55 * idx + 45);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yyz_xx = primBuffer.data(60 * idx + 42);

            auto t_yyz_xy = primBuffer.data(60 * idx + 43);

            auto t_yyz_xz = primBuffer.data(60 * idx + 44);

            // Batch of Integrals (42,45)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, \
                                     pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_yyz_xx, t_yyz_xy, t_yyz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyz_xx[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * pa_yyz[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pb_xx[j] + pa_yyz[j] * pb_xx[j]);

                t_yyz_xx[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.25 * fl2_fx * pc_z[j] - 0.5 * pa_yyz[j] * fl1_fx - 0.5 * pa_yy[j] * pc_z[j] * fl1_fx - pa_yz[j] * pc_y[j] * fl1_fx - fl1_fx * pa_z[j] * pb_x[j] * pc_x[j] - 0.5 * fl1_fx * pc_z[j] * pb_xx[j] - 0.5 * fl1_fx * pa_z[j] * pb_xx[j] - 2.0 * pa_yyz[j] * pb_x[j] * pc_x[j] - pa_yy[j] * pc_z[j] * pb_xx[j] - 2.0 * pa_yz[j] * pc_y[j] * pb_xx[j]);

                t_yyz_xx[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * pa_yy[j] * pc_z[j] * fl1_fx + pa_yz[j] * pc_y[j] * fl1_fx + pa_y[j] * pc_yz[j] * fl1_fx + 0.5 * pc_yy[j] * pa_z[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pc_xx[j] + fl1_fx * pc_xz[j] * pb_x[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_x[j] + 0.5 * fl1_fx * pc_z[j] * pb_xx[j] + pa_yyz[j] * pc_xx[j] + 2.0 * pa_yy[j] * pc_xz[j] * pb_x[j] + 4.0 * pa_yz[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xx[j] + pc_yy[j] * pa_z[j] * pb_xx[j]);

                t_yyz_xx[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_z[j] - pa_y[j] * pc_yz[j] * fl1_fx - 0.5 * pc_yy[j] * pa_z[j] * fl1_fx - 0.5 * pc_yyz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxz[j] - 0.5 * fl1_fx * pa_z[j] * pc_xx[j] - fl1_fx * pc_xz[j] * pb_x[j] - pa_yy[j] * pc_xxz[j] - 2.0 * pa_yz[j] * pc_xxy[j] - 4.0 * pa_y[j] * pc_xyz[j] * pb_x[j] - 2.0 * pc_xyy[j] * pa_z[j] * pb_x[j] - pc_yyz[j] * pb_xx[j]);

                t_yyz_xx[j] += fl_s_0_0_4 * (0.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_xxz[j] + 2.0 * pa_y[j] * pc_xxyz[j] + pc_xxyy[j] * pa_z[j] + 2.0 * pc_xyyz[j] * pb_x[j]);

                t_yyz_xx[j] += -fl_s_0_0_5 * pc_xxyyz[j];

                t_yyz_xy[j] = fl_s_0_0_0 * (pa_yz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pb_xy[j] + pa_yyz[j] * pb_xy[j]);

                t_yyz_xy[j] += fl_s_0_0_1 * (-pa_yz[j] * fl1_fx * pc_x[j] - pa_y[j] * fl1_fx * pc_z[j] * pb_x[j] - pa_yz[j] * fl1_fx * pb_x[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_xy[j] - 0.5 * fl1_fx * pa_z[j] * pb_xy[j] - pa_yyz[j] * pb_x[j] * pc_y[j] - pa_yyz[j] * pc_x[j] * pb_y[j] - pa_yy[j] * pc_z[j] * pb_xy[j] - 2.0 * pa_yz[j] * pc_y[j] * pb_xy[j]);

                t_yyz_xy[j] += fl_s_0_0_2 * (pa_y[j] * fl1_fx * pc_xz[j] + pa_yz[j] * fl1_fx * pc_x[j] + pa_y[j] * fl1_fx * pc_z[j] * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pc_xz[j] * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_xy[j] + pa_yyz[j] * pc_xy[j] + pa_yy[j] * pc_yz[j] * pb_x[j] + pa_yy[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_yz[j] * pc_yy[j] * pb_x[j] + 2.0 * pa_yz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xy[j] + pc_yy[j] * pa_z[j] * pb_xy[j]);

                t_yyz_xy[j] += fl_s_0_0_3 * (-pa_y[j] * fl1_fx * pc_xz[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_xz[j] * pb_y[j] - pa_yy[j] * pc_xyz[j] - 2.0 * pa_yz[j] * pc_xyy[j] - 2.0 * pa_y[j] * pc_yyz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_y[j] - pc_yyy[j] * pa_z[j] * pb_x[j] - pc_xyy[j] * pa_z[j] * pb_y[j] - pc_yyz[j] * pb_xy[j]);

                t_yyz_xy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 2.0 * pa_y[j] * pc_xyyz[j] + pc_xyyy[j] * pa_z[j] + pc_yyyz[j] * pb_x[j] + pc_xyyz[j] * pb_y[j]);

                t_yyz_xy[j] += -fl_s_0_0_5 * pc_xyyyz[j];

                t_yyz_xz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_x[j] + 0.5 * pa_yy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pb_xz[j] + pa_yyz[j] * pb_xz[j]);

                t_yyz_xz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_x[j] - 0.5 * fl2_fx * pb_x[j] - 0.5 * pa_yy[j] * fl1_fx * pc_x[j] - 0.5 * pa_yy[j] * fl1_fx * pb_x[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_xz[j] - 0.5 * fl1_fx * pa_z[j] * pb_xz[j] - pa_yyz[j] * pb_x[j] * pc_z[j] - pa_yyz[j] * pc_x[j] * pb_z[j] - pa_yy[j] * pc_z[j] * pb_xz[j] - 2.0 * pa_yz[j] * pc_y[j] * pb_xz[j]);

                t_yyz_xz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_x[j] + 0.25 * fl2_fx * pb_x[j] + 0.5 * pa_yy[j] * fl1_fx * pc_x[j] + pa_y[j] * pc_xy[j] * fl1_fx + pa_y[j] * pc_y[j] * fl1_fx * pb_x[j] + 0.5 * pc_yy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_z[j] * pc_xz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pc_xz[j] * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_xz[j] + pa_yyz[j] * pc_xz[j] + pa_yy[j] * pc_zz[j] * pb_x[j] + pa_yy[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_yz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_yz[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xz[j] + pc_yy[j] * pa_z[j] * pb_xz[j]);

                t_yyz_xz[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_x[j] - pa_y[j] * pc_xy[j] * fl1_fx - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * pc_yy[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pc_xzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_xz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_x[j] - 0.5 * fl1_fx * pc_xz[j] * pb_z[j] - pa_yy[j] * pc_xzz[j] - 2.0 * pa_yz[j] * pc_xyz[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_z[j] - pc_yyz[j] * pa_z[j] * pb_x[j] - pc_xyy[j] * pa_z[j] * pb_z[j] - pc_yyz[j] * pb_xz[j]);

                t_yyz_xz[j] += fl_s_0_0_4 * (0.5 * pc_xyy[j] * fl1_fx + 0.5 * fl1_fx * pc_xzz[j] + 2.0 * pa_y[j] * pc_xyzz[j] + pc_xyyz[j] * pa_z[j] + pc_yyzz[j] * pb_x[j] + pc_xyyz[j] * pb_z[j]);

                t_yyz_xz[j] += -fl_s_0_0_5 * pc_xyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_45_48(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (45,48)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(19 * idx + 1);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(19 * idx + 6);

            auto pa_yz = paDistances.data(19 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(19 * idx + 16);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(55 * idx + 29);

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(55 * idx + 50);

            auto pc_yyyzz = pcDistances.data(55 * idx + 51);

            auto pc_yyzzz = pcDistances.data(55 * idx + 52);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yyz_yy = primBuffer.data(60 * idx + 45);

            auto t_yyz_yz = primBuffer.data(60 * idx + 46);

            auto t_yyz_zz = primBuffer.data(60 * idx + 47);

            // Batch of Integrals (45,48)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, \
                                     pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_yyz_yy, t_yyz_yz, t_yyz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyz_yy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] + 0.5 * pa_yyz[j] * fl1_fx + 2.0 * pa_yz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pb_yy[j] + pa_yyz[j] * pb_yy[j]);

                t_yyz_yy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * fl2_fx * pa_z[j] - 0.5 * pa_yyz[j] * fl1_fx - 0.5 * pa_yy[j] * pc_z[j] * fl1_fx - 3.0 * pa_yz[j] * pc_y[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pc_z[j] * pb_y[j] - 2.0 * pa_yz[j] * fl1_fx * pb_y[j] - 3.0 * pc_y[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_yy[j] - 0.5 * fl1_fx * pa_z[j] * pb_yy[j] - 2.0 * pa_yyz[j] * pb_y[j] * pc_y[j] - pa_yy[j] * pc_z[j] * pb_yy[j] - 2.0 * pa_yz[j] * pc_y[j] * pb_yy[j]);

                t_yyz_yy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.75 * fl2_fx * pa_z[j] + 0.5 * pa_yy[j] * pc_z[j] * fl1_fx + 3.0 * pa_yz[j] * pc_y[j] * fl1_fx + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pc_z[j] * pb_y[j] + 3.0 * pc_yy[j] * pa_z[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_y[j] + 3.0 * pc_y[j] * fl1_fx * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_yy[j] + pa_yyz[j] * pc_yy[j] + 2.0 * pa_yy[j] * pc_yz[j] * pb_y[j] + 4.0 * pa_yz[j] * pc_yy[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_yy[j] + pc_yy[j] * pa_z[j] * pb_yy[j]);

                t_yyz_yy[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx - 3.0 * pc_yy[j] * pa_z[j] * fl1_fx - 3.0 * pc_yyz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_y[j] - pa_yy[j] * pc_yyz[j] - 2.0 * pa_yz[j] * pc_yyy[j] - 4.0 * pa_y[j] * pc_yyz[j] * pb_y[j] - 2.0 * pc_yyy[j] * pa_z[j] * pb_y[j] - pc_yyz[j] * pb_yy[j]);

                t_yyz_yy[j] += fl_s_0_0_4 * (3.0 * pc_yyz[j] * fl1_fx + 2.0 * pa_y[j] * pc_yyyz[j] + pc_yyyy[j] * pa_z[j] + 2.0 * pc_yyyz[j] * pb_y[j]);

                t_yyz_yy[j] += -fl_s_0_0_5 * pc_yyyyz[j];

                t_yyz_yz[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl2_fx + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_yy[j] * fl1_fx * pb_y[j] + pa_yz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_yz[j] + pa_yyz[j] * pb_yz[j]);

                t_yyz_yz[j] += fl_s_0_0_1 * (-pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 0.5 * fl2_fx * pb_y[j] - 0.5 * pa_yy[j] * fl1_fx * pc_y[j] - 0.5 * pa_yy[j] * fl1_fx * pb_y[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_y[j] - pa_yz[j] * fl1_fx * pc_z[j] - pa_y[j] * fl1_fx * pc_z[j] * pb_z[j] - pa_yz[j] * fl1_fx * pb_z[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_yz[j] - 0.5 * fl1_fx * pa_z[j] * pb_yz[j] - pa_yyz[j] * pb_y[j] * pc_z[j] - pa_yyz[j] * pc_y[j] * pb_z[j] - pa_yy[j] * pc_z[j] * pb_yz[j] - 2.0 * pa_yz[j] * pc_y[j] * pb_yz[j]);

                t_yyz_yz[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 0.25 * fl2_fx * pb_y[j] + 0.5 * pa_yy[j] * fl1_fx * pc_y[j] + pa_y[j] * pc_yy[j] * fl1_fx + pa_y[j] * pc_y[j] * fl1_fx * pb_y[j] + pa_y[j] * fl1_fx * pc_zz[j] + pa_yz[j] * fl1_fx * pc_z[j] + pa_y[j] * fl1_fx * pc_z[j] * pb_z[j] + 0.5 * pc_yy[j] * fl1_fx * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pa_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_yz[j] + pa_yyz[j] * pc_yz[j] + pa_yy[j] * pc_zz[j] * pb_y[j] + pa_yy[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_yz[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_yz[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_yz[j] + pc_yy[j] * pa_z[j] * pb_yz[j]);

                t_yyz_yz[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - pa_y[j] * pc_yy[j] * fl1_fx - pa_y[j] * fl1_fx * pc_zz[j] - 0.5 * pc_yyy[j] * fl1_fx - 0.5 * pc_yy[j] * fl1_fx * pb_y[j] - 1.5 * pc_yzz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pa_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_y[j] - pa_yy[j] * pc_yzz[j] - 2.0 * pa_yz[j] * pc_yyz[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_y[j] * pc_yyz[j] * pb_z[j] - pc_yyz[j] * pa_z[j] * pb_y[j] - pc_yyy[j] * pa_z[j] * pb_z[j] - pc_yyz[j] * pb_yz[j]);

                t_yyz_yz[j] += fl_s_0_0_4 * (0.5 * pc_yyy[j] * fl1_fx + 1.5 * pc_yzz[j] * fl1_fx + 2.0 * pa_y[j] * pc_yyzz[j] + pc_yyyz[j] * pa_z[j] + pc_yyzz[j] * pb_y[j] + pc_yyyz[j] * pb_z[j]);

                t_yyz_yz[j] += -fl_s_0_0_5 * pc_yyyzz[j];

                t_yyz_zz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 0.5 * pa_yyz[j] * fl1_fx + pa_yy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pb_zz[j] + pa_yyz[j] * pb_zz[j]);

                t_yyz_zz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - fl2_fx * pb_z[j] - 0.5 * pa_yyz[j] * fl1_fx - 1.5 * pa_yy[j] * pc_z[j] * fl1_fx - pa_yy[j] * fl1_fx * pb_z[j] - pa_yz[j] * pc_y[j] * fl1_fx - 2.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] - fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_yyz[j] * pb_z[j] * pc_z[j] - pa_yy[j] * pc_z[j] * pb_zz[j] - 2.0 * pa_yz[j] * pc_y[j] * pb_zz[j]);

                t_yyz_zz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.25 * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pb_z[j] + 1.5 * pa_yy[j] * pc_z[j] * fl1_fx + pa_yz[j] * pc_y[j] * fl1_fx + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx + 2.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_yy[j] * pa_z[j] * fl1_fx + pc_yy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_zz[j] + fl1_fx * pc_zz[j] * pb_z[j] + fl1_fx * pa_z[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_zz[j] + pa_yyz[j] * pc_zz[j] + 2.0 * pa_yy[j] * pc_zz[j] * pb_z[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_zz[j] + pc_yy[j] * pa_z[j] * pb_zz[j]);

                t_yyz_zz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx - 0.5 * pc_yy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yyz[j] * fl1_fx - pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pc_zzz[j] - 0.5 * fl1_fx * pa_z[j] * pc_zz[j] - fl1_fx * pc_zz[j] * pb_z[j] - pa_yy[j] * pc_zzz[j] - 2.0 * pa_yz[j] * pc_yzz[j] - 4.0 * pa_y[j] * pc_yzz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_z[j] - pc_yyz[j] * pb_zz[j]);

                t_yyz_zz[j] += fl_s_0_0_4 * (1.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] + pc_yyzz[j] * pa_z[j] + 2.0 * pc_yyzz[j] * pb_z[j]);

                t_yyz_zz[j] += -fl_s_0_0_5 * pc_yyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_48_51(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (48,51)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(19 * idx + 1);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(19 * idx + 7);

            auto pa_zz = paDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(19 * idx + 17);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(55 * idx + 10);

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyy = pcDistances.data(55 * idx + 12);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(55 * idx + 23);

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyyz = pcDistances.data(55 * idx + 26);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(55 * idx + 42);

            auto pc_xyyzz = pcDistances.data(55 * idx + 46);

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yzz_xx = primBuffer.data(60 * idx + 48);

            auto t_yzz_xy = primBuffer.data(60 * idx + 49);

            auto t_yzz_xz = primBuffer.data(60 * idx + 50);

            // Batch of Integrals (48,51)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, \
                                     pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, \
                                     pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_yzz_xx, t_yzz_xy, t_yzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzz_xx[j] = fl_s_0_0_0 * (0.25 * pa_y[j] * fl2_fx + 0.5 * pa_yzz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pb_xx[j] + pa_yzz[j] * pb_xx[j]);

                t_yzz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx - 0.25 * pc_y[j] * fl2_fx - 0.5 * pa_yzz[j] * fl1_fx - pa_yz[j] * pc_z[j] * fl1_fx - 0.5 * pc_y[j] * pa_zz[j] * fl1_fx - pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_xx[j] - 0.5 * pc_y[j] * fl1_fx * pb_xx[j] - 2.0 * pa_yzz[j] * pb_x[j] * pc_x[j] - 2.0 * pa_yz[j] * pc_z[j] * pb_xx[j] - pc_y[j] * pa_zz[j] * pb_xx[j]);

                t_yzz_xx[j] += fl_s_0_0_2 * (0.25 * pa_y[j] * fl2_fx + 0.5 * pc_y[j] * fl2_fx + pa_yz[j] * pc_z[j] * fl1_fx + 0.5 * pa_y[j] * pc_zz[j] * fl1_fx + 0.5 * pc_y[j] * pa_zz[j] * fl1_fx + pc_yz[j] * pa_z[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pc_xx[j] + pa_y[j] * fl1_fx * pb_x[j] * pc_x[j] + pc_xy[j] * fl1_fx * pb_x[j] + 0.5 * pc_y[j] * fl1_fx * pb_xx[j] + pa_yzz[j] * pc_xx[j] + 4.0 * pa_yz[j] * pc_xz[j] * pb_x[j] + pa_y[j] * pc_zz[j] * pb_xx[j] + 2.0 * pc_xy[j] * pa_zz[j] * pb_x[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_xx[j]);

                t_yzz_xx[j] += fl_s_0_0_3 * (-0.25 * pc_y[j] * fl2_fx - 0.5 * pa_y[j] * pc_zz[j] * fl1_fx - pc_yz[j] * pa_z[j] * fl1_fx - 0.5 * pc_yzz[j] * fl1_fx - 0.5 * pa_y[j] * fl1_fx * pc_xx[j] - 0.5 * pc_xxy[j] * fl1_fx - pc_xy[j] * fl1_fx * pb_x[j] - 2.0 * pa_yz[j] * pc_xxz[j] - 2.0 * pa_y[j] * pc_xzz[j] * pb_x[j] - pc_xxy[j] * pa_zz[j] - 4.0 * pc_xyz[j] * pa_z[j] * pb_x[j] - pc_yzz[j] * pb_xx[j]);

                t_yzz_xx[j] += fl_s_0_0_4 * (0.5 * pc_yzz[j] * fl1_fx + 0.5 * pc_xxy[j] * fl1_fx + pa_y[j] * pc_xxzz[j] + 2.0 * pc_xxyz[j] * pa_z[j] + 2.0 * pc_xyzz[j] * pb_x[j]);

                t_yzz_xx[j] += -fl_s_0_0_5 * pc_xxyzz[j];

                t_yzz_xy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pb_x[j] + 0.5 * fl1_fx * pa_zz[j] * pb_x[j] + 0.5 * pa_y[j] * fl1_fx * pb_xy[j] + pa_yzz[j] * pb_xy[j]);

                t_yzz_xy[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pc_x[j] - 0.5 * fl2_fx * pb_x[j] - 0.5 * fl1_fx * pa_zz[j] * pc_x[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_zz[j] * pb_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_y[j] * fl1_fx * pb_xy[j] - 0.5 * pc_y[j] * fl1_fx * pb_xy[j] - pa_yzz[j] * pb_x[j] * pc_y[j] - pa_yzz[j] * pc_x[j] * pb_y[j] - 2.0 * pa_yz[j] * pc_z[j] * pb_xy[j] - pc_y[j] * pa_zz[j] * pb_xy[j]);

                t_yzz_xy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pc_x[j] + 0.25 * fl2_fx * pb_x[j] + fl1_fx * pa_z[j] * pc_xz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pa_zz[j] * pc_x[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_x[j] + 0.5 * pa_y[j] * fl1_fx * pc_xy[j] + 0.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pc_yy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_y[j] * fl1_fx * pb_xy[j] + pa_yzz[j] * pc_xy[j] + 2.0 * pa_yz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_yz[j] * pc_xz[j] * pb_y[j] + pa_y[j] * pc_zz[j] * pb_xy[j] + pc_yy[j] * pa_zz[j] * pb_x[j] + pc_xy[j] * pa_zz[j] * pb_y[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_xy[j]);

                t_yzz_xy[j] += fl_s_0_0_3 * (-0.25 * fl2_fx * pc_x[j] - 0.5 * fl1_fx * pc_xzz[j] - fl1_fx * pa_z[j] * pc_xz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_x[j] - 0.5 * pa_y[j] * fl1_fx * pc_xy[j] - 0.5 * pc_xyy[j] * fl1_fx - 0.5 * pc_yy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xy[j] * fl1_fx * pb_y[j] - 2.0 * pa_yz[j] * pc_xyz[j] - pa_y[j] * pc_yzz[j] * pb_x[j] - pa_y[j] * pc_xzz[j] * pb_y[j] - pc_xyy[j] * pa_zz[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_y[j] - pc_yzz[j] * pb_xy[j]);

                t_yzz_xy[j] += fl_s_0_0_4 * (0.5 * fl1_fx * pc_xzz[j] + 0.5 * pc_xyy[j] * fl1_fx + pa_y[j] * pc_xyzz[j] + 2.0 * pc_xyyz[j] * pa_z[j] + pc_yyzz[j] * pb_x[j] + pc_xyzz[j] * pb_y[j]);

                t_yzz_xy[j] += -fl_s_0_0_5 * pc_xyyzz[j];

                t_yzz_xz[j] = fl_s_0_0_0 * (pa_yz[j] * fl1_fx * pb_x[j] + 0.5 * pa_y[j] * fl1_fx * pb_xz[j] + pa_yzz[j] * pb_xz[j]);

                t_yzz_xz[j] += fl_s_0_0_1 * (-pa_yz[j] * fl1_fx * pc_x[j] - pa_yz[j] * fl1_fx * pb_x[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_x[j] - pc_y[j] * pa_z[j] * fl1_fx * pb_x[j] - 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pb_xz[j] - 0.5 * pc_y[j] * fl1_fx * pb_xz[j] - pa_yzz[j] * pb_x[j] * pc_z[j] - pa_yzz[j] * pc_x[j] * pb_z[j] - 2.0 * pa_yz[j] * pc_z[j] * pb_xz[j] - pc_y[j] * pa_zz[j] * pb_xz[j]);

                t_yzz_xz[j] += fl_s_0_0_2 * (pa_yz[j] * fl1_fx * pc_x[j] + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_x[j] + pc_xy[j] * pa_z[j] * fl1_fx + pc_y[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_yz[j] * fl1_fx * pb_x[j] + 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pc_xy[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * fl1_fx * pb_xz[j] + pa_yzz[j] * pc_xz[j] + 2.0 * pa_yz[j] * pc_zz[j] * pb_x[j] + 2.0 * pa_yz[j] * pc_xz[j] * pb_z[j] + pa_y[j] * pc_zz[j] * pb_xz[j] + pc_yz[j] * pa_zz[j] * pb_x[j] + pc_xy[j] * pa_zz[j] * pb_z[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_xz[j]);

                t_yzz_xz[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * pc_xz[j] * fl1_fx - pc_xy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xy[j] * fl1_fx * pb_z[j] - 2.0 * pa_yz[j] * pc_xzz[j] - pa_y[j] * pc_zzz[j] * pb_x[j] - pa_y[j] * pc_xzz[j] * pb_z[j] - pc_xyz[j] * pa_zz[j] - 2.0 * pc_yzz[j] * pa_z[j] * pb_x[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_z[j] - pc_yzz[j] * pb_xz[j]);

                t_yzz_xz[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + pa_y[j] * pc_xzzz[j] + 2.0 * pc_xyzz[j] * pa_z[j] + pc_yzzz[j] * pb_x[j] + pc_xyzz[j] * pb_z[j]);

                t_yzz_xz[j] += -fl_s_0_0_5 * pc_xyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_51_54(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (51,54)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(19 * idx + 1);

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(19 * idx + 7);

            auto pa_zz = paDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(19 * idx + 17);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(55 * idx + 15);

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(55 * idx + 30);

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(55 * idx + 51);

            auto pc_yyzzz = pcDistances.data(55 * idx + 52);

            auto pc_yzzzz = pcDistances.data(55 * idx + 53);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_yzz_yy = primBuffer.data(60 * idx + 51);

            auto t_yzz_yz = primBuffer.data(60 * idx + 52);

            auto t_yzz_zz = primBuffer.data(60 * idx + 53);

            // Batch of Integrals (51,54)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, \
                                     pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, t_yzz_yy, t_yzz_yz, t_yzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzz_yy[j] = fl_s_0_0_0 * (0.25 * pa_y[j] * fl2_fx + 0.5 * fl2_fx * pb_y[j] + 0.5 * pa_yzz[j] * fl1_fx + fl1_fx * pa_zz[j] * pb_y[j] + 0.5 * pa_y[j] * fl1_fx * pb_yy[j] + pa_yzz[j] * pb_yy[j]);

                t_yzz_yy[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - fl2_fx * pb_y[j] - 0.5 * pa_yzz[j] * fl1_fx - pa_yz[j] * pc_z[j] * fl1_fx - 1.5 * pc_y[j] * pa_zz[j] * fl1_fx - 2.0 * fl1_fx * pa_z[j] * pc_z[j] * pb_y[j] - fl1_fx * pa_zz[j] * pb_y[j] - pa_y[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pb_yy[j] - 0.5 * pc_y[j] * fl1_fx * pb_yy[j] - 2.0 * pa_yzz[j] * pb_y[j] * pc_y[j] - 2.0 * pa_yz[j] * pc_z[j] * pb_yy[j] - pc_y[j] * pa_zz[j] * pb_yy[j]);

                t_yzz_yy[j] += fl_s_0_0_2 * (0.25 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 0.5 * fl2_fx * pb_y[j] + pa_yz[j] * pc_z[j] * fl1_fx + 0.5 * pa_y[j] * pc_zz[j] * fl1_fx + 1.5 * pc_y[j] * pa_zz[j] * fl1_fx + 3.0 * pc_yz[j] * pa_z[j] * fl1_fx + fl1_fx * pc_zz[j] * pb_y[j] + 2.0 * fl1_fx * pa_z[j] * pc_z[j] * pb_y[j] + 0.5 * pa_y[j] * fl1_fx * pc_yy[j] + pa_y[j] * fl1_fx * pb_y[j] * pc_y[j] + pc_yy[j] * fl1_fx * pb_y[j] + 0.5 * pc_y[j] * fl1_fx * pb_yy[j] + pa_yzz[j] * pc_yy[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_y[j] + pa_y[j] * pc_zz[j] * pb_yy[j] + 2.0 * pc_yy[j] * pa_zz[j] * pb_y[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_yy[j]);

                t_yzz_yy[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - 0.5 * pa_y[j] * pc_zz[j] * fl1_fx - 3.0 * pc_yz[j] * pa_z[j] * fl1_fx - 1.5 * pc_yzz[j] * fl1_fx - fl1_fx * pc_zz[j] * pb_y[j] - 0.5 * pa_y[j] * fl1_fx * pc_yy[j] - 0.5 * pc_yyy[j] * fl1_fx - pc_yy[j] * fl1_fx * pb_y[j] - 2.0 * pa_yz[j] * pc_yyz[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_y[j] - pc_yyy[j] * pa_zz[j] - 4.0 * pc_yyz[j] * pa_z[j] * pb_y[j] - pc_yzz[j] * pb_yy[j]);

                t_yzz_yy[j] += fl_s_0_0_4 * (1.5 * pc_yzz[j] * fl1_fx + 0.5 * pc_yyy[j] * fl1_fx + pa_y[j] * pc_yyzz[j] + 2.0 * pc_yyyz[j] * pa_z[j] + 2.0 * pc_yyzz[j] * pb_y[j]);

                t_yzz_yy[j] += -fl_s_0_0_5 * pc_yyyzz[j];

                t_yzz_yz[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_z[j] + 0.25 * fl2_fx * pb_z[j] + pa_yz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_zz[j] * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pb_yz[j] + pa_yzz[j] * pb_yz[j]);

                t_yzz_yz[j] += fl_s_0_0_1 * (-fl2_fx * pa_z[j] - 0.75 * fl2_fx * pc_z[j] - 0.5 * fl2_fx * pb_z[j] - pa_yz[j] * fl1_fx * pc_y[j] - pa_yz[j] * fl1_fx * pb_y[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_y[j] - pc_y[j] * pa_z[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pa_zz[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_zz[j] * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pb_yz[j] - 0.5 * pc_y[j] * fl1_fx * pb_yz[j] - pa_yzz[j] * pb_y[j] * pc_z[j] - pa_yzz[j] * pc_y[j] * pb_z[j] - 2.0 * pa_yz[j] * pc_z[j] * pb_yz[j] - pc_y[j] * pa_zz[j] * pb_yz[j]);

                t_yzz_yz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_z[j] + 0.5 * fl2_fx * pa_z[j] + 0.25 * fl2_fx * pb_z[j] + pa_yz[j] * fl1_fx * pc_y[j] + 1.5 * pa_y[j] * pc_yz[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_y[j] + pc_yy[j] * pa_z[j] * fl1_fx + pc_y[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pb_y[j] + fl1_fx * pa_z[j] * pc_zz[j] + 0.5 * fl1_fx * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pa_zz[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pc_yy[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * fl1_fx * pb_yz[j] + pa_yzz[j] * pc_yz[j] + 2.0 * pa_yz[j] * pc_zz[j] * pb_y[j] + 2.0 * pa_yz[j] * pc_yz[j] * pb_z[j] + pa_y[j] * pc_zz[j] * pb_yz[j] + pc_yz[j] * pa_zz[j] * pb_y[j] + pc_yy[j] * pa_zz[j] * pb_z[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_yz[j]);

                t_yzz_yz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_z[j] - 1.5 * pa_y[j] * pc_yz[j] * fl1_fx - pc_yy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yyz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pc_zzz[j] - fl1_fx * pa_z[j] * pc_zz[j] - 0.5 * fl1_fx * pc_zz[j] * pb_z[j] - 0.5 * pc_yy[j] * fl1_fx * pb_z[j] - 2.0 * pa_yz[j] * pc_yzz[j] - pa_y[j] * pc_zzz[j] * pb_y[j] - pa_y[j] * pc_yzz[j] * pb_z[j] - pc_yyz[j] * pa_zz[j] - 2.0 * pc_yzz[j] * pa_z[j] * pb_y[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_z[j] - pc_yzz[j] * pb_yz[j]);

                t_yzz_yz[j] += fl_s_0_0_4 * (1.5 * pc_yyz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzz[j] + pa_y[j] * pc_yzzz[j] + 2.0 * pc_yyzz[j] * pa_z[j] + pc_yzzz[j] * pb_y[j] + pc_yyzz[j] * pb_z[j]);

                t_yzz_yz[j] += -fl_s_0_0_5 * pc_yyzzz[j];

                t_yzz_zz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx + 0.5 * pa_yzz[j] * fl1_fx + 2.0 * pa_yz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pb_zz[j] + pa_yzz[j] * pb_zz[j]);

                t_yzz_zz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx - 0.5 * pa_yzz[j] * fl1_fx - 3.0 * pa_yz[j] * pc_z[j] * fl1_fx - 2.0 * pa_yz[j] * fl1_fx * pb_z[j] - 3.0 * pa_y[j] * pc_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_y[j] * pa_zz[j] * fl1_fx - 2.0 * pc_y[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pb_zz[j] - 0.5 * pc_y[j] * fl1_fx * pb_zz[j] - 2.0 * pa_yzz[j] * pb_z[j] * pc_z[j] - 2.0 * pa_yz[j] * pc_z[j] * pb_zz[j] - pc_y[j] * pa_zz[j] * pb_zz[j]);

                t_yzz_zz[j] += fl_s_0_0_2 * (0.75 * pa_y[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx + 3.0 * pa_yz[j] * pc_z[j] * fl1_fx + 3.0 * pa_y[j] * pc_zz[j] * fl1_fx + 3.0 * pa_y[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * pa_zz[j] * fl1_fx + 3.0 * pc_yz[j] * pa_z[j] * fl1_fx + 2.0 * pc_y[j] * pa_z[j] * fl1_fx * pb_z[j] + 3.0 * pc_yz[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * fl1_fx * pb_zz[j] + pa_yzz[j] * pc_zz[j] + 4.0 * pa_yz[j] * pc_zz[j] * pb_z[j] + pa_y[j] * pc_zz[j] * pb_zz[j] + 2.0 * pc_yz[j] * pa_zz[j] * pb_z[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_zz[j]);

                t_yzz_zz[j] += fl_s_0_0_3 * (-0.75 * pc_y[j] * fl2_fx - 3.0 * pa_y[j] * pc_zz[j] * fl1_fx - 3.0 * pc_yz[j] * pa_z[j] * fl1_fx - 3.0 * pc_yzz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_z[j] - 2.0 * pa_yz[j] * pc_zzz[j] - 2.0 * pa_y[j] * pc_zzz[j] * pb_z[j] - pc_yzz[j] * pa_zz[j] - 4.0 * pc_yzz[j] * pa_z[j] * pb_z[j] - pc_yzz[j] * pb_zz[j]);

                t_yzz_zz[j] += fl_s_0_0_4 * (3.0 * pc_yzz[j] * fl1_fx + pa_y[j] * pc_zzzz[j] + 2.0 * pc_yzzz[j] * pa_z[j] + 2.0 * pc_yzzz[j] * pb_z[j]);

                t_yzz_zz[j] += -fl_s_0_0_5 * pc_yzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_54_57(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (54,57)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            auto pb_xy = pbDistances.data(9 * idx + 4);

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(55 * idx);

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(55 * idx + 3);

            auto pc_xy = pcDistances.data(55 * idx + 4);

            auto pc_xz = pcDistances.data(55 * idx + 5);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(55 * idx + 11);

            auto pc_xyz = pcDistances.data(55 * idx + 13);

            auto pc_xzz = pcDistances.data(55 * idx + 14);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(55 * idx + 24);

            auto pc_xyzz = pcDistances.data(55 * idx + 27);

            auto pc_xzzz = pcDistances.data(55 * idx + 28);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(55 * idx + 43);

            auto pc_xyzzz = pcDistances.data(55 * idx + 47);

            auto pc_xzzzz = pcDistances.data(55 * idx + 48);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_zzz_xx = primBuffer.data(60 * idx + 54);

            auto t_zzz_xy = primBuffer.data(60 * idx + 55);

            auto t_zzz_xz = primBuffer.data(60 * idx + 56);

            // Batch of Integrals (54,57)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pb_x, pb_xx, pb_xy, pb_xz, pb_y, pb_z, pc_x, pc_xx, pc_xxz, \
                                     pc_xxzz, pc_xxzzz, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, \
                                     pc_y, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_zzz_xx, t_zzz_xy, t_zzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zzz_xx[j] = fl_s_0_0_0 * (0.75 * pa_z[j] * fl2_fx + 0.5 * pa_zzz[j] * fl1_fx + 1.5 * pa_z[j] * fl1_fx * pb_xx[j] + pa_zzz[j] * pb_xx[j]);

                t_zzz_xx[j] += fl_s_0_0_1 * (-1.5 * pa_z[j] * fl2_fx - 0.75 * pc_z[j] * fl2_fx - 0.5 * pa_zzz[j] * fl1_fx - 1.5 * pa_zz[j] * pc_z[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_x[j] - 1.5 * pa_z[j] * fl1_fx * pb_xx[j] - 1.5 * pc_z[j] * fl1_fx * pb_xx[j] - 2.0 * pa_zzz[j] * pb_x[j] * pc_x[j] - 3.0 * pa_zz[j] * pc_z[j] * pb_xx[j]);

                t_zzz_xx[j] += fl_s_0_0_2 * (0.75 * pa_z[j] * fl2_fx + 1.5 * pc_z[j] * fl2_fx + 1.5 * pa_zz[j] * pc_z[j] * fl1_fx + 1.5 * pa_z[j] * pc_zz[j] * fl1_fx + 1.5 * pa_z[j] * fl1_fx * pc_xx[j] + 3.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_x[j] + 3.0 * pc_xz[j] * fl1_fx * pb_x[j] + 1.5 * pc_z[j] * fl1_fx * pb_xx[j] + pa_zzz[j] * pc_xx[j] + 6.0 * pa_zz[j] * pc_xz[j] * pb_x[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_xx[j]);

                t_zzz_xx[j] += fl_s_0_0_3 * (-0.75 * pc_z[j] * fl2_fx - 1.5 * pa_z[j] * pc_zz[j] * fl1_fx - 0.5 * pc_zzz[j] * fl1_fx - 1.5 * pa_z[j] * fl1_fx * pc_xx[j] - 1.5 * pc_xxz[j] * fl1_fx - 3.0 * pc_xz[j] * fl1_fx * pb_x[j] - 3.0 * pa_zz[j] * pc_xxz[j] - 6.0 * pa_z[j] * pc_xzz[j] * pb_x[j] - pc_zzz[j] * pb_xx[j]);

                t_zzz_xx[j] += fl_s_0_0_4 * (0.5 * pc_zzz[j] * fl1_fx + 1.5 * pc_xxz[j] * fl1_fx + 3.0 * pa_z[j] * pc_xxzz[j] + 2.0 * pc_xzzz[j] * pb_x[j]);

                t_zzz_xx[j] += -fl_s_0_0_5 * pc_xxzzz[j];

                t_zzz_xy[j] = fl_s_0_0_0 * (1.5 * pa_z[j] * fl1_fx * pb_xy[j] + pa_zzz[j] * pb_xy[j]);

                t_zzz_xy[j] += fl_s_0_0_1 * (-1.5 * pa_z[j] * fl1_fx * pb_x[j] * pc_y[j] - 1.5 * pa_z[j] * fl1_fx * pc_x[j] * pb_y[j] - 1.5 * pa_z[j] * fl1_fx * pb_xy[j] - 1.5 * pc_z[j] * fl1_fx * pb_xy[j] - pa_zzz[j] * pb_x[j] * pc_y[j] - pa_zzz[j] * pc_x[j] * pb_y[j] - 3.0 * pa_zz[j] * pc_z[j] * pb_xy[j]);

                t_zzz_xy[j] += fl_s_0_0_2 * (1.5 * pa_z[j] * fl1_fx * pc_xy[j] + 1.5 * pa_z[j] * fl1_fx * pb_x[j] * pc_y[j] + 1.5 * pa_z[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_z[j] * fl1_fx * pb_xy[j] + pa_zzz[j] * pc_xy[j] + 3.0 * pa_zz[j] * pc_yz[j] * pb_x[j] + 3.0 * pa_zz[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_xy[j]);

                t_zzz_xy[j] += fl_s_0_0_3 * (-1.5 * pa_z[j] * fl1_fx * pc_xy[j] - 1.5 * pc_xyz[j] * fl1_fx - 1.5 * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_y[j] - 3.0 * pa_zz[j] * pc_xyz[j] - 3.0 * pa_z[j] * pc_yzz[j] * pb_x[j] - 3.0 * pa_z[j] * pc_xzz[j] * pb_y[j] - pc_zzz[j] * pb_xy[j]);

                t_zzz_xy[j] += fl_s_0_0_4 * (1.5 * pc_xyz[j] * fl1_fx + 3.0 * pa_z[j] * pc_xyzz[j] + pc_yzzz[j] * pb_x[j] + pc_xzzz[j] * pb_y[j]);

                t_zzz_xy[j] += -fl_s_0_0_5 * pc_xyzzz[j];

                t_zzz_xz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_x[j] + 1.5 * pa_zz[j] * fl1_fx * pb_x[j] + 1.5 * pa_z[j] * fl1_fx * pb_xz[j] + pa_zzz[j] * pb_xz[j]);

                t_zzz_xz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_x[j] - 1.5 * fl2_fx * pb_x[j] - 1.5 * pa_zz[j] * fl1_fx * pc_x[j] - 1.5 * pa_zz[j] * fl1_fx * pb_x[j] - 4.5 * pa_z[j] * pc_z[j] * fl1_fx * pb_x[j] - 1.5 * pa_z[j] * fl1_fx * pc_x[j] * pb_z[j] - 1.5 * pa_z[j] * fl1_fx * pb_xz[j] - 1.5 * pc_z[j] * fl1_fx * pb_xz[j] - pa_zzz[j] * pb_x[j] * pc_z[j] - pa_zzz[j] * pc_x[j] * pb_z[j] - 3.0 * pa_zz[j] * pc_z[j] * pb_xz[j]);

                t_zzz_xz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_x[j] + 0.75 * fl2_fx * pb_x[j] + 1.5 * pa_zz[j] * fl1_fx * pc_x[j] + 4.5 * pa_z[j] * pc_xz[j] * fl1_fx + 4.5 * pa_z[j] * pc_z[j] * fl1_fx * pb_x[j] + 3.0 * pc_zz[j] * fl1_fx * pb_x[j] + 1.5 * pa_z[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pc_z[j] * fl1_fx * pb_xz[j] + pa_zzz[j] * pc_xz[j] + 3.0 * pa_zz[j] * pc_zz[j] * pb_x[j] + 3.0 * pa_zz[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_xz[j]);

                t_zzz_xz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_x[j] - 4.5 * pa_z[j] * pc_xz[j] * fl1_fx - 3.0 * pc_xzz[j] * fl1_fx - 3.0 * pc_zz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_z[j] - 3.0 * pa_zz[j] * pc_xzz[j] - 3.0 * pa_z[j] * pc_zzz[j] * pb_x[j] - 3.0 * pa_z[j] * pc_xzz[j] * pb_z[j] - pc_zzz[j] * pb_xz[j]);

                t_zzz_xz[j] += fl_s_0_0_4 * (3.0 * pc_xzz[j] * fl1_fx + 3.0 * pa_z[j] * pc_xzzz[j] + pc_zzzz[j] * pb_x[j] + pc_xzzz[j] * pb_z[j]);

                t_zzz_xz[j] += -fl_s_0_0_5 * pc_xzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForFD_57_60(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (57,60)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(19 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(19 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(19 * idx + 18);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            auto pb_yz = pbDistances.data(9 * idx + 7);

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(55 * idx + 1);

            auto pc_z = pcDistances.data(55 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(55 * idx + 6);

            auto pc_yz = pcDistances.data(55 * idx + 7);

            auto pc_zz = pcDistances.data(55 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(55 * idx + 16);

            auto pc_yzz = pcDistances.data(55 * idx + 17);

            auto pc_zzz = pcDistances.data(55 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(55 * idx + 31);

            auto pc_yzzz = pcDistances.data(55 * idx + 32);

            auto pc_zzzz = pcDistances.data(55 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(55 * idx + 52);

            auto pc_yzzzz = pcDistances.data(55 * idx + 53);

            auto pc_zzzzz = pcDistances.data(55 * idx + 54);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(6 * idx);

            auto s_0_0_1 = auxBuffer.data(6 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(6 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(6 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(6 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(6 * idx + 5);

            // set up pointers to integrals

            auto t_zzz_yy = primBuffer.data(60 * idx + 57);

            auto t_zzz_yz = primBuffer.data(60 * idx + 58);

            auto t_zzz_zz = primBuffer.data(60 * idx + 59);

            // Batch of Integrals (57,60)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pb_y, pb_yy, pb_yz, pb_z, pb_zz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     pc_zzzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, t_zzz_yy, t_zzz_yz, \
                                     t_zzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zzz_yy[j] = fl_s_0_0_0 * (0.75 * pa_z[j] * fl2_fx + 0.5 * pa_zzz[j] * fl1_fx + 1.5 * pa_z[j] * fl1_fx * pb_yy[j] + pa_zzz[j] * pb_yy[j]);

                t_zzz_yy[j] += fl_s_0_0_1 * (-1.5 * pa_z[j] * fl2_fx - 0.75 * pc_z[j] * fl2_fx - 0.5 * pa_zzz[j] * fl1_fx - 1.5 * pa_zz[j] * pc_z[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pb_y[j] * pc_y[j] - 1.5 * pa_z[j] * fl1_fx * pb_yy[j] - 1.5 * pc_z[j] * fl1_fx * pb_yy[j] - 2.0 * pa_zzz[j] * pb_y[j] * pc_y[j] - 3.0 * pa_zz[j] * pc_z[j] * pb_yy[j]);

                t_zzz_yy[j] += fl_s_0_0_2 * (0.75 * pa_z[j] * fl2_fx + 1.5 * pc_z[j] * fl2_fx + 1.5 * pa_zz[j] * pc_z[j] * fl1_fx + 1.5 * pa_z[j] * pc_zz[j] * fl1_fx + 1.5 * pa_z[j] * fl1_fx * pc_yy[j] + 3.0 * pa_z[j] * fl1_fx * pb_y[j] * pc_y[j] + 3.0 * pc_yz[j] * fl1_fx * pb_y[j] + 1.5 * pc_z[j] * fl1_fx * pb_yy[j] + pa_zzz[j] * pc_yy[j] + 6.0 * pa_zz[j] * pc_yz[j] * pb_y[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_yy[j]);

                t_zzz_yy[j] += fl_s_0_0_3 * (-0.75 * pc_z[j] * fl2_fx - 1.5 * pa_z[j] * pc_zz[j] * fl1_fx - 0.5 * pc_zzz[j] * fl1_fx - 1.5 * pa_z[j] * fl1_fx * pc_yy[j] - 1.5 * pc_yyz[j] * fl1_fx - 3.0 * pc_yz[j] * fl1_fx * pb_y[j] - 3.0 * pa_zz[j] * pc_yyz[j] - 6.0 * pa_z[j] * pc_yzz[j] * pb_y[j] - pc_zzz[j] * pb_yy[j]);

                t_zzz_yy[j] += fl_s_0_0_4 * (0.5 * pc_zzz[j] * fl1_fx + 1.5 * pc_yyz[j] * fl1_fx + 3.0 * pa_z[j] * pc_yyzz[j] + 2.0 * pc_yzzz[j] * pb_y[j]);

                t_zzz_yy[j] += -fl_s_0_0_5 * pc_yyzzz[j];

                t_zzz_yz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_y[j] + 1.5 * pa_zz[j] * fl1_fx * pb_y[j] + 1.5 * pa_z[j] * fl1_fx * pb_yz[j] + pa_zzz[j] * pb_yz[j]);

                t_zzz_yz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pc_y[j] - 1.5 * fl2_fx * pb_y[j] - 1.5 * pa_zz[j] * fl1_fx * pc_y[j] - 1.5 * pa_zz[j] * fl1_fx * pb_y[j] - 4.5 * pa_z[j] * pc_z[j] * fl1_fx * pb_y[j] - 1.5 * pa_z[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_z[j] * fl1_fx * pb_yz[j] - 1.5 * pc_z[j] * fl1_fx * pb_yz[j] - pa_zzz[j] * pb_y[j] * pc_z[j] - pa_zzz[j] * pc_y[j] * pb_z[j] - 3.0 * pa_zz[j] * pc_z[j] * pb_yz[j]);

                t_zzz_yz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pc_y[j] + 0.75 * fl2_fx * pb_y[j] + 1.5 * pa_zz[j] * fl1_fx * pc_y[j] + 4.5 * pa_z[j] * pc_yz[j] * fl1_fx + 4.5 * pa_z[j] * pc_z[j] * fl1_fx * pb_y[j] + 3.0 * pc_zz[j] * fl1_fx * pb_y[j] + 1.5 * pa_z[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pc_z[j] * fl1_fx * pb_yz[j] + pa_zzz[j] * pc_yz[j] + 3.0 * pa_zz[j] * pc_zz[j] * pb_y[j] + 3.0 * pa_zz[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_yz[j]);

                t_zzz_yz[j] += fl_s_0_0_3 * (-0.75 * fl2_fx * pc_y[j] - 4.5 * pa_z[j] * pc_yz[j] * fl1_fx - 3.0 * pc_yzz[j] * fl1_fx - 3.0 * pc_zz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_z[j] - 3.0 * pa_zz[j] * pc_yzz[j] - 3.0 * pa_z[j] * pc_zzz[j] * pb_y[j] - 3.0 * pa_z[j] * pc_yzz[j] * pb_z[j] - pc_zzz[j] * pb_yz[j]);

                t_zzz_yz[j] += fl_s_0_0_4 * (3.0 * pc_yzz[j] * fl1_fx + 3.0 * pa_z[j] * pc_yzzz[j] + pc_zzzz[j] * pb_y[j] + pc_yzzz[j] * pb_z[j]);

                t_zzz_yz[j] += -fl_s_0_0_5 * pc_yzzzz[j];

                t_zzz_zz[j] = fl_s_0_0_0 * (2.25 * pa_z[j] * fl2_fx + 1.5 * fl2_fx * pb_z[j] + 0.5 * pa_zzz[j] * fl1_fx + 3.0 * pa_zz[j] * fl1_fx * pb_z[j] + 1.5 * pa_z[j] * fl1_fx * pb_zz[j] + pa_zzz[j] * pb_zz[j]);

                t_zzz_zz[j] += fl_s_0_0_1 * (-4.5 * pa_z[j] * fl2_fx - 3.75 * pc_z[j] * fl2_fx - 3.0 * fl2_fx * pb_z[j] - 0.5 * pa_zzz[j] * fl1_fx - 4.5 * pa_zz[j] * pc_z[j] * fl1_fx - 3.0 * pa_zz[j] * fl1_fx * pb_z[j] - 9.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_z[j] - 1.5 * pa_z[j] * fl1_fx * pb_zz[j] - 1.5 * pc_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_zzz[j] * pb_z[j] * pc_z[j] - 3.0 * pa_zz[j] * pc_z[j] * pb_zz[j]);

                t_zzz_zz[j] += fl_s_0_0_2 * (2.25 * pa_z[j] * fl2_fx + 7.5 * pc_z[j] * fl2_fx + 1.5 * fl2_fx * pb_z[j] + 4.5 * pa_zz[j] * pc_z[j] * fl1_fx + 9.0 * pa_z[j] * pc_zz[j] * fl1_fx + 9.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_z[j] + 6.0 * pc_zz[j] * fl1_fx * pb_z[j] + 1.5 * pc_z[j] * fl1_fx * pb_zz[j] + pa_zzz[j] * pc_zz[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_z[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_zz[j]);

                t_zzz_zz[j] += fl_s_0_0_3 * (-3.75 * pc_z[j] * fl2_fx - 9.0 * pa_z[j] * pc_zz[j] * fl1_fx - 5.0 * pc_zzz[j] * fl1_fx - 6.0 * pc_zz[j] * fl1_fx * pb_z[j] - 3.0 * pa_zz[j] * pc_zzz[j] - 6.0 * pa_z[j] * pc_zzz[j] * pb_z[j] - pc_zzz[j] * pb_zz[j]);

                t_zzz_zz[j] += fl_s_0_0_4 * (5.0 * pc_zzz[j] * fl1_fx + 3.0 * pa_z[j] * pc_zzzz[j] + 2.0 * pc_zzzz[j] * pb_z[j]);

                t_zzz_zz[j] += -fl_s_0_0_5 * pc_zzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG(      CMemBlock2D<double>& primBuffer,
                              const CMemBlock2D<double>& auxBuffer,
                              const CMemBlock2D<double>& osFactors,
                              const CMemBlock2D<double>& paDistances,
                              const CMemBlock2D<double>& pbDistances,
                              const CMemBlock2D<double>& pcDistances,
                              const CGtoBlock&           braGtoBlock,
                              const CGtoBlock&           ketGtoBlock,
                              const int32_t              iContrGto)
    {
        npotrecfunc::compNuclearPotentialForDG_0_1(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_1_2(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_2_3(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_3_4(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_4_5(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_5_6(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_6_7(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_7_8(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_8_9(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_9_10(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                    braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_10_11(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_11_12(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_12_13(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_13_14(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_14_15(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_15_16(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_16_17(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_17_18(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_18_19(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_19_20(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_20_21(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_21_22(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_22_23(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_23_24(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_24_25(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_25_26(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_26_27(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_27_28(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_28_29(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_29_30(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_30_31(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_31_32(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_32_33(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_33_34(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_34_35(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_35_36(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_36_37(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_37_38(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_38_39(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_39_40(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_40_41(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_41_42(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_42_43(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_43_44(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_44_45(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_45_46(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_46_47(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_47_48(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_48_49(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_49_50(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_50_51(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_51_52(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_52_53(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_53_54(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_54_55(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_55_56(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_56_57(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_57_58(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_58_59(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_59_60(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_60_61(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_61_62(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_62_63(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_63_64(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_64_65(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_65_66(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_66_67(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_67_68(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_68_69(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_69_70(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_70_71(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_71_72(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_72_73(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_73_74(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_74_75(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_75_76(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_76_77(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_77_78(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_78_79(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_79_80(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_80_81(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_81_82(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_82_83(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_83_84(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_84_85(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_85_86(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_86_87(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_87_88(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_88_89(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForDG_89_90(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 
    }

    void
    compNuclearPotentialForDG_0_1(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (0,1)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxx = pbDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxx = pcDistances.data(83 * idx + 55);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xxxx = primBuffer.data(90 * idx);

            // Batch of Integrals (0,1)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxx, pb_xxxx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxx, pc_xxxxxx, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xx_xxxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xx_xxxx[j] = fl_s_0_0_0 * (1.875 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 6.0 * pa_x[j] * fl2_fx * pb_x[j] + 4.5 * fl2_fx * pb_xx[j] + 3.0 * pa_xx[j] * pb_xx[j] * fl1_fx + 4.0 * pa_x[j] * fl1_fx * pb_xxx[j] + 0.5 * fl1_fx * pb_xxxx[j] + pa_xx[j] * pb_xxxx[j]);

                t_xx_xxxx[j] += fl_s_0_0_1 * (-5.625 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 7.5 * pa_x[j] * pc_x[j] * fl2_fx - 12.0 * pa_x[j] * fl2_fx * pb_x[j] - 15.0 * pc_x[j] * fl2_fx * pb_x[j] - 9.0 * fl2_fx * pb_xx[j] - 3.0 * pa_xx[j] * pb_xx[j] * fl1_fx - 6.0 * pa_xx[j] * pb_x[j] * pc_x[j] * fl1_fx - 18.0 * pa_x[j] * pc_x[j] * pb_xx[j] * fl1_fx - 4.0 * pa_x[j] * fl1_fx * pb_xxx[j] - 6.0 * pc_x[j] * fl1_fx * pb_xxx[j] - 0.5 * fl1_fx * pb_xxxx[j] - 4.0 * pa_xx[j] * pb_xxx[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxxx[j]);

                t_xx_xxxx[j] += fl_s_0_0_2 * (5.625 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 15.0 * pa_x[j] * pc_x[j] * fl2_fx + 6.0 * pa_x[j] * fl2_fx * pb_x[j] + 11.25 * pc_xx[j] * fl2_fx + 30.0 * pc_x[j] * fl2_fx * pb_x[j] + 4.5 * fl2_fx * pb_xx[j] + 6.0 * pa_xx[j] * pb_x[j] * pc_x[j] * fl1_fx + 3.0 * pa_xx[j] * pc_xx[j] * fl1_fx + 18.0 * pa_x[j] * pc_x[j] * pb_xx[j] * fl1_fx + 24.0 * pa_x[j] * pc_xx[j] * pb_x[j] * fl1_fx + 18.0 * pc_xx[j] * pb_xx[j] * fl1_fx + 6.0 * pc_x[j] * fl1_fx * pb_xxx[j] + 6.0 * pa_xx[j] * pb_xx[j] * pc_xx[j] + 8.0 * pa_x[j] * pc_xx[j] * pb_xxx[j] + pc_xx[j] * pb_xxxx[j]);

                t_xx_xxxx[j] += fl_s_0_0_3 * (-1.875 * fl3_fx - 7.5 * pa_x[j] * pc_x[j] * fl2_fx - 22.5 * pc_xx[j] * fl2_fx - 15.0 * pc_x[j] * fl2_fx * pb_x[j] - 3.0 * pa_xx[j] * pc_xx[j] * fl1_fx - 24.0 * pa_x[j] * pc_xx[j] * pb_x[j] * fl1_fx - 10.0 * pa_x[j] * pc_xxx[j] * fl1_fx - 18.0 * pc_xx[j] * pb_xx[j] * fl1_fx - 20.0 * pc_xxx[j] * pb_x[j] * fl1_fx - 4.0 * pa_xx[j] * pb_x[j] * pc_xxx[j] - 12.0 * pa_x[j] * pc_xxx[j] * pb_xx[j] - 4.0 * pc_xxx[j] * pb_xxx[j]);

                t_xx_xxxx[j] += fl_s_0_0_4 * (11.25 * pc_xx[j] * fl2_fx + 10.0 * pa_x[j] * pc_xxx[j] * fl1_fx + 20.0 * pc_xxx[j] * pb_x[j] * fl1_fx + 7.5 * pc_xxxx[j] * fl1_fx + pa_xx[j] * pc_xxxx[j] + 8.0 * pa_x[j] * pc_xxxx[j] * pb_x[j] + 6.0 * pc_xxxx[j] * pb_xx[j]);

                t_xx_xxxx[j] += fl_s_0_0_5 * (-7.5 * pc_xxxx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxxx[j] - 4.0 * pc_xxxxx[j] * pb_x[j]);

                t_xx_xxxx[j] += fl_s_0_0_6 * pc_xxxxxx[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_1_2(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (1,2)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxy = pbDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxy = pcDistances.data(83 * idx + 56);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xxxy = primBuffer.data(90 * idx + 1);

            // Batch of Integrals (1,2)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxx, pb_xxxy, pb_xxy, pb_xy, pb_y, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxx, pc_xxxxx, pc_xxxxxy, pc_xxxxy, pc_xxxy, pc_xxy, pc_xy, pc_y, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_xxxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xxxy[j] = fl_s_0_0_0 * (1.5 * pa_x[j] * fl2_fx * pb_y[j] + 2.25 * fl2_fx * pb_xy[j] + 1.5 * pa_xx[j] * pb_xy[j] * fl1_fx + 3.0 * pa_x[j] * fl1_fx * pb_xxy[j] + 0.5 * fl1_fx * pb_xxxy[j] + pa_xx[j] * pb_xxxy[j]);

                t_xx_xxxy[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx * pc_y[j] - 3.0 * pa_x[j] * fl2_fx * pb_y[j] - 3.75 * pc_x[j] * fl2_fx * pb_y[j] - 2.25 * fl2_fx * pb_x[j] * pc_y[j] - 4.5 * fl2_fx * pb_xy[j] - 1.5 * pa_xx[j] * pb_x[j] * fl1_fx * pc_y[j] - 1.5 * pa_xx[j] * pb_xy[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] - 9.0 * pa_x[j] * pc_x[j] * pb_xy[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_xx[j] * pc_y[j] - 3.0 * pa_x[j] * fl1_fx * pb_xxy[j] - 4.5 * pc_x[j] * fl1_fx * pb_xxy[j] - 0.5 * fl1_fx * pb_xxx[j] * pc_y[j] - 0.5 * fl1_fx * pb_xxxy[j] - pa_xx[j] * pb_xxx[j] * pc_y[j] - 3.0 * pa_xx[j] * pb_xxy[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxxy[j]);

                t_xx_xxxy[j] += fl_s_0_0_2 * (3.0 * pa_x[j] * fl2_fx * pc_y[j] + 1.5 * pa_x[j] * fl2_fx * pb_y[j] + 3.75 * pc_xy[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx * pb_y[j] + 4.5 * fl2_fx * pb_x[j] * pc_y[j] + 2.25 * fl2_fx * pb_xy[j] + 1.5 * pa_xx[j] * pb_x[j] * fl1_fx * pc_y[j] + 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] + 9.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx + 9.0 * pa_x[j] * pc_x[j] * pb_xy[j] * fl1_fx + 6.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] + 3.0 * pa_x[j] * fl1_fx * pb_xx[j] * pc_y[j] + 9.0 * pc_xx[j] * pb_xy[j] * fl1_fx + 4.5 * pc_xy[j] * fl1_fx * pb_xx[j] + 4.5 * pc_x[j] * fl1_fx * pb_xxy[j] + 0.5 * fl1_fx * pb_xxx[j] * pc_y[j] + 3.0 * pa_xx[j] * pb_xx[j] * pc_xy[j] + 3.0 * pa_xx[j] * pb_xy[j] * pc_xx[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xxx[j] + 6.0 * pa_x[j] * pc_xx[j] * pb_xxy[j] + pc_xx[j] * pb_xxxy[j]);

                t_xx_xxxy[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl2_fx * pc_y[j] - 7.5 * pc_xy[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pb_y[j] - 2.25 * fl2_fx * pb_x[j] * pc_y[j] - 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 9.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx - 6.0 * pa_x[j] * pc_xxy[j] * fl1_fx - 6.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] - 9.0 * pc_xxy[j] * pb_x[j] * fl1_fx - 9.0 * pc_xx[j] * pb_xy[j] * fl1_fx - 5.0 * pc_xxx[j] * fl1_fx * pb_y[j] - 4.5 * pc_xy[j] * fl1_fx * pb_xx[j] - 3.0 * pa_xx[j] * pb_x[j] * pc_xxy[j] - pa_xx[j] * pc_xxx[j] * pb_y[j] - 6.0 * pa_x[j] * pc_xxy[j] * pb_xx[j] - 6.0 * pa_x[j] * pc_xxx[j] * pb_xy[j] - pc_xxy[j] * pb_xxx[j] - 3.0 * pc_xxx[j] * pb_xxy[j]);

                t_xx_xxxy[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 6.0 * pa_x[j] * pc_xxy[j] * fl1_fx + 9.0 * pc_xxy[j] * pb_x[j] * fl1_fx + 5.0 * pc_xxxy[j] * fl1_fx + 5.0 * pc_xxx[j] * fl1_fx * pb_y[j] + pa_xx[j] * pc_xxxy[j] + 6.0 * pa_x[j] * pc_xxxy[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxxx[j] * pb_y[j] + 3.0 * pc_xxxy[j] * pb_xx[j] + 3.0 * pc_xxxx[j] * pb_xy[j]);

                t_xx_xxxy[j] += fl_s_0_0_5 * (-5.0 * pc_xxxy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxxy[j] - 3.0 * pc_xxxxy[j] * pb_x[j] - pc_xxxxx[j] * pb_y[j]);

                t_xx_xxxy[j] += fl_s_0_0_6 * pc_xxxxxy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_2_3(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (2,3)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxz = pbDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxz = pcDistances.data(83 * idx + 57);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xxxz = primBuffer.data(90 * idx + 2);

            // Batch of Integrals (2,3)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxx, pb_xxxz, pb_xxz, pb_xz, pb_z, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxx, pc_xxxxx, pc_xxxxxz, pc_xxxxz, pc_xxxz, pc_xxz, pc_xz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_xxxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xxxz[j] = fl_s_0_0_0 * (1.5 * pa_x[j] * fl2_fx * pb_z[j] + 2.25 * fl2_fx * pb_xz[j] + 1.5 * pa_xx[j] * pb_xz[j] * fl1_fx + 3.0 * pa_x[j] * fl1_fx * pb_xxz[j] + 0.5 * fl1_fx * pb_xxxz[j] + pa_xx[j] * pb_xxxz[j]);

                t_xx_xxxz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx * pc_z[j] - 3.0 * pa_x[j] * fl2_fx * pb_z[j] - 3.75 * pc_x[j] * fl2_fx * pb_z[j] - 2.25 * fl2_fx * pb_x[j] * pc_z[j] - 4.5 * fl2_fx * pb_xz[j] - 1.5 * pa_xx[j] * pb_x[j] * fl1_fx * pc_z[j] - 1.5 * pa_xx[j] * pb_xz[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] - 9.0 * pa_x[j] * pc_x[j] * pb_xz[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_xx[j] * pc_z[j] - 3.0 * pa_x[j] * fl1_fx * pb_xxz[j] - 4.5 * pc_x[j] * fl1_fx * pb_xxz[j] - 0.5 * fl1_fx * pb_xxx[j] * pc_z[j] - 0.5 * fl1_fx * pb_xxxz[j] - pa_xx[j] * pb_xxx[j] * pc_z[j] - 3.0 * pa_xx[j] * pb_xxz[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxxz[j]);

                t_xx_xxxz[j] += fl_s_0_0_2 * (3.0 * pa_x[j] * fl2_fx * pc_z[j] + 1.5 * pa_x[j] * fl2_fx * pb_z[j] + 3.75 * pc_xz[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx * pb_z[j] + 4.5 * fl2_fx * pb_x[j] * pc_z[j] + 2.25 * fl2_fx * pb_xz[j] + 1.5 * pa_xx[j] * pb_x[j] * fl1_fx * pc_z[j] + 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] + 9.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx + 9.0 * pa_x[j] * pc_x[j] * pb_xz[j] * fl1_fx + 6.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * fl1_fx * pb_xx[j] * pc_z[j] + 9.0 * pc_xx[j] * pb_xz[j] * fl1_fx + 4.5 * pc_xz[j] * fl1_fx * pb_xx[j] + 4.5 * pc_x[j] * fl1_fx * pb_xxz[j] + 0.5 * fl1_fx * pb_xxx[j] * pc_z[j] + 3.0 * pa_xx[j] * pb_xx[j] * pc_xz[j] + 3.0 * pa_xx[j] * pb_xz[j] * pc_xx[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xxx[j] + 6.0 * pa_x[j] * pc_xx[j] * pb_xxz[j] + pc_xx[j] * pb_xxxz[j]);

                t_xx_xxxz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl2_fx * pc_z[j] - 7.5 * pc_xz[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pb_z[j] - 2.25 * fl2_fx * pb_x[j] * pc_z[j] - 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 9.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx - 6.0 * pa_x[j] * pc_xxz[j] * fl1_fx - 6.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - 9.0 * pc_xxz[j] * pb_x[j] * fl1_fx - 9.0 * pc_xx[j] * pb_xz[j] * fl1_fx - 5.0 * pc_xxx[j] * fl1_fx * pb_z[j] - 4.5 * pc_xz[j] * fl1_fx * pb_xx[j] - 3.0 * pa_xx[j] * pb_x[j] * pc_xxz[j] - pa_xx[j] * pc_xxx[j] * pb_z[j] - 6.0 * pa_x[j] * pc_xxz[j] * pb_xx[j] - 6.0 * pa_x[j] * pc_xxx[j] * pb_xz[j] - pc_xxz[j] * pb_xxx[j] - 3.0 * pc_xxx[j] * pb_xxz[j]);

                t_xx_xxxz[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 6.0 * pa_x[j] * pc_xxz[j] * fl1_fx + 9.0 * pc_xxz[j] * pb_x[j] * fl1_fx + 5.0 * pc_xxxz[j] * fl1_fx + 5.0 * pc_xxx[j] * fl1_fx * pb_z[j] + pa_xx[j] * pc_xxxz[j] + 6.0 * pa_x[j] * pc_xxxz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxxx[j] * pb_z[j] + 3.0 * pc_xxxz[j] * pb_xx[j] + 3.0 * pc_xxxx[j] * pb_xz[j]);

                t_xx_xxxz[j] += fl_s_0_0_5 * (-5.0 * pc_xxxz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxxz[j] - 3.0 * pc_xxxxz[j] * pb_x[j] - pc_xxxxx[j] * pb_z[j]);

                t_xx_xxxz[j] += fl_s_0_0_6 * pc_xxxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_3_4(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (3,4)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyy = pbDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyy = pcDistances.data(83 * idx + 58);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xxyy = primBuffer.data(90 * idx + 3);

            // Batch of Integrals (3,4)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxy, pb_xxyy, pb_xy, pb_xyy, pb_y, pb_yy, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, \
                                     pc_xy, pc_xyy, pc_y, pc_yy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xx_xxyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xx_xxyy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pb_yy[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_xx[j] * pb_xx[j] * fl1_fx + 0.5 * pa_xx[j] * fl1_fx * pb_yy[j] + 2.0 * pa_x[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pb_xxyy[j] + pa_xx[j] * pb_xxyy[j]);

                t_xx_xxyy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 0.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 2.0 * pa_x[j] * fl2_fx * pb_x[j] - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 1.5 * fl2_fx * pb_yy[j] - 0.5 * fl2_fx * pb_xx[j] - 0.5 * pa_xx[j] * pb_xx[j] * fl1_fx - pa_xx[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_xx[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pb_yy[j] - pa_x[j] * pc_x[j] * pb_xx[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] - 4.0 * pa_x[j] * fl1_fx * pb_xy[j] * pc_y[j] - 2.0 * pa_x[j] * fl1_fx * pb_xyy[j] - 3.0 * pc_x[j] * fl1_fx * pb_xyy[j] - fl1_fx * pb_xxy[j] * pc_y[j] - 0.5 * fl1_fx * pb_xxyy[j] - 2.0 * pa_xx[j] * pb_xxy[j] * pc_y[j] - 2.0 * pa_xx[j] * pb_xyy[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxyy[j]);

                t_xx_xxyy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_xx[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pc_yy[j] + 3.0 * fl2_fx * pb_y[j] * pc_y[j] + 0.75 * fl2_fx * pb_yy[j] + 0.25 * fl2_fx * pb_xx[j] + pa_xx[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_xx[j] * pc_xx[j] * fl1_fx + 0.5 * pa_xx[j] * fl1_fx * pc_yy[j] + pa_xx[j] * fl1_fx * pb_y[j] * pc_y[j] + pa_x[j] * pc_x[j] * pb_xx[j] * fl1_fx + 2.0 * pa_x[j] * pc_xx[j] * pb_x[j] * fl1_fx + 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] + 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_yy[j] + 4.0 * pa_x[j] * fl1_fx * pb_xy[j] * pc_y[j] + 0.5 * pc_xx[j] * pb_xx[j] * fl1_fx + 3.0 * pc_xx[j] * fl1_fx * pb_yy[j] + 6.0 * pc_xy[j] * fl1_fx * pb_xy[j] + 3.0 * pc_x[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pb_xx[j] * pc_yy[j] + fl1_fx * pb_xxy[j] * pc_y[j] + pa_xx[j] * pb_xx[j] * pc_yy[j] + 4.0 * pa_xx[j] * pb_xy[j] * pc_xy[j] + pa_xx[j] * pc_xx[j] * pb_yy[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_xxy[j] + 4.0 * pa_x[j] * pc_xx[j] * pb_xyy[j] + pc_xx[j] * pb_xxyy[j]);

                t_xx_xxyy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pc_yy[j] - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xx[j] * pc_xx[j] * fl1_fx - 0.5 * pa_xx[j] * fl1_fx * pc_yy[j] - 2.0 * pa_x[j] * pc_xx[j] * pb_x[j] * fl1_fx - pa_x[j] * pc_xxx[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_yy[j] - 0.5 * pc_xx[j] * pb_xx[j] * fl1_fx - pc_xxx[j] * pb_x[j] * fl1_fx - 6.0 * pc_xxy[j] * fl1_fx * pb_y[j] - 3.0 * pc_xx[j] * fl1_fx * pb_yy[j] - 3.0 * pc_xyy[j] * fl1_fx * pb_x[j] - 6.0 * pc_xy[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pb_xx[j] * pc_yy[j] - 2.0 * pa_xx[j] * pb_x[j] * pc_xyy[j] - 2.0 * pa_xx[j] * pc_xxy[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_xx[j] - 8.0 * pa_x[j] * pc_xxy[j] * pb_xy[j] - 2.0 * pa_x[j] * pc_xxx[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pb_xxy[j] - 2.0 * pc_xxx[j] * pb_xyy[j]);

                t_xx_xxyy[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 0.75 * fl2_fx * pc_yy[j] + pa_x[j] * pc_xxx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx + pc_xxx[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 6.0 * pc_xxy[j] * fl1_fx * pb_y[j] + 3.0 * pc_xyy[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xxyy[j] + 4.0 * pa_x[j] * pc_xxyy[j] * pb_x[j] + 4.0 * pa_x[j] * pc_xxxy[j] * pb_y[j] + pc_xxyy[j] * pb_xx[j] + 4.0 * pc_xxxy[j] * pb_xy[j] + pc_xxxx[j] * pb_yy[j]);

                t_xx_xxyy[j] += fl_s_0_0_5 * (-0.5 * pc_xxxx[j] * fl1_fx - 3.0 * pc_xxyy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxyy[j] - 2.0 * pc_xxxyy[j] * pb_x[j] - 2.0 * pc_xxxxy[j] * pb_y[j]);

                t_xx_xxyy[j] += fl_s_0_0_6 * pc_xxxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_4_5(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (4,5)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyz = pbDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xxyz = primBuffer.data(90 * idx + 4);

            // Batch of Integrals (4,5)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxy, pb_xxyz, pb_xxz, pb_xy, pb_xyz, pb_xz, pb_y, \
                                     pb_yz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, \
                                     pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyz, pc_xxz, pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_xxyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xxyz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_yz[j] + 2.0 * pa_x[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pb_xxyz[j] + pa_xx[j] * pb_xxyz[j]);

                t_xx_xxyz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * fl2_fx * pb_yz[j] - 0.5 * pa_xx[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_yz[j] - 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] - 2.0 * pa_x[j] * fl1_fx * pb_xy[j] * pc_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_xz[j] * pc_y[j] - 2.0 * pa_x[j] * fl1_fx * pb_xyz[j] - 3.0 * pc_x[j] * fl1_fx * pb_xyz[j] - 0.5 * fl1_fx * pb_xxy[j] * pc_z[j] - 0.5 * fl1_fx * pb_xxz[j] * pc_y[j] - 0.5 * fl1_fx * pb_xxyz[j] - pa_xx[j] * pb_xxy[j] * pc_z[j] - pa_xx[j] * pb_xxz[j] * pc_y[j] - 2.0 * pa_xx[j] * pb_xyz[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxyz[j]);

                t_xx_xxyz[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pb_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pc_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] + 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_yz[j] + 2.0 * pa_x[j] * fl1_fx * pb_xy[j] * pc_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_xz[j] * pc_y[j] + 3.0 * pc_xx[j] * fl1_fx * pb_yz[j] + 3.0 * pc_xz[j] * fl1_fx * pb_xy[j] + 3.0 * pc_xy[j] * fl1_fx * pb_xz[j] + 3.0 * pc_x[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pb_xx[j] * pc_yz[j] + 0.5 * fl1_fx * pb_xxy[j] * pc_z[j] + 0.5 * fl1_fx * pb_xxz[j] * pc_y[j] + pa_xx[j] * pb_xx[j] * pc_yz[j] + 2.0 * pa_xx[j] * pb_xy[j] * pc_xz[j] + 2.0 * pa_xx[j] * pb_xz[j] * pc_xy[j] + pa_xx[j] * pc_xx[j] * pb_yz[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xxy[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xxz[j] + 4.0 * pa_x[j] * pc_xx[j] * pb_xyz[j] + pc_xx[j] * pb_xxyz[j]);

                t_xx_xxyz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_yz[j] - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_yz[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] - 3.0 * pc_xx[j] * fl1_fx * pb_yz[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xz[j] * fl1_fx * pb_xy[j] - 3.0 * pc_xy[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pb_xx[j] * pc_yz[j] - 2.0 * pa_xx[j] * pb_x[j] * pc_xyz[j] - pa_xx[j] * pc_xxz[j] * pb_y[j] - pa_xx[j] * pc_xxy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_xx[j] - 4.0 * pa_x[j] * pc_xxz[j] * pb_xy[j] - 4.0 * pa_x[j] * pc_xxy[j] * pb_xz[j] - 2.0 * pa_x[j] * pc_xxx[j] * pb_yz[j] - pc_xxz[j] * pb_xxy[j] - pc_xxy[j] * pb_xxz[j] - 2.0 * pc_xxx[j] * pb_xyz[j]);

                t_xx_xxyz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] + 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xxyz[j] + 4.0 * pa_x[j] * pc_xxyz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxxz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xxxy[j] * pb_z[j] + pc_xxyz[j] * pb_xx[j] + 2.0 * pc_xxxz[j] * pb_xy[j] + 2.0 * pc_xxxy[j] * pb_xz[j] + pc_xxxx[j] * pb_yz[j]);

                t_xx_xxyz[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxyz[j] - 2.0 * pc_xxxyz[j] * pb_x[j] - pc_xxxxz[j] * pb_y[j] - pc_xxxxy[j] * pb_z[j]);

                t_xx_xxyz[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_5_6(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (5,6)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxzz = pbDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxzz = pcDistances.data(83 * idx + 60);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xxzz = primBuffer.data(90 * idx + 5);

            // Batch of Integrals (5,6)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xx, pb_xxz, pb_xxzz, pb_xz, pb_xzz, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxz, pc_xxxxzz, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, \
                                     pc_xz, pc_xzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xx_xxzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xx_xxzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pb_zz[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_xx[j] * pb_xx[j] * fl1_fx + 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] + 2.0 * pa_x[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pb_xxzz[j] + pa_xx[j] * pb_xxzz[j]);

                t_xx_xxzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 0.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 2.0 * pa_x[j] * fl2_fx * pb_x[j] - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 1.5 * fl2_fx * pb_zz[j] - 0.5 * fl2_fx * pb_xx[j] - 0.5 * pa_xx[j] * pb_xx[j] * fl1_fx - pa_xx[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] - pa_x[j] * pc_x[j] * pb_xx[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] - 4.0 * pa_x[j] * fl1_fx * pb_xz[j] * pc_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_xzz[j] - 3.0 * pc_x[j] * fl1_fx * pb_xzz[j] - fl1_fx * pb_xxz[j] * pc_z[j] - 0.5 * fl1_fx * pb_xxzz[j] - 2.0 * pa_xx[j] * pb_xxz[j] * pc_z[j] - 2.0 * pa_xx[j] * pb_xzz[j] * pc_x[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xxzz[j]);

                t_xx_xxzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_xx[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pb_z[j] * pc_z[j] + 0.75 * fl2_fx * pb_zz[j] + 0.25 * fl2_fx * pb_xx[j] + pa_xx[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_xx[j] * pc_xx[j] * fl1_fx + 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] + pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] + pa_x[j] * pc_x[j] * pb_xx[j] * fl1_fx + 2.0 * pa_x[j] * pc_xx[j] * pb_x[j] * fl1_fx + 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] + 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_zz[j] + 4.0 * pa_x[j] * fl1_fx * pb_xz[j] * pc_z[j] + 0.5 * pc_xx[j] * pb_xx[j] * fl1_fx + 3.0 * pc_xx[j] * fl1_fx * pb_zz[j] + 6.0 * pc_xz[j] * fl1_fx * pb_xz[j] + 3.0 * pc_x[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pb_xx[j] * pc_zz[j] + fl1_fx * pb_xxz[j] * pc_z[j] + pa_xx[j] * pb_xx[j] * pc_zz[j] + 4.0 * pa_xx[j] * pb_xz[j] * pc_xz[j] + pa_xx[j] * pc_xx[j] * pb_zz[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_xxz[j] + 4.0 * pa_x[j] * pc_xx[j] * pb_xzz[j] + pc_xx[j] * pb_xxzz[j]);

                t_xx_xxzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xx[j] * pc_xx[j] * fl1_fx - 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] - 2.0 * pa_x[j] * pc_xx[j] * pb_x[j] * fl1_fx - pa_x[j] * pc_xxx[j] * fl1_fx - 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_x[j] * pc_zz[j] - 0.5 * pc_xx[j] * pb_xx[j] * fl1_fx - pc_xxx[j] * pb_x[j] * fl1_fx - 6.0 * pc_xxz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xx[j] * fl1_fx * pb_zz[j] - 3.0 * pc_xzz[j] * fl1_fx * pb_x[j] - 6.0 * pc_xz[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pb_xx[j] * pc_zz[j] - 2.0 * pa_xx[j] * pb_x[j] * pc_xzz[j] - 2.0 * pa_xx[j] * pc_xxz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_xx[j] - 8.0 * pa_x[j] * pc_xxz[j] * pb_xz[j] - 2.0 * pa_x[j] * pc_xxx[j] * pb_zz[j] - 2.0 * pc_xxz[j] * pb_xxz[j] - 2.0 * pc_xxx[j] * pb_xzz[j]);

                t_xx_xxzz[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 0.75 * fl2_fx * pc_zz[j] + pa_x[j] * pc_xxx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx + pc_xxx[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 6.0 * pc_xxz[j] * fl1_fx * pb_z[j] + 3.0 * pc_xzz[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xxzz[j] + 4.0 * pa_x[j] * pc_xxzz[j] * pb_x[j] + 4.0 * pa_x[j] * pc_xxxz[j] * pb_z[j] + pc_xxzz[j] * pb_xx[j] + 4.0 * pc_xxxz[j] * pb_xz[j] + pc_xxxx[j] * pb_zz[j]);

                t_xx_xxzz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxx[j] * fl1_fx - 3.0 * pc_xxzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxzz[j] - 2.0 * pc_xxxzz[j] * pb_x[j] - 2.0 * pc_xxxxz[j] * pb_z[j]);

                t_xx_xxzz[j] += fl_s_0_0_6 * pc_xxxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_6_7(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (6,7)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyy = pbDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyy = pcDistances.data(83 * idx + 61);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xyyy = primBuffer.data(90 * idx + 6);

            // Batch of Integrals (6,7)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xy, pb_xyy, pb_xyyy, pb_y, pb_yy, pb_yyy, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyy, pc_xxy, pc_xxyy, pc_xxyyy, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_y, pc_yy, pc_yyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xx_xyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xyyy[j] = fl_s_0_0_0 * (1.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_xx[j] * pb_xy[j] * fl1_fx + pa_x[j] * fl1_fx * pb_yyy[j] + 0.5 * fl1_fx * pb_xyyy[j] + pa_xx[j] * pb_xyyy[j]);

                t_xx_xyyy[j] += fl_s_0_0_1 * (-3.0 * pa_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_x[j] * fl2_fx * pc_y[j] - 2.25 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pb_xy[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 1.5 * pa_xx[j] * pb_xy[j] * fl1_fx - 1.5 * pa_xx[j] * pb_x[j] * pc_y[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * pb_xy[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_yy[j] * pc_y[j] - pa_x[j] * fl1_fx * pb_yyy[j] - 1.5 * pc_x[j] * fl1_fx * pb_yyy[j] - 1.5 * fl1_fx * pb_xyy[j] * pc_y[j] - 0.5 * fl1_fx * pb_xyyy[j] - 3.0 * pa_xx[j] * pb_xyy[j] * pc_y[j] - pa_xx[j] * pc_x[j] * pb_yyy[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xyyy[j]);

                t_xx_xyyy[j] += fl_s_0_0_2 * (3.0 * pa_x[j] * fl2_fx * pc_y[j] + 1.5 * pa_x[j] * fl2_fx * pb_y[j] + 4.5 * pc_x[j] * fl2_fx * pb_y[j] + 2.25 * pc_xy[j] * fl2_fx + 1.5 * fl2_fx * pb_x[j] * pc_y[j] + 0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_xx[j] * pb_x[j] * pc_y[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * pb_y[j] * fl1_fx + 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * pb_xy[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx + 3.0 * pa_x[j] * pc_xx[j] * pb_y[j] * fl1_fx + 3.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_yy[j] + 3.0 * pa_x[j] * fl1_fx * pb_yy[j] * pc_y[j] + 1.5 * pc_xx[j] * pb_xy[j] * fl1_fx + 4.5 * pc_xy[j] * fl1_fx * pb_yy[j] + 1.5 * pc_x[j] * fl1_fx * pb_yyy[j] + 1.5 * fl1_fx * pb_xy[j] * pc_yy[j] + 1.5 * fl1_fx * pb_xyy[j] * pc_y[j] + 3.0 * pa_xx[j] * pb_xy[j] * pc_yy[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_yy[j] + 6.0 * pa_x[j] * pc_xy[j] * pb_xyy[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_yyy[j] + pc_xx[j] * pb_xyyy[j]);

                t_xx_xyyy[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl2_fx * pc_y[j] - 4.5 * pc_xy[j] * fl2_fx - 2.25 * pc_x[j] * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx - 3.0 * pa_x[j] * pc_xx[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxy[j] * fl1_fx - pa_x[j] * fl1_fx * pc_yyy[j] - 3.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_yy[j] - 1.5 * pc_xx[j] * pb_xy[j] * fl1_fx - 1.5 * pc_xxy[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxx[j] * pb_y[j] * fl1_fx - 4.5 * pc_xyy[j] * fl1_fx * pb_y[j] - 4.5 * pc_xy[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pb_x[j] * pc_yyy[j] - 1.5 * fl1_fx * pb_xy[j] * pc_yy[j] - pa_xx[j] * pb_x[j] * pc_yyy[j] - 3.0 * pa_xx[j] * pc_xyy[j] * pb_y[j] - 6.0 * pa_x[j] * pc_xyy[j] * pb_xy[j] - 6.0 * pa_x[j] * pc_xxy[j] * pb_yy[j] - 3.0 * pc_xxy[j] * pb_xyy[j] - pc_xxx[j] * pb_yyy[j]);

                t_xx_xyyy[j] += fl_s_0_0_4 * (2.25 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_xxy[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yyy[j] + 1.5 * pc_xxy[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxx[j] * pb_y[j] * fl1_fx + 1.5 * pc_xxxy[j] * fl1_fx + 1.5 * pc_xyyy[j] * fl1_fx + 4.5 * pc_xyy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pb_x[j] * pc_yyy[j] + pa_xx[j] * pc_xyyy[j] + 2.0 * pa_x[j] * pc_xyyy[j] * pb_x[j] + 6.0 * pa_x[j] * pc_xxyy[j] * pb_y[j] + 3.0 * pc_xxyy[j] * pb_xy[j] + 3.0 * pc_xxxy[j] * pb_yy[j]);

                t_xx_xyyy[j] += fl_s_0_0_5 * (-1.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyyy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyyy[j] - pc_xxyyy[j] * pb_x[j] - 3.0 * pc_xxxyy[j] * pb_y[j]);

                t_xx_xyyy[j] += fl_s_0_0_6 * pc_xxxyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_7_8(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (7,8)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyz = pbDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xyyz = primBuffer.data(90 * idx + 7);

            // Batch of Integrals (7,8)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xy, pb_xyy, pb_xyyz, pb_xyz, pb_xz, pb_y, pb_yy, pb_yyz, \
                                     pb_yz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, \
                                     pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, \
                                     pc_y, pc_yy, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xx_xyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xyyz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_xx[j] * pb_xz[j] * fl1_fx + pa_x[j] * fl1_fx * pb_yyz[j] + 0.5 * fl1_fx * pb_xyyz[j] + pa_xx[j] * pb_xyyz[j]);

                t_xx_xyyz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx * pc_z[j] - pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 0.25 * fl2_fx * pb_x[j] * pc_z[j] - 0.5 * fl2_fx * pb_xz[j] - 0.5 * pa_xx[j] * pb_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_xx[j] * pb_xz[j] * fl1_fx - 0.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] - pa_x[j] * pc_x[j] * pb_xz[j] * fl1_fx - pa_x[j] * fl1_fx * pb_yy[j] * pc_z[j] - 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_y[j] - pa_x[j] * fl1_fx * pb_yyz[j] - 1.5 * pc_x[j] * fl1_fx * pb_yyz[j] - 0.5 * fl1_fx * pb_xyy[j] * pc_z[j] - fl1_fx * pb_xyz[j] * pc_y[j] - 0.5 * fl1_fx * pb_xyyz[j] - pa_xx[j] * pb_xyy[j] * pc_z[j] - 2.0 * pa_xx[j] * pb_xyz[j] * pc_y[j] - pa_xx[j] * pc_x[j] * pb_yyz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xyyz[j]);

                t_xx_xyyz[j] += fl_s_0_0_2 * (pa_x[j] * fl2_fx * pc_z[j] + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pb_x[j] * pc_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_xx[j] * pb_x[j] * fl1_fx * pc_z[j] + 0.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 0.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_x[j] * pb_xz[j] * fl1_fx + pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_yz[j] + pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] + pa_x[j] * fl1_fx * pb_yy[j] * pc_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_y[j] + 0.5 * pc_xx[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] + 3.0 * pc_xy[j] * fl1_fx * pb_yz[j] + 1.5 * pc_x[j] * fl1_fx * pb_yyz[j] + fl1_fx * pb_xy[j] * pc_yz[j] + 0.5 * fl1_fx * pb_xz[j] * pc_yy[j] + 0.5 * fl1_fx * pb_xyy[j] * pc_z[j] + fl1_fx * pb_xyz[j] * pc_y[j] + 2.0 * pa_xx[j] * pb_xy[j] * pc_yz[j] + pa_xx[j] * pb_xz[j] * pc_yy[j] + pa_xx[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_xx[j] * pc_xy[j] * pb_yz[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xyy[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_xyz[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_yyz[j] + pc_xx[j] * pb_xyyz[j]);

                t_xx_xyyz[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 0.25 * fl2_fx * pb_x[j] * pc_z[j] - 0.5 * pa_xx[j] * pc_xz[j] * fl1_fx - pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx - pa_x[j] * pc_xxz[j] * fl1_fx - pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pc_yyz[j] - 2.0 * pa_x[j] * fl1_fx * pb_y[j] * pc_yz[j] - pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] - 0.5 * pc_xxz[j] * pb_x[j] * fl1_fx - 0.5 * pc_xx[j] * pb_xz[j] * fl1_fx - 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] - 3.0 * pc_xy[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pb_x[j] * pc_yyz[j] - fl1_fx * pb_xy[j] * pc_yz[j] - 0.5 * fl1_fx * pb_xz[j] * pc_yy[j] - pa_xx[j] * pb_x[j] * pc_yyz[j] - 2.0 * pa_xx[j] * pc_xyz[j] * pb_y[j] - pa_xx[j] * pc_xyy[j] * pb_z[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_xy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_xz[j] - 2.0 * pa_x[j] * pc_xxz[j] * pb_yy[j] - 4.0 * pa_x[j] * pc_xxy[j] * pb_yz[j] - pc_xxz[j] * pb_xyy[j] - 2.0 * pc_xxy[j] * pb_xyz[j] - pc_xxx[j] * pb_yyz[j]);

                t_xx_xyyz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + pa_x[j] * pc_xxz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yyz[j] + 0.5 * pc_xxz[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxxz[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] + 1.5 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_x[j] * pc_yyz[j] + pa_xx[j] * pc_xyyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_x[j] + 4.0 * pa_x[j] * pc_xxyz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xxyy[j] * pb_z[j] + 2.0 * pc_xxyz[j] * pb_xy[j] + pc_xxyy[j] * pb_xz[j] + pc_xxxz[j] * pb_yy[j] + 2.0 * pc_xxxy[j] * pb_yz[j]);

                t_xx_xyyz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyyz[j] - pc_xxyyz[j] * pb_x[j] - 2.0 * pc_xxxyz[j] * pb_y[j] - pc_xxxyy[j] * pb_z[j]);

                t_xx_xyyz[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_8_9(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (8,9)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyzz = pbDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xyzz = primBuffer.data(90 * idx + 8);

            // Batch of Integrals (8,9)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xy, pb_xyz, pb_xyzz, pb_xz, pb_xzz, pb_y, pb_yz, pb_yzz, \
                                     pb_z, pb_zz, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, \
                                     pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, \
                                     pc_y, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xx_xyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xyzz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_xx[j] * pb_xy[j] * fl1_fx + pa_x[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pb_xyzz[j] + pa_xx[j] * pb_xyzz[j]);

                t_xx_xyzz[j] += fl_s_0_0_1 * (-pa_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_x[j] * fl2_fx * pc_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * fl2_fx * pb_xy[j] - 0.25 * fl2_fx * pb_x[j] * pc_y[j] - 0.5 * pa_xx[j] * pb_xy[j] * fl1_fx - 0.5 * pa_xx[j] * pb_x[j] * pc_y[j] * fl1_fx - 0.5 * pa_xx[j] * pc_x[j] * pb_y[j] * fl1_fx - pa_x[j] * pc_x[j] * pb_xy[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_z[j] - pa_x[j] * fl1_fx * pc_y[j] * pb_zz[j] - pa_x[j] * fl1_fx * pb_yzz[j] - 1.5 * pc_x[j] * fl1_fx * pb_yzz[j] - fl1_fx * pb_xyz[j] * pc_z[j] - 0.5 * fl1_fx * pb_xzz[j] * pc_y[j] - 0.5 * fl1_fx * pb_xyzz[j] - 2.0 * pa_xx[j] * pb_xyz[j] * pc_z[j] - pa_xx[j] * pb_xzz[j] * pc_y[j] - pa_xx[j] * pc_x[j] * pb_yzz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xyzz[j]);

                t_xx_xyzz[j] += fl_s_0_0_2 * (pa_x[j] * fl2_fx * pc_y[j] + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 0.5 * fl2_fx * pb_x[j] * pc_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_xx[j] * pb_x[j] * pc_y[j] * fl1_fx + 0.5 * pa_xx[j] * pc_x[j] * pb_y[j] * fl1_fx + 0.5 * pa_xx[j] * pc_xy[j] * fl1_fx + pa_x[j] * pc_x[j] * pb_xy[j] * fl1_fx + pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_xx[j] * pb_y[j] * fl1_fx + pa_x[j] * fl1_fx * pb_y[j] * pc_zz[j] + 2.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_z[j] + pa_x[j] * fl1_fx * pc_y[j] * pb_zz[j] + 0.5 * pc_xx[j] * pb_xy[j] * fl1_fx + 3.0 * pc_xz[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pb_xy[j] * pc_zz[j] + fl1_fx * pb_xz[j] * pc_yz[j] + fl1_fx * pb_xyz[j] * pc_z[j] + 0.5 * fl1_fx * pb_xzz[j] * pc_y[j] + pa_xx[j] * pb_xy[j] * pc_zz[j] + 2.0 * pa_xx[j] * pb_xz[j] * pc_yz[j] + 2.0 * pa_xx[j] * pc_xz[j] * pb_yz[j] + pa_xx[j] * pc_xy[j] * pb_zz[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_xyz[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xzz[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_yzz[j] + pc_xx[j] * pb_xyzz[j]);

                t_xx_xyzz[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 0.25 * fl2_fx * pb_x[j] * pc_y[j] - 0.5 * pa_xx[j] * pc_xy[j] * fl1_fx - pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx - pa_x[j] * pc_xx[j] * pb_y[j] * fl1_fx - pa_x[j] * pc_xxy[j] * fl1_fx - pa_x[j] * fl1_fx * pc_yzz[j] - pa_x[j] * fl1_fx * pb_y[j] * pc_zz[j] - 2.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] - 0.5 * pc_xx[j] * pb_xy[j] * fl1_fx - 0.5 * pc_xxy[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * pb_y[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xz[j] * fl1_fx * pb_yz[j] - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pb_x[j] * pc_yzz[j] - 0.5 * fl1_fx * pb_xy[j] * pc_zz[j] - fl1_fx * pb_xz[j] * pc_yz[j] - pa_xx[j] * pb_x[j] * pc_yzz[j] - pa_xx[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_xx[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_xy[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_xz[j] - 4.0 * pa_x[j] * pc_xxz[j] * pb_yz[j] - 2.0 * pa_x[j] * pc_xxy[j] * pb_zz[j] - 2.0 * pc_xxz[j] * pb_xyz[j] - pc_xxy[j] * pb_xzz[j] - pc_xxx[j] * pb_yzz[j]);

                t_xx_xyzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + pa_x[j] * pc_xxy[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yzz[j] + 0.5 * pc_xxy[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxx[j] * pb_y[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_x[j] * pc_yzz[j] + pa_xx[j] * pc_xyzz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxzz[j] * pb_y[j] + 4.0 * pa_x[j] * pc_xxyz[j] * pb_z[j] + pc_xxzz[j] * pb_xy[j] + 2.0 * pc_xxyz[j] * pb_xz[j] + 2.0 * pc_xxxz[j] * pb_yz[j] + pc_xxxy[j] * pb_zz[j]);

                t_xx_xyzz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyzz[j] - pc_xxyzz[j] * pb_x[j] - pc_xxxzz[j] * pb_y[j] - 2.0 * pc_xxxyz[j] * pb_z[j]);

                t_xx_xyzz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_9_10(      CMemBlock2D<double>& primBuffer,
                                   const CMemBlock2D<double>& auxBuffer,
                                   const CMemBlock2D<double>& osFactors,
                                   const CMemBlock2D<double>& paDistances,
                                   const CMemBlock2D<double>& pbDistances,
                                   const CMemBlock2D<double>& pcDistances,
                                   const CGtoBlock&           braGtoBlock,
                                   const CGtoBlock&           ketGtoBlock,
                                   const int32_t              iContrGto)
    {
        // Batch of Integrals (9,10)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xzzz = pbDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxzzz = pcDistances.data(83 * idx + 64);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_xzzz = primBuffer.data(90 * idx + 9);

            // Batch of Integrals (9,10)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_x, pb_xz, pb_xzz, pb_xzzz, pb_z, pb_zz, pb_zzz, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxz, pc_xxxzz, pc_xxxzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xx_xzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_xzzz[j] = fl_s_0_0_0 * (1.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_xx[j] * pb_xz[j] * fl1_fx + pa_x[j] * fl1_fx * pb_zzz[j] + 0.5 * fl1_fx * pb_xzzz[j] + pa_xx[j] * pb_xzzz[j]);

                t_xx_xzzz[j] += fl_s_0_0_1 * (-3.0 * pa_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_x[j] * fl2_fx * pc_z[j] - 2.25 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pb_xz[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 1.5 * pa_xx[j] * pb_xz[j] * fl1_fx - 1.5 * pa_xx[j] * pb_x[j] * pc_z[j] * fl1_fx - 1.5 * pa_xx[j] * pc_x[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * pb_xz[j] * fl1_fx - 3.0 * pa_x[j] * fl1_fx * pb_zz[j] * pc_z[j] - pa_x[j] * fl1_fx * pb_zzz[j] - 1.5 * pc_x[j] * fl1_fx * pb_zzz[j] - 1.5 * fl1_fx * pb_xzz[j] * pc_z[j] - 0.5 * fl1_fx * pb_xzzz[j] - 3.0 * pa_xx[j] * pb_xzz[j] * pc_z[j] - pa_xx[j] * pc_x[j] * pb_zzz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_xzzz[j]);

                t_xx_xzzz[j] += fl_s_0_0_2 * (3.0 * pa_x[j] * fl2_fx * pc_z[j] + 1.5 * pa_x[j] * fl2_fx * pb_z[j] + 4.5 * pc_x[j] * fl2_fx * pb_z[j] + 2.25 * pc_xz[j] * fl2_fx + 1.5 * fl2_fx * pb_x[j] * pc_z[j] + 0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_xx[j] * pb_x[j] * pc_z[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * pb_z[j] * fl1_fx + 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * pb_xz[j] * fl1_fx + 3.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx + 3.0 * pa_x[j] * pc_xx[j] * pb_z[j] * fl1_fx + 3.0 * pa_x[j] * fl1_fx * pb_z[j] * pc_zz[j] + 3.0 * pa_x[j] * fl1_fx * pb_zz[j] * pc_z[j] + 1.5 * pc_xx[j] * pb_xz[j] * fl1_fx + 4.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * fl1_fx * pb_zzz[j] + 1.5 * fl1_fx * pb_xz[j] * pc_zz[j] + 1.5 * fl1_fx * pb_xzz[j] * pc_z[j] + 3.0 * pa_xx[j] * pb_xz[j] * pc_zz[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_zz[j] + 6.0 * pa_x[j] * pc_xz[j] * pb_xzz[j] + 2.0 * pa_x[j] * pc_xx[j] * pb_zzz[j] + pc_xx[j] * pb_xzzz[j]);

                t_xx_xzzz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl2_fx * pc_z[j] - 4.5 * pc_xz[j] * fl2_fx - 2.25 * pc_x[j] * fl2_fx * pb_z[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx - 3.0 * pa_x[j] * pc_xx[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxz[j] * fl1_fx - pa_x[j] * fl1_fx * pc_zzz[j] - 3.0 * pa_x[j] * fl1_fx * pb_z[j] * pc_zz[j] - 1.5 * pc_xx[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xxz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxx[j] * pb_z[j] * fl1_fx - 4.5 * pc_xzz[j] * fl1_fx * pb_z[j] - 4.5 * pc_xz[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pb_x[j] * pc_zzz[j] - 1.5 * fl1_fx * pb_xz[j] * pc_zz[j] - pa_xx[j] * pb_x[j] * pc_zzz[j] - 3.0 * pa_xx[j] * pc_xzz[j] * pb_z[j] - 6.0 * pa_x[j] * pc_xzz[j] * pb_xz[j] - 6.0 * pa_x[j] * pc_xxz[j] * pb_zz[j] - 3.0 * pc_xxz[j] * pb_xzz[j] - pc_xxx[j] * pb_zzz[j]);

                t_xx_xzzz[j] += fl_s_0_0_4 * (2.25 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_xxz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_zzz[j] + 1.5 * pc_xxz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxx[j] * pb_z[j] * fl1_fx + 1.5 * pc_xxxz[j] * fl1_fx + 1.5 * pc_xzzz[j] * fl1_fx + 4.5 * pc_xzz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_x[j] * pc_zzz[j] + pa_xx[j] * pc_xzzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] * pb_x[j] + 6.0 * pa_x[j] * pc_xxzz[j] * pb_z[j] + 3.0 * pc_xxzz[j] * pb_xz[j] + 3.0 * pc_xxxz[j] * pb_zz[j]);

                t_xx_xzzz[j] += fl_s_0_0_5 * (-1.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xzzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxzzz[j] - pc_xxzzz[j] * pb_x[j] - 3.0 * pc_xxxzz[j] * pb_z[j]);

                t_xx_xzzz[j] += fl_s_0_0_6 * pc_xxxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_10_11(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (10,11)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyy = pbDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyy = pcDistances.data(83 * idx + 65);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_yyyy = primBuffer.data(90 * idx + 10);

            // Batch of Integrals (10,11)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_y, pb_yy, pb_yyy, pb_yyyy, pc_x, pc_xx, pc_xxy, pc_xxyy, \
                                     pc_xxyyy, pc_xxyyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_yyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xx_yyyy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 1.5 * fl2_fx * pb_yy[j] + 3.0 * pa_xx[j] * pb_yy[j] * fl1_fx + 0.5 * fl1_fx * pb_yyyy[j] + pa_xx[j] * pb_yyyy[j]);

                t_xx_yyyy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * fl2_fx * pb_yy[j] - 3.0 * fl2_fx * pb_y[j] * pc_y[j] - 3.0 * pa_xx[j] * pb_yy[j] * fl1_fx - 6.0 * pa_xx[j] * pb_y[j] * pc_y[j] * fl1_fx - 6.0 * pa_x[j] * pc_x[j] * pb_yy[j] * fl1_fx - 2.0 * fl1_fx * pb_yyy[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyyy[j] - 4.0 * pa_xx[j] * pb_yyy[j] * pc_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yyyy[j]);

                t_xx_yyyy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + 0.75 * pc_xx[j] * fl2_fx + 6.0 * fl2_fx * pb_y[j] * pc_y[j] + 1.5 * fl2_fx * pc_yy[j] + 1.5 * fl2_fx * pb_yy[j] + 6.0 * pa_xx[j] * pb_y[j] * pc_y[j] * fl1_fx + 3.0 * pa_xx[j] * pc_yy[j] * fl1_fx + 6.0 * pa_x[j] * pc_x[j] * pb_yy[j] * fl1_fx + 12.0 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx + 3.0 * pc_xx[j] * pb_yy[j] * fl1_fx + 3.0 * fl1_fx * pb_yy[j] * pc_yy[j] + 2.0 * fl1_fx * pb_yyy[j] * pc_y[j] + 6.0 * pa_xx[j] * pb_yy[j] * pc_yy[j] + 8.0 * pa_x[j] * pc_xy[j] * pb_yyy[j] + pc_xx[j] * pb_yyyy[j]);

                t_xx_yyyy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 1.5 * pc_xx[j] * fl2_fx - 3.0 * fl2_fx * pc_yy[j] - 3.0 * fl2_fx * pb_y[j] * pc_y[j] - 3.0 * pa_xx[j] * pc_yy[j] * fl1_fx - 12.0 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx - 6.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 3.0 * pc_xx[j] * pb_yy[j] * fl1_fx - 6.0 * pc_xxy[j] * pb_y[j] * fl1_fx - 2.0 * fl1_fx * pb_y[j] * pc_yyy[j] - 3.0 * fl1_fx * pb_yy[j] * pc_yy[j] - 4.0 * pa_xx[j] * pb_y[j] * pc_yyy[j] - 12.0 * pa_x[j] * pc_xyy[j] * pb_yy[j] - 4.0 * pc_xxy[j] * pb_yyy[j]);

                t_xx_yyyy[j] += fl_s_0_0_4 * (0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pc_yy[j] + 6.0 * pa_x[j] * pc_xyy[j] * fl1_fx + 6.0 * pc_xxy[j] * pb_y[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 0.5 * fl1_fx * pc_yyyy[j] + 2.0 * fl1_fx * pb_y[j] * pc_yyy[j] + pa_xx[j] * pc_yyyy[j] + 8.0 * pa_x[j] * pc_xyyy[j] * pb_y[j] + 6.0 * pc_xxyy[j] * pb_yy[j]);

                t_xx_yyyy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyy[j] - 2.0 * pa_x[j] * pc_xyyyy[j] - 4.0 * pc_xxyyy[j] * pb_y[j]);

                t_xx_yyyy[j] += fl_s_0_0_6 * pc_xxyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_11_12(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (11,12)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyz = pbDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_yyyz = primBuffer.data(90 * idx + 11);

            // Batch of Integrals (11,12)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_y, pb_yy, pb_yyy, pb_yyyz, pb_yyz, pb_yz, pb_z, pc_x, pc_xx, \
                                     pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyz, pc_yz, \
                                     pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_yyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_yyyz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_xx[j] * pb_yz[j] * fl1_fx + 0.5 * fl1_fx * pb_yyyz[j] + pa_xx[j] * pb_yyyz[j]);

                t_xx_yyyz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_y[j] * pc_z[j] - 1.5 * fl2_fx * pb_yz[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * pb_y[j] * fl1_fx * pc_z[j] - 1.5 * pa_xx[j] * pb_yz[j] * fl1_fx - 1.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_z[j] - 3.0 * pa_x[j] * pc_x[j] * pb_yz[j] * fl1_fx - 0.5 * fl1_fx * pb_yyy[j] * pc_z[j] - 1.5 * fl1_fx * pb_yyz[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyyz[j] - pa_xx[j] * pb_yyy[j] * pc_z[j] - 3.0 * pa_xx[j] * pb_yyz[j] * pc_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yyyz[j]);

                t_xx_yyyz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pb_y[j] * pc_z[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_xx[j] * pb_y[j] * fl1_fx * pc_z[j] + 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx + 1.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * pb_yz[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_xx[j] * pb_yz[j] * fl1_fx + 1.5 * fl1_fx * pb_yy[j] * pc_yz[j] + 1.5 * fl1_fx * pb_yz[j] * pc_yy[j] + 0.5 * fl1_fx * pb_yyy[j] * pc_z[j] + 1.5 * fl1_fx * pb_yyz[j] * pc_y[j] + 3.0 * pa_xx[j] * pb_yy[j] * pc_yz[j] + 3.0 * pa_xx[j] * pb_yz[j] * pc_yy[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_yyy[j] + 6.0 * pa_x[j] * pc_xy[j] * pb_yyz[j] + pc_xx[j] * pb_yyyz[j]);

                t_xx_yyyz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx - 1.5 * pc_xx[j] * pb_yz[j] * fl1_fx - 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] - 1.5 * fl1_fx * pb_y[j] * pc_yyz[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] - 1.5 * fl1_fx * pb_yy[j] * pc_yz[j] - 1.5 * fl1_fx * pb_yz[j] * pc_yy[j] - 3.0 * pa_xx[j] * pb_y[j] * pc_yyz[j] - pa_xx[j] * pc_yyy[j] * pb_z[j] - 6.0 * pa_x[j] * pc_xyz[j] * pb_yy[j] - 6.0 * pa_x[j] * pc_xyy[j] * pb_yz[j] - pc_xxz[j] * pb_yyy[j] - 3.0 * pc_xxy[j] * pb_yyz[j]);

                t_xx_yyyz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yyyz[j] + 1.5 * fl1_fx * pb_y[j] * pc_yyz[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] + pa_xx[j] * pc_yyyz[j] + 6.0 * pa_x[j] * pc_xyyz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xyyy[j] * pb_z[j] + 3.0 * pc_xxyz[j] * pb_yy[j] + 3.0 * pc_xxyy[j] * pb_yz[j]);

                t_xx_yyyz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyz[j] - 2.0 * pa_x[j] * pc_xyyyz[j] - 3.0 * pc_xxyyz[j] * pb_y[j] - pc_xxyyy[j] * pb_z[j]);

                t_xx_yyyz[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_12_13(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (12,13)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyzz = pbDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_yyzz = primBuffer.data(90 * idx + 12);

            // Batch of Integrals (12,13)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_y, pb_yy, pb_yyz, pb_yyzz, pb_yz, pb_yzz, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xx_yyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xx_yyzz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + 0.25 * fl2_fx * pb_yy[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_xx[j] * pb_yy[j] * fl1_fx + 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_yyzz[j] + pa_xx[j] * pb_yyzz[j]);

                t_xx_yyzz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_xx[j] * fl2_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pb_yy[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_xx[j] * pb_yy[j] * fl1_fx - pa_xx[j] * pb_y[j] * pc_y[j] * fl1_fx - pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] - pa_x[j] * pc_x[j] * pb_yy[j] * fl1_fx - pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] - fl1_fx * pb_yyz[j] * pc_z[j] - fl1_fx * pb_yzz[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyzz[j] - 2.0 * pa_xx[j] * pb_yyz[j] * pc_z[j] - 2.0 * pa_xx[j] * pb_yzz[j] * pc_y[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yyzz[j]);

                t_xx_yyzz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * pc_x[j] * fl2_fx + 0.25 * pc_xx[j] * fl2_fx + fl2_fx * pb_y[j] * pc_y[j] + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pc_zz[j] + fl2_fx * pb_z[j] * pc_z[j] + 0.25 * fl2_fx * pb_yy[j] + 0.25 * fl2_fx * pb_zz[j] + pa_xx[j] * pb_y[j] * pc_y[j] * fl1_fx + 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx + 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] + pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] + pa_x[j] * pc_x[j] * pb_yy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx + 2.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] + 0.5 * pc_xx[j] * pb_yy[j] * fl1_fx + 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_yy[j] * pc_zz[j] + 2.0 * fl1_fx * pb_yz[j] * pc_yz[j] + 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] + fl1_fx * pb_yyz[j] * pc_z[j] + fl1_fx * pb_yzz[j] * pc_y[j] + pa_xx[j] * pb_yy[j] * pc_zz[j] + 4.0 * pa_xx[j] * pb_yz[j] * pc_yz[j] + pa_xx[j] * pc_yy[j] * pb_zz[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_yyz[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_yzz[j] + pc_xx[j] * pb_yyzz[j]);

                t_xx_yyzz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * pc_xx[j] * fl2_fx - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx - 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] - 2.0 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx - pa_x[j] * pc_xyy[j] * fl1_fx - pa_x[j] * pc_xzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * pb_yy[j] * fl1_fx - pc_xxy[j] * pb_y[j] * fl1_fx - pc_xxz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] - fl1_fx * pb_y[j] * pc_yzz[j] - fl1_fx * pc_yyz[j] * pb_z[j] - 0.5 * fl1_fx * pb_yy[j] * pc_zz[j] - 2.0 * fl1_fx * pb_yz[j] * pc_yz[j] - 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] - 2.0 * pa_xx[j] * pb_y[j] * pc_yzz[j] - 2.0 * pa_xx[j] * pc_yyz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_yy[j] - 8.0 * pa_x[j] * pc_xyz[j] * pb_yz[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_zz[j] - 2.0 * pc_xxz[j] * pb_yyz[j] - 2.0 * pc_xxy[j] * pb_yzz[j]);

                t_xx_yyzz[j] += fl_s_0_0_4 * (0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pc_zz[j] + pa_x[j] * pc_xyy[j] * fl1_fx + pa_x[j] * pc_xzz[j] * fl1_fx + pc_xxy[j] * pb_y[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_xxzz[j] * fl1_fx + pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yyzz[j] + fl1_fx * pb_y[j] * pc_yzz[j] + fl1_fx * pc_yyz[j] * pb_z[j] + pa_xx[j] * pc_yyzz[j] + 4.0 * pa_x[j] * pc_xyzz[j] * pb_y[j] + 4.0 * pa_x[j] * pc_xyyz[j] * pb_z[j] + pc_xxzz[j] * pb_yy[j] + 4.0 * pc_xxyz[j] * pb_yz[j] + pc_xxyy[j] * pb_zz[j]);

                t_xx_yyzz[j] += fl_s_0_0_5 * (-0.5 * pc_xxyy[j] * fl1_fx - 0.5 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - 2.0 * pa_x[j] * pc_xyyzz[j] - 2.0 * pc_xxyzz[j] * pb_y[j] - 2.0 * pc_xxyyz[j] * pb_z[j]);

                t_xx_yyzz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_13_14(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (13,14)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yzzz = pbDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_yzzz = primBuffer.data(90 * idx + 13);

            // Batch of Integrals (13,14)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_y, pb_yz, pb_yzz, pb_yzzz, pb_z, pb_zz, pb_zzz, pc_x, pc_xx, \
                                     pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, pc_xyz, \
                                     pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_yzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xx_yzzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_xx[j] * pb_yz[j] * fl1_fx + 0.5 * fl1_fx * pb_yzzz[j] + pa_xx[j] * pb_yzzz[j]);

                t_xx_yzzz[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_yz[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * pb_yz[j] * fl1_fx - 1.5 * pa_xx[j] * pb_y[j] * pc_z[j] * fl1_fx - 1.5 * pa_xx[j] * pc_y[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_x[j] * pb_yz[j] * fl1_fx - 1.5 * fl1_fx * pb_yzz[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_zzz[j] - 0.5 * fl1_fx * pb_yzzz[j] - 3.0 * pa_xx[j] * pb_yzz[j] * pc_z[j] - pa_xx[j] * pc_y[j] * pb_zzz[j] - 2.0 * pa_x[j] * pc_x[j] * pb_yzzz[j]);

                t_xx_yzzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pb_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pc_yz[j] + 0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_xx[j] * pb_y[j] * pc_z[j] * fl1_fx + 1.5 * pa_xx[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx + 3.0 * pa_x[j] * pc_x[j] * pb_yz[j] * fl1_fx + 3.0 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * pb_z[j] * fl1_fx + 1.5 * pc_xx[j] * pb_yz[j] * fl1_fx + 1.5 * fl1_fx * pb_yz[j] * pc_zz[j] + 1.5 * fl1_fx * pc_yz[j] * pb_zz[j] + 1.5 * fl1_fx * pb_yzz[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_zzz[j] + 3.0 * pa_xx[j] * pb_yz[j] * pc_zz[j] + 3.0 * pa_xx[j] * pc_yz[j] * pb_zz[j] + 6.0 * pa_x[j] * pc_xz[j] * pb_yzz[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_zzz[j] + pc_xx[j] * pb_yzzz[j]);

                t_xx_yzzz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_xy[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pc_xx[j] * pb_yz[j] * fl1_fx - 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx - 1.5 * pc_xxy[j] * pb_z[j] * fl1_fx - 0.5 * fl1_fx * pb_y[j] * pc_zzz[j] - 1.5 * fl1_fx * pc_yzz[j] * pb_z[j] - 1.5 * fl1_fx * pb_yz[j] * pc_zz[j] - 1.5 * fl1_fx * pc_yz[j] * pb_zz[j] - pa_xx[j] * pb_y[j] * pc_zzz[j] - 3.0 * pa_xx[j] * pc_yzz[j] * pb_z[j] - 6.0 * pa_x[j] * pc_xzz[j] * pb_yz[j] - 6.0 * pa_x[j] * pc_xyz[j] * pb_zz[j] - 3.0 * pc_xxz[j] * pb_yzz[j] - pc_xxy[j] * pb_zzz[j]);

                t_xx_yzzz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xxy[j] * pb_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 0.5 * fl1_fx * pc_yzzz[j] + 0.5 * fl1_fx * pb_y[j] * pc_zzz[j] + 1.5 * fl1_fx * pc_yzz[j] * pb_z[j] + pa_xx[j] * pc_yzzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] * pb_y[j] + 6.0 * pa_x[j] * pc_xyzz[j] * pb_z[j] + 3.0 * pc_xxzz[j] * pb_yz[j] + 3.0 * pc_xxyz[j] * pb_zz[j]);

                t_xx_yzzz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yzzz[j] - 2.0 * pa_x[j] * pc_xyzzz[j] - pc_xxzzz[j] * pb_y[j] - 3.0 * pc_xxyzz[j] * pb_z[j]);

                t_xx_yzzz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_14_15(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (14,15)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_zzzz = pbDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxzzzz = pcDistances.data(83 * idx + 69);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xx_zzzz = primBuffer.data(90 * idx + 14);

            // Batch of Integrals (14,15)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pb_z, pb_zz, pb_zzz, pb_zzzz, pc_x, pc_xx, pc_xxz, pc_xxzz, \
                                     pc_xxzzz, pc_xxzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xx_zzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xx_zzzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 1.5 * fl2_fx * pb_zz[j] + 3.0 * pa_xx[j] * pb_zz[j] * fl1_fx + 0.5 * fl1_fx * pb_zzzz[j] + pa_xx[j] * pb_zzzz[j]);

                t_xx_zzzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * fl2_fx * pb_zz[j] - 3.0 * fl2_fx * pb_z[j] * pc_z[j] - 3.0 * pa_xx[j] * pb_zz[j] * fl1_fx - 6.0 * pa_xx[j] * pb_z[j] * pc_z[j] * fl1_fx - 6.0 * pa_x[j] * pc_x[j] * pb_zz[j] * fl1_fx - 2.0 * fl1_fx * pb_zzz[j] * pc_z[j] - 0.5 * fl1_fx * pb_zzzz[j] - 4.0 * pa_xx[j] * pb_zzz[j] * pc_z[j] - 2.0 * pa_x[j] * pc_x[j] * pb_zzzz[j]);

                t_xx_zzzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + 0.75 * pc_xx[j] * fl2_fx + 6.0 * fl2_fx * pb_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_zz[j] + 1.5 * fl2_fx * pb_zz[j] + 6.0 * pa_xx[j] * pb_z[j] * pc_z[j] * fl1_fx + 3.0 * pa_xx[j] * pc_zz[j] * fl1_fx + 6.0 * pa_x[j] * pc_x[j] * pb_zz[j] * fl1_fx + 12.0 * pa_x[j] * pc_xz[j] * pb_z[j] * fl1_fx + 3.0 * pc_xx[j] * pb_zz[j] * fl1_fx + 3.0 * fl1_fx * pb_zz[j] * pc_zz[j] + 2.0 * fl1_fx * pb_zzz[j] * pc_z[j] + 6.0 * pa_xx[j] * pb_zz[j] * pc_zz[j] + 8.0 * pa_x[j] * pc_xz[j] * pb_zzz[j] + pc_xx[j] * pb_zzzz[j]);

                t_xx_zzzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 1.5 * pc_xx[j] * fl2_fx - 3.0 * fl2_fx * pc_zz[j] - 3.0 * fl2_fx * pb_z[j] * pc_z[j] - 3.0 * pa_xx[j] * pc_zz[j] * fl1_fx - 12.0 * pa_x[j] * pc_xz[j] * pb_z[j] * fl1_fx - 6.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 3.0 * pc_xx[j] * pb_zz[j] * fl1_fx - 6.0 * pc_xxz[j] * pb_z[j] * fl1_fx - 2.0 * fl1_fx * pb_z[j] * pc_zzz[j] - 3.0 * fl1_fx * pb_zz[j] * pc_zz[j] - 4.0 * pa_xx[j] * pb_z[j] * pc_zzz[j] - 12.0 * pa_x[j] * pc_xzz[j] * pb_zz[j] - 4.0 * pc_xxz[j] * pb_zzz[j]);

                t_xx_zzzz[j] += fl_s_0_0_4 * (0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pc_zz[j] + 6.0 * pa_x[j] * pc_xzz[j] * fl1_fx + 6.0 * pc_xxz[j] * pb_z[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzzz[j] + 2.0 * fl1_fx * pb_z[j] * pc_zzz[j] + pa_xx[j] * pc_zzzz[j] + 8.0 * pa_x[j] * pc_xzzz[j] * pb_z[j] + 6.0 * pc_xxzz[j] * pb_zz[j]);

                t_xx_zzzz[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - 2.0 * pa_x[j] * pc_xzzzz[j] - 4.0 * pc_xxzzz[j] * pb_z[j]);

                t_xx_zzzz[j] += fl_s_0_0_6 * pc_xxzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_15_16(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (15,16)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxx = pbDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxy = pcDistances.data(83 * idx + 56);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xxxx = primBuffer.data(90 * idx + 15);

            // Batch of Integrals (15,16)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxx, pb_xxxx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxx, pc_xxxxxy, pc_xxxxy, pc_xxxy, pc_xxy, pc_xy, pc_y, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xy_xxxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xxxx[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 3.0 * fl2_fx * pa_y[j] * pb_x[j] + 3.0 * pa_xy[j] * pb_xx[j] * fl1_fx + 2.0 * fl1_fx * pa_y[j] * pb_xxx[j] + pa_xy[j] * pb_xxxx[j]);

                t_xy_xxxx[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - 3.75 * pc_x[j] * pa_y[j] * fl2_fx - 6.0 * fl2_fx * pa_y[j] * pb_x[j] - 3.0 * fl2_fx * pc_y[j] * pb_x[j] - 3.0 * pa_xy[j] * pb_xx[j] * fl1_fx - 6.0 * pa_xy[j] * pb_x[j] * pc_x[j] * fl1_fx - 3.0 * pa_x[j] * pc_y[j] * pb_xx[j] * fl1_fx - 9.0 * pc_x[j] * pa_y[j] * pb_xx[j] * fl1_fx - 2.0 * fl1_fx * pc_y[j] * pb_xxx[j] - 2.0 * fl1_fx * pa_y[j] * pb_xxx[j] - 4.0 * pa_xy[j] * pb_xxx[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxxx[j] - pc_x[j] * pa_y[j] * pb_xxxx[j]);

                t_xy_xxxx[j] += fl_s_0_0_2 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 7.5 * pc_x[j] * pa_y[j] * fl2_fx + 3.75 * pc_xy[j] * fl2_fx + 6.0 * fl2_fx * pc_y[j] * pb_x[j] + 3.0 * fl2_fx * pa_y[j] * pb_x[j] + 6.0 * pa_xy[j] * pb_x[j] * pc_x[j] * fl1_fx + 3.0 * pa_xy[j] * pc_xx[j] * fl1_fx + 3.0 * pa_x[j] * pc_y[j] * pb_xx[j] * fl1_fx + 6.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx + 9.0 * pc_x[j] * pa_y[j] * pb_xx[j] * fl1_fx + 12.0 * pc_xx[j] * pa_y[j] * pb_x[j] * fl1_fx + 9.0 * pc_xy[j] * pb_xx[j] * fl1_fx + 2.0 * fl1_fx * pc_y[j] * pb_xxx[j] + 6.0 * pa_xy[j] * pb_xx[j] * pc_xx[j] + 4.0 * pa_x[j] * pc_xy[j] * pb_xxx[j] + 4.0 * pc_xx[j] * pa_y[j] * pb_xxx[j] + pc_xy[j] * pb_xxxx[j]);

                t_xy_xxxx[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 3.75 * pc_x[j] * pa_y[j] * fl2_fx - 7.5 * pc_xy[j] * fl2_fx - 3.0 * fl2_fx * pc_y[j] * pb_x[j] - 3.0 * pa_xy[j] * pc_xx[j] * fl1_fx - 6.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxy[j] * fl1_fx - 12.0 * pc_xx[j] * pa_y[j] * pb_x[j] * fl1_fx - 5.0 * pc_xxx[j] * pa_y[j] * fl1_fx - 9.0 * pc_xy[j] * pb_xx[j] * fl1_fx - 12.0 * pc_xxy[j] * pb_x[j] * fl1_fx - 4.0 * pa_xy[j] * pb_x[j] * pc_xxx[j] - 6.0 * pa_x[j] * pc_xxy[j] * pb_xx[j] - 6.0 * pc_xxx[j] * pa_y[j] * pb_xx[j] - 4.0 * pc_xxy[j] * pb_xxx[j]);

                t_xy_xxxx[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_xxy[j] * fl1_fx + 5.0 * pc_xxx[j] * pa_y[j] * fl1_fx + 12.0 * pc_xxy[j] * pb_x[j] * fl1_fx + 5.0 * pc_xxxy[j] * fl1_fx + pa_xy[j] * pc_xxxx[j] + 4.0 * pa_x[j] * pc_xxxy[j] * pb_x[j] + 4.0 * pc_xxxx[j] * pa_y[j] * pb_x[j] + 6.0 * pc_xxxy[j] * pb_xx[j]);

                t_xy_xxxx[j] += fl_s_0_0_5 * (-5.0 * pc_xxxy[j] * fl1_fx - pa_x[j] * pc_xxxxy[j] - pc_xxxxx[j] * pa_y[j] - 4.0 * pc_xxxxy[j] * pb_x[j]);

                t_xy_xxxx[j] += fl_s_0_0_6 * pc_xxxxxy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_16_17(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (16,17)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxy = pbDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyy = pcDistances.data(83 * idx + 58);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xxxy = primBuffer.data(90 * idx + 16);

            // Batch of Integrals (16,17)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxx, pb_xxxy, pb_xxy, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, \
                                     pc_xy, pc_xyy, pc_y, pc_yy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xy_xxxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xy_xxxy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 0.75 * fl2_fx * pb_xx[j] + 1.5 * pa_xy[j] * pb_xy[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_xxx[j] + 1.5 * fl1_fx * pa_y[j] * pb_xxy[j] + pa_xy[j] * pb_xxxy[j]);

                t_xy_xxxy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 2.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pa_y[j] * pc_y[j] - 1.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * fl2_fx * pb_xx[j] - 1.5 * pa_xy[j] * pb_x[j] * fl1_fx * pc_y[j] - 1.5 * pa_xy[j] * pb_xy[j] * fl1_fx - 1.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * pc_y[j] * pb_xy[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xxx[j] - 4.5 * pc_x[j] * pa_y[j] * pb_xy[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_xxx[j] - 1.5 * fl1_fx * pa_y[j] * pb_xx[j] * pc_y[j] - 1.5 * fl1_fx * pc_y[j] * pb_xxy[j] - 1.5 * fl1_fx * pa_y[j] * pb_xxy[j] - pa_xy[j] * pb_xxx[j] * pc_y[j] - 3.0 * pa_xy[j] * pb_xxy[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxxy[j] - pc_x[j] * pa_y[j] * pb_xxxy[j]);

                t_xy_xxxy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 4.5 * pc_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pa_y[j] * pc_y[j] + 0.75 * fl2_fx * pc_yy[j] + 1.5 * fl2_fx * pc_y[j] * pb_y[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 0.75 * fl2_fx * pb_xx[j] + 1.5 * pa_xy[j] * pb_x[j] * fl1_fx * pc_y[j] + 1.5 * pa_xy[j] * pc_xy[j] * fl1_fx + 1.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_yy[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_xx[j] + 1.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_x[j] + 4.5 * pc_xy[j] * pa_y[j] * pb_x[j] * fl1_fx + 4.5 * pc_x[j] * pa_y[j] * pb_xy[j] * fl1_fx + 3.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] + 4.5 * pc_xy[j] * pb_xy[j] * fl1_fx + 1.5 * pc_xx[j] * fl1_fx * pb_xx[j] + 0.5 * pc_x[j] * fl1_fx * pb_xxx[j] + 1.5 * fl1_fx * pc_yy[j] * pb_xx[j] + 1.5 * fl1_fx * pa_y[j] * pb_xx[j] * pc_y[j] + 1.5 * fl1_fx * pc_y[j] * pb_xxy[j] + 3.0 * pa_xy[j] * pb_xx[j] * pc_xy[j] + 3.0 * pa_xy[j] * pb_xy[j] * pc_xx[j] + pa_x[j] * pc_yy[j] * pb_xxx[j] + 3.0 * pa_x[j] * pc_xy[j] * pb_xxy[j] + pc_xy[j] * pa_y[j] * pb_xxx[j] + 3.0 * pc_xx[j] * pa_y[j] * pb_xxy[j] + pc_xy[j] * pb_xxxy[j]);

                t_xy_xxxy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 3.0 * pc_xx[j] * fl2_fx - 2.25 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pc_yy[j] - 0.75 * fl2_fx * pa_y[j] * pc_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * pa_xy[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yy[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyy[j] * fl1_fx - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_xxx[j] - 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_xx[j] - 4.5 * pc_xy[j] * pa_y[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxy[j] * pa_y[j] * fl1_fx - 3.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] - 4.5 * pc_xyy[j] * pb_x[j] * fl1_fx - 4.5 * pc_xy[j] * pb_xy[j] * fl1_fx - 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xxx[j] * fl1_fx * pb_x[j] - 1.5 * pc_xx[j] * fl1_fx * pb_xx[j] - 1.5 * fl1_fx * pc_yy[j] * pb_xx[j] - 3.0 * pa_xy[j] * pb_x[j] * pc_xxy[j] - pa_xy[j] * pc_xxx[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xyy[j] * pb_xx[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_xy[j] - 3.0 * pc_xxy[j] * pa_y[j] * pb_xx[j] - 3.0 * pc_xxx[j] * pa_y[j] * pb_xy[j] - pc_xyy[j] * pb_xxx[j] - 3.0 * pc_xxy[j] * pb_xxy[j]);

                t_xy_xxxy[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 0.75 * fl2_fx * pc_yy[j] + 1.5 * pa_x[j] * pc_xyy[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_xxx[j] + 3.0 * pc_xxy[j] * pa_y[j] * fl1_fx + 4.5 * pc_xyy[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] + 0.5 * pc_xxxx[j] * fl1_fx + 1.5 * pc_xxx[j] * fl1_fx * pb_x[j] + pa_xy[j] * pc_xxxy[j] + 3.0 * pa_x[j] * pc_xxyy[j] * pb_x[j] + pa_x[j] * pc_xxxy[j] * pb_y[j] + 3.0 * pc_xxxy[j] * pa_y[j] * pb_x[j] + pc_xxxx[j] * pa_y[j] * pb_y[j] + 3.0 * pc_xxyy[j] * pb_xx[j] + 3.0 * pc_xxxy[j] * pb_xy[j]);

                t_xy_xxxy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * pc_xxxx[j] * fl1_fx - pa_x[j] * pc_xxxyy[j] - pc_xxxxy[j] * pa_y[j] - 3.0 * pc_xxxyy[j] * pb_x[j] - pc_xxxxy[j] * pb_y[j]);

                t_xy_xxxy[j] += fl_s_0_0_6 * pc_xxxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_17_18(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (17,18)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxz = pbDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xxxz = primBuffer.data(90 * idx + 17);

            // Batch of Integrals (17,18)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxx, pb_xxxz, pb_xxz, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, \
                                     pc_xxy, pc_xxyz, pc_xxz, pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xy_xxxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xxxz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xy[j] * pb_xz[j] * fl1_fx + 1.5 * fl1_fx * pa_y[j] * pb_xxz[j] + pa_xy[j] * pb_xxxz[j]);

                t_xy_xxxz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_y[j] * pc_z[j] - 1.5 * fl2_fx * pa_y[j] * pb_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xy[j] * pb_x[j] * fl1_fx * pc_z[j] - 1.5 * pa_xy[j] * pb_xz[j] * fl1_fx - 1.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_y[j] * pb_xz[j] * fl1_fx - 4.5 * pc_x[j] * pa_y[j] * pb_xz[j] * fl1_fx - 1.5 * fl1_fx * pa_y[j] * pb_xx[j] * pc_z[j] - 1.5 * fl1_fx * pc_y[j] * pb_xxz[j] - 1.5 * fl1_fx * pa_y[j] * pb_xxz[j] - pa_xy[j] * pb_xxx[j] * pc_z[j] - 3.0 * pa_xy[j] * pb_xxz[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxxz[j] - pc_x[j] * pa_y[j] * pb_xxxz[j]);

                t_xy_xxxz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_y[j] * pc_z[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xy[j] * pb_x[j] * fl1_fx * pc_z[j] + 1.5 * pa_xy[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_xz[j] * fl1_fx + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 4.5 * pc_xz[j] * pa_y[j] * pb_x[j] * fl1_fx + 4.5 * pc_x[j] * pa_y[j] * pb_xz[j] * fl1_fx + 3.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] + 4.5 * pc_xy[j] * pb_xz[j] * fl1_fx + 1.5 * fl1_fx * pc_yz[j] * pb_xx[j] + 1.5 * fl1_fx * pa_y[j] * pb_xx[j] * pc_z[j] + 1.5 * fl1_fx * pc_y[j] * pb_xxz[j] + 3.0 * pa_xy[j] * pb_xx[j] * pc_xz[j] + 3.0 * pa_xy[j] * pb_xz[j] * pc_xx[j] + pa_x[j] * pc_yz[j] * pb_xxx[j] + 3.0 * pa_x[j] * pc_xy[j] * pb_xxz[j] + pc_xz[j] * pa_y[j] * pb_xxx[j] + 3.0 * pc_xx[j] * pa_y[j] * pb_xxz[j] + pc_xy[j] * pb_xxxz[j]);

                t_xy_xxxz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xy[j] * pc_xz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 4.5 * pc_xz[j] * pa_y[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxz[j] * pa_y[j] * fl1_fx - 3.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] - 4.5 * pc_xyz[j] * pb_x[j] * fl1_fx - 4.5 * pc_xy[j] * pb_xz[j] * fl1_fx - 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] - 1.5 * fl1_fx * pc_yz[j] * pb_xx[j] - 3.0 * pa_xy[j] * pb_x[j] * pc_xxz[j] - pa_xy[j] * pc_xxx[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xyz[j] * pb_xx[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_xz[j] - 3.0 * pc_xxz[j] * pa_y[j] * pb_xx[j] - 3.0 * pc_xxx[j] * pa_y[j] * pb_xz[j] - pc_xyz[j] * pb_xxx[j] - 3.0 * pc_xxy[j] * pb_xxz[j]);

                t_xy_xxxz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxz[j] * pa_y[j] * fl1_fx + 4.5 * pc_xyz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_xxxz[j] + 3.0 * pa_x[j] * pc_xxyz[j] * pb_x[j] + pa_x[j] * pc_xxxy[j] * pb_z[j] + 3.0 * pc_xxxz[j] * pa_y[j] * pb_x[j] + pc_xxxx[j] * pa_y[j] * pb_z[j] + 3.0 * pc_xxyz[j] * pb_xx[j] + 3.0 * pc_xxxy[j] * pb_xz[j]);

                t_xy_xxxz[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - pa_x[j] * pc_xxxyz[j] - pc_xxxxz[j] * pa_y[j] - 3.0 * pc_xxxyz[j] * pb_x[j] - pc_xxxxy[j] * pb_z[j]);

                t_xy_xxxz[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_18_19(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (18,19)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyy = pbDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyy = pcDistances.data(83 * idx + 61);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xxyy = primBuffer.data(90 * idx + 18);

            // Batch of Integrals (18,19)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxy, pb_xxyy, pb_xy, pb_xyy, pb_y, pb_yy, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyy, pc_xxy, pc_xxyy, pc_xxyyy, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_y, pc_yy, pc_yyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xy_xxyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xxyy[j] = fl_s_0_0_0 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + fl2_fx * pb_xy[j] + 0.5 * pa_xy[j] * pb_xx[j] * fl1_fx + 0.5 * pa_xy[j] * fl1_fx * pb_yy[j] + pa_x[j] * fl1_fx * pb_xxy[j] + fl1_fx * pa_y[j] * pb_xyy[j] + pa_xy[j] * pb_xxyy[j]);

                t_xy_xxyy[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_y[j] - fl2_fx * pa_y[j] * pb_x[j] - 1.5 * fl2_fx * pc_y[j] * pb_x[j] - 2.0 * fl2_fx * pb_xy[j] - 0.5 * pa_xy[j] * pb_xx[j] * fl1_fx - pa_xy[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_xy[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xy[j] * fl1_fx * pb_yy[j] - 1.5 * pa_x[j] * pc_y[j] * pb_xx[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yy[j] - 2.0 * pa_x[j] * fl1_fx * pb_xy[j] * pc_x[j] - pa_x[j] * fl1_fx * pb_xxy[j] - 0.5 * pc_x[j] * pa_y[j] * pb_xx[j] * fl1_fx - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yy[j] - pc_x[j] * fl1_fx * pb_xxy[j] - 2.0 * fl1_fx * pa_y[j] * pb_xy[j] * pc_y[j] - fl1_fx * pc_y[j] * pb_xyy[j] - fl1_fx * pa_y[j] * pb_xyy[j] - 2.0 * pa_xy[j] * pb_xxy[j] * pc_y[j] - 2.0 * pa_xy[j] * pb_xyy[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxyy[j] - pc_x[j] * pa_y[j] * pb_xxyy[j]);

                t_xy_xxyy[j] += fl_s_0_0_2 * (0.25 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 2.25 * pc_xy[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_y[j] + 3.0 * fl2_fx * pc_y[j] * pb_x[j] + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + fl2_fx * pb_xy[j] + pa_xy[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_xy[j] * pc_xx[j] * fl1_fx + 0.5 * pa_xy[j] * fl1_fx * pc_yy[j] + pa_xy[j] * fl1_fx * pb_y[j] * pc_y[j] + 1.5 * pa_x[j] * pc_y[j] * pb_xx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yy[j] + pa_x[j] * fl1_fx * pc_xx[j] * pb_y[j] + 2.0 * pa_x[j] * fl1_fx * pb_xy[j] * pc_x[j] + 0.5 * pc_x[j] * pa_y[j] * pb_xx[j] * fl1_fx + pc_xx[j] * pa_y[j] * pb_x[j] * fl1_fx + 3.0 * pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yy[j] + 1.5 * pc_xy[j] * pb_xx[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] + 2.0 * pc_xx[j] * fl1_fx * pb_xy[j] + pc_x[j] * fl1_fx * pb_xxy[j] + fl1_fx * pa_y[j] * pb_x[j] * pc_yy[j] + 2.0 * fl1_fx * pc_yy[j] * pb_xy[j] + 2.0 * fl1_fx * pa_y[j] * pb_xy[j] * pc_y[j] + fl1_fx * pc_y[j] * pb_xyy[j] + pa_xy[j] * pb_xx[j] * pc_yy[j] + 4.0 * pa_xy[j] * pb_xy[j] * pc_xy[j] + pa_xy[j] * pc_xx[j] * pb_yy[j] + 2.0 * pa_x[j] * pc_yy[j] * pb_xxy[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xyy[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_xxy[j] + 2.0 * pc_xx[j] * pa_y[j] * pb_xyy[j] + pc_xy[j] * pb_xxyy[j]);

                t_xy_xxyy[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 4.5 * pc_xy[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xy[j] * pc_xx[j] * fl1_fx - 0.5 * pa_xy[j] * fl1_fx * pc_yy[j] - 3.0 * pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx - pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] - pa_x[j] * fl1_fx * pc_xx[j] * pb_y[j] - pc_xx[j] * pa_y[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyy[j] * pa_y[j] * fl1_fx - 3.0 * pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * pb_xx[j] * fl1_fx - 3.0 * pc_xxy[j] * pb_x[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] - pc_xxx[j] * fl1_fx * pb_y[j] - 2.0 * pc_xx[j] * fl1_fx * pb_xy[j] - fl1_fx * pc_yyy[j] * pb_x[j] - fl1_fx * pa_y[j] * pb_x[j] * pc_yy[j] - 2.0 * fl1_fx * pc_yy[j] * pb_xy[j] - 2.0 * pa_xy[j] * pb_x[j] * pc_xyy[j] - 2.0 * pa_xy[j] * pc_xxy[j] * pb_y[j] - pa_x[j] * pc_yyy[j] * pb_xx[j] - 4.0 * pa_x[j] * pc_xyy[j] * pb_xy[j] - pa_x[j] * pc_xxy[j] * pb_yy[j] - pc_xyy[j] * pa_y[j] * pb_xx[j] - 4.0 * pc_xxy[j] * pa_y[j] * pb_xy[j] - pc_xxx[j] * pa_y[j] * pb_yy[j] - 2.0 * pc_xyy[j] * pb_xxy[j] - 2.0 * pc_xxy[j] * pb_xyy[j]);

                t_xy_xxyy[j] += fl_s_0_0_4 * (2.25 * pc_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_y[j] * fl1_fx + 3.0 * pc_xxy[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxxy[j] * fl1_fx + 1.5 * pc_xyyy[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pb_y[j] + pc_xxx[j] * fl1_fx * pb_y[j] + fl1_fx * pc_yyy[j] * pb_x[j] + pa_xy[j] * pc_xxyy[j] + 2.0 * pa_x[j] * pc_xyyy[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyy[j] * pb_y[j] + 2.0 * pc_xxyy[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxxy[j] * pa_y[j] * pb_y[j] + pc_xyyy[j] * pb_xx[j] + 4.0 * pc_xxyy[j] * pb_xy[j] + pc_xxxy[j] * pb_yy[j]);

                t_xy_xxyy[j] += fl_s_0_0_5 * (-1.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyyy[j] * fl1_fx - pa_x[j] * pc_xxyyy[j] - pc_xxxyy[j] * pa_y[j] - 2.0 * pc_xxyyy[j] * pb_x[j] - 2.0 * pc_xxxyy[j] * pb_y[j]);

                t_xy_xxyy[j] += fl_s_0_0_6 * pc_xxxyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_19_20(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (19,20)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyz = pbDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xxyz = primBuffer.data(90 * idx + 19);

            // Batch of Integrals (19,20)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxy, pb_xxyz, pb_xxz, pb_xy, pb_xyz, pb_xz, \
                                     pb_y, pb_yz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, \
                                     pc_xxxz, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, \
                                     pc_xz, pc_y, pc_yy, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xy_xxyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xxyz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pb_xz[j] + 0.5 * pa_xy[j] * fl1_fx * pb_yz[j] + 0.5 * pa_x[j] * fl1_fx * pb_xxz[j] + fl1_fx * pa_y[j] * pb_xyz[j] + pa_xy[j] * pb_xxyz[j]);

                t_xy_xxyz[j] += fl_s_0_0_1 * (-0.25 * pa_x[j] * fl2_fx * pc_z[j] - 0.5 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * fl2_fx * pb_x[j] * pc_z[j] - fl2_fx * pb_xz[j] - 0.5 * pa_xy[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_yz[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yz[j] - 0.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_z[j] - pa_x[j] * fl1_fx * pb_xz[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xxz[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * fl1_fx * pb_xxz[j] - fl1_fx * pa_y[j] * pb_xy[j] * pc_z[j] - fl1_fx * pa_y[j] * pb_xz[j] * pc_y[j] - fl1_fx * pc_y[j] * pb_xyz[j] - fl1_fx * pa_y[j] * pb_xyz[j] - pa_xy[j] * pb_xxy[j] * pc_z[j] - pa_xy[j] * pb_xxz[j] * pc_y[j] - 2.0 * pa_xy[j] * pb_xyz[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxyz[j] - pc_x[j] * pa_y[j] * pb_xxyz[j]);

                t_xy_xxyz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.25 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + fl2_fx * pb_x[j] * pc_z[j] + 0.5 * fl2_fx * pb_xz[j] + 0.5 * pa_xy[j] * fl1_fx * pc_yz[j] + 0.5 * pa_xy[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yz[j] + pa_x[j] * fl1_fx * pb_x[j] * pc_xz[j] + 0.5 * pa_x[j] * fl1_fx * pc_xx[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_z[j] + pa_x[j] * fl1_fx * pb_xz[j] * pc_x[j] + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xy[j] * fl1_fx * pb_yz[j] + 0.5 * pc_xz[j] * fl1_fx * pb_xx[j] + pc_xx[j] * fl1_fx * pb_xz[j] + 0.5 * pc_x[j] * fl1_fx * pb_xxz[j] + fl1_fx * pa_y[j] * pb_x[j] * pc_yz[j] + fl1_fx * pc_yz[j] * pb_xy[j] + fl1_fx * pc_yy[j] * pb_xz[j] + fl1_fx * pa_y[j] * pb_xy[j] * pc_z[j] + fl1_fx * pa_y[j] * pb_xz[j] * pc_y[j] + fl1_fx * pc_y[j] * pb_xyz[j] + pa_xy[j] * pb_xx[j] * pc_yz[j] + 2.0 * pa_xy[j] * pb_xy[j] * pc_xz[j] + 2.0 * pa_xy[j] * pb_xz[j] * pc_xy[j] + pa_xy[j] * pc_xx[j] * pb_yz[j] + pa_x[j] * pc_yz[j] * pb_xxy[j] + pa_x[j] * pc_yy[j] * pb_xxz[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xyz[j] + pc_xz[j] * pa_y[j] * pb_xxy[j] + pc_xy[j] * pa_y[j] * pb_xxz[j] + 2.0 * pc_xx[j] * pa_y[j] * pb_xyz[j] + pc_xy[j] * pb_xxyz[j]);

                t_xy_xxyz[j] += fl_s_0_0_3 * (-0.25 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * fl2_fx * pb_x[j] * pc_z[j] - 0.5 * pa_xy[j] * fl1_fx * pc_yz[j] - 0.5 * pa_x[j] * pc_yyz[j] * fl1_fx - 0.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xxz[j] - pa_x[j] * fl1_fx * pb_x[j] * pc_xz[j] - 0.5 * pa_x[j] * fl1_fx * pc_xx[j] * pb_z[j] - 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yz[j] - pc_xxz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_xx[j] - pc_xx[j] * fl1_fx * pb_xz[j] - fl1_fx * pc_yyz[j] * pb_x[j] - fl1_fx * pa_y[j] * pb_x[j] * pc_yz[j] - fl1_fx * pc_yz[j] * pb_xy[j] - fl1_fx * pc_yy[j] * pb_xz[j] - 2.0 * pa_xy[j] * pb_x[j] * pc_xyz[j] - pa_xy[j] * pc_xxz[j] * pb_y[j] - pa_xy[j] * pc_xxy[j] * pb_z[j] - pa_x[j] * pc_yyz[j] * pb_xx[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_xy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_xz[j] - pa_x[j] * pc_xxy[j] * pb_yz[j] - pc_xyz[j] * pa_y[j] * pb_xx[j] - 2.0 * pc_xxz[j] * pa_y[j] * pb_xy[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_xz[j] - pc_xxx[j] * pa_y[j] * pb_yz[j] - pc_xyz[j] * pb_xxy[j] - pc_xyy[j] * pb_xxz[j] - 2.0 * pc_xxy[j] * pb_xyz[j]);

                t_xy_xxyz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 0.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_xxz[j] + 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxxz[j] * fl1_fx + pc_xxz[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] + fl1_fx * pc_yyz[j] * pb_x[j] + pa_xy[j] * pc_xxyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_x[j] + pa_x[j] * pc_xxyz[j] * pb_y[j] + pa_x[j] * pc_xxyy[j] * pb_z[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_x[j] + pc_xxxz[j] * pa_y[j] * pb_y[j] + pc_xxxy[j] * pa_y[j] * pb_z[j] + pc_xyyz[j] * pb_xx[j] + 2.0 * pc_xxyz[j] * pb_xy[j] + 2.0 * pc_xxyy[j] * pb_xz[j] + pc_xxxy[j] * pb_yz[j]);

                t_xy_xxyz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xxxz[j] * fl1_fx - pa_x[j] * pc_xxyyz[j] - pc_xxxyz[j] * pa_y[j] - 2.0 * pc_xxyyz[j] * pb_x[j] - pc_xxxyz[j] * pb_y[j] - pc_xxxyy[j] * pb_z[j]);

                t_xy_xxyz[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_20_21(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (20,21)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxzz = pbDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xxzz = primBuffer.data(90 * idx + 20);

            // Batch of Integrals (20,21)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xx, pb_xxz, pb_xxzz, pb_xz, pb_xzz, pb_z, pb_zz, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, pc_xxy, \
                                     pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yz, \
                                     pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xy_xxzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xxzz[j] = fl_s_0_0_0 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xy[j] * pb_xx[j] * fl1_fx + 0.5 * pa_xy[j] * fl1_fx * pb_zz[j] + fl1_fx * pa_y[j] * pb_xzz[j] + pa_xy[j] * pb_xxzz[j]);

                t_xy_xxzz[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl2_fx - 0.25 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - fl2_fx * pa_y[j] * pb_x[j] - 0.5 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xy[j] * pb_xx[j] * fl1_fx - pa_xy[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_zz[j] - 0.5 * pa_x[j] * pc_y[j] * pb_xx[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] - 0.5 * pc_x[j] * pa_y[j] * pb_xx[j] * fl1_fx - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] - 2.0 * fl1_fx * pa_y[j] * pb_xz[j] * pc_z[j] - fl1_fx * pc_y[j] * pb_xzz[j] - fl1_fx * pa_y[j] * pb_xzz[j] - 2.0 * pa_xy[j] * pb_xxz[j] * pc_z[j] - 2.0 * pa_xy[j] * pb_xzz[j] * pc_x[j] - pa_x[j] * pc_y[j] * pb_xxzz[j] - pc_x[j] * pa_y[j] * pb_xxzz[j]);

                t_xy_xxzz[j] += fl_s_0_0_2 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_y[j] * fl2_fx + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + fl2_fx * pc_y[j] * pb_x[j] + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + pa_xy[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_xy[j] * pc_xx[j] * fl1_fx + 0.5 * pa_xy[j] * fl1_fx * pc_zz[j] + pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] + 0.5 * pa_x[j] * pc_y[j] * pb_xx[j] * fl1_fx + pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_x[j] * pa_y[j] * pb_xx[j] * fl1_fx + pc_xx[j] * pa_y[j] * pb_x[j] * fl1_fx + 3.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_xy[j] * pb_xx[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + fl1_fx * pa_y[j] * pb_x[j] * pc_zz[j] + 2.0 * fl1_fx * pc_yz[j] * pb_xz[j] + 2.0 * fl1_fx * pa_y[j] * pb_xz[j] * pc_z[j] + fl1_fx * pc_y[j] * pb_xzz[j] + pa_xy[j] * pb_xx[j] * pc_zz[j] + 4.0 * pa_xy[j] * pb_xz[j] * pc_xz[j] + pa_xy[j] * pc_xx[j] * pb_zz[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_xxz[j] + 2.0 * pa_x[j] * pc_xy[j] * pb_xzz[j] + 2.0 * pc_xz[j] * pa_y[j] * pb_xxz[j] + 2.0 * pc_xx[j] * pa_y[j] * pb_xzz[j] + pc_xy[j] * pb_xxzz[j]);

                t_xy_xxzz[j] += fl_s_0_0_3 * (-0.25 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 0.5 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xy[j] * pc_xx[j] * fl1_fx - 0.5 * pa_xy[j] * fl1_fx * pc_zz[j] - pa_x[j] * pc_xy[j] * pb_x[j] * fl1_fx - 0.5 * pa_x[j] * pc_xxy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yzz[j] * fl1_fx - pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - pc_xx[j] * pa_y[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx - 1.5 * pc_xzz[j] * pa_y[j] * fl1_fx - 3.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * pb_xx[j] * fl1_fx - pc_xxy[j] * pb_x[j] * fl1_fx - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - fl1_fx * pc_yzz[j] * pb_x[j] - fl1_fx * pa_y[j] * pb_x[j] * pc_zz[j] - 2.0 * fl1_fx * pc_yz[j] * pb_xz[j] - 2.0 * pa_xy[j] * pb_x[j] * pc_xzz[j] - 2.0 * pa_xy[j] * pc_xxz[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_xx[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_xz[j] - pa_x[j] * pc_xxy[j] * pb_zz[j] - pc_xzz[j] * pa_y[j] * pb_xx[j] - 4.0 * pc_xxz[j] * pa_y[j] * pb_xz[j] - pc_xxx[j] * pa_y[j] * pb_zz[j] - 2.0 * pc_xyz[j] * pb_xxz[j] - 2.0 * pc_xxy[j] * pb_xzz[j]);

                t_xy_xxzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 1.5 * pc_xzz[j] * pa_y[j] * fl1_fx + pc_xxy[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + fl1_fx * pc_yzz[j] * pb_x[j] + pa_xy[j] * pc_xxzz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyz[j] * pb_z[j] + 2.0 * pc_xxzz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxxz[j] * pa_y[j] * pb_z[j] + pc_xyzz[j] * pb_xx[j] + 4.0 * pc_xxyz[j] * pb_xz[j] + pc_xxxy[j] * pb_zz[j]);

                t_xy_xxzz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_xxyzz[j] - pc_xxxzz[j] * pa_y[j] - 2.0 * pc_xxyzz[j] * pb_x[j] - 2.0 * pc_xxxyz[j] * pb_z[j]);

                t_xy_xxzz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_21_22(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (21,22)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyy = pbDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyy = pcDistances.data(83 * idx + 65);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xyyy = primBuffer.data(90 * idx + 21);

            // Batch of Integrals (21,22)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xy, pb_xyy, pb_xyyy, pb_y, pb_yy, pb_yyy, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xy_xyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xy_xyyy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 0.75 * fl2_fx * pb_yy[j] + 1.5 * pa_xy[j] * pb_xy[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pa_y[j] * pb_yyy[j] + pa_xy[j] * pb_xyyy[j]);

                t_xy_xyyy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.75 * fl2_fx * pa_y[j] * pc_y[j] - 2.25 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * fl2_fx * pb_yy[j] - 1.5 * pa_xy[j] * pb_xy[j] * fl1_fx - 1.5 * pa_xy[j] * pb_x[j] * pc_y[j] * fl1_fx - 1.5 * pa_xy[j] * pc_x[j] * pb_y[j] * fl1_fx - 4.5 * pa_x[j] * pc_y[j] * pb_xy[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_yy[j] - 1.5 * pa_x[j] * fl1_fx * pb_xyy[j] - 1.5 * pc_x[j] * pa_y[j] * pb_xy[j] * fl1_fx - 1.5 * pc_x[j] * fl1_fx * pb_xyy[j] - 1.5 * fl1_fx * pa_y[j] * pb_yy[j] * pc_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_yyy[j] - 0.5 * fl1_fx * pa_y[j] * pb_yyy[j] - 3.0 * pa_xy[j] * pb_xyy[j] * pc_y[j] - pa_xy[j] * pc_x[j] * pb_yyy[j] - pa_x[j] * pc_y[j] * pb_xyyy[j] - pc_x[j] * pa_y[j] * pb_xyyy[j]);

                t_xy_xyyy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pa_y[j] * pc_y[j] + 4.5 * fl2_fx * pc_y[j] * pb_y[j] + 1.5 * fl2_fx * pc_yy[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 0.75 * fl2_fx * pb_yy[j] + 1.5 * pa_xy[j] * pb_x[j] * pc_y[j] * fl1_fx + 1.5 * pa_xy[j] * pc_x[j] * pb_y[j] * fl1_fx + 1.5 * pa_xy[j] * pc_xy[j] * fl1_fx + 4.5 * pa_x[j] * pc_y[j] * pb_xy[j] * fl1_fx + 3.0 * pa_x[j] * pc_yy[j] * pb_x[j] * fl1_fx + 4.5 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_yy[j] + 1.5 * pc_x[j] * pa_y[j] * pb_xy[j] * fl1_fx + 1.5 * pc_xy[j] * pa_y[j] * pb_x[j] * fl1_fx + 1.5 * pc_xx[j] * pa_y[j] * pb_y[j] * fl1_fx + 4.5 * pc_xy[j] * pb_xy[j] * fl1_fx + 1.5 * pc_xx[j] * fl1_fx * pb_yy[j] + 1.5 * pc_x[j] * fl1_fx * pb_xyy[j] + 1.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_yy[j] + 1.5 * fl1_fx * pc_yy[j] * pb_yy[j] + 1.5 * fl1_fx * pa_y[j] * pb_yy[j] * pc_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_yyy[j] + 3.0 * pa_xy[j] * pb_xy[j] * pc_yy[j] + 3.0 * pa_xy[j] * pc_xy[j] * pb_yy[j] + 3.0 * pa_x[j] * pc_yy[j] * pb_xyy[j] + pa_x[j] * pc_xy[j] * pb_yyy[j] + 3.0 * pc_xy[j] * pa_y[j] * pb_xyy[j] + pc_xx[j] * pa_y[j] * pb_yyy[j] + pc_xy[j] * pb_xyyy[j]);

                t_xy_xyyy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 1.5 * pc_xx[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 3.0 * fl2_fx * pc_yy[j] - 0.75 * fl2_fx * pa_y[j] * pc_y[j] - 2.25 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * pa_xy[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_yy[j] * pb_x[j] * fl1_fx - 4.5 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 1.5 * pc_xy[j] * pa_y[j] * pb_x[j] * fl1_fx - 1.5 * pc_xx[j] * pa_y[j] * pb_y[j] * fl1_fx - 1.5 * pc_xxy[j] * pa_y[j] * fl1_fx - 4.5 * pc_xy[j] * pb_xy[j] * fl1_fx - 3.0 * pc_xyy[j] * pb_x[j] * fl1_fx - 4.5 * pc_xxy[j] * pb_y[j] * fl1_fx - 1.5 * pc_xx[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pa_y[j] * pc_yyy[j] - 1.5 * fl1_fx * pc_yyy[j] * pb_y[j] - 1.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_yy[j] - 1.5 * fl1_fx * pc_yy[j] * pb_yy[j] - pa_xy[j] * pb_x[j] * pc_yyy[j] - 3.0 * pa_xy[j] * pc_xyy[j] * pb_y[j] - 3.0 * pa_x[j] * pc_yyy[j] * pb_xy[j] - 3.0 * pa_x[j] * pc_xyy[j] * pb_yy[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_xy[j] - 3.0 * pc_xxy[j] * pa_y[j] * pb_yy[j] - 3.0 * pc_xyy[j] * pb_xyy[j] - pc_xxy[j] * pb_yyy[j]);

                t_xy_xyyy[j] += fl_s_0_0_4 * (0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pc_yy[j] + 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx + 1.5 * pc_xxy[j] * pa_y[j] * fl1_fx + 3.0 * pc_xyy[j] * pb_x[j] * fl1_fx + 4.5 * pc_xxy[j] * pb_y[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 0.5 * fl1_fx * pc_yyyy[j] + 0.5 * fl1_fx * pa_y[j] * pc_yyy[j] + 1.5 * fl1_fx * pc_yyy[j] * pb_y[j] + pa_xy[j] * pc_xyyy[j] + pa_x[j] * pc_yyyy[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xyyy[j] * pb_y[j] + pc_xyyy[j] * pa_y[j] * pb_x[j] + 3.0 * pc_xxyy[j] * pa_y[j] * pb_y[j] + 3.0 * pc_xyyy[j] * pb_xy[j] + 3.0 * pc_xxyy[j] * pb_yy[j]);

                t_xy_xyyy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyy[j] - pa_x[j] * pc_xyyyy[j] - pc_xxyyy[j] * pa_y[j] - pc_xyyyy[j] * pb_x[j] - 3.0 * pc_xxyyy[j] * pb_y[j]);

                t_xy_xyyy[j] += fl_s_0_0_6 * pc_xxyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_22_23(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (22,23)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyz = pbDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xyyz = primBuffer.data(90 * idx + 22);

            // Batch of Integrals (22,23)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xy, pb_xyy, pb_xyyz, pb_xyz, pb_xz, pb_y, pb_yy, \
                                     pb_yyz, pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, \
                                     pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xy_xyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xyyz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_y[j] * pb_z[j] + 0.5 * fl2_fx * pb_yz[j] + 0.5 * pa_xy[j] * pb_xz[j] * fl1_fx + pa_x[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pa_y[j] * pb_yyz[j] + pa_xy[j] * pb_xyyz[j]);

                t_xy_xyyz[j] += fl_s_0_0_1 * (-0.25 * fl2_fx * pa_y[j] * pc_z[j] - 0.5 * fl2_fx * pa_y[j] * pb_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * fl2_fx * pb_y[j] * pc_z[j] - fl2_fx * pb_yz[j] - 0.5 * pa_xy[j] * pb_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_xy[j] * pb_xz[j] * fl1_fx - 0.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_y[j] * pb_xz[j] * fl1_fx - pa_x[j] * fl1_fx * pb_xy[j] * pc_z[j] - pa_x[j] * fl1_fx * pc_x[j] * pb_yz[j] - pa_x[j] * fl1_fx * pb_xyz[j] - 0.5 * pc_x[j] * pa_y[j] * pb_xz[j] * fl1_fx - pc_x[j] * fl1_fx * pb_xyz[j] - 0.5 * fl1_fx * pa_y[j] * pb_yy[j] * pc_z[j] - fl1_fx * pa_y[j] * pb_yz[j] * pc_y[j] - 0.5 * fl1_fx * pc_y[j] * pb_yyz[j] - 0.5 * fl1_fx * pa_y[j] * pb_yyz[j] - pa_xy[j] * pb_xyy[j] * pc_z[j] - 2.0 * pa_xy[j] * pb_xyz[j] * pc_y[j] - pa_xy[j] * pc_x[j] * pb_yyz[j] - pa_x[j] * pc_y[j] * pb_xyyz[j] - pc_x[j] * pa_y[j] * pb_xyyz[j]);

                t_xy_xyyz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pa_y[j] * pc_z[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + fl2_fx * pb_y[j] * pc_z[j] + 0.25 * fl2_fx * pa_y[j] * pb_z[j] + 0.5 * fl2_fx * pb_yz[j] + 0.5 * pa_xy[j] * pb_x[j] * fl1_fx * pc_z[j] + 0.5 * pa_xy[j] * pc_xz[j] * fl1_fx + 0.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_xz[j] * fl1_fx + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + pa_x[j] * fl1_fx * pc_xz[j] * pb_y[j] + pa_x[j] * fl1_fx * pb_xy[j] * pc_z[j] + pa_x[j] * fl1_fx * pc_x[j] * pb_yz[j] + 0.5 * pc_xz[j] * pa_y[j] * pb_x[j] * fl1_fx + 0.5 * pc_x[j] * pa_y[j] * pb_xz[j] * fl1_fx + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_xy[j] * pb_xz[j] * fl1_fx + pc_xz[j] * fl1_fx * pb_xy[j] + pc_xx[j] * fl1_fx * pb_yz[j] + pc_x[j] * fl1_fx * pb_xyz[j] + fl1_fx * pa_y[j] * pb_y[j] * pc_yz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pc_yz[j] * pb_yy[j] + fl1_fx * pc_yy[j] * pb_yz[j] + 0.5 * fl1_fx * pa_y[j] * pb_yy[j] * pc_z[j] + fl1_fx * pa_y[j] * pb_yz[j] * pc_y[j] + 0.5 * fl1_fx * pc_y[j] * pb_yyz[j] + 2.0 * pa_xy[j] * pb_xy[j] * pc_yz[j] + pa_xy[j] * pb_xz[j] * pc_yy[j] + pa_xy[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_xy[j] * pc_xy[j] * pb_yz[j] + pa_x[j] * pc_yz[j] * pb_xyy[j] + 2.0 * pa_x[j] * pc_yy[j] * pb_xyz[j] + pa_x[j] * pc_xy[j] * pb_yyz[j] + pc_xz[j] * pa_y[j] * pb_xyy[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_xyz[j] + pc_xx[j] * pa_y[j] * pb_yyz[j] + pc_xy[j] * pb_xyyz[j]);

                t_xy_xyyz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.25 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * fl2_fx * pb_y[j] * pc_z[j] - 0.5 * pa_xy[j] * pc_xz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pc_xz[j] * pb_y[j] - 0.5 * pc_xz[j] * pa_y[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxz[j] * pa_y[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xy[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] - pc_xxz[j] * fl1_fx * pb_y[j] - pc_xz[j] * fl1_fx * pb_xy[j] - pc_xx[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pa_y[j] * pc_yyz[j] - fl1_fx * pc_yyz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] - fl1_fx * pa_y[j] * pb_y[j] * pc_yz[j] - 0.5 * fl1_fx * pa_y[j] * pc_yy[j] * pb_z[j] - 0.5 * fl1_fx * pc_yz[j] * pb_yy[j] - fl1_fx * pc_yy[j] * pb_yz[j] - pa_xy[j] * pb_x[j] * pc_yyz[j] - 2.0 * pa_xy[j] * pc_xyz[j] * pb_y[j] - pa_xy[j] * pc_xyy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_yyz[j] * pb_xy[j] - pa_x[j] * pc_yyy[j] * pb_xz[j] - pa_x[j] * pc_xyz[j] * pb_yy[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_yz[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_xy[j] - pc_xyy[j] * pa_y[j] * pb_xz[j] - pc_xxz[j] * pa_y[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_yz[j] - pc_xyz[j] * pb_xyy[j] - 2.0 * pc_xyy[j] * pb_xyz[j] - pc_xxy[j] * pb_yyz[j]);

                t_xy_xyyz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 0.5 * pc_xxz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] + pc_xxz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyyz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yyz[j] + fl1_fx * pc_yyz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] + pa_xy[j] * pc_xyyz[j] + pa_x[j] * pc_yyyz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_y[j] + pa_x[j] * pc_xyyy[j] * pb_z[j] + pc_xyyz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_y[j] + pc_xxyy[j] * pa_y[j] * pb_z[j] + 2.0 * pc_xyyz[j] * pb_xy[j] + pc_xyyy[j] * pb_xz[j] + pc_xxyz[j] * pb_yy[j] + 2.0 * pc_xxyy[j] * pb_yz[j]);

                t_xy_xyyz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyz[j] - pa_x[j] * pc_xyyyz[j] - pc_xxyyz[j] * pa_y[j] - pc_xyyyz[j] * pb_x[j] - 2.0 * pc_xxyyz[j] * pb_y[j] - pc_xxyyy[j] * pb_z[j]);

                t_xy_xyyz[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_23_24(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (23,24)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyzz = pbDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xyzz = primBuffer.data(90 * idx + 23);

            // Batch of Integrals (23,24)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xy, pb_xyz, pb_xyzz, pb_xz, pb_xzz, pb_y, pb_yz, \
                                     pb_yzz, pb_z, pb_zz, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xy_xyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xy_xyzz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pa_y[j] * pb_y[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_xy[j] * pb_xy[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pa_y[j] * pb_yzz[j] + pa_xy[j] * pb_xyzz[j]);

                t_xy_xyzz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_y[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_xy[j] * pb_xy[j] * fl1_fx - 0.5 * pa_xy[j] * pb_x[j] * pc_y[j] * fl1_fx - 0.5 * pa_xy[j] * pc_x[j] * pb_y[j] * fl1_fx - 0.5 * pa_x[j] * pc_y[j] * pb_xy[j] * fl1_fx - pa_x[j] * fl1_fx * pb_xz[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_zz[j] - 0.5 * pa_x[j] * fl1_fx * pb_xzz[j] - 0.5 * pc_x[j] * pa_y[j] * pb_xy[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_xzz[j] - fl1_fx * pa_y[j] * pb_yz[j] * pc_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pc_y[j] * pb_yzz[j] - 0.5 * fl1_fx * pa_y[j] * pb_yzz[j] - 2.0 * pa_xy[j] * pb_xyz[j] * pc_z[j] - pa_xy[j] * pb_xzz[j] * pc_y[j] - pa_xy[j] * pc_x[j] * pb_yzz[j] - pa_x[j] * pc_y[j] * pb_xyzz[j] - pc_x[j] * pa_y[j] * pb_xyzz[j]);

                t_xy_xyzz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.25 * pc_xx[j] * fl2_fx + 0.5 * fl2_fx * pa_y[j] * pc_y[j] + 0.5 * fl2_fx * pc_y[j] * pb_y[j] + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pc_zz[j] + fl2_fx * pb_z[j] * pc_z[j] + 0.25 * fl2_fx * pa_y[j] * pb_y[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_xy[j] * pb_x[j] * pc_y[j] * fl1_fx + 0.5 * pa_xy[j] * pc_x[j] * pb_y[j] * fl1_fx + 0.5 * pa_xy[j] * pc_xy[j] * fl1_fx + 0.5 * pa_x[j] * pc_y[j] * pb_xy[j] * fl1_fx + 0.5 * pa_x[j] * pc_yy[j] * pb_x[j] * fl1_fx + 0.5 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_zz[j] + pa_x[j] * fl1_fx * pc_xz[j] * pb_z[j] + pa_x[j] * fl1_fx * pb_xz[j] * pc_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_zz[j] + 0.5 * pc_x[j] * pa_y[j] * pb_xy[j] * fl1_fx + 0.5 * pc_xy[j] * pa_y[j] * pb_x[j] * fl1_fx + 0.5 * pc_xx[j] * pa_y[j] * pb_y[j] * fl1_fx + 0.5 * pc_xy[j] * pb_xy[j] * fl1_fx + pc_xz[j] * fl1_fx * pb_xz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] + 0.5 * pc_x[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_zz[j] + fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] + fl1_fx * pc_yz[j] * pb_yz[j] + 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] + fl1_fx * pa_y[j] * pb_yz[j] * pc_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_y[j] * pb_zz[j] + 0.5 * fl1_fx * pc_y[j] * pb_yzz[j] + pa_xy[j] * pb_xy[j] * pc_zz[j] + 2.0 * pa_xy[j] * pb_xz[j] * pc_yz[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_yz[j] + pa_xy[j] * pc_xy[j] * pb_zz[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_xyz[j] + pa_x[j] * pc_yy[j] * pb_xzz[j] + pa_x[j] * pc_xy[j] * pb_yzz[j] + 2.0 * pc_xz[j] * pa_y[j] * pb_xyz[j] + pc_xy[j] * pa_y[j] * pb_xzz[j] + pc_xx[j] * pa_y[j] * pb_yzz[j] + pc_xy[j] * pb_xyzz[j]);

                t_xy_xyzz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.5 * pc_xx[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pc_zz[j] - 0.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_y[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xy[j] * pc_xy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yy[j] * pb_x[j] * fl1_fx - 0.5 * pa_x[j] * pc_xy[j] * pb_y[j] * fl1_fx - 0.5 * pa_x[j] * pc_xyy[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_xzz[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_zz[j] - pa_x[j] * fl1_fx * pc_xz[j] * pb_z[j] - 0.5 * pc_xy[j] * pa_y[j] * pb_x[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * pb_y[j] * fl1_fx - 0.5 * pc_xxy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xy[j] * pb_xy[j] * fl1_fx - 0.5 * pc_xyy[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxy[j] * pb_y[j] * fl1_fx - 0.5 * pc_xzz[j] * fl1_fx * pb_x[j] - pc_xxz[j] * fl1_fx * pb_z[j] - pc_xz[j] * fl1_fx * pb_xz[j] - 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pa_y[j] * pc_yzz[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_y[j] - fl1_fx * pc_yyz[j] * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pb_y[j] * pc_zz[j] - fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] - fl1_fx * pc_yz[j] * pb_yz[j] - 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] - pa_xy[j] * pb_x[j] * pc_yzz[j] - pa_xy[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_xy[j] * pc_xyz[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_xy[j] - 2.0 * pa_x[j] * pc_yyz[j] * pb_xz[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_yz[j] - pa_x[j] * pc_xyy[j] * pb_zz[j] - pc_xzz[j] * pa_y[j] * pb_xy[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_xz[j] - 2.0 * pc_xxz[j] * pa_y[j] * pb_yz[j] - pc_xxy[j] * pa_y[j] * pb_zz[j] - 2.0 * pc_xyz[j] * pb_xyz[j] - pc_xyy[j] * pb_xzz[j] - pc_xxy[j] * pb_yzz[j]);

                t_xy_xyzz[j] += fl_s_0_0_4 * (0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pc_zz[j] + 0.5 * pa_x[j] * pc_xyy[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_xzz[j] + 0.5 * pc_xxy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xyy[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxy[j] * pb_y[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_xxzz[j] * fl1_fx + 0.5 * pc_xzz[j] * fl1_fx * pb_x[j] + pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yyzz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yzz[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_y[j] + fl1_fx * pc_yyz[j] * pb_z[j] + pa_xy[j] * pc_xyzz[j] + pa_x[j] * pc_yyzz[j] * pb_x[j] + pa_x[j] * pc_xyzz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_z[j] + pc_xyzz[j] * pa_y[j] * pb_x[j] + pc_xxzz[j] * pa_y[j] * pb_y[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_z[j] + pc_xyzz[j] * pb_xy[j] + 2.0 * pc_xyyz[j] * pb_xz[j] + 2.0 * pc_xxyz[j] * pb_yz[j] + pc_xxyy[j] * pb_zz[j]);

                t_xy_xyzz[j] += fl_s_0_0_5 * (-0.5 * pc_xxyy[j] * fl1_fx - 0.5 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - pa_x[j] * pc_xyyzz[j] - pc_xxyzz[j] * pa_y[j] - pc_xyyzz[j] * pb_x[j] - pc_xxyzz[j] * pb_y[j] - 2.0 * pc_xxyyz[j] * pb_z[j]);

                t_xy_xyzz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_24_25(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (24,25)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xzzz = pbDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_xzzz = primBuffer.data(90 * idx + 24);

            // Batch of Integrals (24,25)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_x, pb_xz, pb_xzz, pb_xzzz, pb_z, pb_zz, pb_zzz, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, \
                                     pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, pc_z, \
                                     pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xy_xzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_xzzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xy[j] * pb_xz[j] * fl1_fx + 0.5 * fl1_fx * pa_y[j] * pb_zzz[j] + pa_xy[j] * pb_xzzz[j]);

                t_xy_xzzz[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_y[j] * pb_z[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xy[j] * pb_xz[j] * fl1_fx - 1.5 * pa_xy[j] * pb_x[j] * pc_z[j] * fl1_fx - 1.5 * pa_xy[j] * pc_x[j] * pb_z[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * pb_xz[j] * fl1_fx - 1.5 * pc_x[j] * pa_y[j] * pb_xz[j] * fl1_fx - 1.5 * fl1_fx * pa_y[j] * pb_zz[j] * pc_z[j] - 0.5 * fl1_fx * pc_y[j] * pb_zzz[j] - 0.5 * fl1_fx * pa_y[j] * pb_zzz[j] - 3.0 * pa_xy[j] * pb_xzz[j] * pc_z[j] - pa_xy[j] * pc_x[j] * pb_zzz[j] - pa_x[j] * pc_y[j] * pb_xzzz[j] - pc_x[j] * pa_y[j] * pb_xzzz[j]);

                t_xy_xzzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pc_yz[j] + 0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xy[j] * pb_x[j] * pc_z[j] * fl1_fx + 1.5 * pa_xy[j] * pc_x[j] * pb_z[j] * fl1_fx + 1.5 * pa_xy[j] * pc_xz[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_xz[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xy[j] * pb_z[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_y[j] * pb_x[j] * fl1_fx + 1.5 * pc_xx[j] * pa_y[j] * pb_z[j] * fl1_fx + 1.5 * pc_xy[j] * pb_xz[j] * fl1_fx + 1.5 * fl1_fx * pa_y[j] * pb_z[j] * pc_zz[j] + 1.5 * fl1_fx * pc_yz[j] * pb_zz[j] + 1.5 * fl1_fx * pa_y[j] * pb_zz[j] * pc_z[j] + 0.5 * fl1_fx * pc_y[j] * pb_zzz[j] + 3.0 * pa_xy[j] * pb_xz[j] * pc_zz[j] + 3.0 * pa_xy[j] * pc_xz[j] * pb_zz[j] + 3.0 * pa_x[j] * pc_yz[j] * pb_xzz[j] + pa_x[j] * pc_xy[j] * pb_zzz[j] + 3.0 * pc_xz[j] * pa_y[j] * pb_xzz[j] + pc_xx[j] * pa_y[j] * pb_zzz[j] + pc_xy[j] * pb_xzzz[j]);

                t_xy_xzzz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xy[j] * pc_xz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xy[j] * pb_z[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * pb_x[j] * fl1_fx - 1.5 * pc_xx[j] * pa_y[j] * pb_z[j] * fl1_fx - 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxy[j] * pb_z[j] * fl1_fx - 0.5 * fl1_fx * pa_y[j] * pc_zzz[j] - 1.5 * fl1_fx * pc_yzz[j] * pb_z[j] - 1.5 * fl1_fx * pa_y[j] * pb_z[j] * pc_zz[j] - 1.5 * fl1_fx * pc_yz[j] * pb_zz[j] - pa_xy[j] * pb_x[j] * pc_zzz[j] - 3.0 * pa_xy[j] * pc_xzz[j] * pb_z[j] - 3.0 * pa_x[j] * pc_yzz[j] * pb_xz[j] - 3.0 * pa_x[j] * pc_xyz[j] * pb_zz[j] - 3.0 * pc_xzz[j] * pa_y[j] * pb_xz[j] - 3.0 * pc_xxz[j] * pa_y[j] * pb_zz[j] - 3.0 * pc_xyz[j] * pb_xzz[j] - pc_xxy[j] * pb_zzz[j]);

                t_xy_xzzz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxy[j] * pb_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 0.5 * fl1_fx * pc_yzzz[j] + 0.5 * fl1_fx * pa_y[j] * pc_zzz[j] + 1.5 * fl1_fx * pc_yzz[j] * pb_z[j] + pa_xy[j] * pc_xzzz[j] + pa_x[j] * pc_yzzz[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xyzz[j] * pb_z[j] + pc_xzzz[j] * pa_y[j] * pb_x[j] + 3.0 * pc_xxzz[j] * pa_y[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pb_xz[j] + 3.0 * pc_xxyz[j] * pb_zz[j]);

                t_xy_xzzz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yzzz[j] - pa_x[j] * pc_xyzzz[j] - pc_xxzzz[j] * pa_y[j] - pc_xyzzz[j] * pb_x[j] - 3.0 * pc_xxyzz[j] * pb_z[j]);

                t_xy_xzzz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_25_26(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (25,26)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyy = pbDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyy = pcDistances.data(83 * idx + 70);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_yyyy = primBuffer.data(90 * idx + 25);

            // Batch of Integrals (25,26)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_y, pb_yy, pb_yyy, pb_yyyy, pc_x, pc_xy, pc_xyy, pc_xyyy, \
                                     pc_xyyyy, pc_xyyyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyyy, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xy_yyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_yyyy[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 3.0 * pa_x[j] * fl2_fx * pb_y[j] + 3.0 * pa_xy[j] * pb_yy[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pb_yyy[j] + pa_xy[j] * pb_yyyy[j]);

                t_xy_yyyy[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 3.75 * pa_x[j] * pc_y[j] * fl2_fx - 6.0 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 3.0 * pc_x[j] * fl2_fx * pb_y[j] - 3.0 * pa_xy[j] * pb_yy[j] * fl1_fx - 6.0 * pa_xy[j] * pb_y[j] * pc_y[j] * fl1_fx - 9.0 * pa_x[j] * pc_y[j] * pb_yy[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pb_yyy[j] - 3.0 * pc_x[j] * pa_y[j] * pb_yy[j] * fl1_fx - 2.0 * pc_x[j] * fl1_fx * pb_yyy[j] - 4.0 * pa_xy[j] * pb_yyy[j] * pc_y[j] - pa_x[j] * pc_y[j] * pb_yyyy[j] - pc_x[j] * pa_y[j] * pb_yyyy[j]);

                t_xy_yyyy[j] += fl_s_0_0_2 * (0.75 * pa_xy[j] * fl2_fx + 7.5 * pa_x[j] * pc_y[j] * fl2_fx + 3.0 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 3.75 * pc_xy[j] * fl2_fx + 6.0 * pc_x[j] * fl2_fx * pb_y[j] + 6.0 * pa_xy[j] * pb_y[j] * pc_y[j] * fl1_fx + 3.0 * pa_xy[j] * pc_yy[j] * fl1_fx + 9.0 * pa_x[j] * pc_y[j] * pb_yy[j] * fl1_fx + 12.0 * pa_x[j] * pc_yy[j] * pb_y[j] * fl1_fx + 3.0 * pc_x[j] * pa_y[j] * pb_yy[j] * fl1_fx + 6.0 * pc_xy[j] * pa_y[j] * pb_y[j] * fl1_fx + 9.0 * pc_xy[j] * pb_yy[j] * fl1_fx + 2.0 * pc_x[j] * fl1_fx * pb_yyy[j] + 6.0 * pa_xy[j] * pb_yy[j] * pc_yy[j] + 4.0 * pa_x[j] * pc_yy[j] * pb_yyy[j] + 4.0 * pc_xy[j] * pa_y[j] * pb_yyy[j] + pc_xy[j] * pb_yyyy[j]);

                t_xy_yyyy[j] += fl_s_0_0_3 * (-3.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 7.5 * pc_xy[j] * fl2_fx - 3.0 * pc_x[j] * fl2_fx * pb_y[j] - 3.0 * pa_xy[j] * pc_yy[j] * fl1_fx - 12.0 * pa_x[j] * pc_yy[j] * pb_y[j] * fl1_fx - 5.0 * pa_x[j] * pc_yyy[j] * fl1_fx - 6.0 * pc_xy[j] * pa_y[j] * pb_y[j] * fl1_fx - 3.0 * pc_xyy[j] * pa_y[j] * fl1_fx - 9.0 * pc_xy[j] * pb_yy[j] * fl1_fx - 12.0 * pc_xyy[j] * pb_y[j] * fl1_fx - 4.0 * pa_xy[j] * pb_y[j] * pc_yyy[j] - 6.0 * pa_x[j] * pc_yyy[j] * pb_yy[j] - 6.0 * pc_xyy[j] * pa_y[j] * pb_yy[j] - 4.0 * pc_xyy[j] * pb_yyy[j]);

                t_xy_yyyy[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 5.0 * pa_x[j] * pc_yyy[j] * fl1_fx + 3.0 * pc_xyy[j] * pa_y[j] * fl1_fx + 12.0 * pc_xyy[j] * pb_y[j] * fl1_fx + 5.0 * pc_xyyy[j] * fl1_fx + pa_xy[j] * pc_yyyy[j] + 4.0 * pa_x[j] * pc_yyyy[j] * pb_y[j] + 4.0 * pc_xyyy[j] * pa_y[j] * pb_y[j] + 6.0 * pc_xyyy[j] * pb_yy[j]);

                t_xy_yyyy[j] += fl_s_0_0_5 * (-5.0 * pc_xyyy[j] * fl1_fx - pa_x[j] * pc_yyyyy[j] - pc_xyyyy[j] * pa_y[j] - 4.0 * pc_xyyyy[j] * pb_y[j]);

                t_xy_yyyy[j] += fl_s_0_0_6 * pc_xyyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_26_27(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (26,27)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyz = pbDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_yyyz = primBuffer.data(90 * idx + 26);

            // Batch of Integrals (26,27)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_y, pb_yy, pb_yyy, pb_yyyz, pb_yyz, pb_yz, pb_z, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xy_yyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_yyyz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xy[j] * pb_yz[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_yyz[j] + pa_xy[j] * pb_yyyz[j]);

                t_xy_yyyz[j] += fl_s_0_0_1 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xy[j] * pb_y[j] * fl1_fx * pc_z[j] - 1.5 * pa_xy[j] * pb_yz[j] * fl1_fx - 1.5 * pa_xy[j] * pc_y[j] * fl1_fx * pb_z[j] - 4.5 * pa_x[j] * pc_y[j] * pb_yz[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_yy[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pb_yyz[j] - 1.5 * pc_x[j] * pa_y[j] * pb_yz[j] * fl1_fx - 1.5 * pc_x[j] * fl1_fx * pb_yyz[j] - pa_xy[j] * pb_yyy[j] * pc_z[j] - 3.0 * pa_xy[j] * pb_yyz[j] * pc_y[j] - pa_x[j] * pc_y[j] * pb_yyyz[j] - pc_x[j] * pa_y[j] * pb_yyyz[j]);

                t_xy_yyyz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xy[j] * pb_y[j] * fl1_fx * pc_z[j] + 1.5 * pa_xy[j] * pc_yz[j] * fl1_fx + 1.5 * pa_xy[j] * pc_y[j] * fl1_fx * pb_z[j] + 4.5 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx + 4.5 * pa_x[j] * pc_y[j] * pb_yz[j] * fl1_fx + 3.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pb_yy[j] * pc_z[j] + 1.5 * pc_xz[j] * pa_y[j] * pb_y[j] * fl1_fx + 1.5 * pc_x[j] * pa_y[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] + 4.5 * pc_xy[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] + 1.5 * pc_x[j] * fl1_fx * pb_yyz[j] + 3.0 * pa_xy[j] * pb_yy[j] * pc_yz[j] + 3.0 * pa_xy[j] * pb_yz[j] * pc_yy[j] + pa_x[j] * pc_yz[j] * pb_yyy[j] + 3.0 * pa_x[j] * pc_yy[j] * pb_yyz[j] + pc_xz[j] * pa_y[j] * pb_yyy[j] + 3.0 * pc_xy[j] * pa_y[j] * pb_yyz[j] + pc_xy[j] * pb_yyyz[j]);

                t_xy_yyyz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xy[j] * pc_yz[j] * fl1_fx - 4.5 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * pa_y[j] * pb_y[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] - 4.5 * pc_xyz[j] * pb_y[j] * fl1_fx - 4.5 * pc_xy[j] * pb_yz[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] - 3.0 * pa_xy[j] * pb_y[j] * pc_yyz[j] - pa_xy[j] * pc_yyy[j] * pb_z[j] - 3.0 * pa_x[j] * pc_yyz[j] * pb_yy[j] - 3.0 * pa_x[j] * pc_yyy[j] * pb_yz[j] - 3.0 * pc_xyz[j] * pa_y[j] * pb_yy[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_yz[j] - pc_xyz[j] * pb_yyy[j] - 3.0 * pc_xyy[j] * pb_yyz[j]);

                t_xy_yyyz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx + 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx + 4.5 * pc_xyz[j] * pb_y[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_yyyz[j] + 3.0 * pa_x[j] * pc_yyyz[j] * pb_y[j] + pa_x[j] * pc_yyyy[j] * pb_z[j] + 3.0 * pc_xyyz[j] * pa_y[j] * pb_y[j] + pc_xyyy[j] * pa_y[j] * pb_z[j] + 3.0 * pc_xyyz[j] * pb_yy[j] + 3.0 * pc_xyyy[j] * pb_yz[j]);

                t_xy_yyyz[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - pa_x[j] * pc_yyyyz[j] - pc_xyyyz[j] * pa_y[j] - 3.0 * pc_xyyyz[j] * pb_y[j] - pc_xyyyy[j] * pb_z[j]);

                t_xy_yyyz[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_27_28(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (27,28)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyzz = pbDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_yyzz = primBuffer.data(90 * idx + 27);

            // Batch of Integrals (27,28)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_y, pb_yy, pb_yyz, pb_yyzz, pb_yz, pb_yzz, pb_z, pb_zz, \
                                     pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, pc_xyz, \
                                     pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, \
                                     pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xy_yyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_yyzz[j] = fl_s_0_0_0 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xy[j] * pb_yy[j] * fl1_fx + 0.5 * pa_xy[j] * fl1_fx * pb_zz[j] + pa_x[j] * fl1_fx * pb_yzz[j] + pa_xy[j] * pb_yyzz[j]);

                t_xy_yyzz[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - pa_x[j] * fl2_fx * pb_y[j] - 0.25 * pc_x[j] * pa_y[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xy[j] * pb_yy[j] * fl1_fx - pa_xy[j] * pb_y[j] * pc_y[j] * fl1_fx - pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_zz[j] - 0.5 * pa_x[j] * pc_y[j] * pb_yy[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] - 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_z[j] - pa_x[j] * fl1_fx * pb_yzz[j] - 0.5 * pc_x[j] * pa_y[j] * pb_yy[j] * fl1_fx - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] - pc_x[j] * fl1_fx * pb_yzz[j] - 2.0 * pa_xy[j] * pb_yyz[j] * pc_z[j] - 2.0 * pa_xy[j] * pb_yzz[j] * pc_y[j] - pa_x[j] * pc_y[j] * pb_yyzz[j] - pc_x[j] * pa_y[j] * pb_yyzz[j]);

                t_xy_yyzz[j] += fl_s_0_0_2 * (0.25 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + pc_x[j] * fl2_fx * pb_y[j] + pa_xy[j] * pb_y[j] * pc_y[j] * fl1_fx + 0.5 * pa_xy[j] * pc_yy[j] * fl1_fx + 0.5 * pa_xy[j] * fl1_fx * pc_zz[j] + pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] + 0.5 * pa_x[j] * pc_y[j] * pb_yy[j] * fl1_fx + pa_x[j] * pc_yy[j] * pb_y[j] * fl1_fx + 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] + pa_x[j] * fl1_fx * pb_y[j] * pc_zz[j] + 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_z[j] + 0.5 * pc_x[j] * pa_y[j] * pb_yy[j] * fl1_fx + pc_xy[j] * pa_y[j] * pb_y[j] * fl1_fx + pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_xy[j] * pb_yy[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + 2.0 * pc_xz[j] * fl1_fx * pb_yz[j] + pc_x[j] * fl1_fx * pb_yzz[j] + pa_xy[j] * pb_yy[j] * pc_zz[j] + 4.0 * pa_xy[j] * pb_yz[j] * pc_yz[j] + pa_xy[j] * pc_yy[j] * pb_zz[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_yyz[j] + 2.0 * pa_x[j] * pc_yy[j] * pb_yzz[j] + 2.0 * pc_xz[j] * pa_y[j] * pb_yyz[j] + 2.0 * pc_xy[j] * pa_y[j] * pb_yzz[j] + pc_xy[j] * pb_yyzz[j]);

                t_xy_yyzz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.25 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xy[j] * pc_yy[j] * fl1_fx - 0.5 * pa_xy[j] * fl1_fx * pc_zz[j] - pa_x[j] * pc_yy[j] * pb_y[j] * fl1_fx - 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pb_y[j] * pc_zz[j] - pc_xy[j] * pa_y[j] * pb_y[j] * fl1_fx - 0.5 * pc_xyy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xzz[j] * pa_y[j] * fl1_fx - pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * pb_yy[j] * fl1_fx - pc_xyy[j] * pb_y[j] * fl1_fx - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - pc_xzz[j] * fl1_fx * pb_y[j] - 2.0 * pc_xz[j] * fl1_fx * pb_yz[j] - 2.0 * pa_xy[j] * pb_y[j] * pc_yzz[j] - 2.0 * pa_xy[j] * pc_yyz[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_yy[j] - 4.0 * pa_x[j] * pc_yyz[j] * pb_yz[j] - pa_x[j] * pc_yyy[j] * pb_zz[j] - pc_xzz[j] * pa_y[j] * pb_yy[j] - 4.0 * pc_xyz[j] * pa_y[j] * pb_yz[j] - pc_xyy[j] * pa_y[j] * pb_zz[j] - 2.0 * pc_xyz[j] * pb_yyz[j] - 2.0 * pc_xyy[j] * pb_yzz[j]);

                t_xy_yyzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx + 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 0.5 * pc_xyy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xzz[j] * pa_y[j] * fl1_fx + pc_xyy[j] * pb_y[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + pc_xzz[j] * fl1_fx * pb_y[j] + pa_xy[j] * pc_yyzz[j] + 2.0 * pa_x[j] * pc_yyzz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_yyyz[j] * pb_z[j] + 2.0 * pc_xyzz[j] * pa_y[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pa_y[j] * pb_z[j] + pc_xyzz[j] * pb_yy[j] + 4.0 * pc_xyyz[j] * pb_yz[j] + pc_xyyy[j] * pb_zz[j]);

                t_xy_yyzz[j] += fl_s_0_0_5 * (-0.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yyyzz[j] - pc_xyyzz[j] * pa_y[j] - 2.0 * pc_xyyzz[j] * pb_y[j] - 2.0 * pc_xyyyz[j] * pb_z[j]);

                t_xy_yyzz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_28_29(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (28,29)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yzzz = pbDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_yzzz = primBuffer.data(90 * idx + 28);

            // Batch of Integrals (28,29)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_y, pb_yz, pb_yzz, pb_yzzz, pb_z, pb_zz, pb_zzz, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, \
                                     pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_z, \
                                     pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xy_yzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_yzzz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xy[j] * pb_yz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_zzz[j] + pa_xy[j] * pb_yzzz[j]);

                t_xy_yzzz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pa_x[j] * fl2_fx * pc_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xy[j] * pb_yz[j] * fl1_fx - 1.5 * pa_xy[j] * pb_y[j] * pc_z[j] * fl1_fx - 1.5 * pa_xy[j] * pc_y[j] * pb_z[j] * fl1_fx - 1.5 * pa_x[j] * pc_y[j] * pb_yz[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_zz[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pb_zzz[j] - 1.5 * pc_x[j] * pa_y[j] * pb_yz[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_zzz[j] - 3.0 * pa_xy[j] * pb_yzz[j] * pc_z[j] - pa_xy[j] * pc_y[j] * pb_zzz[j] - pa_x[j] * pc_y[j] * pb_yzzz[j] - pc_x[j] * pa_y[j] * pb_yzzz[j]);

                t_xy_yzzz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_xy[j] * pb_y[j] * pc_z[j] * fl1_fx + 1.5 * pa_xy[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_xy[j] * pc_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_y[j] * pb_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_yy[j] * pb_z[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_z[j] * pc_zz[j] + 1.5 * pa_x[j] * fl1_fx * pb_zz[j] * pc_z[j] + 1.5 * pc_x[j] * pa_y[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_y[j] * pb_y[j] * fl1_fx + 1.5 * pc_xy[j] * pa_y[j] * pb_z[j] * fl1_fx + 1.5 * pc_xy[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 0.5 * pc_x[j] * fl1_fx * pb_zzz[j] + 3.0 * pa_xy[j] * pb_yz[j] * pc_zz[j] + 3.0 * pa_xy[j] * pc_yz[j] * pb_zz[j] + 3.0 * pa_x[j] * pc_yz[j] * pb_yzz[j] + pa_x[j] * pc_yy[j] * pb_zzz[j] + 3.0 * pc_xz[j] * pa_y[j] * pb_yzz[j] + pc_xy[j] * pa_y[j] * pb_zzz[j] + pc_xy[j] * pb_yzzz[j]);

                t_xy_yzzz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xy[j] * pc_yz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_yy[j] * pb_z[j] * fl1_fx - 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx - 0.5 * pa_x[j] * fl1_fx * pc_zzz[j] - 1.5 * pa_x[j] * fl1_fx * pb_z[j] * pc_zz[j] - 1.5 * pc_xz[j] * pa_y[j] * pb_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_y[j] * pb_z[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pb_yz[j] * fl1_fx - 1.5 * pc_xyz[j] * pb_y[j] * fl1_fx - 1.5 * pc_xyy[j] * pb_z[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] - pa_xy[j] * pb_y[j] * pc_zzz[j] - 3.0 * pa_xy[j] * pc_yzz[j] * pb_z[j] - 3.0 * pa_x[j] * pc_yzz[j] * pb_yz[j] - 3.0 * pa_x[j] * pc_yyz[j] * pb_zz[j] - 3.0 * pc_xzz[j] * pa_y[j] * pb_yz[j] - 3.0 * pc_xyz[j] * pa_y[j] * pb_zz[j] - 3.0 * pc_xyz[j] * pb_yzz[j] - pc_xyy[j] * pb_zzz[j]);

                t_xy_yzzz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_zzz[j] + 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xyy[j] * pb_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 0.5 * pc_xzzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_yzzz[j] + pa_x[j] * pc_yzzz[j] * pb_y[j] + 3.0 * pa_x[j] * pc_yyzz[j] * pb_z[j] + pc_xzzz[j] * pa_y[j] * pb_y[j] + 3.0 * pc_xyzz[j] * pa_y[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pb_yz[j] + 3.0 * pc_xyyz[j] * pb_zz[j]);

                t_xy_yzzz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_yyzzz[j] - pc_xyzzz[j] * pa_y[j] - pc_xyzzz[j] * pb_y[j] - 3.0 * pc_xyyzz[j] * pb_z[j]);

                t_xy_yzzz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_29_30(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (29,30)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_zzzz = pbDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xy_zzzz = primBuffer.data(90 * idx + 29);

            // Batch of Integrals (29,30)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_y, pb_z, pb_zz, pb_zzz, pb_zzzz, pc_x, pc_xy, pc_xyz, pc_xyzz, \
                                     pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, \
                                     pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xy_zzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xy_zzzz[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 3.0 * pa_xy[j] * pb_zz[j] * fl1_fx + pa_xy[j] * pb_zzzz[j]);

                t_xy_zzzz[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 3.0 * pa_xy[j] * pb_zz[j] * fl1_fx - 6.0 * pa_xy[j] * pb_z[j] * pc_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_y[j] * pb_zz[j] * fl1_fx - 3.0 * pc_x[j] * pa_y[j] * pb_zz[j] * fl1_fx - 4.0 * pa_xy[j] * pb_zzz[j] * pc_z[j] - pa_x[j] * pc_y[j] * pb_zzzz[j] - pc_x[j] * pa_y[j] * pb_zzzz[j]);

                t_xy_zzzz[j] += fl_s_0_0_2 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + 6.0 * pa_xy[j] * pb_z[j] * pc_z[j] * fl1_fx + 3.0 * pa_xy[j] * pc_zz[j] * fl1_fx + 3.0 * pa_x[j] * pc_y[j] * pb_zz[j] * fl1_fx + 6.0 * pa_x[j] * pc_yz[j] * pb_z[j] * fl1_fx + 3.0 * pc_x[j] * pa_y[j] * pb_zz[j] * fl1_fx + 6.0 * pc_xz[j] * pa_y[j] * pb_z[j] * fl1_fx + 3.0 * pc_xy[j] * pb_zz[j] * fl1_fx + 6.0 * pa_xy[j] * pb_zz[j] * pc_zz[j] + 4.0 * pa_x[j] * pc_yz[j] * pb_zzz[j] + 4.0 * pc_xz[j] * pa_y[j] * pb_zzz[j] + pc_xy[j] * pb_zzzz[j]);

                t_xy_zzzz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 3.0 * pa_xy[j] * pc_zz[j] * fl1_fx - 6.0 * pa_x[j] * pc_yz[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx - 6.0 * pc_xz[j] * pa_y[j] * pb_z[j] * fl1_fx - 3.0 * pc_xzz[j] * pa_y[j] * fl1_fx - 3.0 * pc_xy[j] * pb_zz[j] * fl1_fx - 6.0 * pc_xyz[j] * pb_z[j] * fl1_fx - 4.0 * pa_xy[j] * pb_z[j] * pc_zzz[j] - 6.0 * pa_x[j] * pc_yzz[j] * pb_zz[j] - 6.0 * pc_xzz[j] * pa_y[j] * pb_zz[j] - 4.0 * pc_xyz[j] * pb_zzz[j]);

                t_xy_zzzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx + 3.0 * pc_xzz[j] * pa_y[j] * fl1_fx + 6.0 * pc_xyz[j] * pb_z[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + pa_xy[j] * pc_zzzz[j] + 4.0 * pa_x[j] * pc_yzzz[j] * pb_z[j] + 4.0 * pc_xzzz[j] * pa_y[j] * pb_z[j] + 6.0 * pc_xyzz[j] * pb_zz[j]);

                t_xy_zzzz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yzzzz[j] - pc_xzzzz[j] * pa_y[j] - 4.0 * pc_xyzzz[j] * pb_z[j]);

                t_xy_zzzz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_30_31(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (30,31)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxx = pbDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxz = pcDistances.data(83 * idx + 57);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xxxx = primBuffer.data(90 * idx + 30);

            // Batch of Integrals (30,31)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxxx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxx, pc_xxxxxz, pc_xxxxz, pc_xxxz, pc_xxz, pc_xz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xz_xxxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xxxx[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 3.0 * fl2_fx * pa_z[j] * pb_x[j] + 3.0 * pa_xz[j] * pb_xx[j] * fl1_fx + 2.0 * fl1_fx * pa_z[j] * pb_xxx[j] + pa_xz[j] * pb_xxxx[j]);

                t_xz_xxxx[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * pc_z[j] * fl2_fx - 3.75 * pc_x[j] * pa_z[j] * fl2_fx - 6.0 * fl2_fx * pa_z[j] * pb_x[j] - 3.0 * fl2_fx * pc_z[j] * pb_x[j] - 3.0 * pa_xz[j] * pb_xx[j] * fl1_fx - 6.0 * pa_xz[j] * pb_x[j] * pc_x[j] * fl1_fx - 3.0 * pa_x[j] * pc_z[j] * pb_xx[j] * fl1_fx - 9.0 * pc_x[j] * pa_z[j] * pb_xx[j] * fl1_fx - 2.0 * fl1_fx * pc_z[j] * pb_xxx[j] - 2.0 * fl1_fx * pa_z[j] * pb_xxx[j] - 4.0 * pa_xz[j] * pb_xxx[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxxx[j] - pc_x[j] * pa_z[j] * pb_xxxx[j]);

                t_xz_xxxx[j] += fl_s_0_0_2 * (0.75 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_z[j] * fl2_fx + 7.5 * pc_x[j] * pa_z[j] * fl2_fx + 3.75 * pc_xz[j] * fl2_fx + 6.0 * fl2_fx * pc_z[j] * pb_x[j] + 3.0 * fl2_fx * pa_z[j] * pb_x[j] + 6.0 * pa_xz[j] * pb_x[j] * pc_x[j] * fl1_fx + 3.0 * pa_xz[j] * pc_xx[j] * fl1_fx + 3.0 * pa_x[j] * pc_z[j] * pb_xx[j] * fl1_fx + 6.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx + 9.0 * pc_x[j] * pa_z[j] * pb_xx[j] * fl1_fx + 12.0 * pc_xx[j] * pa_z[j] * pb_x[j] * fl1_fx + 9.0 * pc_xz[j] * pb_xx[j] * fl1_fx + 2.0 * fl1_fx * pc_z[j] * pb_xxx[j] + 6.0 * pa_xz[j] * pb_xx[j] * pc_xx[j] + 4.0 * pa_x[j] * pc_xz[j] * pb_xxx[j] + 4.0 * pc_xx[j] * pa_z[j] * pb_xxx[j] + pc_xz[j] * pb_xxxx[j]);

                t_xz_xxxx[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_z[j] * fl2_fx - 3.75 * pc_x[j] * pa_z[j] * fl2_fx - 7.5 * pc_xz[j] * fl2_fx - 3.0 * fl2_fx * pc_z[j] * pb_x[j] - 3.0 * pa_xz[j] * pc_xx[j] * fl1_fx - 6.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxz[j] * fl1_fx - 12.0 * pc_xx[j] * pa_z[j] * pb_x[j] * fl1_fx - 5.0 * pc_xxx[j] * pa_z[j] * fl1_fx - 9.0 * pc_xz[j] * pb_xx[j] * fl1_fx - 12.0 * pc_xxz[j] * pb_x[j] * fl1_fx - 4.0 * pa_xz[j] * pb_x[j] * pc_xxx[j] - 6.0 * pa_x[j] * pc_xxz[j] * pb_xx[j] - 6.0 * pc_xxx[j] * pa_z[j] * pb_xx[j] - 4.0 * pc_xxz[j] * pb_xxx[j]);

                t_xz_xxxx[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_xxz[j] * fl1_fx + 5.0 * pc_xxx[j] * pa_z[j] * fl1_fx + 12.0 * pc_xxz[j] * pb_x[j] * fl1_fx + 5.0 * pc_xxxz[j] * fl1_fx + pa_xz[j] * pc_xxxx[j] + 4.0 * pa_x[j] * pc_xxxz[j] * pb_x[j] + 4.0 * pc_xxxx[j] * pa_z[j] * pb_x[j] + 6.0 * pc_xxxz[j] * pb_xx[j]);

                t_xz_xxxx[j] += fl_s_0_0_5 * (-5.0 * pc_xxxz[j] * fl1_fx - pa_x[j] * pc_xxxxz[j] - pc_xxxxx[j] * pa_z[j] - 4.0 * pc_xxxxz[j] * pb_x[j]);

                t_xz_xxxx[j] += fl_s_0_0_6 * pc_xxxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_31_32(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (31,32)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxy = pbDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xxxy = primBuffer.data(90 * idx + 31);

            // Batch of Integrals (31,32)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxxy, pb_xxy, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, \
                                     pc_xxy, pc_xxyz, pc_xxz, pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xz_xxxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xxxy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_xz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pa_z[j] * pb_xxy[j] + pa_xz[j] * pb_xxxy[j]);

                t_xz_xxxy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_z[j] * pc_y[j] - 1.5 * fl2_fx * pa_z[j] * pb_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xz[j] * pb_x[j] * fl1_fx * pc_y[j] - 1.5 * pa_xz[j] * pb_xy[j] * fl1_fx - 1.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * pc_z[j] * pb_xy[j] * fl1_fx - 4.5 * pc_x[j] * pa_z[j] * pb_xy[j] * fl1_fx - 1.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_y[j] - 1.5 * fl1_fx * pc_z[j] * pb_xxy[j] - 1.5 * fl1_fx * pa_z[j] * pb_xxy[j] - pa_xz[j] * pb_xxx[j] * pc_y[j] - 3.0 * pa_xz[j] * pb_xxy[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxxy[j] - pc_x[j] * pa_z[j] * pb_xxxy[j]);

                t_xz_xxxy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_z[j] * pc_y[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_xz[j] * pb_x[j] * fl1_fx * pc_y[j] + 1.5 * pa_xz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + 4.5 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx + 4.5 * pc_x[j] * pa_z[j] * pb_xy[j] * fl1_fx + 3.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_y[j] + 4.5 * pc_xz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pc_yz[j] * pb_xx[j] + 1.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_y[j] + 1.5 * fl1_fx * pc_z[j] * pb_xxy[j] + 3.0 * pa_xz[j] * pb_xx[j] * pc_xy[j] + 3.0 * pa_xz[j] * pb_xy[j] * pc_xx[j] + pa_x[j] * pc_yz[j] * pb_xxx[j] + 3.0 * pa_x[j] * pc_xz[j] * pb_xxy[j] + pc_xy[j] * pa_z[j] * pb_xxx[j] + 3.0 * pc_xx[j] * pa_z[j] * pb_xxy[j] + pc_xz[j] * pb_xxxy[j]);

                t_xz_xxxy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 4.5 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_y[j] - 4.5 * pc_xyz[j] * pb_x[j] * fl1_fx - 4.5 * pc_xz[j] * pb_xy[j] * fl1_fx - 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] - 1.5 * fl1_fx * pc_yz[j] * pb_xx[j] - 3.0 * pa_xz[j] * pb_x[j] * pc_xxy[j] - pa_xz[j] * pc_xxx[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xyz[j] * pb_xx[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_xy[j] - 3.0 * pc_xxy[j] * pa_z[j] * pb_xx[j] - 3.0 * pc_xxx[j] * pa_z[j] * pb_xy[j] - pc_xyz[j] * pb_xxx[j] - 3.0 * pc_xxz[j] * pb_xxy[j]);

                t_xz_xxxy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxy[j] * pa_z[j] * fl1_fx + 4.5 * pc_xyz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] + pa_xz[j] * pc_xxxy[j] + 3.0 * pa_x[j] * pc_xxyz[j] * pb_x[j] + pa_x[j] * pc_xxxz[j] * pb_y[j] + 3.0 * pc_xxxy[j] * pa_z[j] * pb_x[j] + pc_xxxx[j] * pa_z[j] * pb_y[j] + 3.0 * pc_xxyz[j] * pb_xx[j] + 3.0 * pc_xxxz[j] * pb_xy[j]);

                t_xz_xxxy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - pa_x[j] * pc_xxxyz[j] - pc_xxxxy[j] * pa_z[j] - 3.0 * pc_xxxyz[j] * pb_x[j] - pc_xxxxz[j] * pb_y[j]);

                t_xz_xxxy[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_32_33(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (32,33)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxz = pbDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxzz = pcDistances.data(83 * idx + 60);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xxxz = primBuffer.data(90 * idx + 32);

            // Batch of Integrals (32,33)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxxz, pb_xxz, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxz, pc_xxxxzz, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, \
                                     pc_xz, pc_xzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xz_xxxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xz_xxxz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_xx[j] + 1.5 * pa_xz[j] * pb_xz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_xxx[j] + 1.5 * fl1_fx * pa_z[j] * pb_xxz[j] + pa_xz[j] * pb_xxxz[j]);

                t_xz_xxxz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 2.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * fl2_fx * pb_xx[j] - 1.5 * pa_xz[j] * pb_x[j] * fl1_fx * pc_z[j] - 1.5 * pa_xz[j] * pb_xz[j] * fl1_fx - 1.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_z[j] * pb_xz[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xxx[j] - 4.5 * pc_x[j] * pa_z[j] * pb_xz[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_xxx[j] - 1.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_z[j] - 1.5 * fl1_fx * pc_z[j] * pb_xxz[j] - 1.5 * fl1_fx * pa_z[j] * pb_xxz[j] - pa_xz[j] * pb_xxx[j] * pc_z[j] - 3.0 * pa_xz[j] * pb_xxz[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxxz[j] - pc_x[j] * pa_z[j] * pb_xxxz[j]);

                t_xz_xxxz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 4.5 * pc_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pc_z[j] + 0.75 * fl2_fx * pc_zz[j] + 1.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_xx[j] + 1.5 * pa_xz[j] * pb_x[j] * fl1_fx * pc_z[j] + 1.5 * pa_xz[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_zz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_xz[j] * fl1_fx + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_xx[j] + 1.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_x[j] + 4.5 * pc_xz[j] * pa_z[j] * pb_x[j] * fl1_fx + 4.5 * pc_x[j] * pa_z[j] * pb_xz[j] * fl1_fx + 3.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] + 4.5 * pc_xz[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xx[j] * fl1_fx * pb_xx[j] + 0.5 * pc_x[j] * fl1_fx * pb_xxx[j] + 1.5 * fl1_fx * pc_zz[j] * pb_xx[j] + 1.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_z[j] + 1.5 * fl1_fx * pc_z[j] * pb_xxz[j] + 3.0 * pa_xz[j] * pb_xx[j] * pc_xz[j] + 3.0 * pa_xz[j] * pb_xz[j] * pc_xx[j] + pa_x[j] * pc_zz[j] * pb_xxx[j] + 3.0 * pa_x[j] * pc_xz[j] * pb_xxz[j] + pc_xz[j] * pa_z[j] * pb_xxx[j] + 3.0 * pc_xx[j] * pa_z[j] * pb_xxz[j] + pc_xz[j] * pb_xxxz[j]);

                t_xz_xxxz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 3.0 * pc_xx[j] * fl2_fx - 2.25 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pc_zz[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_xz[j] * pc_xz[j] * fl1_fx - 1.5 * pa_x[j] * pc_zz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xzz[j] * fl1_fx - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xxx[j] - 1.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_xx[j] - 4.5 * pc_xz[j] * pa_z[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxz[j] * pa_z[j] * fl1_fx - 3.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] - 4.5 * pc_xzz[j] * pb_x[j] * fl1_fx - 4.5 * pc_xz[j] * pb_xz[j] * fl1_fx - 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxx[j] * fl1_fx * pb_x[j] - 1.5 * pc_xx[j] * fl1_fx * pb_xx[j] - 1.5 * fl1_fx * pc_zz[j] * pb_xx[j] - 3.0 * pa_xz[j] * pb_x[j] * pc_xxz[j] - pa_xz[j] * pc_xxx[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xzz[j] * pb_xx[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_xz[j] - 3.0 * pc_xxz[j] * pa_z[j] * pb_xx[j] - 3.0 * pc_xxx[j] * pa_z[j] * pb_xz[j] - pc_xzz[j] * pb_xxx[j] - 3.0 * pc_xxz[j] * pb_xxz[j]);

                t_xz_xxxz[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 0.75 * fl2_fx * pc_zz[j] + 1.5 * pa_x[j] * pc_xzz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_xxx[j] + 3.0 * pc_xxz[j] * pa_z[j] * fl1_fx + 4.5 * pc_xzz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxxx[j] * fl1_fx + 1.5 * pc_xxx[j] * fl1_fx * pb_x[j] + pa_xz[j] * pc_xxxz[j] + 3.0 * pa_x[j] * pc_xxzz[j] * pb_x[j] + pa_x[j] * pc_xxxz[j] * pb_z[j] + 3.0 * pc_xxxz[j] * pa_z[j] * pb_x[j] + pc_xxxx[j] * pa_z[j] * pb_z[j] + 3.0 * pc_xxzz[j] * pb_xx[j] + 3.0 * pc_xxxz[j] * pb_xz[j]);

                t_xz_xxxz[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * pc_xxxx[j] * fl1_fx - pa_x[j] * pc_xxxzz[j] - pc_xxxxz[j] * pa_z[j] - 3.0 * pc_xxxzz[j] * pb_x[j] - pc_xxxxz[j] * pb_z[j]);

                t_xz_xxxz[j] += fl_s_0_0_6 * pc_xxxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_33_34(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (33,34)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyy = pbDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xxyy = primBuffer.data(90 * idx + 33);

            // Batch of Integrals (33,34)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxy, pb_xxyy, pb_xy, pb_xyy, pb_y, pb_yy, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, pc_xxy, \
                                     pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, \
                                     pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xz_xxyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xxyy[j] = fl_s_0_0_0 * (0.25 * pa_xz[j] * fl2_fx + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xz[j] * pb_xx[j] * fl1_fx + 0.5 * pa_xz[j] * fl1_fx * pb_yy[j] + fl1_fx * pa_z[j] * pb_xyy[j] + pa_xz[j] * pb_xxyy[j]);

                t_xz_xxyy[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl2_fx - 0.25 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - fl2_fx * pa_z[j] * pb_x[j] - 0.5 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xz[j] * pb_xx[j] * fl1_fx - pa_xz[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_xz[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xz[j] * fl1_fx * pb_yy[j] - 0.5 * pa_x[j] * pc_z[j] * pb_xx[j] * fl1_fx - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yy[j] - 0.5 * pc_x[j] * pa_z[j] * pb_xx[j] * fl1_fx - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yy[j] - 2.0 * fl1_fx * pa_z[j] * pb_xy[j] * pc_y[j] - fl1_fx * pc_z[j] * pb_xyy[j] - fl1_fx * pa_z[j] * pb_xyy[j] - 2.0 * pa_xz[j] * pb_xxy[j] * pc_y[j] - 2.0 * pa_xz[j] * pb_xyy[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxyy[j] - pc_x[j] * pa_z[j] * pb_xxyy[j]);

                t_xz_xxyy[j] += fl_s_0_0_2 * (0.25 * pa_xz[j] * fl2_fx + 0.5 * pa_x[j] * pc_z[j] * fl2_fx + 1.5 * pc_x[j] * pa_z[j] * fl2_fx + 0.75 * pc_xz[j] * fl2_fx + fl2_fx * pc_z[j] * pb_x[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + pa_xz[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_xz[j] * pc_xx[j] * fl1_fx + 0.5 * pa_xz[j] * fl1_fx * pc_yy[j] + pa_xz[j] * fl1_fx * pb_y[j] * pc_y[j] + 0.5 * pa_x[j] * pc_z[j] * pb_xx[j] * fl1_fx + pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yy[j] + 0.5 * pc_x[j] * pa_z[j] * pb_xx[j] * fl1_fx + pc_xx[j] * pa_z[j] * pb_x[j] * fl1_fx + 3.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yy[j] + 0.5 * pc_xz[j] * pb_xx[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_yy[j] + 2.0 * fl1_fx * pc_yz[j] * pb_xy[j] + 2.0 * fl1_fx * pa_z[j] * pb_xy[j] * pc_y[j] + fl1_fx * pc_z[j] * pb_xyy[j] + pa_xz[j] * pb_xx[j] * pc_yy[j] + 4.0 * pa_xz[j] * pb_xy[j] * pc_xy[j] + pa_xz[j] * pc_xx[j] * pb_yy[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_xxy[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xyy[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xxy[j] + 2.0 * pc_xx[j] * pa_z[j] * pb_xyy[j] + pc_xz[j] * pb_xxyy[j]);

                t_xz_xxyy[j] += fl_s_0_0_3 * (-0.25 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 1.5 * pc_xz[j] * fl2_fx - 0.5 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xz[j] * pc_xx[j] * fl1_fx - 0.5 * pa_xz[j] * fl1_fx * pc_yy[j] - pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx - 0.5 * pa_x[j] * pc_xxz[j] * fl1_fx - 0.5 * pa_x[j] * pc_yyz[j] * fl1_fx - pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] - pc_xx[j] * pa_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx - 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] - 0.5 * pc_xz[j] * pb_xx[j] * fl1_fx - pc_xxz[j] * pb_x[j] * fl1_fx - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] - fl1_fx * pc_yyz[j] * pb_x[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_yy[j] - 2.0 * fl1_fx * pc_yz[j] * pb_xy[j] - 2.0 * pa_xz[j] * pb_x[j] * pc_xyy[j] - 2.0 * pa_xz[j] * pc_xxy[j] * pb_y[j] - pa_x[j] * pc_yyz[j] * pb_xx[j] - 4.0 * pa_x[j] * pc_xyz[j] * pb_xy[j] - pa_x[j] * pc_xxz[j] * pb_yy[j] - pc_xyy[j] * pa_z[j] * pb_xx[j] - 4.0 * pc_xxy[j] * pa_z[j] * pb_xy[j] - pc_xxx[j] * pa_z[j] * pb_yy[j] - 2.0 * pc_xyz[j] * pb_xxy[j] - 2.0 * pc_xxz[j] * pb_xyy[j]);

                t_xz_xxyy[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 0.5 * pa_x[j] * pc_xxz[j] * fl1_fx + 0.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx + pc_xxz[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxxz[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + fl1_fx * pc_yyz[j] * pb_x[j] + pa_xz[j] * pc_xxyy[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyz[j] * pb_y[j] + 2.0 * pc_xxyy[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxxy[j] * pa_z[j] * pb_y[j] + pc_xyyz[j] * pb_xx[j] + 4.0 * pc_xxyz[j] * pb_xy[j] + pc_xxxz[j] * pb_yy[j]);

                t_xz_xxyy[j] += fl_s_0_0_5 * (-0.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - pa_x[j] * pc_xxyyz[j] - pc_xxxyy[j] * pa_z[j] - 2.0 * pc_xxyyz[j] * pb_x[j] - 2.0 * pc_xxxyz[j] * pb_y[j]);

                t_xz_xxyy[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_34_35(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (34,35)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyz = pbDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xxyz = primBuffer.data(90 * idx + 34);

            // Batch of Integrals (34,35)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxy, pb_xxyz, pb_xxz, pb_xy, pb_xyz, pb_xz, \
                                     pb_y, pb_yz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, \
                                     pc_xxxzz, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xz_xxyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xxyz[j] = fl_s_0_0_0 * (0.25 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * fl2_fx * pb_xy[j] + 0.5 * pa_xz[j] * fl1_fx * pb_yz[j] + 0.5 * pa_x[j] * fl1_fx * pb_xxy[j] + fl1_fx * pa_z[j] * pb_xyz[j] + pa_xz[j] * pb_xxyz[j]);

                t_xz_xxyz[j] += fl_s_0_0_1 * (-0.25 * pa_x[j] * fl2_fx * pc_y[j] - 0.5 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * fl2_fx * pb_x[j] * pc_y[j] - fl2_fx * pb_xy[j] - 0.5 * pa_xz[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_yz[j] - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yz[j] - 0.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_y[j] - pa_x[j] * fl1_fx * pb_xy[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pb_xxy[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * fl1_fx * pb_xxy[j] - fl1_fx * pa_z[j] * pb_xy[j] * pc_z[j] - fl1_fx * pa_z[j] * pb_xz[j] * pc_y[j] - fl1_fx * pc_z[j] * pb_xyz[j] - fl1_fx * pa_z[j] * pb_xyz[j] - pa_xz[j] * pb_xxy[j] * pc_z[j] - pa_xz[j] * pb_xxz[j] * pc_y[j] - 2.0 * pa_xz[j] * pb_xyz[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxyz[j] - pc_x[j] * pa_z[j] * pb_xxyz[j]);

                t_xz_xxyz[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.25 * pa_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + fl2_fx * pb_x[j] * pc_y[j] + 0.5 * fl2_fx * pb_xy[j] + 0.5 * pa_xz[j] * fl1_fx * pc_yz[j] + 0.5 * pa_xz[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pa_x[j] * pc_zz[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yz[j] + pa_x[j] * fl1_fx * pb_x[j] * pc_xy[j] + 0.5 * pa_x[j] * fl1_fx * pc_xx[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pb_xx[j] * pc_y[j] + pa_x[j] * fl1_fx * pb_xy[j] * pc_x[j] + 1.5 * pc_xz[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xz[j] * fl1_fx * pb_yz[j] + 0.5 * pc_xy[j] * fl1_fx * pb_xx[j] + pc_xx[j] * fl1_fx * pb_xy[j] + 0.5 * pc_x[j] * fl1_fx * pb_xxy[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_yz[j] + fl1_fx * pc_zz[j] * pb_xy[j] + fl1_fx * pc_yz[j] * pb_xz[j] + fl1_fx * pa_z[j] * pb_xy[j] * pc_z[j] + fl1_fx * pa_z[j] * pb_xz[j] * pc_y[j] + fl1_fx * pc_z[j] * pb_xyz[j] + pa_xz[j] * pb_xx[j] * pc_yz[j] + 2.0 * pa_xz[j] * pb_xy[j] * pc_xz[j] + 2.0 * pa_xz[j] * pb_xz[j] * pc_xy[j] + pa_xz[j] * pc_xx[j] * pb_yz[j] + pa_x[j] * pc_zz[j] * pb_xxy[j] + pa_x[j] * pc_yz[j] * pb_xxz[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xyz[j] + pc_xz[j] * pa_z[j] * pb_xxy[j] + pc_xy[j] * pa_z[j] * pb_xxz[j] + 2.0 * pc_xx[j] * pa_z[j] * pb_xyz[j] + pc_xz[j] * pb_xxyz[j]);

                t_xz_xxyz[j] += fl_s_0_0_3 * (-0.25 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * fl2_fx * pb_x[j] * pc_y[j] - 0.5 * pa_xz[j] * fl1_fx * pc_yz[j] - 0.5 * pa_x[j] * pc_yzz[j] * fl1_fx - 0.5 * pa_x[j] * pc_zz[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xxy[j] - pa_x[j] * fl1_fx * pb_x[j] * pc_xy[j] - 0.5 * pa_x[j] * fl1_fx * pc_xx[j] * pb_y[j] - 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 1.5 * pc_xz[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yz[j] - pc_xxy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xy[j] * fl1_fx * pb_xx[j] - pc_xx[j] * fl1_fx * pb_xy[j] - fl1_fx * pc_yzz[j] * pb_x[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_yz[j] - fl1_fx * pc_zz[j] * pb_xy[j] - fl1_fx * pc_yz[j] * pb_xz[j] - 2.0 * pa_xz[j] * pb_x[j] * pc_xyz[j] - pa_xz[j] * pc_xxz[j] * pb_y[j] - pa_xz[j] * pc_xxy[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_xx[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_xy[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_xz[j] - pa_x[j] * pc_xxz[j] * pb_yz[j] - pc_xyz[j] * pa_z[j] * pb_xx[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_xy[j] - 2.0 * pc_xxy[j] * pa_z[j] * pb_xz[j] - pc_xxx[j] * pa_z[j] * pb_yz[j] - pc_xzz[j] * pb_xxy[j] - pc_xyz[j] * pb_xxz[j] - 2.0 * pc_xxz[j] * pb_xyz[j]);

                t_xz_xxyz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_xxy[j] + 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxxy[j] * fl1_fx + pc_xxy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] + fl1_fx * pc_yzz[j] * pb_x[j] + pa_xz[j] * pc_xxyz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_x[j] + pa_x[j] * pc_xxzz[j] * pb_y[j] + pa_x[j] * pc_xxyz[j] * pb_z[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_x[j] + pc_xxxz[j] * pa_z[j] * pb_y[j] + pc_xxxy[j] * pa_z[j] * pb_z[j] + pc_xyzz[j] * pb_xx[j] + 2.0 * pc_xxzz[j] * pb_xy[j] + 2.0 * pc_xxyz[j] * pb_xz[j] + pc_xxxz[j] * pb_yz[j]);

                t_xz_xxyz[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xxxy[j] * fl1_fx - pa_x[j] * pc_xxyzz[j] - pc_xxxyz[j] * pa_z[j] - 2.0 * pc_xxyzz[j] * pb_x[j] - pc_xxxzz[j] * pb_y[j] - pc_xxxyz[j] * pb_z[j]);

                t_xz_xxyz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_35_36(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (35,36)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxzz = pbDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxzzz = pcDistances.data(83 * idx + 64);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xxzz = primBuffer.data(90 * idx + 35);

            // Batch of Integrals (35,36)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xx, pb_xxz, pb_xxzz, pb_xz, pb_xzz, pb_z, pb_zz, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxz, pc_xxxzz, pc_xxxzzz, pc_xxz, pc_xxzz, pc_xxzzz, \
                                     pc_xz, pc_xzz, pc_xzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xz_xxzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xxzz[j] = fl_s_0_0_0 * (0.25 * pa_xz[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + fl2_fx * pb_xz[j] + 0.5 * pa_xz[j] * pb_xx[j] * fl1_fx + 0.5 * pa_xz[j] * fl1_fx * pb_zz[j] + pa_x[j] * fl1_fx * pb_xxz[j] + fl1_fx * pa_z[j] * pb_xzz[j] + pa_xz[j] * pb_xxzz[j]);

                t_xz_xxzz[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * pc_z[j] * fl2_fx - pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_z[j] - fl2_fx * pa_z[j] * pb_x[j] - 1.5 * fl2_fx * pc_z[j] * pb_x[j] - 2.0 * fl2_fx * pb_xz[j] - 0.5 * pa_xz[j] * pb_xx[j] * fl1_fx - pa_xz[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_zz[j] - 1.5 * pa_x[j] * pc_z[j] * pb_xx[j] * fl1_fx - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_x[j] * fl1_fx * pb_xz[j] * pc_x[j] - pa_x[j] * fl1_fx * pb_xxz[j] - 0.5 * pc_x[j] * pa_z[j] * pb_xx[j] * fl1_fx - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_zz[j] - pc_x[j] * fl1_fx * pb_xxz[j] - 2.0 * fl1_fx * pa_z[j] * pb_xz[j] * pc_z[j] - fl1_fx * pc_z[j] * pb_xzz[j] - fl1_fx * pa_z[j] * pb_xzz[j] - 2.0 * pa_xz[j] * pb_xxz[j] * pc_z[j] - 2.0 * pa_xz[j] * pb_xzz[j] * pc_x[j] - pa_x[j] * pc_z[j] * pb_xxzz[j] - pc_x[j] * pa_z[j] * pb_xxzz[j]);

                t_xz_xxzz[j] += fl_s_0_0_2 * (0.25 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_z[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pc_x[j] * pa_z[j] * fl2_fx + 2.25 * pc_xz[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_z[j] + 3.0 * fl2_fx * pc_z[j] * pb_x[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + fl2_fx * pb_xz[j] + pa_xz[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_xz[j] * pc_xx[j] * fl1_fx + 0.5 * pa_xz[j] * fl1_fx * pc_zz[j] + pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_x[j] * pc_z[j] * pb_xx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx + pa_x[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_zz[j] + pa_x[j] * fl1_fx * pc_xx[j] * pb_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_xz[j] * pc_x[j] + 0.5 * pc_x[j] * pa_z[j] * pb_xx[j] * fl1_fx + pc_xx[j] * pa_z[j] * pb_x[j] * fl1_fx + 3.0 * pc_xz[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_xz[j] * pb_xx[j] * fl1_fx + 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 2.0 * pc_xx[j] * fl1_fx * pb_xz[j] + pc_x[j] * fl1_fx * pb_xxz[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_zz[j] + 2.0 * fl1_fx * pc_zz[j] * pb_xz[j] + 2.0 * fl1_fx * pa_z[j] * pb_xz[j] * pc_z[j] + fl1_fx * pc_z[j] * pb_xzz[j] + pa_xz[j] * pb_xx[j] * pc_zz[j] + 4.0 * pa_xz[j] * pb_xz[j] * pc_xz[j] + pa_xz[j] * pc_xx[j] * pb_zz[j] + 2.0 * pa_x[j] * pc_zz[j] * pb_xxz[j] + 2.0 * pa_x[j] * pc_xz[j] * pb_xzz[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_xxz[j] + 2.0 * pc_xx[j] * pa_z[j] * pb_xzz[j] + pc_xz[j] * pb_xxzz[j]);

                t_xz_xxzz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 4.5 * pc_xz[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xz[j] * pc_xx[j] * fl1_fx - 0.5 * pa_xz[j] * fl1_fx * pc_zz[j] - 3.0 * pa_x[j] * pc_xz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx - 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx - pa_x[j] * pc_zz[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pc_xx[j] * pb_z[j] - pc_xx[j] * pa_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx - 1.5 * pc_xzz[j] * pa_z[j] * fl1_fx - 3.0 * pc_xz[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * pb_xx[j] * fl1_fx - 3.0 * pc_xxz[j] * pb_x[j] * fl1_fx - 3.0 * pc_xzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] - pc_xxx[j] * fl1_fx * pb_z[j] - 2.0 * pc_xx[j] * fl1_fx * pb_xz[j] - fl1_fx * pc_zzz[j] * pb_x[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_zz[j] - 2.0 * fl1_fx * pc_zz[j] * pb_xz[j] - 2.0 * pa_xz[j] * pb_x[j] * pc_xzz[j] - 2.0 * pa_xz[j] * pc_xxz[j] * pb_z[j] - pa_x[j] * pc_zzz[j] * pb_xx[j] - 4.0 * pa_x[j] * pc_xzz[j] * pb_xz[j] - pa_x[j] * pc_xxz[j] * pb_zz[j] - pc_xzz[j] * pa_z[j] * pb_xx[j] - 4.0 * pc_xxz[j] * pa_z[j] * pb_xz[j] - pc_xxx[j] * pa_z[j] * pb_zz[j] - 2.0 * pc_xzz[j] * pb_xxz[j] - 2.0 * pc_xxz[j] * pb_xzz[j]);

                t_xz_xxzz[j] += fl_s_0_0_4 * (2.25 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx + 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx + 1.5 * pc_xzz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xxz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxxz[j] * fl1_fx + 1.5 * pc_xzzz[j] * fl1_fx + 3.0 * pc_xzz[j] * fl1_fx * pb_z[j] + pc_xxx[j] * fl1_fx * pb_z[j] + fl1_fx * pc_zzz[j] * pb_x[j] + pa_xz[j] * pc_xxzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxzz[j] * pb_z[j] + 2.0 * pc_xxzz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxxz[j] * pa_z[j] * pb_z[j] + pc_xzzz[j] * pb_xx[j] + 4.0 * pc_xxzz[j] * pb_xz[j] + pc_xxxz[j] * pb_zz[j]);

                t_xz_xxzz[j] += fl_s_0_0_5 * (-1.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_xxzzz[j] - pc_xxxzz[j] * pa_z[j] - 2.0 * pc_xxzzz[j] * pb_x[j] - 2.0 * pc_xxxzz[j] * pb_z[j]);

                t_xz_xxzz[j] += fl_s_0_0_6 * pc_xxxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_36_37(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (36,37)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyy = pbDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xyyy = primBuffer.data(90 * idx + 36);

            // Batch of Integrals (36,37)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xy, pb_xyy, pb_xyyy, pb_y, pb_yy, pb_yyy, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyz, \
                                     pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xz_xyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xyyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_xz[j] * pb_xy[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pb_yyy[j] + pa_xz[j] * pb_xyyy[j]);

                t_xz_xyyy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_z[j] * pb_y[j] - 0.75 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xz[j] * pb_xy[j] * fl1_fx - 1.5 * pa_xz[j] * pb_x[j] * pc_y[j] * fl1_fx - 1.5 * pa_xz[j] * pc_x[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * pb_xy[j] * fl1_fx - 1.5 * pc_x[j] * pa_z[j] * pb_xy[j] * fl1_fx - 1.5 * fl1_fx * pa_z[j] * pb_yy[j] * pc_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_yyy[j] - 0.5 * fl1_fx * pa_z[j] * pb_yyy[j] - 3.0 * pa_xz[j] * pb_xyy[j] * pc_y[j] - pa_xz[j] * pc_x[j] * pb_yyy[j] - pa_x[j] * pc_z[j] * pb_xyyy[j] - pc_x[j] * pa_z[j] * pb_xyyy[j]);

                t_xz_xyyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_z[j] * pc_y[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.75 * fl2_fx * pc_yz[j] + 0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_xz[j] * pb_x[j] * pc_y[j] * fl1_fx + 1.5 * pa_xz[j] * pc_x[j] * pb_y[j] * fl1_fx + 1.5 * pa_xz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * pb_xy[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_xx[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_xz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_yy[j] + 1.5 * fl1_fx * pc_yz[j] * pb_yy[j] + 1.5 * fl1_fx * pa_z[j] * pb_yy[j] * pc_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_yyy[j] + 3.0 * pa_xz[j] * pb_xy[j] * pc_yy[j] + 3.0 * pa_xz[j] * pc_xy[j] * pb_yy[j] + 3.0 * pa_x[j] * pc_yz[j] * pb_xyy[j] + pa_x[j] * pc_xz[j] * pb_yyy[j] + 3.0 * pc_xy[j] * pa_z[j] * pb_xyy[j] + pc_xx[j] * pa_z[j] * pb_yyy[j] + pc_xz[j] * pb_xyyy[j]);

                t_xz_xyyy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xx[j] * pa_z[j] * pb_y[j] * fl1_fx - 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xz[j] * pb_xy[j] * fl1_fx - 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx - 0.5 * fl1_fx * pa_z[j] * pc_yyy[j] - 1.5 * fl1_fx * pc_yyz[j] * pb_y[j] - 1.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_yy[j] - 1.5 * fl1_fx * pc_yz[j] * pb_yy[j] - pa_xz[j] * pb_x[j] * pc_yyy[j] - 3.0 * pa_xz[j] * pc_xyy[j] * pb_y[j] - 3.0 * pa_x[j] * pc_yyz[j] * pb_xy[j] - 3.0 * pa_x[j] * pc_xyz[j] * pb_yy[j] - 3.0 * pc_xyy[j] * pa_z[j] * pb_xy[j] - 3.0 * pc_xxy[j] * pa_z[j] * pb_yy[j] - 3.0 * pc_xyz[j] * pb_xyy[j] - pc_xxz[j] * pb_yyy[j]);

                t_xz_xyyy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyyz[j] + 0.5 * fl1_fx * pa_z[j] * pc_yyy[j] + 1.5 * fl1_fx * pc_yyz[j] * pb_y[j] + pa_xz[j] * pc_xyyy[j] + pa_x[j] * pc_yyyz[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xyyz[j] * pb_y[j] + pc_xyyy[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xxyy[j] * pa_z[j] * pb_y[j] + 3.0 * pc_xyyz[j] * pb_xy[j] + 3.0 * pc_xxyz[j] * pb_yy[j]);

                t_xz_xyyy[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyz[j] - pa_x[j] * pc_xyyyz[j] - pc_xxyyy[j] * pa_z[j] - pc_xyyyz[j] * pb_x[j] - 3.0 * pc_xxyyz[j] * pb_y[j]);

                t_xz_xyyy[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_37_38(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (37,38)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyz = pbDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xyyz = primBuffer.data(90 * idx + 37);

            // Batch of Integrals (37,38)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xy, pb_xyy, pb_xyyz, pb_xyz, pb_xz, pb_y, pb_yy, \
                                     pb_yyz, pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xz_xyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xz_xyyz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_xz[j] * pb_xz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pa_z[j] * pb_yyz[j] + pa_xz[j] * pb_xyyz[j]);

                t_xz_xyyz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * fl2_fx * pb_yy[j] - 0.5 * pa_xz[j] * pb_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_xz[j] * pb_xz[j] * fl1_fx - 0.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * pc_z[j] * pb_xz[j] * fl1_fx - pa_x[j] * fl1_fx * pb_xy[j] * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_yy[j] - 0.5 * pa_x[j] * fl1_fx * pb_xyy[j] - 0.5 * pc_x[j] * pa_z[j] * pb_xz[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_xyy[j] - 0.5 * fl1_fx * pa_z[j] * pb_yy[j] * pc_z[j] - fl1_fx * pa_z[j] * pb_yz[j] * pc_y[j] - 0.5 * fl1_fx * pc_z[j] * pb_yyz[j] - 0.5 * fl1_fx * pa_z[j] * pb_yyz[j] - pa_xz[j] * pb_xyy[j] * pc_z[j] - 2.0 * pa_xz[j] * pb_xyz[j] * pc_y[j] - pa_xz[j] * pc_x[j] * pb_yyz[j] - pa_x[j] * pc_z[j] * pb_xyyz[j] - pc_x[j] * pa_z[j] * pb_xyyz[j]);

                t_xz_xyyz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.25 * pc_xx[j] * fl2_fx + 0.5 * fl2_fx * pa_z[j] * pc_z[j] + 0.25 * fl2_fx * pc_zz[j] + 0.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.25 * fl2_fx * pc_yy[j] + fl2_fx * pb_y[j] * pc_y[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_xz[j] * pb_x[j] * fl1_fx * pc_z[j] + 0.5 * pa_xz[j] * pc_xz[j] * fl1_fx + 0.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_zz[j] * pb_x[j] * fl1_fx + 0.5 * pa_x[j] * pc_z[j] * pb_xz[j] * fl1_fx + 0.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_yy[j] + pa_x[j] * fl1_fx * pc_xy[j] * pb_y[j] + pa_x[j] * fl1_fx * pb_xy[j] * pc_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_yy[j] + 0.5 * pc_xz[j] * pa_z[j] * pb_x[j] * fl1_fx + 0.5 * pc_x[j] * pa_z[j] * pb_xz[j] * fl1_fx + 0.5 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_xz[j] * pb_xz[j] * fl1_fx + pc_xy[j] * fl1_fx * pb_xy[j] + 0.5 * pc_xx[j] * fl1_fx * pb_yy[j] + 0.5 * pc_x[j] * fl1_fx * pb_xyy[j] + fl1_fx * pa_z[j] * pb_y[j] * pc_yz[j] + 0.5 * fl1_fx * pa_z[j] * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_yy[j] + fl1_fx * pc_yz[j] * pb_yz[j] + 0.5 * fl1_fx * pa_z[j] * pb_yy[j] * pc_z[j] + fl1_fx * pa_z[j] * pb_yz[j] * pc_y[j] + 0.5 * fl1_fx * pc_z[j] * pb_yyz[j] + 2.0 * pa_xz[j] * pb_xy[j] * pc_yz[j] + pa_xz[j] * pb_xz[j] * pc_yy[j] + pa_xz[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_yz[j] + pa_x[j] * pc_zz[j] * pb_xyy[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_xyz[j] + pa_x[j] * pc_xz[j] * pb_yyz[j] + pc_xz[j] * pa_z[j] * pb_xyy[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xyz[j] + pc_xx[j] * pa_z[j] * pb_yyz[j] + pc_xz[j] * pb_xyyz[j]);

                t_xz_xyyz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.5 * pc_xx[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pc_yy[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xz[j] * pc_xz[j] * fl1_fx - 0.5 * pa_x[j] * pc_zz[j] * pb_x[j] * fl1_fx - 0.5 * pa_x[j] * pc_xzz[j] * fl1_fx - 0.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xyy[j] - 0.5 * pa_x[j] * fl1_fx * pb_x[j] * pc_yy[j] - pa_x[j] * fl1_fx * pc_xy[j] * pb_y[j] - 0.5 * pc_xz[j] * pa_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxz[j] * pa_z[j] * fl1_fx - 0.5 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_xzz[j] * pb_x[j] * fl1_fx - 0.5 * pc_xz[j] * pb_xz[j] * fl1_fx - 0.5 * pc_xxz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_x[j] - pc_xxy[j] * fl1_fx * pb_y[j] - pc_xy[j] * fl1_fx * pb_xy[j] - 0.5 * pc_xx[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pa_z[j] * pc_yyz[j] - fl1_fx * pc_yzz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_z[j] - fl1_fx * pa_z[j] * pb_y[j] * pc_yz[j] - 0.5 * fl1_fx * pa_z[j] * pc_yy[j] * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_yy[j] - fl1_fx * pc_yz[j] * pb_yz[j] - pa_xz[j] * pb_x[j] * pc_yyz[j] - 2.0 * pa_xz[j] * pc_xyz[j] * pb_y[j] - pa_xz[j] * pc_xyy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_yzz[j] * pb_xy[j] - pa_x[j] * pc_yyz[j] * pb_xz[j] - pa_x[j] * pc_xzz[j] * pb_yy[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_yz[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_xy[j] - pc_xyy[j] * pa_z[j] * pb_xz[j] - pc_xxz[j] * pa_z[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pa_z[j] * pb_yz[j] - pc_xzz[j] * pb_xyy[j] - 2.0 * pc_xyz[j] * pb_xyz[j] - pc_xxz[j] * pb_yyz[j]);

                t_xz_xyyz[j] += fl_s_0_0_4 * (0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_zz[j] + 0.25 * fl2_fx * pc_yy[j] + 0.5 * pa_x[j] * pc_xzz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_xyy[j] + 0.5 * pc_xxz[j] * pa_z[j] * fl1_fx + 0.5 * pc_xzz[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxzz[j] * fl1_fx + 0.5 * pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_xyy[j] * fl1_fx * pb_x[j] + pc_xxy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyzz[j] + 0.5 * fl1_fx * pa_z[j] * pc_yyz[j] + fl1_fx * pc_yzz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_z[j] + pa_xz[j] * pc_xyyz[j] + pa_x[j] * pc_yyzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_y[j] + pa_x[j] * pc_xyyz[j] * pb_z[j] + pc_xyyz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_y[j] + pc_xxyy[j] * pa_z[j] * pb_z[j] + 2.0 * pc_xyzz[j] * pb_xy[j] + pc_xyyz[j] * pb_xz[j] + pc_xxzz[j] * pb_yy[j] + 2.0 * pc_xxyz[j] * pb_yz[j]);

                t_xz_xyyz[j] += fl_s_0_0_5 * (-0.5 * pc_xxzz[j] * fl1_fx - 0.5 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - pa_x[j] * pc_xyyzz[j] - pc_xxyyz[j] * pa_z[j] - pc_xyyzz[j] * pb_x[j] - 2.0 * pc_xxyzz[j] * pb_y[j] - pc_xxyyz[j] * pb_z[j]);

                t_xz_xyyz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_38_39(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (38,39)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyzz = pbDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xyzz = primBuffer.data(90 * idx + 38);

            // Batch of Integrals (38,39)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xy, pb_xyz, pb_xyzz, pb_xz, pb_xzz, pb_y, pb_yz, \
                                     pb_yzz, pb_z, pb_zz, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, \
                                     pc_xxzz, pc_xxzzz, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xz_xyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_xyzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * fl2_fx * pb_yz[j] + 0.5 * pa_xz[j] * pb_xy[j] * fl1_fx + pa_x[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pa_z[j] * pb_yzz[j] + pa_xz[j] * pb_xyzz[j]);

                t_xz_xyzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] * pb_y[j] - 0.25 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * fl2_fx * pc_y[j] * pb_z[j] - fl2_fx * pb_yz[j] - 0.5 * pa_xz[j] * pb_xy[j] * fl1_fx - 0.5 * pa_xz[j] * pb_x[j] * pc_y[j] * fl1_fx - 0.5 * pa_xz[j] * pc_x[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_z[j] * pb_xy[j] * fl1_fx - pa_x[j] * fl1_fx * pb_xz[j] * pc_y[j] - pa_x[j] * fl1_fx * pc_x[j] * pb_yz[j] - pa_x[j] * fl1_fx * pb_xyz[j] - 0.5 * pc_x[j] * pa_z[j] * pb_xy[j] * fl1_fx - pc_x[j] * fl1_fx * pb_xyz[j] - fl1_fx * pa_z[j] * pb_yz[j] * pc_z[j] - 0.5 * fl1_fx * pa_z[j] * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pc_z[j] * pb_yzz[j] - 0.5 * fl1_fx * pa_z[j] * pb_yzz[j] - 2.0 * pa_xz[j] * pb_xyz[j] * pc_z[j] - pa_xz[j] * pb_xzz[j] * pc_y[j] - pa_xz[j] * pc_x[j] * pb_yzz[j] - pa_x[j] * pc_z[j] * pb_xyzz[j] - pc_x[j] * pa_z[j] * pb_xyzz[j]);

                t_xz_xyzz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pa_z[j] * pc_y[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.75 * fl2_fx * pc_yz[j] + fl2_fx * pc_y[j] * pb_z[j] + 0.25 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * fl2_fx * pb_yz[j] + 0.5 * pa_xz[j] * pb_x[j] * pc_y[j] * fl1_fx + 0.5 * pa_xz[j] * pc_x[j] * pb_y[j] * fl1_fx + 0.5 * pa_xz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx + pa_x[j] * fl1_fx * pc_xy[j] * pb_z[j] + pa_x[j] * fl1_fx * pb_xz[j] * pc_y[j] + pa_x[j] * fl1_fx * pc_x[j] * pb_yz[j] + 0.5 * pc_x[j] * pa_z[j] * pb_xy[j] * fl1_fx + 0.5 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx + 0.5 * pc_xx[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_xz[j] * pb_xy[j] * fl1_fx + pc_xy[j] * fl1_fx * pb_xz[j] + pc_xx[j] * fl1_fx * pb_yz[j] + pc_x[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_zz[j] + fl1_fx * pa_z[j] * pc_yz[j] * pb_z[j] + fl1_fx * pc_zz[j] * pb_yz[j] + 0.5 * fl1_fx * pc_yz[j] * pb_zz[j] + fl1_fx * pa_z[j] * pb_yz[j] * pc_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_y[j] * pb_zz[j] + 0.5 * fl1_fx * pc_z[j] * pb_yzz[j] + pa_xz[j] * pb_xy[j] * pc_zz[j] + 2.0 * pa_xz[j] * pb_xz[j] * pc_yz[j] + 2.0 * pa_xz[j] * pc_xz[j] * pb_yz[j] + pa_xz[j] * pc_xy[j] * pb_zz[j] + 2.0 * pa_x[j] * pc_zz[j] * pb_xyz[j] + pa_x[j] * pc_yz[j] * pb_xzz[j] + pa_x[j] * pc_xz[j] * pb_yzz[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_xyz[j] + pc_xy[j] * pa_z[j] * pb_xzz[j] + pc_xx[j] * pa_z[j] * pb_yzz[j] + pc_xz[j] * pb_xyzz[j]);

                t_xz_xyzz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.25 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_x[j] * pc_xz[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - pa_x[j] * fl1_fx * pc_xy[j] * pb_z[j] - 0.5 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_xx[j] * pa_z[j] * pb_y[j] * fl1_fx - 0.5 * pc_xxy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xz[j] * pb_xy[j] * fl1_fx - 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx - pc_xxy[j] * fl1_fx * pb_z[j] - pc_xy[j] * fl1_fx * pb_xz[j] - pc_xx[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pa_z[j] * pc_yzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] - fl1_fx * pc_yzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_z[j] * pb_y[j] * pc_zz[j] - fl1_fx * pa_z[j] * pc_yz[j] * pb_z[j] - fl1_fx * pc_zz[j] * pb_yz[j] - 0.5 * fl1_fx * pc_yz[j] * pb_zz[j] - pa_xz[j] * pb_x[j] * pc_yzz[j] - pa_xz[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_xz[j] * pc_xyz[j] * pb_z[j] - pa_x[j] * pc_zzz[j] * pb_xy[j] - 2.0 * pa_x[j] * pc_yzz[j] * pb_xz[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_yz[j] - pa_x[j] * pc_xyz[j] * pb_zz[j] - pc_xzz[j] * pa_z[j] * pb_xy[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_xz[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_yz[j] - pc_xxy[j] * pa_z[j] * pb_zz[j] - 2.0 * pc_xzz[j] * pb_xyz[j] - pc_xyz[j] * pb_xzz[j] - pc_xxz[j] * pb_yzz[j]);

                t_xz_xyzz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 0.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + pc_xxy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yzzz[j] + 0.5 * fl1_fx * pa_z[j] * pc_yzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] + fl1_fx * pc_yzz[j] * pb_z[j] + pa_xz[j] * pc_xyzz[j] + pa_x[j] * pc_yzzz[j] * pb_x[j] + pa_x[j] * pc_xzzz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_z[j] + pc_xyzz[j] * pa_z[j] * pb_x[j] + pc_xxzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_z[j] + pc_xzzz[j] * pb_xy[j] + 2.0 * pc_xyzz[j] * pb_xz[j] + 2.0 * pc_xxzz[j] * pb_yz[j] + pc_xxyz[j] * pb_zz[j]);

                t_xz_xyzz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yzzz[j] - pa_x[j] * pc_xyzzz[j] - pc_xxyzz[j] * pa_z[j] - pc_xyzzz[j] * pb_x[j] - pc_xxzzz[j] * pb_y[j] - 2.0 * pc_xxyzz[j] * pb_z[j]);

                t_xz_xyzz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_39_40(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (39,40)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xzzz = pbDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxzzzz = pcDistances.data(83 * idx + 69);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_xzzz = primBuffer.data(90 * idx + 39);

            // Batch of Integrals (39,40)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_x, pb_xz, pb_xzz, pb_xzzz, pb_z, pb_zz, pb_zzz, pc_x, \
                                     pc_xx, pc_xxz, pc_xxzz, pc_xxzzz, pc_xxzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xz_xzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xz_xzzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_zz[j] + 1.5 * pa_xz[j] * pb_xz[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pa_z[j] * pb_zzz[j] + pa_xz[j] * pb_xzzz[j]);

                t_xz_xzzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 2.25 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * fl2_fx * pb_zz[j] - 1.5 * pa_xz[j] * pb_xz[j] * fl1_fx - 1.5 * pa_xz[j] * pb_x[j] * pc_z[j] * fl1_fx - 1.5 * pa_xz[j] * pc_x[j] * pb_z[j] * fl1_fx - 4.5 * pa_x[j] * pc_z[j] * pb_xz[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_zz[j] - 1.5 * pa_x[j] * fl1_fx * pb_xzz[j] - 1.5 * pc_x[j] * pa_z[j] * pb_xz[j] * fl1_fx - 1.5 * pc_x[j] * fl1_fx * pb_xzz[j] - 1.5 * fl1_fx * pa_z[j] * pb_zz[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_zzz[j] - 0.5 * fl1_fx * pa_z[j] * pb_zzz[j] - 3.0 * pa_xz[j] * pb_xzz[j] * pc_z[j] - pa_xz[j] * pc_x[j] * pb_zzz[j] - pa_x[j] * pc_z[j] * pb_xzzz[j] - pc_x[j] * pa_z[j] * pb_xzzz[j]);

                t_xz_xzzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pc_z[j] + 4.5 * fl2_fx * pc_z[j] * pb_z[j] + 1.5 * fl2_fx * pc_zz[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_zz[j] + 1.5 * pa_xz[j] * pb_x[j] * pc_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_x[j] * pb_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_xz[j] * fl1_fx + 4.5 * pa_x[j] * pc_z[j] * pb_xz[j] * fl1_fx + 3.0 * pa_x[j] * pc_zz[j] * pb_x[j] * fl1_fx + 4.5 * pa_x[j] * pc_xz[j] * pb_z[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_x[j] * pb_zz[j] + 1.5 * pc_x[j] * pa_z[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_xx[j] * pa_z[j] * pb_z[j] * fl1_fx + 4.5 * pc_xz[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xx[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * fl1_fx * pb_xzz[j] + 1.5 * fl1_fx * pa_z[j] * pb_z[j] * pc_zz[j] + 1.5 * fl1_fx * pc_zz[j] * pb_zz[j] + 1.5 * fl1_fx * pa_z[j] * pb_zz[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_zzz[j] + 3.0 * pa_xz[j] * pb_xz[j] * pc_zz[j] + 3.0 * pa_xz[j] * pc_xz[j] * pb_zz[j] + 3.0 * pa_x[j] * pc_zz[j] * pb_xzz[j] + pa_x[j] * pc_xz[j] * pb_zzz[j] + 3.0 * pc_xz[j] * pa_z[j] * pb_xzz[j] + pc_xx[j] * pa_z[j] * pb_zzz[j] + pc_xz[j] * pb_xzzz[j]);

                t_xz_xzzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 1.5 * pc_xx[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 3.0 * fl2_fx * pc_zz[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 2.25 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_xz[j] * pc_xz[j] * fl1_fx - 3.0 * pa_x[j] * pc_zz[j] * pb_x[j] * fl1_fx - 4.5 * pa_x[j] * pc_xz[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xx[j] * pa_z[j] * pb_z[j] * fl1_fx - 1.5 * pc_xxz[j] * pa_z[j] * fl1_fx - 4.5 * pc_xz[j] * pb_xz[j] * fl1_fx - 3.0 * pc_xzz[j] * pb_x[j] * fl1_fx - 4.5 * pc_xxz[j] * pb_z[j] * fl1_fx - 1.5 * pc_xx[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pa_z[j] * pc_zzz[j] - 1.5 * fl1_fx * pc_zzz[j] * pb_z[j] - 1.5 * fl1_fx * pa_z[j] * pb_z[j] * pc_zz[j] - 1.5 * fl1_fx * pc_zz[j] * pb_zz[j] - pa_xz[j] * pb_x[j] * pc_zzz[j] - 3.0 * pa_xz[j] * pc_xzz[j] * pb_z[j] - 3.0 * pa_x[j] * pc_zzz[j] * pb_xz[j] - 3.0 * pa_x[j] * pc_xzz[j] * pb_zz[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_xz[j] - 3.0 * pc_xxz[j] * pa_z[j] * pb_zz[j] - 3.0 * pc_xzz[j] * pb_xzz[j] - pc_xxz[j] * pb_zzz[j]);

                t_xz_xzzz[j] += fl_s_0_0_4 * (0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pc_zz[j] + 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx + 1.5 * pc_xxz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xzz[j] * pb_x[j] * fl1_fx + 4.5 * pc_xxz[j] * pb_z[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzzz[j] + 0.5 * fl1_fx * pa_z[j] * pc_zzz[j] + 1.5 * fl1_fx * pc_zzz[j] * pb_z[j] + pa_xz[j] * pc_xzzz[j] + pa_x[j] * pc_zzzz[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xzzz[j] * pb_z[j] + pc_xzzz[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xxzz[j] * pa_z[j] * pb_z[j] + 3.0 * pc_xzzz[j] * pb_xz[j] + 3.0 * pc_xxzz[j] * pb_zz[j]);

                t_xz_xzzz[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - pa_x[j] * pc_xzzzz[j] - pc_xxzzz[j] * pa_z[j] - pc_xzzzz[j] * pb_x[j] - 3.0 * pc_xxzzz[j] * pb_z[j]);

                t_xz_xzzz[j] += fl_s_0_0_6 * pc_xxzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_40_41(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (40,41)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyy = pbDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_yyyy = primBuffer.data(90 * idx + 40);

            // Batch of Integrals (40,41)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_y, pb_yy, pb_yyy, pb_yyyy, pc_x, pc_xy, pc_xyy, pc_xyyy, \
                                     pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xz_yyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_yyyy[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 3.0 * pa_xz[j] * pb_yy[j] * fl1_fx + pa_xz[j] * pb_yyyy[j]);

                t_xz_yyyy[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 3.0 * pa_xz[j] * pb_yy[j] * fl1_fx - 6.0 * pa_xz[j] * pb_y[j] * pc_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_z[j] * pb_yy[j] * fl1_fx - 3.0 * pc_x[j] * pa_z[j] * pb_yy[j] * fl1_fx - 4.0 * pa_xz[j] * pb_yyy[j] * pc_y[j] - pa_x[j] * pc_z[j] * pb_yyyy[j] - pc_x[j] * pa_z[j] * pb_yyyy[j]);

                t_xz_yyyy[j] += fl_s_0_0_2 * (0.75 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_z[j] * fl2_fx + 1.5 * pc_x[j] * pa_z[j] * fl2_fx + 0.75 * pc_xz[j] * fl2_fx + 6.0 * pa_xz[j] * pb_y[j] * pc_y[j] * fl1_fx + 3.0 * pa_xz[j] * pc_yy[j] * fl1_fx + 3.0 * pa_x[j] * pc_z[j] * pb_yy[j] * fl1_fx + 6.0 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx + 3.0 * pc_x[j] * pa_z[j] * pb_yy[j] * fl1_fx + 6.0 * pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx + 3.0 * pc_xz[j] * pb_yy[j] * fl1_fx + 6.0 * pa_xz[j] * pb_yy[j] * pc_yy[j] + 4.0 * pa_x[j] * pc_yz[j] * pb_yyy[j] + 4.0 * pc_xy[j] * pa_z[j] * pb_yyy[j] + pc_xz[j] * pb_yyyy[j]);

                t_xz_yyyy[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 1.5 * pc_xz[j] * fl2_fx - 3.0 * pa_xz[j] * pc_yy[j] * fl1_fx - 6.0 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx - 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx - 6.0 * pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx - 3.0 * pc_xyy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xz[j] * pb_yy[j] * fl1_fx - 6.0 * pc_xyz[j] * pb_y[j] * fl1_fx - 4.0 * pa_xz[j] * pb_y[j] * pc_yyy[j] - 6.0 * pa_x[j] * pc_yyz[j] * pb_yy[j] - 6.0 * pc_xyy[j] * pa_z[j] * pb_yy[j] - 4.0 * pc_xyz[j] * pb_yyy[j]);

                t_xz_yyyy[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx + 3.0 * pc_xyy[j] * pa_z[j] * fl1_fx + 6.0 * pc_xyz[j] * pb_y[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + pa_xz[j] * pc_yyyy[j] + 4.0 * pa_x[j] * pc_yyyz[j] * pb_y[j] + 4.0 * pc_xyyy[j] * pa_z[j] * pb_y[j] + 6.0 * pc_xyyz[j] * pb_yy[j]);

                t_xz_yyyy[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - pa_x[j] * pc_yyyyz[j] - pc_xyyyy[j] * pa_z[j] - 4.0 * pc_xyyyz[j] * pb_y[j]);

                t_xz_yyyy[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_41_42(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (41,42)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyz = pbDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_yyyz = primBuffer.data(90 * idx + 41);

            // Batch of Integrals (41,42)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_y, pb_yy, pb_yyy, pb_yyyz, pb_yyz, pb_yz, pb_z, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, \
                                     pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, \
                                     pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xz_yyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_yyyz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pa_xz[j] * pb_yz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pb_yyy[j] + pa_xz[j] * pb_yyyz[j]);

                t_xz_yyyz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pa_x[j] * fl2_fx * pc_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_xz[j] * pb_y[j] * fl1_fx * pc_z[j] - 1.5 * pa_xz[j] * pb_yz[j] * fl1_fx - 1.5 * pa_xz[j] * pc_y[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_z[j] * pb_yz[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pb_yy[j] * pc_y[j] - 0.5 * pa_x[j] * fl1_fx * pb_yyy[j] - 1.5 * pc_x[j] * pa_z[j] * pb_yz[j] * fl1_fx - 0.5 * pc_x[j] * fl1_fx * pb_yyy[j] - pa_xz[j] * pb_yyy[j] * pc_z[j] - 3.0 * pa_xz[j] * pb_yyz[j] * pc_y[j] - pa_x[j] * pc_z[j] * pb_yyyz[j] - pc_x[j] * pa_z[j] * pb_yyyz[j]);

                t_xz_yyyz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.75 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_xz[j] * pb_y[j] * fl1_fx * pc_z[j] + 1.5 * pa_xz[j] * pc_yz[j] * fl1_fx + 1.5 * pa_xz[j] * pc_y[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_zz[j] * pb_y[j] * fl1_fx + 1.5 * pa_x[j] * pc_z[j] * pb_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pb_y[j] * pc_yy[j] + 1.5 * pa_x[j] * fl1_fx * pb_yy[j] * pc_y[j] + 1.5 * pc_xz[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_x[j] * pa_z[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_xz[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] + 0.5 * pc_x[j] * fl1_fx * pb_yyy[j] + 3.0 * pa_xz[j] * pb_yy[j] * pc_yz[j] + 3.0 * pa_xz[j] * pb_yz[j] * pc_yy[j] + pa_x[j] * pc_zz[j] * pb_yyy[j] + 3.0 * pa_x[j] * pc_yz[j] * pb_yyz[j] + pc_xz[j] * pa_z[j] * pb_yyy[j] + 3.0 * pc_xy[j] * pa_z[j] * pb_yyz[j] + pc_xz[j] * pb_yyyz[j]);

                t_xz_yyyz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_xz[j] * pc_yz[j] * fl1_fx - 1.5 * pa_x[j] * pc_zz[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_yyy[j] - 1.5 * pa_x[j] * fl1_fx * pb_y[j] * pc_yy[j] - 1.5 * pc_xz[j] * pa_z[j] * pb_y[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xzz[j] * pb_y[j] * fl1_fx - 1.5 * pc_xz[j] * pb_yz[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] - 3.0 * pa_xz[j] * pb_y[j] * pc_yyz[j] - pa_xz[j] * pc_yyy[j] * pb_z[j] - 3.0 * pa_x[j] * pc_yzz[j] * pb_yy[j] - 3.0 * pa_x[j] * pc_yyz[j] * pb_yz[j] - 3.0 * pc_xyz[j] * pa_z[j] * pb_yy[j] - 3.0 * pc_xyy[j] * pa_z[j] * pb_yz[j] - pc_xzz[j] * pb_yyy[j] - 3.0 * pc_xyz[j] * pb_yyz[j]);

                t_xz_yyyz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_yyy[j] + 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 1.5 * pc_xzz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xyyy[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx * pb_y[j] + pa_xz[j] * pc_yyyz[j] + 3.0 * pa_x[j] * pc_yyzz[j] * pb_y[j] + pa_x[j] * pc_yyyz[j] * pb_z[j] + 3.0 * pc_xyyz[j] * pa_z[j] * pb_y[j] + pc_xyyy[j] * pa_z[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pb_yy[j] + 3.0 * pc_xyyz[j] * pb_yz[j]);

                t_xz_yyyz[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xyyy[j] * fl1_fx - pa_x[j] * pc_yyyzz[j] - pc_xyyyz[j] * pa_z[j] - 3.0 * pc_xyyzz[j] * pb_y[j] - pc_xyyyz[j] * pb_z[j]);

                t_xz_yyyz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_42_43(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (42,43)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyzz = pbDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_yyzz = primBuffer.data(90 * idx + 42);

            // Batch of Integrals (42,43)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_y, pb_yy, pb_yyz, pb_yyzz, pb_yz, pb_yzz, pb_z, pb_zz, \
                                     pc_x, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, pc_xyzzz, \
                                     pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xz_yyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_yyzz[j] = fl_s_0_0_0 * (0.25 * pa_xz[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pa_xz[j] * pb_yy[j] * fl1_fx + 0.5 * pa_xz[j] * fl1_fx * pb_zz[j] + pa_x[j] * fl1_fx * pb_yyz[j] + pa_xz[j] * pb_yyzz[j]);

                t_xz_yyzz[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * pc_z[j] * fl2_fx - pa_x[j] * fl2_fx * pb_z[j] - 0.25 * pc_x[j] * pa_z[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * pa_xz[j] * pb_yy[j] * fl1_fx - pa_xz[j] * pb_y[j] * pc_y[j] * fl1_fx - pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_zz[j] - 1.5 * pa_x[j] * pc_z[j] * pb_yy[j] * fl1_fx - 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_y[j] - pa_x[j] * fl1_fx * pb_yyz[j] - 0.5 * pc_x[j] * pa_z[j] * pb_yy[j] * fl1_fx - 0.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_zz[j] - pc_x[j] * fl1_fx * pb_yyz[j] - 2.0 * pa_xz[j] * pb_yyz[j] * pc_z[j] - 2.0 * pa_xz[j] * pb_yzz[j] * pc_y[j] - pa_x[j] * pc_z[j] * pb_yyzz[j] - pc_x[j] * pa_z[j] * pb_yyzz[j]);

                t_xz_yyzz[j] += fl_s_0_0_2 * (0.25 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_z[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pc_x[j] * pa_z[j] * fl2_fx + 0.75 * pc_xz[j] * fl2_fx + pc_x[j] * fl2_fx * pb_z[j] + pa_xz[j] * pb_y[j] * pc_y[j] * fl1_fx + 0.5 * pa_xz[j] * pc_yy[j] * fl1_fx + 0.5 * pa_xz[j] * fl1_fx * pc_zz[j] + pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_x[j] * pc_z[j] * pb_yy[j] * fl1_fx + 3.0 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx + pa_x[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_zz[j] + pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] + 2.0 * pa_x[j] * fl1_fx * pb_yz[j] * pc_y[j] + 0.5 * pc_x[j] * pa_z[j] * pb_yy[j] * fl1_fx + pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx + pc_xz[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_xz[j] * pb_yy[j] * fl1_fx + 0.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 2.0 * pc_xy[j] * fl1_fx * pb_yz[j] + pc_x[j] * fl1_fx * pb_yyz[j] + pa_xz[j] * pb_yy[j] * pc_zz[j] + 4.0 * pa_xz[j] * pb_yz[j] * pc_yz[j] + pa_xz[j] * pc_yy[j] * pb_zz[j] + 2.0 * pa_x[j] * pc_zz[j] * pb_yyz[j] + 2.0 * pa_x[j] * pc_yz[j] * pb_yzz[j] + 2.0 * pc_xz[j] * pa_z[j] * pb_yyz[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_yzz[j] + pc_xz[j] * pb_yyzz[j]);

                t_xz_yyzz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.25 * pc_x[j] * pa_z[j] * fl2_fx - 1.5 * pc_xz[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * pa_xz[j] * pc_yy[j] * fl1_fx - 0.5 * pa_xz[j] * fl1_fx * pc_zz[j] - 3.0 * pa_x[j] * pc_yz[j] * pb_y[j] * fl1_fx - 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx - 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx - pa_x[j] * pc_zz[j] * fl1_fx * pb_z[j] - pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] - pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx - 0.5 * pc_xyy[j] * pa_z[j] * fl1_fx - 0.5 * pc_xzz[j] * pa_z[j] * fl1_fx - pc_xz[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * pb_yy[j] * fl1_fx - 3.0 * pc_xyz[j] * pb_y[j] * fl1_fx - pc_xzz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_zz[j] - pc_xyy[j] * fl1_fx * pb_z[j] - 2.0 * pc_xy[j] * fl1_fx * pb_yz[j] - 2.0 * pa_xz[j] * pb_y[j] * pc_yzz[j] - 2.0 * pa_xz[j] * pc_yyz[j] * pb_z[j] - pa_x[j] * pc_zzz[j] * pb_yy[j] - 4.0 * pa_x[j] * pc_yzz[j] * pb_yz[j] - pa_x[j] * pc_yyz[j] * pb_zz[j] - pc_xzz[j] * pa_z[j] * pb_yy[j] - 4.0 * pc_xyz[j] * pa_z[j] * pb_yz[j] - pc_xyy[j] * pa_z[j] * pb_zz[j] - 2.0 * pc_xzz[j] * pb_yyz[j] - 2.0 * pc_xyz[j] * pb_yzz[j]);

                t_xz_yyzz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx + 0.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 0.5 * pc_xzz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 0.5 * pc_xzzz[j] * fl1_fx + pc_xzz[j] * fl1_fx * pb_z[j] + pc_xyy[j] * fl1_fx * pb_z[j] + pa_xz[j] * pc_yyzz[j] + 2.0 * pa_x[j] * pc_yzzz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_yyzz[j] * pb_z[j] + 2.0 * pc_xyzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_z[j] + pc_xzzz[j] * pb_yy[j] + 4.0 * pc_xyzz[j] * pb_yz[j] + pc_xyyz[j] * pb_zz[j]);

                t_xz_yyzz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_yyzzz[j] - pc_xyyzz[j] * pa_z[j] - 2.0 * pc_xyzzz[j] * pb_y[j] - 2.0 * pc_xyyzz[j] * pb_z[j]);

                t_xz_yyzz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_43_44(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (43,44)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yzzz = pbDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_yzzz = primBuffer.data(90 * idx + 43);

            // Batch of Integrals (43,44)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_y, pb_yz, pb_yzz, pb_yzzz, pb_z, pb_zz, pb_zzz, pc_x, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_y, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xz_yzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_yzzz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pa_xz[j] * pb_yz[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pb_yzz[j] + pa_xz[j] * pb_yzzz[j]);

                t_xz_yzzz[j] += fl_s_0_0_1 * (-1.5 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pa_x[j] * fl2_fx * pc_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_xz[j] * pb_yz[j] * fl1_fx - 1.5 * pa_xz[j] * pb_y[j] * pc_z[j] * fl1_fx - 1.5 * pa_xz[j] * pc_y[j] * pb_z[j] * fl1_fx - 4.5 * pa_x[j] * pc_z[j] * pb_yz[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_zz[j] - 1.5 * pa_x[j] * fl1_fx * pb_yzz[j] - 1.5 * pc_x[j] * pa_z[j] * pb_yz[j] * fl1_fx - 1.5 * pc_x[j] * fl1_fx * pb_yzz[j] - 3.0 * pa_xz[j] * pb_yzz[j] * pc_z[j] - pa_xz[j] * pc_y[j] * pb_zzz[j] - pa_x[j] * pc_z[j] * pb_yzzz[j] - pc_x[j] * pa_z[j] * pb_yzzz[j]);

                t_xz_yzzz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.75 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_xz[j] * pb_y[j] * pc_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_yz[j] * fl1_fx + 4.5 * pa_x[j] * pc_z[j] * pb_yz[j] * fl1_fx + 3.0 * pa_x[j] * pc_zz[j] * pb_y[j] * fl1_fx + 4.5 * pa_x[j] * pc_yz[j] * pb_z[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_zz[j] + 1.5 * pc_x[j] * pa_z[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * pb_z[j] * fl1_fx + 4.5 * pc_xz[j] * pb_yz[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * fl1_fx * pb_yzz[j] + 3.0 * pa_xz[j] * pb_yz[j] * pc_zz[j] + 3.0 * pa_xz[j] * pc_yz[j] * pb_zz[j] + 3.0 * pa_x[j] * pc_zz[j] * pb_yzz[j] + pa_x[j] * pc_yz[j] * pb_zzz[j] + 3.0 * pc_xz[j] * pa_z[j] * pb_yzz[j] + pc_xy[j] * pa_z[j] * pb_zzz[j] + pc_xz[j] * pb_yzzz[j]);

                t_xz_yzzz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_xz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_x[j] * pc_zz[j] * pb_y[j] * fl1_fx - 4.5 * pa_x[j] * pc_yz[j] * pb_z[j] * fl1_fx - 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_z[j] * pb_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * pb_z[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 4.5 * pc_xz[j] * pb_yz[j] * fl1_fx - 3.0 * pc_xzz[j] * pb_y[j] * fl1_fx - 4.5 * pc_xyz[j] * pb_z[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - pa_xz[j] * pb_y[j] * pc_zzz[j] - 3.0 * pa_xz[j] * pc_yzz[j] * pb_z[j] - 3.0 * pa_x[j] * pc_zzz[j] * pb_yz[j] - 3.0 * pa_x[j] * pc_yzz[j] * pb_zz[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_yz[j] - 3.0 * pc_xyz[j] * pa_z[j] * pb_zz[j] - 3.0 * pc_xzz[j] * pb_yzz[j] - pc_xyz[j] * pb_zzz[j]);

                t_xz_yzzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx + 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xzz[j] * pb_y[j] * fl1_fx + 4.5 * pc_xyz[j] * pb_z[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + pa_xz[j] * pc_yzzz[j] + pa_x[j] * pc_zzzz[j] * pb_y[j] + 3.0 * pa_x[j] * pc_yzzz[j] * pb_z[j] + pc_xzzz[j] * pa_z[j] * pb_y[j] + 3.0 * pc_xyzz[j] * pa_z[j] * pb_z[j] + 3.0 * pc_xzzz[j] * pb_yz[j] + 3.0 * pc_xyzz[j] * pb_zz[j]);

                t_xz_yzzz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yzzzz[j] - pc_xyzzz[j] * pa_z[j] - pc_xzzzz[j] * pb_y[j] - 3.0 * pc_xyzzz[j] * pb_z[j]);

                t_xz_yzzz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_44_45(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (44,45)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(9 * idx);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_zzzz = pbDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xzzzzz = pcDistances.data(83 * idx + 75);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xz_zzzz = primBuffer.data(90 * idx + 44);

            // Batch of Integrals (44,45)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_z, pb_z, pb_zz, pb_zzz, pb_zzzz, pc_x, pc_xz, pc_xzz, pc_xzzz, \
                                     pc_xzzzz, pc_xzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xz_zzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xz_zzzz[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 3.0 * pa_x[j] * fl2_fx * pb_z[j] + 3.0 * pa_xz[j] * pb_zz[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pb_zzz[j] + pa_xz[j] * pb_zzzz[j]);

                t_xz_zzzz[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 3.75 * pa_x[j] * pc_z[j] * fl2_fx - 6.0 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 3.0 * pc_x[j] * fl2_fx * pb_z[j] - 3.0 * pa_xz[j] * pb_zz[j] * fl1_fx - 6.0 * pa_xz[j] * pb_z[j] * pc_z[j] * fl1_fx - 9.0 * pa_x[j] * pc_z[j] * pb_zz[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pb_zzz[j] - 3.0 * pc_x[j] * pa_z[j] * pb_zz[j] * fl1_fx - 2.0 * pc_x[j] * fl1_fx * pb_zzz[j] - 4.0 * pa_xz[j] * pb_zzz[j] * pc_z[j] - pa_x[j] * pc_z[j] * pb_zzzz[j] - pc_x[j] * pa_z[j] * pb_zzzz[j]);

                t_xz_zzzz[j] += fl_s_0_0_2 * (0.75 * pa_xz[j] * fl2_fx + 7.5 * pa_x[j] * pc_z[j] * fl2_fx + 3.0 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pc_x[j] * pa_z[j] * fl2_fx + 3.75 * pc_xz[j] * fl2_fx + 6.0 * pc_x[j] * fl2_fx * pb_z[j] + 6.0 * pa_xz[j] * pb_z[j] * pc_z[j] * fl1_fx + 3.0 * pa_xz[j] * pc_zz[j] * fl1_fx + 9.0 * pa_x[j] * pc_z[j] * pb_zz[j] * fl1_fx + 12.0 * pa_x[j] * pc_zz[j] * pb_z[j] * fl1_fx + 3.0 * pc_x[j] * pa_z[j] * pb_zz[j] * fl1_fx + 6.0 * pc_xz[j] * pa_z[j] * pb_z[j] * fl1_fx + 9.0 * pc_xz[j] * pb_zz[j] * fl1_fx + 2.0 * pc_x[j] * fl1_fx * pb_zzz[j] + 6.0 * pa_xz[j] * pb_zz[j] * pc_zz[j] + 4.0 * pa_x[j] * pc_zz[j] * pb_zzz[j] + 4.0 * pc_xz[j] * pa_z[j] * pb_zzz[j] + pc_xz[j] * pb_zzzz[j]);

                t_xz_zzzz[j] += fl_s_0_0_3 * (-3.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 7.5 * pc_xz[j] * fl2_fx - 3.0 * pc_x[j] * fl2_fx * pb_z[j] - 3.0 * pa_xz[j] * pc_zz[j] * fl1_fx - 12.0 * pa_x[j] * pc_zz[j] * pb_z[j] * fl1_fx - 5.0 * pa_x[j] * pc_zzz[j] * fl1_fx - 6.0 * pc_xz[j] * pa_z[j] * pb_z[j] * fl1_fx - 3.0 * pc_xzz[j] * pa_z[j] * fl1_fx - 9.0 * pc_xz[j] * pb_zz[j] * fl1_fx - 12.0 * pc_xzz[j] * pb_z[j] * fl1_fx - 4.0 * pa_xz[j] * pb_z[j] * pc_zzz[j] - 6.0 * pa_x[j] * pc_zzz[j] * pb_zz[j] - 6.0 * pc_xzz[j] * pa_z[j] * pb_zz[j] - 4.0 * pc_xzz[j] * pb_zzz[j]);

                t_xz_zzzz[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 5.0 * pa_x[j] * pc_zzz[j] * fl1_fx + 3.0 * pc_xzz[j] * pa_z[j] * fl1_fx + 12.0 * pc_xzz[j] * pb_z[j] * fl1_fx + 5.0 * pc_xzzz[j] * fl1_fx + pa_xz[j] * pc_zzzz[j] + 4.0 * pa_x[j] * pc_zzzz[j] * pb_z[j] + 4.0 * pc_xzzz[j] * pa_z[j] * pb_z[j] + 6.0 * pc_xzzz[j] * pb_zz[j]);

                t_xz_zzzz[j] += fl_s_0_0_5 * (-5.0 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_zzzzz[j] - pc_xzzzz[j] * pa_z[j] - 4.0 * pc_xzzzz[j] * pb_z[j]);

                t_xz_zzzz[j] += fl_s_0_0_6 * pc_xzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_45_46(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (45,46)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxx = pbDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyy = pcDistances.data(83 * idx + 58);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xxxx = primBuffer.data(90 * idx + 45);

            // Batch of Integrals (45,46)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxx, pb_xxxx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxy, pc_xxxxyy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, pc_xy, pc_xyy, pc_y, pc_yy, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_xxxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yy_xxxx[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 1.5 * fl2_fx * pb_xx[j] + 3.0 * pa_yy[j] * pb_xx[j] * fl1_fx + 0.5 * fl1_fx * pb_xxxx[j] + pa_yy[j] * pb_xxxx[j]);

                t_yy_xxxx[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_yy[j] * fl2_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * fl2_fx * pb_xx[j] - 3.0 * fl2_fx * pb_x[j] * pc_x[j] - 3.0 * pa_yy[j] * pb_xx[j] * fl1_fx - 6.0 * pa_yy[j] * pb_x[j] * pc_x[j] * fl1_fx - 6.0 * pa_y[j] * pc_y[j] * pb_xx[j] * fl1_fx - 2.0 * fl1_fx * pb_xxx[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxxx[j] - 4.0 * pa_yy[j] * pb_xxx[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxxx[j]);

                t_yy_xxxx[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl2_fx + 0.75 * pc_yy[j] * fl2_fx + 6.0 * fl2_fx * pb_x[j] * pc_x[j] + 1.5 * fl2_fx * pc_xx[j] + 1.5 * fl2_fx * pb_xx[j] + 6.0 * pa_yy[j] * pb_x[j] * pc_x[j] * fl1_fx + 3.0 * pa_yy[j] * pc_xx[j] * fl1_fx + 6.0 * pa_y[j] * pc_y[j] * pb_xx[j] * fl1_fx + 12.0 * pa_y[j] * pc_xy[j] * pb_x[j] * fl1_fx + 3.0 * pc_yy[j] * pb_xx[j] * fl1_fx + 3.0 * fl1_fx * pb_xx[j] * pc_xx[j] + 2.0 * fl1_fx * pb_xxx[j] * pc_x[j] + 6.0 * pa_yy[j] * pb_xx[j] * pc_xx[j] + 8.0 * pa_y[j] * pc_xy[j] * pb_xxx[j] + pc_yy[j] * pb_xxxx[j]);

                t_yy_xxxx[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 1.5 * pc_yy[j] * fl2_fx - 3.0 * fl2_fx * pc_xx[j] - 3.0 * fl2_fx * pb_x[j] * pc_x[j] - 3.0 * pa_yy[j] * pc_xx[j] * fl1_fx - 12.0 * pa_y[j] * pc_xy[j] * pb_x[j] * fl1_fx - 6.0 * pa_y[j] * pc_xxy[j] * fl1_fx - 3.0 * pc_yy[j] * pb_xx[j] * fl1_fx - 6.0 * pc_xyy[j] * pb_x[j] * fl1_fx - 2.0 * fl1_fx * pb_x[j] * pc_xxx[j] - 3.0 * fl1_fx * pb_xx[j] * pc_xx[j] - 4.0 * pa_yy[j] * pb_x[j] * pc_xxx[j] - 12.0 * pa_y[j] * pc_xxy[j] * pb_xx[j] - 4.0 * pc_xyy[j] * pb_xxx[j]);

                t_yy_xxxx[j] += fl_s_0_0_4 * (0.75 * pc_yy[j] * fl2_fx + 1.5 * fl2_fx * pc_xx[j] + 6.0 * pa_y[j] * pc_xxy[j] * fl1_fx + 6.0 * pc_xyy[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 0.5 * fl1_fx * pc_xxxx[j] + 2.0 * fl1_fx * pb_x[j] * pc_xxx[j] + pa_yy[j] * pc_xxxx[j] + 8.0 * pa_y[j] * pc_xxxy[j] * pb_x[j] + 6.0 * pc_xxyy[j] * pb_xx[j]);

                t_yy_xxxx[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_xxxx[j] - 2.0 * pa_y[j] * pc_xxxxy[j] - 4.0 * pc_xxxyy[j] * pb_x[j]);

                t_yy_xxxx[j] += fl_s_0_0_6 * pc_xxxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_46_47(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (46,47)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxy = pbDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyy = pcDistances.data(83 * idx + 61);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xxxy = primBuffer.data(90 * idx + 46);

            // Batch of Integrals (46,47)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxx, pb_xxxy, pb_xxy, pb_xy, pb_y, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyy, pc_xxy, pc_xxyy, pc_xxyyy, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_y, pc_yy, pc_yyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yy_xxxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xxxy[j] = fl_s_0_0_0 * (1.5 * pa_y[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_yy[j] * pb_xy[j] * fl1_fx + pa_y[j] * fl1_fx * pb_xxx[j] + 0.5 * fl1_fx * pb_xxxy[j] + pa_yy[j] * pb_xxxy[j]);

                t_yy_xxxy[j] += fl_s_0_0_1 * (-3.0 * pa_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_y[j] * fl2_fx * pc_x[j] - 2.25 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pb_xy[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_yy[j] * pb_x[j] * fl1_fx * pc_y[j] - 1.5 * pa_yy[j] * pb_xy[j] * fl1_fx - 1.5 * pa_yy[j] * pc_x[j] * fl1_fx * pb_y[j] - 3.0 * pa_y[j] * pc_y[j] * pb_xy[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pb_xx[j] * pc_x[j] - pa_y[j] * fl1_fx * pb_xxx[j] - 1.5 * pc_y[j] * fl1_fx * pb_xxx[j] - 1.5 * fl1_fx * pb_xxy[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxxy[j] - pa_yy[j] * pb_xxx[j] * pc_y[j] - 3.0 * pa_yy[j] * pb_xxy[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxxy[j]);

                t_yy_xxxy[j] += fl_s_0_0_2 * (3.0 * pa_y[j] * fl2_fx * pc_x[j] + 1.5 * pa_y[j] * fl2_fx * pb_x[j] + 4.5 * pc_y[j] * fl2_fx * pb_x[j] + 2.25 * pc_xy[j] * fl2_fx + 1.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_yy[j] * pb_x[j] * fl1_fx * pc_y[j] + 1.5 * pa_yy[j] * pc_xy[j] * fl1_fx + 1.5 * pa_yy[j] * pc_x[j] * fl1_fx * pb_y[j] + 3.0 * pa_y[j] * pc_yy[j] * pb_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_xy[j] * fl1_fx + 3.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_y[j] + 3.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_xx[j] + 3.0 * pa_y[j] * fl1_fx * pb_xx[j] * pc_x[j] + 1.5 * pc_yy[j] * pb_xy[j] * fl1_fx + 4.5 * pc_xy[j] * fl1_fx * pb_xx[j] + 1.5 * pc_y[j] * fl1_fx * pb_xxx[j] + 1.5 * fl1_fx * pb_xy[j] * pc_xx[j] + 1.5 * fl1_fx * pb_xxy[j] * pc_x[j] + 3.0 * pa_yy[j] * pb_xx[j] * pc_xy[j] + 3.0 * pa_yy[j] * pb_xy[j] * pc_xx[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_xxx[j] + 6.0 * pa_y[j] * pc_xy[j] * pb_xxy[j] + pc_yy[j] * pb_xxxy[j]);

                t_yy_xxxy[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * fl2_fx * pc_x[j] - 4.5 * pc_xy[j] * fl2_fx - 2.25 * pc_y[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_yy[j] * pc_xy[j] * fl1_fx - 3.0 * pa_y[j] * pc_yy[j] * pb_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyy[j] * fl1_fx - 3.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_y[j] - pa_y[j] * fl1_fx * pc_xxx[j] - 3.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_xx[j] - 1.5 * pc_yyy[j] * pb_x[j] * fl1_fx - 1.5 * pc_yy[j] * pb_xy[j] * fl1_fx - 1.5 * pc_xyy[j] * fl1_fx * pb_y[j] - 4.5 * pc_xxy[j] * fl1_fx * pb_x[j] - 4.5 * pc_xy[j] * fl1_fx * pb_xx[j] - 0.5 * fl1_fx * pc_xxx[j] * pb_y[j] - 1.5 * fl1_fx * pb_xy[j] * pc_xx[j] - 3.0 * pa_yy[j] * pb_x[j] * pc_xxy[j] - pa_yy[j] * pc_xxx[j] * pb_y[j] - 6.0 * pa_y[j] * pc_xyy[j] * pb_xx[j] - 6.0 * pa_y[j] * pc_xxy[j] * pb_xy[j] - pc_yyy[j] * pb_xxx[j] - 3.0 * pc_xyy[j] * pb_xxy[j]);

                t_yy_xxxy[j] += fl_s_0_0_4 * (2.25 * pc_xy[j] * fl2_fx + 3.0 * pa_y[j] * pc_xyy[j] * fl1_fx + pa_y[j] * fl1_fx * pc_xxx[j] + 1.5 * pc_yyy[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyyy[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx * pb_y[j] + 1.5 * pc_xxxy[j] * fl1_fx + 4.5 * pc_xxy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_xxx[j] * pb_y[j] + pa_yy[j] * pc_xxxy[j] + 6.0 * pa_y[j] * pc_xxyy[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xxxy[j] * pb_y[j] + 3.0 * pc_xyyy[j] * pb_xx[j] + 3.0 * pc_xxyy[j] * pb_xy[j]);

                t_yy_xxxy[j] += fl_s_0_0_5 * (-1.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xxxy[j] * fl1_fx - 2.0 * pa_y[j] * pc_xxxyy[j] - 3.0 * pc_xxyyy[j] * pb_x[j] - pc_xxxyy[j] * pb_y[j]);

                t_yy_xxxy[j] += fl_s_0_0_6 * pc_xxxyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_47_48(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (47,48)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxz = pbDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xxxz = primBuffer.data(90 * idx + 47);

            // Batch of Integrals (47,48)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxx, pb_xxxz, pb_xxz, pb_xz, pb_z, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, pc_xxyyz, \
                                     pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyz, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_xxxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xxxz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_yy[j] * pb_xz[j] * fl1_fx + 0.5 * fl1_fx * pb_xxxz[j] + pa_yy[j] * pb_xxxz[j]);

                t_yy_xxxz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_x[j] * pc_z[j] - 1.5 * fl2_fx * pb_xz[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_yy[j] * pb_x[j] * fl1_fx * pc_z[j] - 1.5 * pa_yy[j] * pb_xz[j] * fl1_fx - 1.5 * pa_yy[j] * pc_x[j] * fl1_fx * pb_z[j] - 3.0 * pa_y[j] * pc_y[j] * pb_xz[j] * fl1_fx - 0.5 * fl1_fx * pb_xxx[j] * pc_z[j] - 1.5 * fl1_fx * pb_xxz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxxz[j] - pa_yy[j] * pb_xxx[j] * pc_z[j] - 3.0 * pa_yy[j] * pb_xxz[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxxz[j]);

                t_yy_xxxz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pb_x[j] * pc_z[j] + 0.75 * fl2_fx * pc_xz[j] + 1.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_yy[j] * pb_x[j] * fl1_fx * pc_z[j] + 1.5 * pa_yy[j] * pc_xz[j] * fl1_fx + 1.5 * pa_yy[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_xz[j] * fl1_fx + 3.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pc_yy[j] * pb_xz[j] * fl1_fx + 1.5 * fl1_fx * pb_xx[j] * pc_xz[j] + 1.5 * fl1_fx * pb_xz[j] * pc_xx[j] + 0.5 * fl1_fx * pb_xxx[j] * pc_z[j] + 1.5 * fl1_fx * pb_xxz[j] * pc_x[j] + 3.0 * pa_yy[j] * pb_xx[j] * pc_xz[j] + 3.0 * pa_yy[j] * pb_xz[j] * pc_xx[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xxx[j] + 6.0 * pa_y[j] * pc_xy[j] * pb_xxz[j] + pc_yy[j] * pb_xxxz[j]);

                t_yy_xxxz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_yy[j] * pc_xz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] - 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_yy[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * fl1_fx * pb_x[j] * pc_xxz[j] - 0.5 * fl1_fx * pc_xxx[j] * pb_z[j] - 1.5 * fl1_fx * pb_xx[j] * pc_xz[j] - 1.5 * fl1_fx * pb_xz[j] * pc_xx[j] - 3.0 * pa_yy[j] * pb_x[j] * pc_xxz[j] - pa_yy[j] * pc_xxx[j] * pb_z[j] - 6.0 * pa_y[j] * pc_xyz[j] * pb_xx[j] - 6.0 * pa_y[j] * pc_xxy[j] * pb_xz[j] - pc_yyz[j] * pb_xxx[j] - 3.0 * pc_xyy[j] * pb_xxz[j]);

                t_yy_xxxz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_xxxz[j] + 1.5 * fl1_fx * pb_x[j] * pc_xxz[j] + 0.5 * fl1_fx * pc_xxx[j] * pb_z[j] + pa_yy[j] * pc_xxxz[j] + 6.0 * pa_y[j] * pc_xxyz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xxxy[j] * pb_z[j] + 3.0 * pc_xyyz[j] * pb_xx[j] + 3.0 * pc_xxyy[j] * pb_xz[j]);

                t_yy_xxxz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxxz[j] - 2.0 * pa_y[j] * pc_xxxyz[j] - 3.0 * pc_xxyyz[j] * pb_x[j] - pc_xxxyy[j] * pb_z[j]);

                t_yy_xxxz[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_48_49(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (48,49)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyy = pbDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyy = pcDistances.data(83 * idx + 65);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xxyy = primBuffer.data(90 * idx + 48);

            // Batch of Integrals (48,49)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxy, pb_xxyy, pb_xy, pb_xyy, pb_y, pb_yy, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yy_xxyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yy_xxyy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + pa_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_yy[j] * pb_xx[j] * fl1_fx + 0.5 * pa_yy[j] * fl1_fx * pb_yy[j] + 2.0 * pa_y[j] * fl1_fx * pb_xxy[j] + 0.5 * fl1_fx * pb_xxyy[j] + pa_yy[j] * pb_xxyy[j]);

                t_yy_xxyy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 0.5 * pa_yy[j] * fl2_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 2.0 * pa_y[j] * fl2_fx * pb_y[j] - 1.5 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 1.5 * fl2_fx * pb_xx[j] - 0.5 * fl2_fx * pb_yy[j] - 0.5 * pa_yy[j] * pb_xx[j] * fl1_fx - pa_yy[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_yy[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_yy[j] * fl1_fx * pb_yy[j] - 3.0 * pa_y[j] * pc_y[j] * pb_xx[j] * fl1_fx - pa_y[j] * pc_y[j] * fl1_fx * pb_yy[j] - 4.0 * pa_y[j] * fl1_fx * pb_xy[j] * pc_x[j] - 2.0 * pa_y[j] * fl1_fx * pb_xxy[j] - 3.0 * pc_y[j] * fl1_fx * pb_xxy[j] - fl1_fx * pb_xyy[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxyy[j] - 2.0 * pa_yy[j] * pb_xxy[j] * pc_y[j] - 2.0 * pa_yy[j] * pb_xyy[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxyy[j]);

                t_yy_xxyy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl2_fx + pa_y[j] * fl2_fx * pb_y[j] + 1.5 * pc_yy[j] * fl2_fx + 3.0 * pc_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pc_xx[j] + 3.0 * fl2_fx * pb_x[j] * pc_x[j] + 0.75 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_yy[j] + pa_yy[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_yy[j] * pc_xx[j] * fl1_fx + 0.5 * pa_yy[j] * fl1_fx * pc_yy[j] + pa_yy[j] * fl1_fx * pb_y[j] * pc_y[j] + 3.0 * pa_y[j] * pc_y[j] * pb_xx[j] * fl1_fx + 6.0 * pa_y[j] * pc_xy[j] * pb_x[j] * fl1_fx + 2.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_yy[j] + 2.0 * pa_y[j] * fl1_fx * pc_xx[j] * pb_y[j] + 4.0 * pa_y[j] * fl1_fx * pb_xy[j] * pc_x[j] + 3.0 * pc_yy[j] * pb_xx[j] * fl1_fx + 0.5 * pc_yy[j] * fl1_fx * pb_yy[j] + 6.0 * pc_xy[j] * fl1_fx * pb_xy[j] + 3.0 * pc_y[j] * fl1_fx * pb_xxy[j] + 0.5 * fl1_fx * pc_xx[j] * pb_yy[j] + fl1_fx * pb_xyy[j] * pc_x[j] + pa_yy[j] * pb_xx[j] * pc_yy[j] + 4.0 * pa_yy[j] * pb_xy[j] * pc_xy[j] + pa_yy[j] * pc_xx[j] * pb_yy[j] + 4.0 * pa_y[j] * pc_yy[j] * pb_xxy[j] + 4.0 * pa_y[j] * pc_xy[j] * pb_xyy[j] + pc_yy[j] * pb_xxyy[j]);

                t_yy_xxyy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * pc_yy[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pc_xx[j] - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * pa_yy[j] * pc_xx[j] * fl1_fx - 0.5 * pa_yy[j] * fl1_fx * pc_yy[j] - 6.0 * pa_y[j] * pc_xy[j] * pb_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_xxy[j] * fl1_fx - pa_y[j] * pc_yyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] - 2.0 * pa_y[j] * fl1_fx * pc_xx[j] * pb_y[j] - 3.0 * pc_yy[j] * pb_xx[j] * fl1_fx - 6.0 * pc_xyy[j] * pb_x[j] * fl1_fx - pc_yyy[j] * fl1_fx * pb_y[j] - 0.5 * pc_yy[j] * fl1_fx * pb_yy[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] - 6.0 * pc_xy[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pc_xx[j] * pb_yy[j] - 2.0 * pa_yy[j] * pb_x[j] * pc_xyy[j] - 2.0 * pa_yy[j] * pc_xxy[j] * pb_y[j] - 2.0 * pa_y[j] * pc_yyy[j] * pb_xx[j] - 8.0 * pa_y[j] * pc_xyy[j] * pb_xy[j] - 2.0 * pa_y[j] * pc_xxy[j] * pb_yy[j] - 2.0 * pc_yyy[j] * pb_xxy[j] - 2.0 * pc_xyy[j] * pb_xyy[j]);

                t_yy_xxyy[j] += fl_s_0_0_4 * (1.5 * pc_yy[j] * fl2_fx + 0.75 * fl2_fx * pc_xx[j] + 3.0 * pa_y[j] * pc_xxy[j] * fl1_fx + pa_y[j] * pc_yyy[j] * fl1_fx + 6.0 * pc_xyy[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 0.5 * pc_yyyy[j] * fl1_fx + pc_yyy[j] * fl1_fx * pb_y[j] + 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] + pa_yy[j] * pc_xxyy[j] + 4.0 * pa_y[j] * pc_xyyy[j] * pb_x[j] + 4.0 * pa_y[j] * pc_xxyy[j] * pb_y[j] + pc_yyyy[j] * pb_xx[j] + 4.0 * pc_xyyy[j] * pb_xy[j] + pc_xxyy[j] * pb_yy[j]);

                t_yy_xxyy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * pc_yyyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_xxyyy[j] - 2.0 * pc_xyyyy[j] * pb_x[j] - 2.0 * pc_xxyyy[j] * pb_y[j]);

                t_yy_xxyy[j] += fl_s_0_0_6 * pc_xxyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_49_50(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (49,50)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyz = pbDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xxyz = primBuffer.data(90 * idx + 49);

            // Batch of Integrals (49,50)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxy, pb_xxyz, pb_xxz, pb_xy, pb_xyz, pb_xz, pb_y, \
                                     pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, \
                                     pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, \
                                     pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yy_xxyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xxyz[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_yy[j] * fl1_fx * pb_yz[j] + pa_y[j] * fl1_fx * pb_xxz[j] + 0.5 * fl1_fx * pb_xxyz[j] + pa_yy[j] * pb_xxyz[j]);

                t_yy_xxyz[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx * pc_z[j] - pa_y[j] * fl2_fx * pb_z[j] - 0.75 * pc_y[j] * fl2_fx * pb_z[j] - 0.25 * fl2_fx * pb_y[j] * pc_z[j] - 0.5 * fl2_fx * pb_yz[j] - 0.5 * pa_yy[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_yy[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_yz[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_yz[j] - pa_y[j] * fl1_fx * pb_xx[j] * pc_z[j] - 2.0 * pa_y[j] * fl1_fx * pb_xz[j] * pc_x[j] - pa_y[j] * fl1_fx * pb_xxz[j] - 1.5 * pc_y[j] * fl1_fx * pb_xxz[j] - 0.5 * fl1_fx * pb_xxy[j] * pc_z[j] - fl1_fx * pb_xyz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxyz[j] - pa_yy[j] * pb_xxy[j] * pc_z[j] - pa_yy[j] * pb_xxz[j] * pc_y[j] - 2.0 * pa_yy[j] * pb_xyz[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxyz[j]);

                t_yy_xxyz[j] += fl_s_0_0_2 * (pa_y[j] * fl2_fx * pc_z[j] + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.75 * pc_yz[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pb_y[j] * pc_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_yy[j] * fl1_fx * pc_yz[j] + 0.5 * pa_yy[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_yy[j] * fl1_fx * pc_y[j] * pb_z[j] + pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] + pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_yz[j] + 2.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_xz[j] + pa_y[j] * fl1_fx * pc_xx[j] * pb_z[j] + pa_y[j] * fl1_fx * pb_xx[j] * pc_z[j] + 2.0 * pa_y[j] * fl1_fx * pb_xz[j] * pc_x[j] + 0.5 * pc_yy[j] * fl1_fx * pb_yz[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] + 3.0 * pc_xy[j] * fl1_fx * pb_xz[j] + 1.5 * pc_y[j] * fl1_fx * pb_xxz[j] + fl1_fx * pb_xy[j] * pc_xz[j] + 0.5 * fl1_fx * pc_xx[j] * pb_yz[j] + 0.5 * fl1_fx * pb_xxy[j] * pc_z[j] + fl1_fx * pb_xyz[j] * pc_x[j] + pa_yy[j] * pb_xx[j] * pc_yz[j] + 2.0 * pa_yy[j] * pb_xy[j] * pc_xz[j] + 2.0 * pa_yy[j] * pb_xz[j] * pc_xy[j] + pa_yy[j] * pc_xx[j] * pb_yz[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xxy[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_xxz[j] + 4.0 * pa_y[j] * pc_xy[j] * pb_xyz[j] + pc_yy[j] * pb_xxyz[j]);

                t_yy_xxyz[j] += fl_s_0_0_3 * (-0.5 * pa_y[j] * fl2_fx * pc_z[j] - 1.5 * pc_yz[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_z[j] - 0.25 * fl2_fx * pb_y[j] * pc_z[j] - 0.5 * pa_yy[j] * fl1_fx * pc_yz[j] - pa_y[j] * pc_yyz[j] * fl1_fx - pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] - pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] - pa_y[j] * fl1_fx * pc_xxz[j] - 2.0 * pa_y[j] * fl1_fx * pb_x[j] * pc_xz[j] - pa_y[j] * fl1_fx * pc_xx[j] * pb_z[j] - 0.5 * pc_yyz[j] * fl1_fx * pb_y[j] - 0.5 * pc_yyy[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * fl1_fx * pb_yz[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] - 3.0 * pc_xy[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pc_xxz[j] * pb_y[j] - fl1_fx * pb_xy[j] * pc_xz[j] - 0.5 * fl1_fx * pc_xx[j] * pb_yz[j] - 2.0 * pa_yy[j] * pb_x[j] * pc_xyz[j] - pa_yy[j] * pc_xxz[j] * pb_y[j] - pa_yy[j] * pc_xxy[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yyz[j] * pb_xx[j] - 4.0 * pa_y[j] * pc_xyz[j] * pb_xy[j] - 4.0 * pa_y[j] * pc_xyy[j] * pb_xz[j] - 2.0 * pa_y[j] * pc_xxy[j] * pb_yz[j] - pc_yyz[j] * pb_xxy[j] - pc_yyy[j] * pb_xxz[j] - 2.0 * pc_xyy[j] * pb_xyz[j]);

                t_yy_xxyz[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + pa_y[j] * pc_yyz[j] * fl1_fx + pa_y[j] * fl1_fx * pc_xxz[j] + 0.5 * pc_yyyz[j] * fl1_fx + 0.5 * pc_yyz[j] * fl1_fx * pb_y[j] + 0.5 * pc_yyy[j] * fl1_fx * pb_z[j] + 1.5 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_xxz[j] * pb_y[j] + pa_yy[j] * pc_xxyz[j] + 4.0 * pa_y[j] * pc_xyyz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xxyz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_xxyy[j] * pb_z[j] + pc_yyyz[j] * pb_xx[j] + 2.0 * pc_xyyz[j] * pb_xy[j] + 2.0 * pc_xyyy[j] * pb_xz[j] + pc_xxyy[j] * pb_yz[j]);

                t_yy_xxyz[j] += fl_s_0_0_5 * (-0.5 * pc_yyyz[j] * fl1_fx - 1.5 * pc_xxyz[j] * fl1_fx - 2.0 * pa_y[j] * pc_xxyyz[j] - 2.0 * pc_xyyyz[j] * pb_x[j] - pc_xxyyz[j] * pb_y[j] - pc_xxyyy[j] * pb_z[j]);

                t_yy_xxyz[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_50_51(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (50,51)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxzz = pbDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xxzz = primBuffer.data(90 * idx + 50);

            // Batch of Integrals (50,51)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xx, pb_xxz, pb_xxzz, pb_xz, pb_xzz, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_yy_xxzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yy_xxzz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + 0.25 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_yy[j] * pb_xx[j] * fl1_fx + 0.5 * pa_yy[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_xxzz[j] + pa_yy[j] * pb_xxzz[j]);

                t_yy_xxzz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_yy[j] * fl2_fx - 0.5 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * fl2_fx * pb_xx[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_yy[j] * pb_xx[j] * fl1_fx - pa_yy[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_yy[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_zz[j] - pa_y[j] * pc_y[j] * pb_xx[j] * fl1_fx - pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] - fl1_fx * pb_xxz[j] * pc_z[j] - fl1_fx * pb_xzz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxzz[j] - 2.0 * pa_yy[j] * pb_xxz[j] * pc_z[j] - 2.0 * pa_yy[j] * pb_xzz[j] * pc_x[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xxzz[j]);

                t_yy_xxzz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + pa_y[j] * pc_y[j] * fl2_fx + 0.25 * pc_yy[j] * fl2_fx + fl2_fx * pb_x[j] * pc_x[j] + 0.25 * fl2_fx * pc_xx[j] + 0.25 * fl2_fx * pc_zz[j] + fl2_fx * pb_z[j] * pc_z[j] + 0.25 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_zz[j] + pa_yy[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_yy[j] * pc_xx[j] * fl1_fx + 0.5 * pa_yy[j] * fl1_fx * pc_zz[j] + pa_yy[j] * fl1_fx * pb_z[j] * pc_z[j] + pa_y[j] * pc_y[j] * pb_xx[j] * fl1_fx + 2.0 * pa_y[j] * pc_xy[j] * pb_x[j] * fl1_fx + 2.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_yy[j] * pb_xx[j] * fl1_fx + 0.5 * pc_yy[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pb_xx[j] * pc_zz[j] + 2.0 * fl1_fx * pb_xz[j] * pc_xz[j] + 0.5 * fl1_fx * pc_xx[j] * pb_zz[j] + fl1_fx * pb_xxz[j] * pc_z[j] + fl1_fx * pb_xzz[j] * pc_x[j] + pa_yy[j] * pb_xx[j] * pc_zz[j] + 4.0 * pa_yy[j] * pb_xz[j] * pc_xz[j] + pa_yy[j] * pc_xx[j] * pb_zz[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_xxz[j] + 4.0 * pa_y[j] * pc_xy[j] * pb_xzz[j] + pc_yy[j] * pb_xxzz[j]);

                t_yy_xxzz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * pc_yy[j] * fl2_fx - 0.5 * fl2_fx * pc_xx[j] - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * pa_yy[j] * pc_xx[j] * fl1_fx - 0.5 * pa_yy[j] * fl1_fx * pc_zz[j] - 2.0 * pa_y[j] * pc_xy[j] * pb_x[j] * fl1_fx - pa_y[j] * pc_xxy[j] * fl1_fx - pa_y[j] * pc_yzz[j] * fl1_fx - 2.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * pb_xx[j] * fl1_fx - pc_xyy[j] * pb_x[j] * fl1_fx - pc_yyz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * fl1_fx * pb_zz[j] - fl1_fx * pb_x[j] * pc_xzz[j] - fl1_fx * pc_xxz[j] * pb_z[j] - 0.5 * fl1_fx * pb_xx[j] * pc_zz[j] - 2.0 * fl1_fx * pb_xz[j] * pc_xz[j] - 0.5 * fl1_fx * pc_xx[j] * pb_zz[j] - 2.0 * pa_yy[j] * pb_x[j] * pc_xzz[j] - 2.0 * pa_yy[j] * pc_xxz[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xx[j] - 8.0 * pa_y[j] * pc_xyz[j] * pb_xz[j] - 2.0 * pa_y[j] * pc_xxy[j] * pb_zz[j] - 2.0 * pc_yyz[j] * pb_xxz[j] - 2.0 * pc_xyy[j] * pb_xzz[j]);

                t_yy_xxzz[j] += fl_s_0_0_4 * (0.25 * pc_yy[j] * fl2_fx + 0.25 * fl2_fx * pc_xx[j] + 0.25 * fl2_fx * pc_zz[j] + pa_y[j] * pc_xxy[j] * fl1_fx + pa_y[j] * pc_yzz[j] * fl1_fx + pc_xyy[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_yyzz[j] * fl1_fx + pc_yyz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_xxzz[j] + fl1_fx * pb_x[j] * pc_xzz[j] + fl1_fx * pc_xxz[j] * pb_z[j] + pa_yy[j] * pc_xxzz[j] + 4.0 * pa_y[j] * pc_xyzz[j] * pb_x[j] + 4.0 * pa_y[j] * pc_xxyz[j] * pb_z[j] + pc_yyzz[j] * pb_xx[j] + 4.0 * pc_xyyz[j] * pb_xz[j] + pc_xxyy[j] * pb_zz[j]);

                t_yy_xxzz[j] += fl_s_0_0_5 * (-0.5 * pc_xxyy[j] * fl1_fx - 0.5 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxzz[j] - 2.0 * pa_y[j] * pc_xxyzz[j] - 2.0 * pc_xyyzz[j] * pb_x[j] - 2.0 * pc_xxyyz[j] * pb_z[j]);

                t_yy_xxzz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_51_52(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (51,52)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyy = pbDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyy = pcDistances.data(83 * idx + 70);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xyyy = primBuffer.data(90 * idx + 51);

            // Batch of Integrals (51,52)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xy, pb_xyy, pb_xyyy, pb_y, pb_yy, pb_yyy, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyyy, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_xyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xyyy[j] = fl_s_0_0_0 * (1.5 * pa_y[j] * fl2_fx * pb_x[j] + 2.25 * fl2_fx * pb_xy[j] + 1.5 * pa_yy[j] * pb_xy[j] * fl1_fx + 3.0 * pa_y[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pb_xyyy[j] + pa_yy[j] * pb_xyyy[j]);

                t_yy_xyyy[j] += fl_s_0_0_1 * (-3.0 * pa_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_y[j] * fl2_fx * pc_x[j] - 3.75 * pc_y[j] * fl2_fx * pb_x[j] - 2.25 * fl2_fx * pc_x[j] * pb_y[j] - 4.5 * fl2_fx * pb_xy[j] - 1.5 * pa_yy[j] * pb_xy[j] * fl1_fx - 1.5 * pa_yy[j] * pb_x[j] * pc_y[j] * fl1_fx - 1.5 * pa_yy[j] * pc_x[j] * pb_y[j] * fl1_fx - 9.0 * pa_y[j] * pc_y[j] * pb_xy[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pc_x[j] * pb_yy[j] - 3.0 * pa_y[j] * fl1_fx * pb_xyy[j] - 4.5 * pc_y[j] * fl1_fx * pb_xyy[j] - 0.5 * fl1_fx * pc_x[j] * pb_yyy[j] - 0.5 * fl1_fx * pb_xyyy[j] - 3.0 * pa_yy[j] * pb_xyy[j] * pc_y[j] - pa_yy[j] * pc_x[j] * pb_yyy[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xyyy[j]);

                t_yy_xyyy[j] += fl_s_0_0_2 * (3.0 * pa_y[j] * fl2_fx * pc_x[j] + 1.5 * pa_y[j] * fl2_fx * pb_x[j] + 7.5 * pc_y[j] * fl2_fx * pb_x[j] + 3.75 * pc_xy[j] * fl2_fx + 4.5 * fl2_fx * pc_x[j] * pb_y[j] + 2.25 * fl2_fx * pb_xy[j] + 1.5 * pa_yy[j] * pb_x[j] * pc_y[j] * fl1_fx + 1.5 * pa_yy[j] * pc_x[j] * pb_y[j] * fl1_fx + 1.5 * pa_yy[j] * pc_xy[j] * fl1_fx + 9.0 * pa_y[j] * pc_y[j] * pb_xy[j] * fl1_fx + 6.0 * pa_y[j] * pc_yy[j] * pb_x[j] * fl1_fx + 9.0 * pa_y[j] * pc_xy[j] * pb_y[j] * fl1_fx + 3.0 * pa_y[j] * fl1_fx * pc_x[j] * pb_yy[j] + 9.0 * pc_yy[j] * pb_xy[j] * fl1_fx + 4.5 * pc_xy[j] * fl1_fx * pb_yy[j] + 4.5 * pc_y[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pc_x[j] * pb_yyy[j] + 3.0 * pa_yy[j] * pb_xy[j] * pc_yy[j] + 3.0 * pa_yy[j] * pc_xy[j] * pb_yy[j] + 6.0 * pa_y[j] * pc_yy[j] * pb_xyy[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_yyy[j] + pc_yy[j] * pb_xyyy[j]);

                t_yy_xyyy[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * fl2_fx * pc_x[j] - 7.5 * pc_xy[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx * pb_x[j] - 2.25 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_yy[j] * pc_xy[j] * fl1_fx - 6.0 * pa_y[j] * pc_yy[j] * pb_x[j] * fl1_fx - 9.0 * pa_y[j] * pc_xy[j] * pb_y[j] * fl1_fx - 6.0 * pa_y[j] * pc_xyy[j] * fl1_fx - 9.0 * pc_yy[j] * pb_xy[j] * fl1_fx - 5.0 * pc_yyy[j] * pb_x[j] * fl1_fx - 9.0 * pc_xyy[j] * pb_y[j] * fl1_fx - 4.5 * pc_xy[j] * fl1_fx * pb_yy[j] - pa_yy[j] * pb_x[j] * pc_yyy[j] - 3.0 * pa_yy[j] * pc_xyy[j] * pb_y[j] - 6.0 * pa_y[j] * pc_yyy[j] * pb_xy[j] - 6.0 * pa_y[j] * pc_xyy[j] * pb_yy[j] - 3.0 * pc_yyy[j] * pb_xyy[j] - pc_xyy[j] * pb_yyy[j]);

                t_yy_xyyy[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 6.0 * pa_y[j] * pc_xyy[j] * fl1_fx + 5.0 * pc_yyy[j] * pb_x[j] * fl1_fx + 9.0 * pc_xyy[j] * pb_y[j] * fl1_fx + 5.0 * pc_xyyy[j] * fl1_fx + pa_yy[j] * pc_xyyy[j] + 2.0 * pa_y[j] * pc_yyyy[j] * pb_x[j] + 6.0 * pa_y[j] * pc_xyyy[j] * pb_y[j] + 3.0 * pc_yyyy[j] * pb_xy[j] + 3.0 * pc_xyyy[j] * pb_yy[j]);

                t_yy_xyyy[j] += fl_s_0_0_5 * (-5.0 * pc_xyyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_xyyyy[j] - pc_yyyyy[j] * pb_x[j] - 3.0 * pc_xyyyy[j] * pb_y[j]);

                t_yy_xyyy[j] += fl_s_0_0_6 * pc_xyyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_52_53(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (52,53)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyz = pbDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xyyz = primBuffer.data(90 * idx + 52);

            // Batch of Integrals (52,53)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xy, pb_xyy, pb_xyyz, pb_xyz, pb_xz, pb_y, pb_yy, pb_yyz, \
                                     pb_yz, pb_z, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, \
                                     pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_xyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xyyz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xz[j] + 0.5 * pa_yy[j] * pb_xz[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pb_xyyz[j] + pa_yy[j] * pb_xyyz[j]);

                t_yy_xyyz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * fl2_fx * pb_xz[j] - 0.5 * pa_yy[j] * pb_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_yy[j] * pb_xz[j] * fl1_fx - 0.5 * pa_yy[j] * pc_x[j] * fl1_fx * pb_z[j] - 3.0 * pa_y[j] * pc_y[j] * pb_xz[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pb_xy[j] * pc_z[j] - 2.0 * pa_y[j] * fl1_fx * pc_x[j] * pb_yz[j] - 2.0 * pa_y[j] * fl1_fx * pb_xyz[j] - 3.0 * pc_y[j] * fl1_fx * pb_xyz[j] - 0.5 * fl1_fx * pb_xyy[j] * pc_z[j] - 0.5 * fl1_fx * pc_x[j] * pb_yyz[j] - 0.5 * fl1_fx * pb_xyyz[j] - pa_yy[j] * pb_xyy[j] * pc_z[j] - 2.0 * pa_yy[j] * pb_xyz[j] * pc_y[j] - pa_yy[j] * pc_x[j] * pb_yyz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xyyz[j]);

                t_yy_xyyz[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_xz[j] + 1.5 * fl2_fx * pb_x[j] * pc_z[j] + 1.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 0.5 * pa_yy[j] * pb_x[j] * fl1_fx * pc_z[j] + 0.5 * pa_yy[j] * pc_xz[j] * fl1_fx + 0.5 * pa_yy[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_xz[j] * fl1_fx + 3.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] + 2.0 * pa_y[j] * fl1_fx * pc_xz[j] * pb_y[j] + 2.0 * pa_y[j] * fl1_fx * pb_xy[j] * pc_z[j] + 2.0 * pa_y[j] * fl1_fx * pc_x[j] * pb_yz[j] + 3.0 * pc_yy[j] * pb_xz[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_xy[j] + 3.0 * pc_xy[j] * fl1_fx * pb_yz[j] + 3.0 * pc_y[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pc_xz[j] * pb_yy[j] + 0.5 * fl1_fx * pb_xyy[j] * pc_z[j] + 0.5 * fl1_fx * pc_x[j] * pb_yyz[j] + 2.0 * pa_yy[j] * pb_xy[j] * pc_yz[j] + pa_yy[j] * pb_xz[j] * pc_yy[j] + pa_yy[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_yy[j] * pc_xy[j] * pb_yz[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xyy[j] + 4.0 * pa_y[j] * pc_yy[j] * pb_xyz[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_yyz[j] + pc_yy[j] * pb_xyyz[j]);

                t_yy_xyyz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 0.5 * pa_yy[j] * pc_xz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] - 2.0 * pa_y[j] * fl1_fx * pc_xz[j] * pb_y[j] - 3.0 * pc_yyz[j] * pb_x[j] * fl1_fx - 3.0 * pc_yy[j] * pb_xz[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 3.0 * pc_yz[j] * fl1_fx * pb_xy[j] - 3.0 * pc_xy[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pc_xz[j] * pb_yy[j] - pa_yy[j] * pb_x[j] * pc_yyz[j] - 2.0 * pa_yy[j] * pc_xyz[j] * pb_y[j] - pa_yy[j] * pc_xyy[j] * pb_z[j] - 4.0 * pa_y[j] * pc_yyz[j] * pb_xy[j] - 2.0 * pa_y[j] * pc_yyy[j] * pb_xz[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_yy[j] - 4.0 * pa_y[j] * pc_xyy[j] * pb_yz[j] - pc_yyz[j] * pb_xyy[j] - 2.0 * pc_yyy[j] * pb_xyz[j] - pc_xyy[j] * pb_yyz[j]);

                t_yy_xyyz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_yyz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + pa_yy[j] * pc_xyyz[j] + 2.0 * pa_y[j] * pc_yyyz[j] * pb_x[j] + 4.0 * pa_y[j] * pc_xyyz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_xyyy[j] * pb_z[j] + 2.0 * pc_yyyz[j] * pb_xy[j] + pc_yyyy[j] * pb_xz[j] + pc_xyyz[j] * pb_yy[j] + 2.0 * pc_xyyy[j] * pb_yz[j]);

                t_yy_xyyz[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - 2.0 * pa_y[j] * pc_xyyyz[j] - pc_yyyyz[j] * pb_x[j] - 2.0 * pc_xyyyz[j] * pb_y[j] - pc_xyyyy[j] * pb_z[j]);

                t_yy_xyyz[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_53_54(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (53,54)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyzz = pbDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xyzz = primBuffer.data(90 * idx + 53);

            // Batch of Integrals (53,54)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xy, pb_xyz, pb_xyzz, pb_xz, pb_xzz, pb_y, pb_yz, pb_yzz, \
                                     pb_z, pb_zz, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, \
                                     pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_yy_xyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xyzz[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_yy[j] * pb_xy[j] * fl1_fx + pa_y[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pb_xyzz[j] + pa_yy[j] * pb_xyzz[j]);

                t_yy_xyzz[j] += fl_s_0_0_1 * (-pa_y[j] * fl2_fx * pb_x[j] - 0.5 * pa_y[j] * fl2_fx * pc_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pb_xy[j] - 0.25 * fl2_fx * pc_x[j] * pb_y[j] - 0.5 * pa_yy[j] * pb_xy[j] * fl1_fx - 0.5 * pa_yy[j] * pb_x[j] * pc_y[j] * fl1_fx - 0.5 * pa_yy[j] * pc_x[j] * pb_y[j] * fl1_fx - pa_y[j] * pc_y[j] * pb_xy[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pb_xz[j] * pc_z[j] - pa_y[j] * fl1_fx * pc_x[j] * pb_zz[j] - pa_y[j] * fl1_fx * pb_xzz[j] - 1.5 * pc_y[j] * fl1_fx * pb_xzz[j] - fl1_fx * pb_xyz[j] * pc_z[j] - 0.5 * fl1_fx * pc_x[j] * pb_yzz[j] - 0.5 * fl1_fx * pb_xyzz[j] - 2.0 * pa_yy[j] * pb_xyz[j] * pc_z[j] - pa_yy[j] * pb_xzz[j] * pc_y[j] - pa_yy[j] * pc_x[j] * pb_yzz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xyzz[j]);

                t_yy_xyzz[j] += fl_s_0_0_2 * (pa_y[j] * fl2_fx * pc_x[j] + 0.5 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + 0.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_yy[j] * pb_x[j] * pc_y[j] * fl1_fx + 0.5 * pa_yy[j] * pc_x[j] * pb_y[j] * fl1_fx + 0.5 * pa_yy[j] * pc_xy[j] * fl1_fx + pa_y[j] * pc_y[j] * pb_xy[j] * fl1_fx + pa_y[j] * pc_yy[j] * pb_x[j] * fl1_fx + pa_y[j] * pc_xy[j] * pb_y[j] * fl1_fx + pa_y[j] * fl1_fx * pb_x[j] * pc_zz[j] + 2.0 * pa_y[j] * fl1_fx * pc_xz[j] * pb_z[j] + 2.0 * pa_y[j] * fl1_fx * pb_xz[j] * pc_z[j] + pa_y[j] * fl1_fx * pc_x[j] * pb_zz[j] + 0.5 * pc_yy[j] * pb_xy[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_xz[j] + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + 1.5 * pc_y[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pb_xy[j] * pc_zz[j] + fl1_fx * pc_xz[j] * pb_yz[j] + fl1_fx * pb_xyz[j] * pc_z[j] + 0.5 * fl1_fx * pc_x[j] * pb_yzz[j] + pa_yy[j] * pb_xy[j] * pc_zz[j] + 2.0 * pa_yy[j] * pb_xz[j] * pc_yz[j] + 2.0 * pa_yy[j] * pc_xz[j] * pb_yz[j] + pa_yy[j] * pc_xy[j] * pb_zz[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_xyz[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_xzz[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_yzz[j] + pc_yy[j] * pb_xyzz[j]);

                t_yy_xyzz[j] += fl_s_0_0_3 * (-0.5 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pc_x[j] * pb_y[j] - 0.5 * pa_yy[j] * pc_xy[j] * fl1_fx - pa_y[j] * pc_yy[j] * pb_x[j] * fl1_fx - pa_y[j] * pc_xy[j] * pb_y[j] * fl1_fx - pa_y[j] * pc_xyy[j] * fl1_fx - pa_y[j] * fl1_fx * pc_xzz[j] - pa_y[j] * fl1_fx * pb_x[j] * pc_zz[j] - 2.0 * pa_y[j] * fl1_fx * pc_xz[j] * pb_z[j] - 0.5 * pc_yy[j] * pb_xy[j] * fl1_fx - 0.5 * pc_yyy[j] * pb_x[j] * fl1_fx - 0.5 * pc_xyy[j] * pb_y[j] * fl1_fx - 1.5 * pc_yzz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yz[j] * fl1_fx * pb_xz[j] - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pc_xzz[j] * pb_y[j] - 0.5 * fl1_fx * pb_xy[j] * pc_zz[j] - fl1_fx * pc_xz[j] * pb_yz[j] - pa_yy[j] * pb_x[j] * pc_yzz[j] - pa_yy[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_yy[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xy[j] - 4.0 * pa_y[j] * pc_yyz[j] * pb_xz[j] - 4.0 * pa_y[j] * pc_xyz[j] * pb_yz[j] - 2.0 * pa_y[j] * pc_xyy[j] * pb_zz[j] - 2.0 * pc_yyz[j] * pb_xyz[j] - pc_yyy[j] * pb_xzz[j] - pc_xyy[j] * pb_yzz[j]);

                t_yy_xyzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + pa_y[j] * pc_xyy[j] * fl1_fx + pa_y[j] * fl1_fx * pc_xzz[j] + 0.5 * pc_yyy[j] * pb_x[j] * fl1_fx + 0.5 * pc_xyy[j] * pb_y[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_yzz[j] * fl1_fx * pb_x[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_xzz[j] * pb_y[j] + pa_yy[j] * pc_xyzz[j] + 2.0 * pa_y[j] * pc_yyzz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xyzz[j] * pb_y[j] + 4.0 * pa_y[j] * pc_xyyz[j] * pb_z[j] + pc_yyzz[j] * pb_xy[j] + 2.0 * pc_yyyz[j] * pb_xz[j] + 2.0 * pc_xyyz[j] * pb_yz[j] + pc_xyyy[j] * pb_zz[j]);

                t_yy_xyzz[j] += fl_s_0_0_5 * (-0.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - 2.0 * pa_y[j] * pc_xyyzz[j] - pc_yyyzz[j] * pb_x[j] - pc_xyyzz[j] * pb_y[j] - 2.0 * pc_xyyyz[j] * pb_z[j]);

                t_yy_xyzz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_54_55(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (54,55)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xzzz = pbDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_xzzz = primBuffer.data(90 * idx + 54);

            // Batch of Integrals (54,55)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_x, pb_xz, pb_xzz, pb_xzzz, pb_z, pb_zz, pb_zzz, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_xzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_xzzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_yy[j] * pb_xz[j] * fl1_fx + 0.5 * fl1_fx * pb_xzzz[j] + pa_yy[j] * pb_xzzz[j]);

                t_yy_xzzz[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_xz[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_yy[j] * pb_xz[j] * fl1_fx - 1.5 * pa_yy[j] * pb_x[j] * pc_z[j] * fl1_fx - 1.5 * pa_yy[j] * pc_x[j] * pb_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * pb_xz[j] * fl1_fx - 1.5 * fl1_fx * pb_xzz[j] * pc_z[j] - 0.5 * fl1_fx * pc_x[j] * pb_zzz[j] - 0.5 * fl1_fx * pb_xzzz[j] - 3.0 * pa_yy[j] * pb_xzz[j] * pc_z[j] - pa_yy[j] * pc_x[j] * pb_zzz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_xzzz[j]);

                t_yy_xzzz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pb_x[j] * pc_z[j] + 1.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.75 * fl2_fx * pc_xz[j] + 0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_yy[j] * pb_x[j] * pc_z[j] * fl1_fx + 1.5 * pa_yy[j] * pc_x[j] * pb_z[j] * fl1_fx + 1.5 * pa_yy[j] * pc_xz[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_xz[j] * fl1_fx + 3.0 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_y[j] * pc_xy[j] * pb_z[j] * fl1_fx + 1.5 * pc_yy[j] * pb_xz[j] * fl1_fx + 1.5 * fl1_fx * pb_xz[j] * pc_zz[j] + 1.5 * fl1_fx * pc_xz[j] * pb_zz[j] + 1.5 * fl1_fx * pb_xzz[j] * pc_z[j] + 0.5 * fl1_fx * pc_x[j] * pb_zzz[j] + 3.0 * pa_yy[j] * pb_xz[j] * pc_zz[j] + 3.0 * pa_yy[j] * pc_xz[j] * pb_zz[j] + 6.0 * pa_y[j] * pc_yz[j] * pb_xzz[j] + 2.0 * pa_y[j] * pc_xy[j] * pb_zzz[j] + pc_yy[j] * pb_xzzz[j]);

                t_yy_xzzz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_yy[j] * pc_xz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_xy[j] * pb_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx - 1.5 * pc_yy[j] * pb_xz[j] * fl1_fx - 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyy[j] * pb_z[j] * fl1_fx - 0.5 * fl1_fx * pb_x[j] * pc_zzz[j] - 1.5 * fl1_fx * pc_xzz[j] * pb_z[j] - 1.5 * fl1_fx * pb_xz[j] * pc_zz[j] - 1.5 * fl1_fx * pc_xz[j] * pb_zz[j] - pa_yy[j] * pb_x[j] * pc_zzz[j] - 3.0 * pa_yy[j] * pc_xzz[j] * pb_z[j] - 6.0 * pa_y[j] * pc_yzz[j] * pb_xz[j] - 6.0 * pa_y[j] * pc_xyz[j] * pb_zz[j] - 3.0 * pc_yyz[j] * pb_xzz[j] - pc_xyy[j] * pb_zzz[j]);

                t_yy_xzzz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyy[j] * pb_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 0.5 * fl1_fx * pc_xzzz[j] + 0.5 * fl1_fx * pb_x[j] * pc_zzz[j] + 1.5 * fl1_fx * pc_xzz[j] * pb_z[j] + pa_yy[j] * pc_xzzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] * pb_x[j] + 6.0 * pa_y[j] * pc_xyzz[j] * pb_z[j] + 3.0 * pc_yyzz[j] * pb_xz[j] + 3.0 * pc_xyyz[j] * pb_zz[j]);

                t_yy_xzzz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * fl1_fx * pc_xzzz[j] - 2.0 * pa_y[j] * pc_xyzzz[j] - pc_yyzzz[j] * pb_x[j] - 3.0 * pc_xyyzz[j] * pb_z[j]);

                t_yy_xzzz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_55_56(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (55,56)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyy = pbDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyyy = pcDistances.data(83 * idx + 76);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_yyyy = primBuffer.data(90 * idx + 55);

            // Batch of Integrals (55,56)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_y, pb_yy, pb_yyy, pb_yyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyy, pc_yyyyyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yy_yyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yy_yyyy[j] = fl_s_0_0_0 * (1.875 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 6.0 * pa_y[j] * fl2_fx * pb_y[j] + 4.5 * fl2_fx * pb_yy[j] + 3.0 * pa_yy[j] * pb_yy[j] * fl1_fx + 4.0 * pa_y[j] * fl1_fx * pb_yyy[j] + 0.5 * fl1_fx * pb_yyyy[j] + pa_yy[j] * pb_yyyy[j]);

                t_yy_yyyy[j] += fl_s_0_0_1 * (-5.625 * fl3_fx - 1.5 * pa_yy[j] * fl2_fx - 7.5 * pa_y[j] * pc_y[j] * fl2_fx - 12.0 * pa_y[j] * fl2_fx * pb_y[j] - 15.0 * pc_y[j] * fl2_fx * pb_y[j] - 9.0 * fl2_fx * pb_yy[j] - 3.0 * pa_yy[j] * pb_yy[j] * fl1_fx - 6.0 * pa_yy[j] * pb_y[j] * pc_y[j] * fl1_fx - 18.0 * pa_y[j] * pc_y[j] * pb_yy[j] * fl1_fx - 4.0 * pa_y[j] * fl1_fx * pb_yyy[j] - 6.0 * pc_y[j] * fl1_fx * pb_yyy[j] - 0.5 * fl1_fx * pb_yyyy[j] - 4.0 * pa_yy[j] * pb_yyy[j] * pc_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yyyy[j]);

                t_yy_yyyy[j] += fl_s_0_0_2 * (5.625 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 15.0 * pa_y[j] * pc_y[j] * fl2_fx + 6.0 * pa_y[j] * fl2_fx * pb_y[j] + 11.25 * pc_yy[j] * fl2_fx + 30.0 * pc_y[j] * fl2_fx * pb_y[j] + 4.5 * fl2_fx * pb_yy[j] + 6.0 * pa_yy[j] * pb_y[j] * pc_y[j] * fl1_fx + 3.0 * pa_yy[j] * pc_yy[j] * fl1_fx + 18.0 * pa_y[j] * pc_y[j] * pb_yy[j] * fl1_fx + 24.0 * pa_y[j] * pc_yy[j] * pb_y[j] * fl1_fx + 18.0 * pc_yy[j] * pb_yy[j] * fl1_fx + 6.0 * pc_y[j] * fl1_fx * pb_yyy[j] + 6.0 * pa_yy[j] * pb_yy[j] * pc_yy[j] + 8.0 * pa_y[j] * pc_yy[j] * pb_yyy[j] + pc_yy[j] * pb_yyyy[j]);

                t_yy_yyyy[j] += fl_s_0_0_3 * (-1.875 * fl3_fx - 7.5 * pa_y[j] * pc_y[j] * fl2_fx - 22.5 * pc_yy[j] * fl2_fx - 15.0 * pc_y[j] * fl2_fx * pb_y[j] - 3.0 * pa_yy[j] * pc_yy[j] * fl1_fx - 24.0 * pa_y[j] * pc_yy[j] * pb_y[j] * fl1_fx - 10.0 * pa_y[j] * pc_yyy[j] * fl1_fx - 18.0 * pc_yy[j] * pb_yy[j] * fl1_fx - 20.0 * pc_yyy[j] * pb_y[j] * fl1_fx - 4.0 * pa_yy[j] * pb_y[j] * pc_yyy[j] - 12.0 * pa_y[j] * pc_yyy[j] * pb_yy[j] - 4.0 * pc_yyy[j] * pb_yyy[j]);

                t_yy_yyyy[j] += fl_s_0_0_4 * (11.25 * pc_yy[j] * fl2_fx + 10.0 * pa_y[j] * pc_yyy[j] * fl1_fx + 20.0 * pc_yyy[j] * pb_y[j] * fl1_fx + 7.5 * pc_yyyy[j] * fl1_fx + pa_yy[j] * pc_yyyy[j] + 8.0 * pa_y[j] * pc_yyyy[j] * pb_y[j] + 6.0 * pc_yyyy[j] * pb_yy[j]);

                t_yy_yyyy[j] += fl_s_0_0_5 * (-7.5 * pc_yyyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyyyy[j] - 4.0 * pc_yyyyy[j] * pb_y[j]);

                t_yy_yyyy[j] += fl_s_0_0_6 * pc_yyyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_56_57(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (56,57)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyz = pbDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyyz = pcDistances.data(83 * idx + 77);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_yyyz = primBuffer.data(90 * idx + 56);

            // Batch of Integrals (56,57)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_y, pb_yy, pb_yyy, pb_yyyz, pb_yyz, pb_yz, pb_z, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyy, pc_yyyyy, pc_yyyyyz, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_yyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_yyyz[j] = fl_s_0_0_0 * (1.5 * pa_y[j] * fl2_fx * pb_z[j] + 2.25 * fl2_fx * pb_yz[j] + 1.5 * pa_yy[j] * pb_yz[j] * fl1_fx + 3.0 * pa_y[j] * fl1_fx * pb_yyz[j] + 0.5 * fl1_fx * pb_yyyz[j] + pa_yy[j] * pb_yyyz[j]);

                t_yy_yyyz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx * pc_z[j] - 3.0 * pa_y[j] * fl2_fx * pb_z[j] - 3.75 * pc_y[j] * fl2_fx * pb_z[j] - 2.25 * fl2_fx * pb_y[j] * pc_z[j] - 4.5 * fl2_fx * pb_yz[j] - 1.5 * pa_yy[j] * pb_y[j] * fl1_fx * pc_z[j] - 1.5 * pa_yy[j] * pb_yz[j] * fl1_fx - 1.5 * pa_yy[j] * pc_y[j] * fl1_fx * pb_z[j] - 9.0 * pa_y[j] * pc_y[j] * pb_yz[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pb_yy[j] * pc_z[j] - 3.0 * pa_y[j] * fl1_fx * pb_yyz[j] - 4.5 * pc_y[j] * fl1_fx * pb_yyz[j] - 0.5 * fl1_fx * pb_yyy[j] * pc_z[j] - 0.5 * fl1_fx * pb_yyyz[j] - pa_yy[j] * pb_yyy[j] * pc_z[j] - 3.0 * pa_yy[j] * pb_yyz[j] * pc_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yyyz[j]);

                t_yy_yyyz[j] += fl_s_0_0_2 * (3.0 * pa_y[j] * fl2_fx * pc_z[j] + 1.5 * pa_y[j] * fl2_fx * pb_z[j] + 3.75 * pc_yz[j] * fl2_fx + 7.5 * pc_y[j] * fl2_fx * pb_z[j] + 4.5 * fl2_fx * pb_y[j] * pc_z[j] + 2.25 * fl2_fx * pb_yz[j] + 1.5 * pa_yy[j] * pb_y[j] * fl1_fx * pc_z[j] + 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx + 1.5 * pa_yy[j] * pc_y[j] * fl1_fx * pb_z[j] + 9.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx + 9.0 * pa_y[j] * pc_y[j] * pb_yz[j] * fl1_fx + 6.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] + 3.0 * pa_y[j] * fl1_fx * pb_yy[j] * pc_z[j] + 9.0 * pc_yy[j] * pb_yz[j] * fl1_fx + 4.5 * pc_yz[j] * fl1_fx * pb_yy[j] + 4.5 * pc_y[j] * fl1_fx * pb_yyz[j] + 0.5 * fl1_fx * pb_yyy[j] * pc_z[j] + 3.0 * pa_yy[j] * pb_yy[j] * pc_yz[j] + 3.0 * pa_yy[j] * pb_yz[j] * pc_yy[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_yyy[j] + 6.0 * pa_y[j] * pc_yy[j] * pb_yyz[j] + pc_yy[j] * pb_yyyz[j]);

                t_yy_yyyz[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * fl2_fx * pc_z[j] - 7.5 * pc_yz[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx * pb_z[j] - 2.25 * fl2_fx * pb_y[j] * pc_z[j] - 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx - 9.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx - 6.0 * pa_y[j] * pc_yyz[j] * fl1_fx - 6.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] - 9.0 * pc_yyz[j] * pb_y[j] * fl1_fx - 9.0 * pc_yy[j] * pb_yz[j] * fl1_fx - 5.0 * pc_yyy[j] * fl1_fx * pb_z[j] - 4.5 * pc_yz[j] * fl1_fx * pb_yy[j] - 3.0 * pa_yy[j] * pb_y[j] * pc_yyz[j] - pa_yy[j] * pc_yyy[j] * pb_z[j] - 6.0 * pa_y[j] * pc_yyz[j] * pb_yy[j] - 6.0 * pa_y[j] * pc_yyy[j] * pb_yz[j] - pc_yyz[j] * pb_yyy[j] - 3.0 * pc_yyy[j] * pb_yyz[j]);

                t_yy_yyyz[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 6.0 * pa_y[j] * pc_yyz[j] * fl1_fx + 9.0 * pc_yyz[j] * pb_y[j] * fl1_fx + 5.0 * pc_yyyz[j] * fl1_fx + 5.0 * pc_yyy[j] * fl1_fx * pb_z[j] + pa_yy[j] * pc_yyyz[j] + 6.0 * pa_y[j] * pc_yyyz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yyyy[j] * pb_z[j] + 3.0 * pc_yyyz[j] * pb_yy[j] + 3.0 * pc_yyyy[j] * pb_yz[j]);

                t_yy_yyyz[j] += fl_s_0_0_5 * (-5.0 * pc_yyyz[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyyyz[j] - 3.0 * pc_yyyyz[j] * pb_y[j] - pc_yyyyy[j] * pb_z[j]);

                t_yy_yyyz[j] += fl_s_0_0_6 * pc_yyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_57_58(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (57,58)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyzz = pbDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyzz = pcDistances.data(83 * idx + 78);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_yyzz = primBuffer.data(90 * idx + 57);

            // Batch of Integrals (57,58)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_y, pb_yy, pb_yyz, pb_yyzz, pb_yz, pb_yzz, pb_z, pb_zz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyyzz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yy_yyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yy_yyzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + pa_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pb_zz[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_yy[j] * pb_yy[j] * fl1_fx + 0.5 * pa_yy[j] * fl1_fx * pb_zz[j] + 2.0 * pa_y[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pb_yyzz[j] + pa_yy[j] * pb_yyzz[j]);

                t_yy_yyzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 0.5 * pa_yy[j] * fl2_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 2.0 * pa_y[j] * fl2_fx * pb_y[j] - 1.5 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 1.5 * fl2_fx * pb_zz[j] - 0.5 * fl2_fx * pb_yy[j] - 0.5 * pa_yy[j] * pb_yy[j] * fl1_fx - pa_yy[j] * pb_y[j] * pc_y[j] * fl1_fx - pa_yy[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_zz[j] - pa_y[j] * pc_y[j] * pb_yy[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] - 4.0 * pa_y[j] * fl1_fx * pb_yz[j] * pc_z[j] - 2.0 * pa_y[j] * fl1_fx * pb_yzz[j] - 3.0 * pc_y[j] * fl1_fx * pb_yzz[j] - fl1_fx * pb_yyz[j] * pc_z[j] - 0.5 * fl1_fx * pb_yyzz[j] - 2.0 * pa_yy[j] * pb_yyz[j] * pc_z[j] - 2.0 * pa_yy[j] * pb_yzz[j] * pc_y[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yyzz[j]);

                t_yy_yyzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl2_fx + pa_y[j] * fl2_fx * pb_y[j] + 1.5 * pc_yy[j] * fl2_fx + 3.0 * pc_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pb_z[j] * pc_z[j] + 0.75 * fl2_fx * pb_zz[j] + 0.25 * fl2_fx * pb_yy[j] + pa_yy[j] * pb_y[j] * pc_y[j] * fl1_fx + 0.5 * pa_yy[j] * pc_yy[j] * fl1_fx + 0.5 * pa_yy[j] * fl1_fx * pc_zz[j] + pa_yy[j] * fl1_fx * pb_z[j] * pc_z[j] + pa_y[j] * pc_y[j] * pb_yy[j] * fl1_fx + 2.0 * pa_y[j] * pc_yy[j] * pb_y[j] * fl1_fx + 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 3.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] + 2.0 * pa_y[j] * fl1_fx * pb_y[j] * pc_zz[j] + 4.0 * pa_y[j] * fl1_fx * pb_yz[j] * pc_z[j] + 0.5 * pc_yy[j] * pb_yy[j] * fl1_fx + 3.0 * pc_yy[j] * fl1_fx * pb_zz[j] + 6.0 * pc_yz[j] * fl1_fx * pb_yz[j] + 3.0 * pc_y[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pb_yy[j] * pc_zz[j] + fl1_fx * pb_yyz[j] * pc_z[j] + pa_yy[j] * pb_yy[j] * pc_zz[j] + 4.0 * pa_yy[j] * pb_yz[j] * pc_yz[j] + pa_yy[j] * pc_yy[j] * pb_zz[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_yyz[j] + 4.0 * pa_y[j] * pc_yy[j] * pb_yzz[j] + pc_yy[j] * pb_yyzz[j]);

                t_yy_yyzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * pc_yy[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * pa_yy[j] * pc_yy[j] * fl1_fx - 0.5 * pa_yy[j] * fl1_fx * pc_zz[j] - 2.0 * pa_y[j] * pc_yy[j] * pb_y[j] * fl1_fx - pa_y[j] * pc_yyy[j] * fl1_fx - 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 2.0 * pa_y[j] * fl1_fx * pb_y[j] * pc_zz[j] - 0.5 * pc_yy[j] * pb_yy[j] * fl1_fx - pc_yyy[j] * pb_y[j] * fl1_fx - 6.0 * pc_yyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yy[j] * fl1_fx * pb_zz[j] - 3.0 * pc_yzz[j] * fl1_fx * pb_y[j] - 6.0 * pc_yz[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pb_yy[j] * pc_zz[j] - 2.0 * pa_yy[j] * pb_y[j] * pc_yzz[j] - 2.0 * pa_yy[j] * pc_yyz[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_yy[j] - 8.0 * pa_y[j] * pc_yyz[j] * pb_yz[j] - 2.0 * pa_y[j] * pc_yyy[j] * pb_zz[j] - 2.0 * pc_yyz[j] * pb_yyz[j] - 2.0 * pc_yyy[j] * pb_yzz[j]);

                t_yy_yyzz[j] += fl_s_0_0_4 * (1.5 * pc_yy[j] * fl2_fx + 0.75 * fl2_fx * pc_zz[j] + pa_y[j] * pc_yyy[j] * fl1_fx + 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx + pc_yyy[j] * pb_y[j] * fl1_fx + 0.5 * pc_yyyy[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 6.0 * pc_yyz[j] * fl1_fx * pb_z[j] + 3.0 * pc_yzz[j] * fl1_fx * pb_y[j] + pa_yy[j] * pc_yyzz[j] + 4.0 * pa_y[j] * pc_yyzz[j] * pb_y[j] + 4.0 * pa_y[j] * pc_yyyz[j] * pb_z[j] + pc_yyzz[j] * pb_yy[j] + 4.0 * pc_yyyz[j] * pb_yz[j] + pc_yyyy[j] * pb_zz[j]);

                t_yy_yyzz[j] += fl_s_0_0_5 * (-0.5 * pc_yyyy[j] * fl1_fx - 3.0 * pc_yyzz[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyyzz[j] - 2.0 * pc_yyyzz[j] * pb_y[j] - 2.0 * pc_yyyyz[j] * pb_z[j]);

                t_yy_yyzz[j] += fl_s_0_0_6 * pc_yyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_58_59(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (58,59)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yzzz = pbDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyzzz = pcDistances.data(83 * idx + 79);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_yzzz = primBuffer.data(90 * idx + 58);

            // Batch of Integrals (58,59)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_y, pb_yz, pb_yzz, pb_yzzz, pb_z, pb_zz, pb_zzz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyyzz, pc_yyyzzz, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yy_yzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yy_yzzz[j] = fl_s_0_0_0 * (1.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_yy[j] * pb_yz[j] * fl1_fx + pa_y[j] * fl1_fx * pb_zzz[j] + 0.5 * fl1_fx * pb_yzzz[j] + pa_yy[j] * pb_yzzz[j]);

                t_yy_yzzz[j] += fl_s_0_0_1 * (-3.0 * pa_y[j] * fl2_fx * pb_z[j] - 1.5 * pa_y[j] * fl2_fx * pc_z[j] - 2.25 * pc_y[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pb_yz[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 1.5 * pa_yy[j] * pb_yz[j] * fl1_fx - 1.5 * pa_yy[j] * pb_y[j] * pc_z[j] * fl1_fx - 1.5 * pa_yy[j] * pc_y[j] * pb_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_y[j] * pb_yz[j] * fl1_fx - 3.0 * pa_y[j] * fl1_fx * pb_zz[j] * pc_z[j] - pa_y[j] * fl1_fx * pb_zzz[j] - 1.5 * pc_y[j] * fl1_fx * pb_zzz[j] - 1.5 * fl1_fx * pb_yzz[j] * pc_z[j] - 0.5 * fl1_fx * pb_yzzz[j] - 3.0 * pa_yy[j] * pb_yzz[j] * pc_z[j] - pa_yy[j] * pc_y[j] * pb_zzz[j] - 2.0 * pa_y[j] * pc_y[j] * pb_yzzz[j]);

                t_yy_yzzz[j] += fl_s_0_0_2 * (3.0 * pa_y[j] * fl2_fx * pc_z[j] + 1.5 * pa_y[j] * fl2_fx * pb_z[j] + 4.5 * pc_y[j] * fl2_fx * pb_z[j] + 2.25 * pc_yz[j] * fl2_fx + 1.5 * fl2_fx * pb_y[j] * pc_z[j] + 0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_yy[j] * pb_y[j] * pc_z[j] * fl1_fx + 1.5 * pa_yy[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx + 3.0 * pa_y[j] * pc_y[j] * pb_yz[j] * fl1_fx + 3.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx + 3.0 * pa_y[j] * pc_yy[j] * pb_z[j] * fl1_fx + 3.0 * pa_y[j] * fl1_fx * pb_z[j] * pc_zz[j] + 3.0 * pa_y[j] * fl1_fx * pb_zz[j] * pc_z[j] + 1.5 * pc_yy[j] * pb_yz[j] * fl1_fx + 4.5 * pc_yz[j] * fl1_fx * pb_zz[j] + 1.5 * pc_y[j] * fl1_fx * pb_zzz[j] + 1.5 * fl1_fx * pb_yz[j] * pc_zz[j] + 1.5 * fl1_fx * pb_yzz[j] * pc_z[j] + 3.0 * pa_yy[j] * pb_yz[j] * pc_zz[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_zz[j] + 6.0 * pa_y[j] * pc_yz[j] * pb_yzz[j] + 2.0 * pa_y[j] * pc_yy[j] * pb_zzz[j] + pc_yy[j] * pb_yzzz[j]);

                t_yy_yzzz[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * fl2_fx * pc_z[j] - 4.5 * pc_yz[j] * fl2_fx - 2.25 * pc_y[j] * fl2_fx * pb_z[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx - 3.0 * pa_y[j] * pc_yy[j] * pb_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_yyz[j] * fl1_fx - pa_y[j] * fl1_fx * pc_zzz[j] - 3.0 * pa_y[j] * fl1_fx * pb_z[j] * pc_zz[j] - 1.5 * pc_yy[j] * pb_yz[j] * fl1_fx - 1.5 * pc_yyz[j] * pb_y[j] * fl1_fx - 1.5 * pc_yyy[j] * pb_z[j] * fl1_fx - 4.5 * pc_yzz[j] * fl1_fx * pb_z[j] - 4.5 * pc_yz[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pb_y[j] * pc_zzz[j] - 1.5 * fl1_fx * pb_yz[j] * pc_zz[j] - pa_yy[j] * pb_y[j] * pc_zzz[j] - 3.0 * pa_yy[j] * pc_yzz[j] * pb_z[j] - 6.0 * pa_y[j] * pc_yzz[j] * pb_yz[j] - 6.0 * pa_y[j] * pc_yyz[j] * pb_zz[j] - 3.0 * pc_yyz[j] * pb_yzz[j] - pc_yyy[j] * pb_zzz[j]);

                t_yy_yzzz[j] += fl_s_0_0_4 * (2.25 * pc_yz[j] * fl2_fx + 3.0 * pa_y[j] * pc_yyz[j] * fl1_fx + pa_y[j] * fl1_fx * pc_zzz[j] + 1.5 * pc_yyz[j] * pb_y[j] * fl1_fx + 1.5 * pc_yyy[j] * pb_z[j] * fl1_fx + 1.5 * pc_yyyz[j] * fl1_fx + 1.5 * pc_yzzz[j] * fl1_fx + 4.5 * pc_yzz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pb_y[j] * pc_zzz[j] + pa_yy[j] * pc_yzzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] * pb_y[j] + 6.0 * pa_y[j] * pc_yyzz[j] * pb_z[j] + 3.0 * pc_yyzz[j] * pb_yz[j] + 3.0 * pc_yyyz[j] * pb_zz[j]);

                t_yy_yzzz[j] += fl_s_0_0_5 * (-1.5 * pc_yyyz[j] * fl1_fx - 1.5 * pc_yzzz[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyzzz[j] - pc_yyzzz[j] * pb_y[j] - 3.0 * pc_yyyzz[j] * pb_z[j]);

                t_yy_yzzz[j] += fl_s_0_0_6 * pc_yyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_59_60(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (59,60)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_zzzz = pbDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyzzzz = pcDistances.data(83 * idx + 80);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yy_zzzz = primBuffer.data(90 * idx + 59);

            // Batch of Integrals (59,60)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pb_z, pb_zz, pb_zzz, pb_zzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, \
                                     pc_yyzzz, pc_yyzzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yy_zzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yy_zzzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 1.5 * fl2_fx * pb_zz[j] + 3.0 * pa_yy[j] * pb_zz[j] * fl1_fx + 0.5 * fl1_fx * pb_zzzz[j] + pa_yy[j] * pb_zzzz[j]);

                t_yy_zzzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_yy[j] * fl2_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * fl2_fx * pb_zz[j] - 3.0 * fl2_fx * pb_z[j] * pc_z[j] - 3.0 * pa_yy[j] * pb_zz[j] * fl1_fx - 6.0 * pa_yy[j] * pb_z[j] * pc_z[j] * fl1_fx - 6.0 * pa_y[j] * pc_y[j] * pb_zz[j] * fl1_fx - 2.0 * fl1_fx * pb_zzz[j] * pc_z[j] - 0.5 * fl1_fx * pb_zzzz[j] - 4.0 * pa_yy[j] * pb_zzz[j] * pc_z[j] - 2.0 * pa_y[j] * pc_y[j] * pb_zzzz[j]);

                t_yy_zzzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl2_fx + 0.75 * pc_yy[j] * fl2_fx + 6.0 * fl2_fx * pb_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_zz[j] + 1.5 * fl2_fx * pb_zz[j] + 6.0 * pa_yy[j] * pb_z[j] * pc_z[j] * fl1_fx + 3.0 * pa_yy[j] * pc_zz[j] * fl1_fx + 6.0 * pa_y[j] * pc_y[j] * pb_zz[j] * fl1_fx + 12.0 * pa_y[j] * pc_yz[j] * pb_z[j] * fl1_fx + 3.0 * pc_yy[j] * pb_zz[j] * fl1_fx + 3.0 * fl1_fx * pb_zz[j] * pc_zz[j] + 2.0 * fl1_fx * pb_zzz[j] * pc_z[j] + 6.0 * pa_yy[j] * pb_zz[j] * pc_zz[j] + 8.0 * pa_y[j] * pc_yz[j] * pb_zzz[j] + pc_yy[j] * pb_zzzz[j]);

                t_yy_zzzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 1.5 * pc_yy[j] * fl2_fx - 3.0 * fl2_fx * pc_zz[j] - 3.0 * fl2_fx * pb_z[j] * pc_z[j] - 3.0 * pa_yy[j] * pc_zz[j] * fl1_fx - 12.0 * pa_y[j] * pc_yz[j] * pb_z[j] * fl1_fx - 6.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 3.0 * pc_yy[j] * pb_zz[j] * fl1_fx - 6.0 * pc_yyz[j] * pb_z[j] * fl1_fx - 2.0 * fl1_fx * pb_z[j] * pc_zzz[j] - 3.0 * fl1_fx * pb_zz[j] * pc_zz[j] - 4.0 * pa_yy[j] * pb_z[j] * pc_zzz[j] - 12.0 * pa_y[j] * pc_yzz[j] * pb_zz[j] - 4.0 * pc_yyz[j] * pb_zzz[j]);

                t_yy_zzzz[j] += fl_s_0_0_4 * (0.75 * pc_yy[j] * fl2_fx + 1.5 * fl2_fx * pc_zz[j] + 6.0 * pa_y[j] * pc_yzz[j] * fl1_fx + 6.0 * pc_yyz[j] * pb_z[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzzz[j] + 2.0 * fl1_fx * pb_z[j] * pc_zzz[j] + pa_yy[j] * pc_zzzz[j] + 8.0 * pa_y[j] * pc_yzzz[j] * pb_z[j] + 6.0 * pc_yyzz[j] * pb_zz[j]);

                t_yy_zzzz[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - 2.0 * pa_y[j] * pc_yzzzz[j] - 4.0 * pc_yyzzz[j] * pb_z[j]);

                t_yy_zzzz[j] += fl_s_0_0_6 * pc_yyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_60_61(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (60,61)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxx = pbDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xxxx = primBuffer.data(90 * idx + 60);

            // Batch of Integrals (60,61)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxxx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyz, pc_xxz, \
                                     pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_yz_xxxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xxxx[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 3.0 * pa_yz[j] * pb_xx[j] * fl1_fx + pa_yz[j] * pb_xxxx[j]);

                t_yz_xxxx[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 3.0 * pa_yz[j] * pb_xx[j] * fl1_fx - 6.0 * pa_yz[j] * pb_x[j] * pc_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_z[j] * pb_xx[j] * fl1_fx - 3.0 * pc_y[j] * pa_z[j] * pb_xx[j] * fl1_fx - 4.0 * pa_yz[j] * pb_xxx[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxxx[j] - pc_y[j] * pa_z[j] * pb_xxxx[j]);

                t_yz_xxxx[j] += fl_s_0_0_2 * (0.75 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_z[j] * fl2_fx + 1.5 * pc_y[j] * pa_z[j] * fl2_fx + 0.75 * pc_yz[j] * fl2_fx + 6.0 * pa_yz[j] * pb_x[j] * pc_x[j] * fl1_fx + 3.0 * pa_yz[j] * pc_xx[j] * fl1_fx + 3.0 * pa_y[j] * pc_z[j] * pb_xx[j] * fl1_fx + 6.0 * pa_y[j] * pc_xz[j] * pb_x[j] * fl1_fx + 3.0 * pc_y[j] * pa_z[j] * pb_xx[j] * fl1_fx + 6.0 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx + 3.0 * pc_yz[j] * pb_xx[j] * fl1_fx + 6.0 * pa_yz[j] * pb_xx[j] * pc_xx[j] + 4.0 * pa_y[j] * pc_xz[j] * pb_xxx[j] + 4.0 * pc_xy[j] * pa_z[j] * pb_xxx[j] + pc_yz[j] * pb_xxxx[j]);

                t_yz_xxxx[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 1.5 * pc_yz[j] * fl2_fx - 3.0 * pa_yz[j] * pc_xx[j] * fl1_fx - 6.0 * pa_y[j] * pc_xz[j] * pb_x[j] * fl1_fx - 3.0 * pa_y[j] * pc_xxz[j] * fl1_fx - 6.0 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx - 3.0 * pc_xxy[j] * pa_z[j] * fl1_fx - 3.0 * pc_yz[j] * pb_xx[j] * fl1_fx - 6.0 * pc_xyz[j] * pb_x[j] * fl1_fx - 4.0 * pa_yz[j] * pb_x[j] * pc_xxx[j] - 6.0 * pa_y[j] * pc_xxz[j] * pb_xx[j] - 6.0 * pc_xxy[j] * pa_z[j] * pb_xx[j] - 4.0 * pc_xyz[j] * pb_xxx[j]);

                t_yz_xxxx[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + 3.0 * pa_y[j] * pc_xxz[j] * fl1_fx + 3.0 * pc_xxy[j] * pa_z[j] * fl1_fx + 6.0 * pc_xyz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + pa_yz[j] * pc_xxxx[j] + 4.0 * pa_y[j] * pc_xxxz[j] * pb_x[j] + 4.0 * pc_xxxy[j] * pa_z[j] * pb_x[j] + 6.0 * pc_xxyz[j] * pb_xx[j]);

                t_yz_xxxx[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - pa_y[j] * pc_xxxxz[j] - pc_xxxxy[j] * pa_z[j] - 4.0 * pc_xxxyz[j] * pb_x[j]);

                t_yz_xxxx[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_61_62(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (61,62)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxy = pbDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xxxy = primBuffer.data(90 * idx + 61);

            // Batch of Integrals (61,62)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxxy, pb_xxy, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, \
                                     pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyz, \
                                     pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yz_xxxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xxxy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_yz[j] * pb_xy[j] * fl1_fx + 0.5 * fl1_fx * pa_z[j] * pb_xxx[j] + pa_yz[j] * pb_xxxy[j]);

                t_yz_xxxy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_z[j] * pb_x[j] - 0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yz[j] * pb_x[j] * fl1_fx * pc_y[j] - 1.5 * pa_yz[j] * pb_xy[j] * fl1_fx - 1.5 * pa_yz[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_y[j] * pc_z[j] * pb_xy[j] * fl1_fx - 1.5 * pc_y[j] * pa_z[j] * pb_xy[j] * fl1_fx - 1.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_x[j] - 0.5 * fl1_fx * pc_z[j] * pb_xxx[j] - 0.5 * fl1_fx * pa_z[j] * pb_xxx[j] - pa_yz[j] * pb_xxx[j] * pc_y[j] - 3.0 * pa_yz[j] * pb_xxy[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxxy[j] - pc_y[j] * pa_z[j] * pb_xxxy[j]);

                t_yz_xxxy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_z[j] * pc_x[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.75 * fl2_fx * pc_xz[j] + 0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_yz[j] * pb_x[j] * fl1_fx * pc_y[j] + 1.5 * pa_yz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_yz[j] * pc_x[j] * fl1_fx * pb_y[j] + 1.5 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_xy[j] * fl1_fx + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_yy[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * pb_xy[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_yz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_xx[j] + 1.5 * fl1_fx * pc_xz[j] * pb_xx[j] + 1.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_x[j] + 0.5 * fl1_fx * pc_z[j] * pb_xxx[j] + 3.0 * pa_yz[j] * pb_xx[j] * pc_xy[j] + 3.0 * pa_yz[j] * pb_xy[j] * pc_xx[j] + pa_y[j] * pc_yz[j] * pb_xxx[j] + 3.0 * pa_y[j] * pc_xz[j] * pb_xxy[j] + pc_yy[j] * pa_z[j] * pb_xxx[j] + 3.0 * pc_xy[j] * pa_z[j] * pb_xxy[j] + pc_yz[j] * pb_xxxy[j]);

                t_yz_xxxy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yy[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_yz[j] * pb_xy[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pa_z[j] * pc_xxx[j] - 1.5 * fl1_fx * pc_xxz[j] * pb_x[j] - 1.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_xx[j] - 1.5 * fl1_fx * pc_xz[j] * pb_xx[j] - 3.0 * pa_yz[j] * pb_x[j] * pc_xxy[j] - pa_yz[j] * pc_xxx[j] * pb_y[j] - 3.0 * pa_y[j] * pc_xyz[j] * pb_xx[j] - 3.0 * pa_y[j] * pc_xxz[j] * pb_xy[j] - 3.0 * pc_xyy[j] * pa_z[j] * pb_xx[j] - 3.0 * pc_xxy[j] * pa_z[j] * pb_xy[j] - pc_yyz[j] * pb_xxx[j] - 3.0 * pc_xyz[j] * pb_xxy[j]);

                t_yz_xxxy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xxxz[j] + 0.5 * fl1_fx * pa_z[j] * pc_xxx[j] + 1.5 * fl1_fx * pc_xxz[j] * pb_x[j] + pa_yz[j] * pc_xxxy[j] + 3.0 * pa_y[j] * pc_xxyz[j] * pb_x[j] + pa_y[j] * pc_xxxz[j] * pb_y[j] + 3.0 * pc_xxyy[j] * pa_z[j] * pb_x[j] + pc_xxxy[j] * pa_z[j] * pb_y[j] + 3.0 * pc_xyyz[j] * pb_xx[j] + 3.0 * pc_xxyz[j] * pb_xy[j]);

                t_yz_xxxy[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxxz[j] - pa_y[j] * pc_xxxyz[j] - pc_xxxyy[j] * pa_z[j] - 3.0 * pc_xxyyz[j] * pb_x[j] - pc_xxxyz[j] * pb_y[j]);

                t_yz_xxxy[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_62_63(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (62,63)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxz = pbDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xxxz = primBuffer.data(90 * idx + 62);

            // Batch of Integrals (62,63)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxx, pb_xxxz, pb_xxz, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, pc_xxy, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yz, pc_yzz, \
                                     pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yz_xxxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xxxz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pa_yz[j] * pb_xz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pb_xxx[j] + pa_yz[j] * pb_xxxz[j]);

                t_yz_xxxz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx * pb_x[j] - 0.75 * pa_y[j] * fl2_fx * pc_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_yz[j] * pb_x[j] * fl1_fx * pc_z[j] - 1.5 * pa_yz[j] * pb_xz[j] * fl1_fx - 1.5 * pa_yz[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_y[j] * pc_z[j] * pb_xz[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pb_xx[j] * pc_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_xxx[j] - 1.5 * pc_y[j] * pa_z[j] * pb_xz[j] * fl1_fx - 0.5 * pc_y[j] * fl1_fx * pb_xxx[j] - pa_yz[j] * pb_xxx[j] * pc_z[j] - 3.0 * pa_yz[j] * pb_xxz[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxxz[j] - pc_y[j] * pa_z[j] * pb_xxxz[j]);

                t_yz_xxxz[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl2_fx * pc_x[j] + 0.75 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_yz[j] * pb_x[j] * fl1_fx * pc_z[j] + 1.5 * pa_yz[j] * pc_xz[j] * fl1_fx + 1.5 * pa_yz[j] * pc_x[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * pc_zz[j] * pb_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_xz[j] * fl1_fx + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_xx[j] + 1.5 * pa_y[j] * fl1_fx * pb_xx[j] * pc_x[j] + 1.5 * pc_yz[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_yz[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_xx[j] + 0.5 * pc_y[j] * fl1_fx * pb_xxx[j] + 3.0 * pa_yz[j] * pb_xx[j] * pc_xz[j] + 3.0 * pa_yz[j] * pb_xz[j] * pc_xx[j] + pa_y[j] * pc_zz[j] * pb_xxx[j] + 3.0 * pa_y[j] * pc_xz[j] * pb_xxz[j] + pc_yz[j] * pa_z[j] * pb_xxx[j] + 3.0 * pc_xy[j] * pa_z[j] * pb_xxz[j] + pc_yz[j] * pb_xxxz[j]);

                t_yz_xxxz[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_yz[j] * pc_xz[j] * fl1_fx - 1.5 * pa_y[j] * pc_zz[j] * pb_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_xzz[j] * fl1_fx - 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pc_xxx[j] - 1.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_xx[j] - 1.5 * pc_yz[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx - 1.5 * pc_yz[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xx[j] - 3.0 * pa_yz[j] * pb_x[j] * pc_xxz[j] - pa_yz[j] * pc_xxx[j] * pb_z[j] - 3.0 * pa_y[j] * pc_xzz[j] * pb_xx[j] - 3.0 * pa_y[j] * pc_xxz[j] * pb_xz[j] - 3.0 * pc_xyz[j] * pa_z[j] * pb_xx[j] - 3.0 * pc_xxy[j] * pa_z[j] * pb_xz[j] - pc_yzz[j] * pb_xxx[j] - 3.0 * pc_xyz[j] * pb_xxz[j]);

                t_yz_xxxz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_y[j] * pc_xzz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pc_xxx[j] + 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxxy[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pb_x[j] + pa_yz[j] * pc_xxxz[j] + 3.0 * pa_y[j] * pc_xxzz[j] * pb_x[j] + pa_y[j] * pc_xxxz[j] * pb_z[j] + 3.0 * pc_xxyz[j] * pa_z[j] * pb_x[j] + pc_xxxy[j] * pa_z[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pb_xx[j] + 3.0 * pc_xxyz[j] * pb_xz[j]);

                t_yz_xxxz[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xxxy[j] * fl1_fx - pa_y[j] * pc_xxxzz[j] - pc_xxxyz[j] * pa_z[j] - 3.0 * pc_xxyzz[j] * pb_x[j] - pc_xxxyz[j] * pb_z[j]);

                t_yz_xxxz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_63_64(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (63,64)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyy = pbDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xxyy = primBuffer.data(90 * idx + 63);

            // Batch of Integrals (63,64)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxy, pb_xxyy, pb_xy, pb_xyy, pb_y, pb_yy, \
                                     pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, pc_xxz, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, \
                                     pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yz_xxyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xxyy[j] = fl_s_0_0_0 * (0.25 * pa_yz[j] * fl2_fx + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * pa_yz[j] * pb_xx[j] * fl1_fx + 0.5 * pa_yz[j] * fl1_fx * pb_yy[j] + fl1_fx * pa_z[j] * pb_xxy[j] + pa_yz[j] * pb_xxyy[j]);

                t_yz_xxyy[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * fl2_fx - 0.25 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - fl2_fx * pa_z[j] * pb_y[j] - 0.5 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * pa_yz[j] * pb_xx[j] * fl1_fx - pa_yz[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_yz[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_yz[j] * fl1_fx * pb_yy[j] - 0.5 * pa_y[j] * pc_z[j] * pb_xx[j] * fl1_fx - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yy[j] - 1.5 * pc_y[j] * pa_z[j] * pb_xx[j] * fl1_fx - 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yy[j] - 2.0 * fl1_fx * pa_z[j] * pb_xy[j] * pc_x[j] - fl1_fx * pc_z[j] * pb_xxy[j] - fl1_fx * pa_z[j] * pb_xxy[j] - 2.0 * pa_yz[j] * pb_xxy[j] * pc_y[j] - 2.0 * pa_yz[j] * pb_xyy[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxyy[j] - pc_y[j] * pa_z[j] * pb_xxyy[j]);

                t_yz_xxyy[j] += fl_s_0_0_2 * (0.25 * pa_yz[j] * fl2_fx + 0.5 * pa_y[j] * pc_z[j] * fl2_fx + 1.5 * pc_y[j] * pa_z[j] * fl2_fx + 0.75 * pc_yz[j] * fl2_fx + fl2_fx * pc_z[j] * pb_y[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + pa_yz[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_yz[j] * pc_xx[j] * fl1_fx + 0.5 * pa_yz[j] * fl1_fx * pc_yy[j] + pa_yz[j] * fl1_fx * pb_y[j] * pc_y[j] + 0.5 * pa_y[j] * pc_z[j] * pb_xx[j] * fl1_fx + pa_y[j] * pc_xz[j] * pb_x[j] * fl1_fx + pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yy[j] + 1.5 * pc_y[j] * pa_z[j] * pb_xx[j] * fl1_fx + 3.0 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx + pc_yy[j] * pa_z[j] * fl1_fx * pb_y[j] + 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yy[j] + 1.5 * pc_yz[j] * pb_xx[j] * fl1_fx + 0.5 * pc_yz[j] * fl1_fx * pb_yy[j] + fl1_fx * pa_z[j] * pc_xx[j] * pb_y[j] + 2.0 * fl1_fx * pc_xz[j] * pb_xy[j] + 2.0 * fl1_fx * pa_z[j] * pb_xy[j] * pc_x[j] + fl1_fx * pc_z[j] * pb_xxy[j] + pa_yz[j] * pb_xx[j] * pc_yy[j] + 4.0 * pa_yz[j] * pb_xy[j] * pc_xy[j] + pa_yz[j] * pc_xx[j] * pb_yy[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xxy[j] + 2.0 * pa_y[j] * pc_xz[j] * pb_xyy[j] + 2.0 * pc_yy[j] * pa_z[j] * pb_xxy[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xyy[j] + pc_yz[j] * pb_xxyy[j]);

                t_yz_xxyy[j] += fl_s_0_0_3 * (-0.25 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 1.5 * pc_yz[j] * fl2_fx - 0.5 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * pa_yz[j] * pc_xx[j] * fl1_fx - 0.5 * pa_yz[j] * fl1_fx * pc_yy[j] - pa_y[j] * pc_xz[j] * pb_x[j] * fl1_fx - 0.5 * pa_y[j] * pc_xxz[j] * fl1_fx - 0.5 * pa_y[j] * pc_yyz[j] * fl1_fx - pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx - 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx - pc_yy[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_yz[j] * pb_xx[j] * fl1_fx - 3.0 * pc_xyz[j] * pb_x[j] * fl1_fx - pc_yyz[j] * fl1_fx * pb_y[j] - 0.5 * pc_yz[j] * fl1_fx * pb_yy[j] - fl1_fx * pc_xxz[j] * pb_y[j] - fl1_fx * pa_z[j] * pc_xx[j] * pb_y[j] - 2.0 * fl1_fx * pc_xz[j] * pb_xy[j] - 2.0 * pa_yz[j] * pb_x[j] * pc_xyy[j] - 2.0 * pa_yz[j] * pc_xxy[j] * pb_y[j] - pa_y[j] * pc_yyz[j] * pb_xx[j] - 4.0 * pa_y[j] * pc_xyz[j] * pb_xy[j] - pa_y[j] * pc_xxz[j] * pb_yy[j] - pc_yyy[j] * pa_z[j] * pb_xx[j] - 4.0 * pc_xyy[j] * pa_z[j] * pb_xy[j] - pc_xxy[j] * pa_z[j] * pb_yy[j] - 2.0 * pc_yyz[j] * pb_xxy[j] - 2.0 * pc_xyz[j] * pb_xyy[j]);

                t_yz_xxyy[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + 0.5 * pa_y[j] * pc_xxz[j] * fl1_fx + 0.5 * pa_y[j] * pc_yyz[j] * fl1_fx + 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 0.5 * pc_yyyz[j] * fl1_fx + pc_yyz[j] * fl1_fx * pb_y[j] + fl1_fx * pc_xxz[j] * pb_y[j] + pa_yz[j] * pc_xxyy[j] + 2.0 * pa_y[j] * pc_xyyz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xxyz[j] * pb_y[j] + 2.0 * pc_xyyy[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxyy[j] * pa_z[j] * pb_y[j] + pc_yyyz[j] * pb_xx[j] + 4.0 * pc_xyyz[j] * pb_xy[j] + pc_xxyz[j] * pb_yy[j]);

                t_yz_xxyy[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * pc_yyyz[j] * fl1_fx - pa_y[j] * pc_xxyyz[j] - pc_xxyyy[j] * pa_z[j] - 2.0 * pc_xyyyz[j] * pb_x[j] - 2.0 * pc_xxyyz[j] * pb_y[j]);

                t_yz_xxyy[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_64_65(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (64,65)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyz = pbDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xxyz = primBuffer.data(90 * idx + 64);

            // Batch of Integrals (64,65)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxy, pb_xxyz, pb_xxz, pb_xy, pb_xyz, pb_xz, \
                                     pb_y, pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yz_xxyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yz_xxyz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_y[j] * fl2_fx * pb_y[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_yz[j] * fl1_fx * pb_yz[j] + 0.5 * pa_y[j] * fl1_fx * pb_xxy[j] + 0.5 * fl1_fx * pa_z[j] * pb_xxz[j] + pa_yz[j] * pb_xxyz[j]);

                t_yz_xxyz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.25 * pa_y[j] * fl2_fx * pc_y[j] - 0.5 * pa_y[j] * fl2_fx * pb_y[j] - 0.25 * pc_y[j] * fl2_fx * pb_y[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * fl2_fx * pb_xx[j] - 0.5 * pa_yz[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_yz[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_yz[j] * fl1_fx * pb_yz[j] - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yz[j] - 0.5 * pa_y[j] * fl1_fx * pb_xx[j] * pc_y[j] - pa_y[j] * fl1_fx * pb_xy[j] * pc_x[j] - 0.5 * pa_y[j] * fl1_fx * pb_xxy[j] - 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yz[j] - 0.5 * pc_y[j] * fl1_fx * pb_xxy[j] - 0.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_z[j] - fl1_fx * pa_z[j] * pb_xz[j] * pc_x[j] - 0.5 * fl1_fx * pc_z[j] * pb_xxz[j] - 0.5 * fl1_fx * pa_z[j] * pb_xxz[j] - pa_yz[j] * pb_xxy[j] * pc_z[j] - pa_yz[j] * pb_xxz[j] * pc_y[j] - 2.0 * pa_yz[j] * pb_xyz[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxyz[j] - pc_y[j] * pa_z[j] * pb_xxyz[j]);

                t_yz_xxyz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.5 * pa_y[j] * fl2_fx * pc_y[j] + 0.25 * pa_y[j] * fl2_fx * pb_y[j] + 0.25 * pc_yy[j] * fl2_fx + 0.5 * pc_y[j] * fl2_fx * pb_y[j] + 0.5 * fl2_fx * pa_z[j] * pc_z[j] + 0.25 * fl2_fx * pc_zz[j] + 0.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.25 * fl2_fx * pc_xx[j] + fl2_fx * pb_x[j] * pc_x[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_yz[j] * fl1_fx * pc_yz[j] + 0.5 * pa_yz[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_yz[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pa_y[j] * pc_zz[j] * fl1_fx * pb_y[j] + 0.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yz[j] + pa_y[j] * fl1_fx * pb_x[j] * pc_xy[j] + 0.5 * pa_y[j] * fl1_fx * pc_xx[j] * pb_y[j] + 0.5 * pa_y[j] * fl1_fx * pb_xx[j] * pc_y[j] + pa_y[j] * fl1_fx * pb_xy[j] * pc_x[j] + 0.5 * pc_yz[j] * pa_z[j] * fl1_fx * pb_y[j] + 0.5 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yz[j] + 0.5 * pc_yz[j] * fl1_fx * pb_yz[j] + 0.5 * pc_yy[j] * fl1_fx * pb_xx[j] + pc_xy[j] * fl1_fx * pb_xy[j] + 0.5 * pc_y[j] * fl1_fx * pb_xxy[j] + fl1_fx * pa_z[j] * pb_x[j] * pc_xz[j] + 0.5 * fl1_fx * pa_z[j] * pc_xx[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xx[j] + fl1_fx * pc_xz[j] * pb_xz[j] + 0.5 * fl1_fx * pa_z[j] * pb_xx[j] * pc_z[j] + fl1_fx * pa_z[j] * pb_xz[j] * pc_x[j] + 0.5 * fl1_fx * pc_z[j] * pb_xxz[j] + pa_yz[j] * pb_xx[j] * pc_yz[j] + 2.0 * pa_yz[j] * pb_xy[j] * pc_xz[j] + 2.0 * pa_yz[j] * pb_xz[j] * pc_xy[j] + pa_yz[j] * pc_xx[j] * pb_yz[j] + pa_y[j] * pc_zz[j] * pb_xxy[j] + pa_y[j] * pc_yz[j] * pb_xxz[j] + 2.0 * pa_y[j] * pc_xz[j] * pb_xyz[j] + pc_yz[j] * pa_z[j] * pb_xxy[j] + pc_yy[j] * pa_z[j] * pb_xxz[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xyz[j] + pc_yz[j] * pb_xxyz[j]);

                t_yz_xxyz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.25 * pa_y[j] * fl2_fx * pc_y[j] - 0.5 * pc_yy[j] * fl2_fx - 0.25 * pc_y[j] * fl2_fx * pb_y[j] - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pc_xx[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * pa_yz[j] * fl1_fx * pc_yz[j] - 0.5 * pa_y[j] * pc_yzz[j] * fl1_fx - 0.5 * pa_y[j] * pc_zz[j] * fl1_fx * pb_y[j] - 0.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pc_xxy[j] - pa_y[j] * fl1_fx * pb_x[j] * pc_xy[j] - 0.5 * pa_y[j] * fl1_fx * pc_xx[j] * pb_y[j] - 0.5 * pc_yyz[j] * pa_z[j] * fl1_fx - 0.5 * pc_yz[j] * pa_z[j] * fl1_fx * pb_y[j] - 0.5 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_yzz[j] * fl1_fx * pb_y[j] - 0.5 * pc_yyz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yz[j] * fl1_fx * pb_yz[j] - pc_xyy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_y[j] - 0.5 * pc_yy[j] * fl1_fx * pb_xx[j] - pc_xy[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pa_z[j] * pc_xxz[j] - fl1_fx * pc_xzz[j] * pb_x[j] - 0.5 * fl1_fx * pc_xxz[j] * pb_z[j] - fl1_fx * pa_z[j] * pb_x[j] * pc_xz[j] - 0.5 * fl1_fx * pa_z[j] * pc_xx[j] * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xx[j] - fl1_fx * pc_xz[j] * pb_xz[j] - 2.0 * pa_yz[j] * pb_x[j] * pc_xyz[j] - pa_yz[j] * pc_xxz[j] * pb_y[j] - pa_yz[j] * pc_xxy[j] * pb_z[j] - pa_y[j] * pc_yzz[j] * pb_xx[j] - 2.0 * pa_y[j] * pc_xzz[j] * pb_xy[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_xz[j] - pa_y[j] * pc_xxz[j] * pb_yz[j] - pc_yyz[j] * pa_z[j] * pb_xx[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_xy[j] - 2.0 * pc_xyy[j] * pa_z[j] * pb_xz[j] - pc_xxy[j] * pa_z[j] * pb_yz[j] - pc_yzz[j] * pb_xxy[j] - pc_yyz[j] * pb_xxz[j] - 2.0 * pc_xyz[j] * pb_xyz[j]);

                t_yz_xxyz[j] += fl_s_0_0_4 * (0.25 * pc_yy[j] * fl2_fx + 0.25 * fl2_fx * pc_zz[j] + 0.25 * fl2_fx * pc_xx[j] + 0.5 * pa_y[j] * pc_yzz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pc_xxy[j] + 0.5 * pc_yyz[j] * pa_z[j] * fl1_fx + 0.5 * pc_yyzz[j] * fl1_fx + 0.5 * pc_yzz[j] * fl1_fx * pb_y[j] + 0.5 * pc_yyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxyy[j] * fl1_fx + pc_xyy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xxzz[j] + 0.5 * fl1_fx * pa_z[j] * pc_xxz[j] + fl1_fx * pc_xzz[j] * pb_x[j] + 0.5 * fl1_fx * pc_xxz[j] * pb_z[j] + pa_yz[j] * pc_xxyz[j] + 2.0 * pa_y[j] * pc_xyzz[j] * pb_x[j] + pa_y[j] * pc_xxzz[j] * pb_y[j] + pa_y[j] * pc_xxyz[j] * pb_z[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_x[j] + pc_xxyz[j] * pa_z[j] * pb_y[j] + pc_xxyy[j] * pa_z[j] * pb_z[j] + pc_yyzz[j] * pb_xx[j] + 2.0 * pc_xyzz[j] * pb_xy[j] + 2.0 * pc_xyyz[j] * pb_xz[j] + pc_xxyz[j] * pb_yz[j]);

                t_yz_xxyz[j] += fl_s_0_0_5 * (-0.5 * pc_yyzz[j] * fl1_fx - 0.5 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_xxzz[j] - pa_y[j] * pc_xxyzz[j] - pc_xxyyz[j] * pa_z[j] - 2.0 * pc_xyyzz[j] * pb_x[j] - pc_xxyzz[j] * pb_y[j] - pc_xxyyz[j] * pb_z[j]);

                t_yz_xxyz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_65_66(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (65,66)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxzz = pbDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xxzz = primBuffer.data(90 * idx + 65);

            // Batch of Integrals (65,66)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xx, pb_xxz, pb_xxzz, pb_xz, pb_xzz, pb_z, pb_zz, \
                                     pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, pc_xxzzz, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yz_xxzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xxzz[j] = fl_s_0_0_0 * (0.25 * pa_yz[j] * fl2_fx + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.5 * pa_yz[j] * pb_xx[j] * fl1_fx + 0.5 * pa_yz[j] * fl1_fx * pb_zz[j] + pa_y[j] * fl1_fx * pb_xxz[j] + pa_yz[j] * pb_xxzz[j]);

                t_yz_xxzz[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * pc_z[j] * fl2_fx - pa_y[j] * fl2_fx * pb_z[j] - 0.25 * pc_y[j] * pa_z[j] * fl2_fx - 0.5 * pc_y[j] * fl2_fx * pb_z[j] - 0.5 * pa_yz[j] * pb_xx[j] * fl1_fx - pa_yz[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_yz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_yz[j] * fl1_fx * pb_zz[j] - 1.5 * pa_y[j] * pc_z[j] * pb_xx[j] * fl1_fx - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_y[j] * fl1_fx * pb_xz[j] * pc_x[j] - pa_y[j] * fl1_fx * pb_xxz[j] - 0.5 * pc_y[j] * pa_z[j] * pb_xx[j] * fl1_fx - 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_zz[j] - pc_y[j] * fl1_fx * pb_xxz[j] - 2.0 * pa_yz[j] * pb_xxz[j] * pc_z[j] - 2.0 * pa_yz[j] * pb_xzz[j] * pc_x[j] - pa_y[j] * pc_z[j] * pb_xxzz[j] - pc_y[j] * pa_z[j] * pb_xxzz[j]);

                t_yz_xxzz[j] += fl_s_0_0_2 * (0.25 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_z[j] * fl2_fx + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.5 * pc_y[j] * pa_z[j] * fl2_fx + 0.75 * pc_yz[j] * fl2_fx + pc_y[j] * fl2_fx * pb_z[j] + pa_yz[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_yz[j] * pc_xx[j] * fl1_fx + 0.5 * pa_yz[j] * fl1_fx * pc_zz[j] + pa_yz[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_y[j] * pc_z[j] * pb_xx[j] * fl1_fx + 3.0 * pa_y[j] * pc_xz[j] * pb_x[j] * fl1_fx + pa_y[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_zz[j] + pa_y[j] * fl1_fx * pc_xx[j] * pb_z[j] + 2.0 * pa_y[j] * fl1_fx * pb_xz[j] * pc_x[j] + 0.5 * pc_y[j] * pa_z[j] * pb_xx[j] * fl1_fx + pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx + pc_yz[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_yz[j] * pb_xx[j] * fl1_fx + 0.5 * pc_yz[j] * fl1_fx * pb_zz[j] + 2.0 * pc_xy[j] * fl1_fx * pb_xz[j] + pc_y[j] * fl1_fx * pb_xxz[j] + pa_yz[j] * pb_xx[j] * pc_zz[j] + 4.0 * pa_yz[j] * pb_xz[j] * pc_xz[j] + pa_yz[j] * pc_xx[j] * pb_zz[j] + 2.0 * pa_y[j] * pc_zz[j] * pb_xxz[j] + 2.0 * pa_y[j] * pc_xz[j] * pb_xzz[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_xxz[j] + 2.0 * pc_xy[j] * pa_z[j] * pb_xzz[j] + pc_yz[j] * pb_xxzz[j]);

                t_yz_xxzz[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.25 * pc_y[j] * pa_z[j] * fl2_fx - 1.5 * pc_yz[j] * fl2_fx - 0.5 * pc_y[j] * fl2_fx * pb_z[j] - 0.5 * pa_yz[j] * pc_xx[j] * fl1_fx - 0.5 * pa_yz[j] * fl1_fx * pc_zz[j] - 3.0 * pa_y[j] * pc_xz[j] * pb_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_xxz[j] * fl1_fx - 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx - pa_y[j] * pc_zz[j] * fl1_fx * pb_z[j] - pa_y[j] * fl1_fx * pc_xx[j] * pb_z[j] - pc_xy[j] * pa_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_xxy[j] * pa_z[j] * fl1_fx - 0.5 * pc_yzz[j] * pa_z[j] * fl1_fx - pc_yz[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * pb_xx[j] * fl1_fx - 3.0 * pc_xyz[j] * pb_x[j] * fl1_fx - pc_yzz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yz[j] * fl1_fx * pb_zz[j] - pc_xxy[j] * fl1_fx * pb_z[j] - 2.0 * pc_xy[j] * fl1_fx * pb_xz[j] - 2.0 * pa_yz[j] * pb_x[j] * pc_xzz[j] - 2.0 * pa_yz[j] * pc_xxz[j] * pb_z[j] - pa_y[j] * pc_zzz[j] * pb_xx[j] - 4.0 * pa_y[j] * pc_xzz[j] * pb_xz[j] - pa_y[j] * pc_xxz[j] * pb_zz[j] - pc_yzz[j] * pa_z[j] * pb_xx[j] - 4.0 * pc_xyz[j] * pa_z[j] * pb_xz[j] - pc_xxy[j] * pa_z[j] * pb_zz[j] - 2.0 * pc_yzz[j] * pb_xxz[j] - 2.0 * pc_xyz[j] * pb_xzz[j]);

                t_yz_xxzz[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_xxz[j] * fl1_fx + 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx + 0.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 0.5 * pc_yzz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 0.5 * pc_yzzz[j] * fl1_fx + pc_yzz[j] * fl1_fx * pb_z[j] + pc_xxy[j] * fl1_fx * pb_z[j] + pa_yz[j] * pc_xxzz[j] + 2.0 * pa_y[j] * pc_xzzz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xxzz[j] * pb_z[j] + 2.0 * pc_xyzz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_z[j] + pc_yzzz[j] * pb_xx[j] + 4.0 * pc_xyzz[j] * pb_xz[j] + pc_xxyz[j] * pb_zz[j]);

                t_yz_xxzz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * pc_yzzz[j] * fl1_fx - pa_y[j] * pc_xxzzz[j] - pc_xxyzz[j] * pa_z[j] - 2.0 * pc_xyzzz[j] * pb_x[j] - 2.0 * pc_xxyzz[j] * pb_z[j]);

                t_yz_xxzz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_66_67(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (66,67)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyy = pbDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xyyy = primBuffer.data(90 * idx + 66);

            // Batch of Integrals (66,67)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xy, pb_xyy, pb_xyyy, pb_y, pb_yy, pb_yyy, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yz_xyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xyyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_yz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pa_z[j] * pb_xyy[j] + pa_yz[j] * pb_xyyy[j]);

                t_yz_xyyy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pa_z[j] * pb_x[j] - 0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yz[j] * pb_xy[j] * fl1_fx - 1.5 * pa_yz[j] * pb_x[j] * pc_y[j] * fl1_fx - 1.5 * pa_yz[j] * pc_x[j] * pb_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * pb_xy[j] * fl1_fx - 4.5 * pc_y[j] * pa_z[j] * pb_xy[j] * fl1_fx - 1.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_yy[j] - 1.5 * fl1_fx * pc_z[j] * pb_xyy[j] - 1.5 * fl1_fx * pa_z[j] * pb_xyy[j] - 3.0 * pa_yz[j] * pb_xyy[j] * pc_y[j] - pa_yz[j] * pc_x[j] * pb_yyy[j] - pa_y[j] * pc_z[j] * pb_xyyy[j] - pc_y[j] * pa_z[j] * pb_xyyy[j]);

                t_yz_xyyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_z[j] * pc_x[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.75 * fl2_fx * pc_xz[j] + 0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_yz[j] * pb_x[j] * pc_y[j] * fl1_fx + 1.5 * pa_yz[j] * pc_x[j] * pb_y[j] * fl1_fx + 1.5 * pa_yz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_xy[j] * fl1_fx + 1.5 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_xz[j] * pb_y[j] * fl1_fx + 4.5 * pc_y[j] * pa_z[j] * pb_xy[j] * fl1_fx + 3.0 * pc_yy[j] * pa_z[j] * pb_x[j] * fl1_fx + 4.5 * pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx + 4.5 * pc_yz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pc_xz[j] * pb_yy[j] + 1.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_yy[j] + 1.5 * fl1_fx * pc_z[j] * pb_xyy[j] + 3.0 * pa_yz[j] * pb_xy[j] * pc_yy[j] + 3.0 * pa_yz[j] * pc_xy[j] * pb_yy[j] + 3.0 * pa_y[j] * pc_yz[j] * pb_xyy[j] + pa_y[j] * pc_xz[j] * pb_yyy[j] + 3.0 * pc_yy[j] * pa_z[j] * pb_xyy[j] + pc_xy[j] * pa_z[j] * pb_yyy[j] + pc_yz[j] * pb_xyyy[j]);

                t_yz_xyyy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_xz[j] * pb_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx - 3.0 * pc_yy[j] * pa_z[j] * pb_x[j] * fl1_fx - 4.5 * pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx - 3.0 * pc_xyy[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pb_xy[j] * fl1_fx - 3.0 * pc_yyz[j] * pb_x[j] * fl1_fx - 4.5 * pc_xyz[j] * pb_y[j] * fl1_fx - 1.5 * fl1_fx * pc_xz[j] * pb_yy[j] - pa_yz[j] * pb_x[j] * pc_yyy[j] - 3.0 * pa_yz[j] * pc_xyy[j] * pb_y[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_xy[j] - 3.0 * pa_y[j] * pc_xyz[j] * pb_yy[j] - 3.0 * pc_yyy[j] * pa_z[j] * pb_xy[j] - 3.0 * pc_xyy[j] * pa_z[j] * pb_yy[j] - 3.0 * pc_yyz[j] * pb_xyy[j] - pc_xyz[j] * pb_yyy[j]);

                t_yz_xyyy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xyy[j] * pa_z[j] * fl1_fx + 3.0 * pc_yyz[j] * pb_x[j] * fl1_fx + 4.5 * pc_xyz[j] * pb_y[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + pa_yz[j] * pc_xyyy[j] + pa_y[j] * pc_yyyz[j] * pb_x[j] + 3.0 * pa_y[j] * pc_xyyz[j] * pb_y[j] + pc_yyyy[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xyyy[j] * pa_z[j] * pb_y[j] + 3.0 * pc_yyyz[j] * pb_xy[j] + 3.0 * pc_xyyz[j] * pb_yy[j]);

                t_yz_xyyy[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - pa_y[j] * pc_xyyyz[j] - pc_xyyyy[j] * pa_z[j] - pc_yyyyz[j] * pb_x[j] - 3.0 * pc_xyyyz[j] * pb_y[j]);

                t_yz_xyyy[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_67_68(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (67,68)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyz = pbDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xyyz = primBuffer.data(90 * idx + 67);

            // Batch of Integrals (67,68)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xy, pb_xyy, pb_xyyz, pb_xyz, pb_xz, pb_y, pb_yy, \
                                     pb_yyz, pb_yz, pb_z, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, \
                                     pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_yz_xyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xyyz[j] = fl_s_0_0_0 * (0.25 * pa_y[j] * fl2_fx * pb_x[j] + 0.5 * fl2_fx * pb_xy[j] + 0.5 * pa_yz[j] * pb_xz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pb_xyy[j] + fl1_fx * pa_z[j] * pb_xyz[j] + pa_yz[j] * pb_xyyz[j]);

                t_yz_xyyz[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx * pb_x[j] - 0.25 * pa_y[j] * fl2_fx * pc_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pc_x[j] * pb_y[j] - fl2_fx * pb_xy[j] - 0.5 * pa_yz[j] * pb_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_yz[j] * pb_xz[j] * fl1_fx - 0.5 * pa_yz[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * pc_z[j] * pb_xz[j] * fl1_fx - pa_y[j] * fl1_fx * pb_xy[j] * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_yy[j] - 0.5 * pa_y[j] * fl1_fx * pb_xyy[j] - 1.5 * pc_y[j] * pa_z[j] * pb_xz[j] * fl1_fx - 0.5 * pc_y[j] * fl1_fx * pb_xyy[j] - fl1_fx * pa_z[j] * pb_xy[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_x[j] * pb_yz[j] - fl1_fx * pc_z[j] * pb_xyz[j] - fl1_fx * pa_z[j] * pb_xyz[j] - pa_yz[j] * pb_xyy[j] * pc_z[j] - 2.0 * pa_yz[j] * pb_xyz[j] * pc_y[j] - pa_yz[j] * pc_x[j] * pb_yyz[j] - pa_y[j] * pc_z[j] * pb_xyyz[j] - pc_y[j] * pa_z[j] * pb_xyyz[j]);

                t_yz_xyyz[j] += fl_s_0_0_2 * (0.5 * pa_y[j] * fl2_fx * pc_x[j] + 0.25 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + fl2_fx * pc_x[j] * pb_y[j] + 0.5 * fl2_fx * pb_xy[j] + 0.5 * pa_yz[j] * pb_x[j] * fl1_fx * pc_z[j] + 0.5 * pa_yz[j] * pc_xz[j] * fl1_fx + 0.5 * pa_yz[j] * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * pc_zz[j] * pb_x[j] * fl1_fx + 0.5 * pa_y[j] * pc_z[j] * pb_xz[j] * fl1_fx + 0.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_yy[j] + pa_y[j] * fl1_fx * pc_xy[j] * pb_y[j] + pa_y[j] * fl1_fx * pb_xy[j] * pc_y[j] + 0.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_yy[j] + 1.5 * pc_yz[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_y[j] * pa_z[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_yz[j] * pb_xz[j] * fl1_fx + pc_yy[j] * fl1_fx * pb_xy[j] + 0.5 * pc_xy[j] * fl1_fx * pb_yy[j] + 0.5 * pc_y[j] * fl1_fx * pb_xyy[j] + fl1_fx * pa_z[j] * pc_xz[j] * pb_y[j] + fl1_fx * pc_zz[j] * pb_xy[j] + fl1_fx * pc_xz[j] * pb_yz[j] + fl1_fx * pa_z[j] * pb_xy[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_x[j] * pb_yz[j] + fl1_fx * pc_z[j] * pb_xyz[j] + 2.0 * pa_yz[j] * pb_xy[j] * pc_yz[j] + pa_yz[j] * pb_xz[j] * pc_yy[j] + pa_yz[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_yz[j] * pc_xy[j] * pb_yz[j] + pa_y[j] * pc_zz[j] * pb_xyy[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_xyz[j] + pa_y[j] * pc_xz[j] * pb_yyz[j] + pc_yz[j] * pa_z[j] * pb_xyy[j] + 2.0 * pc_yy[j] * pa_z[j] * pb_xyz[j] + pc_xy[j] * pa_z[j] * pb_yyz[j] + pc_yz[j] * pb_xyyz[j]);

                t_yz_xyyz[j] += fl_s_0_0_3 * (-0.25 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pc_x[j] * pb_y[j] - 0.5 * pa_yz[j] * pc_xz[j] * fl1_fx - 0.5 * pa_y[j] * pc_zz[j] * pb_x[j] * fl1_fx - 0.5 * pa_y[j] * pc_xzz[j] * fl1_fx - 0.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pc_xyy[j] - 0.5 * pa_y[j] * fl1_fx * pb_x[j] * pc_yy[j] - pa_y[j] * fl1_fx * pc_xy[j] * pb_y[j] - 1.5 * pc_yz[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx - 1.5 * pc_yz[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yyy[j] * fl1_fx * pb_x[j] - pc_xyy[j] * fl1_fx * pb_y[j] - pc_yy[j] * fl1_fx * pb_xy[j] - 0.5 * pc_xy[j] * fl1_fx * pb_yy[j] - fl1_fx * pc_xzz[j] * pb_y[j] - fl1_fx * pa_z[j] * pc_xz[j] * pb_y[j] - fl1_fx * pc_zz[j] * pb_xy[j] - fl1_fx * pc_xz[j] * pb_yz[j] - pa_yz[j] * pb_x[j] * pc_yyz[j] - 2.0 * pa_yz[j] * pc_xyz[j] * pb_y[j] - pa_yz[j] * pc_xyy[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xy[j] - pa_y[j] * pc_yyz[j] * pb_xz[j] - pa_y[j] * pc_xzz[j] * pb_yy[j] - 2.0 * pa_y[j] * pc_xyz[j] * pb_yz[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_xy[j] - pc_yyy[j] * pa_z[j] * pb_xz[j] - pc_xyz[j] * pa_z[j] * pb_yy[j] - 2.0 * pc_xyy[j] * pa_z[j] * pb_yz[j] - pc_yzz[j] * pb_xyy[j] - 2.0 * pc_yyz[j] * pb_xyz[j] - pc_xyz[j] * pb_yyz[j]);

                t_yz_xyyz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_y[j] * pc_xzz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pc_xyy[j] + 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xyyy[j] * fl1_fx + 0.5 * pc_yyy[j] * fl1_fx * pb_x[j] + pc_xyy[j] * fl1_fx * pb_y[j] + fl1_fx * pc_xzz[j] * pb_y[j] + pa_yz[j] * pc_xyyz[j] + pa_y[j] * pc_yyzz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xyzz[j] * pb_y[j] + pa_y[j] * pc_xyyz[j] * pb_z[j] + pc_yyyz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_y[j] + pc_xyyy[j] * pa_z[j] * pb_z[j] + 2.0 * pc_yyzz[j] * pb_xy[j] + pc_yyyz[j] * pb_xz[j] + pc_xyzz[j] * pb_yy[j] + 2.0 * pc_xyyz[j] * pb_yz[j]);

                t_yz_xyyz[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xyyy[j] * fl1_fx - pa_y[j] * pc_xyyzz[j] - pc_xyyyz[j] * pa_z[j] - pc_yyyzz[j] * pb_x[j] - 2.0 * pc_xyyzz[j] * pb_y[j] - pc_xyyyz[j] * pb_z[j]);

                t_yz_xyyz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_68_69(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (68,69)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyzz = pbDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xyzz = primBuffer.data(90 * idx + 68);

            // Batch of Integrals (68,69)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xy, pb_xyz, pb_xyzz, pb_xz, pb_xzz, pb_y, pb_yz, \
                                     pb_yzz, pb_z, pb_zz, pc_x, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, \
                                     pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_yz_xyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xyzz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * fl2_fx * pb_xz[j] + 0.5 * pa_yz[j] * pb_xy[j] * fl1_fx + pa_y[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pa_z[j] * pb_xzz[j] + pa_yz[j] * pb_xyzz[j]);

                t_yz_xyzz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] * pb_x[j] - 0.25 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * fl2_fx * pc_x[j] * pb_z[j] - fl2_fx * pb_xz[j] - 0.5 * pa_yz[j] * pb_xy[j] * fl1_fx - 0.5 * pa_yz[j] * pb_x[j] * pc_y[j] * fl1_fx - 0.5 * pa_yz[j] * pc_x[j] * pb_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_z[j] * pb_xy[j] * fl1_fx - pa_y[j] * fl1_fx * pb_xz[j] * pc_y[j] - pa_y[j] * fl1_fx * pc_x[j] * pb_yz[j] - pa_y[j] * fl1_fx * pb_xyz[j] - 0.5 * pc_y[j] * pa_z[j] * pb_xy[j] * fl1_fx - pc_y[j] * fl1_fx * pb_xyz[j] - fl1_fx * pa_z[j] * pb_xz[j] * pc_z[j] - 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_zz[j] - 0.5 * fl1_fx * pc_z[j] * pb_xzz[j] - 0.5 * fl1_fx * pa_z[j] * pb_xzz[j] - 2.0 * pa_yz[j] * pb_xyz[j] * pc_z[j] - pa_yz[j] * pb_xzz[j] * pc_y[j] - pa_yz[j] * pc_x[j] * pb_yzz[j] - pa_y[j] * pc_z[j] * pb_xyzz[j] - pc_y[j] * pa_z[j] * pb_xyzz[j]);

                t_yz_xyzz[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pa_z[j] * pc_x[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.75 * fl2_fx * pc_xz[j] + fl2_fx * pc_x[j] * pb_z[j] + 0.25 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * fl2_fx * pb_xz[j] + 0.5 * pa_yz[j] * pb_x[j] * pc_y[j] * fl1_fx + 0.5 * pa_yz[j] * pc_x[j] * pb_y[j] * fl1_fx + 0.5 * pa_yz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_xy[j] * fl1_fx + 1.5 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx + 1.5 * pa_y[j] * pc_xz[j] * pb_y[j] * fl1_fx + pa_y[j] * fl1_fx * pc_xy[j] * pb_z[j] + pa_y[j] * fl1_fx * pb_xz[j] * pc_y[j] + pa_y[j] * fl1_fx * pc_x[j] * pb_yz[j] + 0.5 * pc_y[j] * pa_z[j] * pb_xy[j] * fl1_fx + 0.5 * pc_yy[j] * pa_z[j] * pb_x[j] * fl1_fx + 0.5 * pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_yz[j] * pb_xy[j] * fl1_fx + pc_yy[j] * fl1_fx * pb_xz[j] + pc_xy[j] * fl1_fx * pb_yz[j] + pc_y[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_zz[j] + fl1_fx * pa_z[j] * pc_xz[j] * pb_z[j] + fl1_fx * pc_zz[j] * pb_xz[j] + 0.5 * fl1_fx * pc_xz[j] * pb_zz[j] + fl1_fx * pa_z[j] * pb_xz[j] * pc_z[j] + 0.5 * fl1_fx * pa_z[j] * pc_x[j] * pb_zz[j] + 0.5 * fl1_fx * pc_z[j] * pb_xzz[j] + pa_yz[j] * pb_xy[j] * pc_zz[j] + 2.0 * pa_yz[j] * pb_xz[j] * pc_yz[j] + 2.0 * pa_yz[j] * pc_xz[j] * pb_yz[j] + pa_yz[j] * pc_xy[j] * pb_zz[j] + 2.0 * pa_y[j] * pc_zz[j] * pb_xyz[j] + pa_y[j] * pc_yz[j] * pb_xzz[j] + pa_y[j] * pc_xz[j] * pb_yzz[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_xyz[j] + pc_yy[j] * pa_z[j] * pb_xzz[j] + pc_xy[j] * pa_z[j] * pb_yzz[j] + pc_yz[j] * pb_xyzz[j]);

                t_yz_xyzz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.25 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * fl2_fx * pc_x[j] * pb_z[j] - 0.5 * pa_yz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_y[j] * pc_yz[j] * pb_x[j] * fl1_fx - 1.5 * pa_y[j] * pc_xz[j] * pb_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx - pa_y[j] * fl1_fx * pc_xy[j] * pb_z[j] - 0.5 * pc_yy[j] * pa_z[j] * pb_x[j] * fl1_fx - 0.5 * pc_xy[j] * pa_z[j] * pb_y[j] * fl1_fx - 0.5 * pc_xyy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yz[j] * pb_xy[j] * fl1_fx - 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xyz[j] * pb_y[j] * fl1_fx - pc_xyy[j] * fl1_fx * pb_z[j] - pc_yy[j] * fl1_fx * pb_xz[j] - pc_xy[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pa_z[j] * pc_xzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] - fl1_fx * pc_xzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_z[j] * pb_x[j] * pc_zz[j] - fl1_fx * pa_z[j] * pc_xz[j] * pb_z[j] - fl1_fx * pc_zz[j] * pb_xz[j] - 0.5 * fl1_fx * pc_xz[j] * pb_zz[j] - pa_yz[j] * pb_x[j] * pc_yzz[j] - pa_yz[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_yz[j] * pc_xyz[j] * pb_z[j] - pa_y[j] * pc_zzz[j] * pb_xy[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xz[j] - 2.0 * pa_y[j] * pc_xzz[j] * pb_yz[j] - pa_y[j] * pc_xyz[j] * pb_zz[j] - pc_yzz[j] * pa_z[j] * pb_xy[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_xz[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_yz[j] - pc_xyy[j] * pa_z[j] * pb_zz[j] - 2.0 * pc_yzz[j] * pb_xyz[j] - pc_yyz[j] * pb_xzz[j] - pc_xyz[j] * pb_yzz[j]);

                t_yz_xyzz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx + 0.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yyz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + pc_xyy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_xzzz[j] + 0.5 * fl1_fx * pa_z[j] * pc_xzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] + fl1_fx * pc_xzz[j] * pb_z[j] + pa_yz[j] * pc_xyzz[j] + pa_y[j] * pc_yzzz[j] * pb_x[j] + pa_y[j] * pc_xzzz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_xyzz[j] * pb_z[j] + pc_yyzz[j] * pa_z[j] * pb_x[j] + pc_xyzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_z[j] + pc_yzzz[j] * pb_xy[j] + 2.0 * pc_yyzz[j] * pb_xz[j] + 2.0 * pc_xyzz[j] * pb_yz[j] + pc_xyyz[j] * pb_zz[j]);

                t_yz_xyzz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * fl1_fx * pc_xzzz[j] - pa_y[j] * pc_xyzzz[j] - pc_xyyzz[j] * pa_z[j] - pc_yyzzz[j] * pb_x[j] - pc_xyzzz[j] * pb_y[j] - 2.0 * pc_xyyzz[j] * pb_z[j]);

                t_yz_xyzz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_69_70(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (69,70)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xzzz = pbDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_xzzz = primBuffer.data(90 * idx + 69);

            // Batch of Integrals (69,70)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_x, pb_xz, pb_xzz, pb_xzzz, pb_z, pb_zz, pb_zzz, pc_x, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_y, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yz_xzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_xzzz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pa_yz[j] * pb_xz[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pb_xzz[j] + pa_yz[j] * pb_xzzz[j]);

                t_yz_xzzz[j] += fl_s_0_0_1 * (-1.5 * pa_y[j] * fl2_fx * pb_x[j] - 0.75 * pa_y[j] * fl2_fx * pc_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_yz[j] * pb_xz[j] * fl1_fx - 1.5 * pa_yz[j] * pb_x[j] * pc_z[j] * fl1_fx - 1.5 * pa_yz[j] * pc_x[j] * pb_z[j] * fl1_fx - 4.5 * pa_y[j] * pc_z[j] * pb_xz[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_zz[j] - 1.5 * pa_y[j] * fl1_fx * pb_xzz[j] - 1.5 * pc_y[j] * pa_z[j] * pb_xz[j] * fl1_fx - 1.5 * pc_y[j] * fl1_fx * pb_xzz[j] - 3.0 * pa_yz[j] * pb_xzz[j] * pc_z[j] - pa_yz[j] * pc_x[j] * pb_zzz[j] - pa_y[j] * pc_z[j] * pb_xzzz[j] - pc_y[j] * pa_z[j] * pb_xzzz[j]);

                t_yz_xzzz[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl2_fx * pc_x[j] + 0.75 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_yz[j] * pb_x[j] * pc_z[j] * fl1_fx + 1.5 * pa_yz[j] * pc_x[j] * pb_z[j] * fl1_fx + 1.5 * pa_yz[j] * pc_xz[j] * fl1_fx + 4.5 * pa_y[j] * pc_z[j] * pb_xz[j] * fl1_fx + 3.0 * pa_y[j] * pc_zz[j] * pb_x[j] * fl1_fx + 4.5 * pa_y[j] * pc_xz[j] * pb_z[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pc_x[j] * pb_zz[j] + 1.5 * pc_y[j] * pa_z[j] * pb_xz[j] * fl1_fx + 1.5 * pc_yz[j] * pa_z[j] * pb_x[j] * fl1_fx + 1.5 * pc_xy[j] * pa_z[j] * pb_z[j] * fl1_fx + 4.5 * pc_yz[j] * pb_xz[j] * fl1_fx + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + 1.5 * pc_y[j] * fl1_fx * pb_xzz[j] + 3.0 * pa_yz[j] * pb_xz[j] * pc_zz[j] + 3.0 * pa_yz[j] * pc_xz[j] * pb_zz[j] + 3.0 * pa_y[j] * pc_zz[j] * pb_xzz[j] + pa_y[j] * pc_xz[j] * pb_zzz[j] + 3.0 * pc_yz[j] * pa_z[j] * pb_xzz[j] + pc_xy[j] * pa_z[j] * pb_zzz[j] + pc_yz[j] * pb_xzzz[j]);

                t_yz_xzzz[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_yz[j] * pc_xz[j] * fl1_fx - 3.0 * pa_y[j] * pc_zz[j] * pb_x[j] * fl1_fx - 4.5 * pa_y[j] * pc_xz[j] * pb_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_xzz[j] * fl1_fx - 1.5 * pc_yz[j] * pa_z[j] * pb_x[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * pb_z[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pb_xz[j] * fl1_fx - 3.0 * pc_yzz[j] * pb_x[j] * fl1_fx - 4.5 * pc_xyz[j] * pb_z[j] * fl1_fx - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - pa_yz[j] * pb_x[j] * pc_zzz[j] - 3.0 * pa_yz[j] * pc_xzz[j] * pb_z[j] - 3.0 * pa_y[j] * pc_zzz[j] * pb_xz[j] - 3.0 * pa_y[j] * pc_xzz[j] * pb_zz[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_xz[j] - 3.0 * pc_xyz[j] * pa_z[j] * pb_zz[j] - 3.0 * pc_yzz[j] * pb_xzz[j] - pc_xyz[j] * pb_zzz[j]);

                t_yz_xzzz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_y[j] * pc_xzz[j] * fl1_fx + 1.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_yzz[j] * pb_x[j] * fl1_fx + 4.5 * pc_xyz[j] * pb_z[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + pa_yz[j] * pc_xzzz[j] + pa_y[j] * pc_zzzz[j] * pb_x[j] + 3.0 * pa_y[j] * pc_xzzz[j] * pb_z[j] + pc_yzzz[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xyzz[j] * pa_z[j] * pb_z[j] + 3.0 * pc_yzzz[j] * pb_xz[j] + 3.0 * pc_xyzz[j] * pb_zz[j]);

                t_yz_xzzz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - pa_y[j] * pc_xzzzz[j] - pc_xyzzz[j] * pa_z[j] - pc_yzzzz[j] * pb_x[j] - 3.0 * pc_xyzzz[j] * pb_z[j]);

                t_yz_xzzz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_70_71(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (70,71)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyy = pbDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyyz = pcDistances.data(83 * idx + 77);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_yyyy = primBuffer.data(90 * idx + 70);

            // Batch of Integrals (70,71)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_y, pb_yy, pb_yyy, pb_yyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyy, pc_yyyyyz, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yz_yyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_yyyy[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 3.0 * fl2_fx * pa_z[j] * pb_y[j] + 3.0 * pa_yz[j] * pb_yy[j] * fl1_fx + 2.0 * fl1_fx * pa_z[j] * pb_yyy[j] + pa_yz[j] * pb_yyyy[j]);

                t_yz_yyyy[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * pc_z[j] * fl2_fx - 3.75 * pc_y[j] * pa_z[j] * fl2_fx - 6.0 * fl2_fx * pa_z[j] * pb_y[j] - 3.0 * fl2_fx * pc_z[j] * pb_y[j] - 3.0 * pa_yz[j] * pb_yy[j] * fl1_fx - 6.0 * pa_yz[j] * pb_y[j] * pc_y[j] * fl1_fx - 3.0 * pa_y[j] * pc_z[j] * pb_yy[j] * fl1_fx - 9.0 * pc_y[j] * pa_z[j] * pb_yy[j] * fl1_fx - 2.0 * fl1_fx * pc_z[j] * pb_yyy[j] - 2.0 * fl1_fx * pa_z[j] * pb_yyy[j] - 4.0 * pa_yz[j] * pb_yyy[j] * pc_y[j] - pa_y[j] * pc_z[j] * pb_yyyy[j] - pc_y[j] * pa_z[j] * pb_yyyy[j]);

                t_yz_yyyy[j] += fl_s_0_0_2 * (0.75 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_z[j] * fl2_fx + 7.5 * pc_y[j] * pa_z[j] * fl2_fx + 3.75 * pc_yz[j] * fl2_fx + 6.0 * fl2_fx * pc_z[j] * pb_y[j] + 3.0 * fl2_fx * pa_z[j] * pb_y[j] + 6.0 * pa_yz[j] * pb_y[j] * pc_y[j] * fl1_fx + 3.0 * pa_yz[j] * pc_yy[j] * fl1_fx + 3.0 * pa_y[j] * pc_z[j] * pb_yy[j] * fl1_fx + 6.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx + 9.0 * pc_y[j] * pa_z[j] * pb_yy[j] * fl1_fx + 12.0 * pc_yy[j] * pa_z[j] * pb_y[j] * fl1_fx + 9.0 * pc_yz[j] * pb_yy[j] * fl1_fx + 2.0 * fl1_fx * pc_z[j] * pb_yyy[j] + 6.0 * pa_yz[j] * pb_yy[j] * pc_yy[j] + 4.0 * pa_y[j] * pc_yz[j] * pb_yyy[j] + 4.0 * pc_yy[j] * pa_z[j] * pb_yyy[j] + pc_yz[j] * pb_yyyy[j]);

                t_yz_yyyy[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * pc_z[j] * fl2_fx - 3.75 * pc_y[j] * pa_z[j] * fl2_fx - 7.5 * pc_yz[j] * fl2_fx - 3.0 * fl2_fx * pc_z[j] * pb_y[j] - 3.0 * pa_yz[j] * pc_yy[j] * fl1_fx - 6.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx - 3.0 * pa_y[j] * pc_yyz[j] * fl1_fx - 12.0 * pc_yy[j] * pa_z[j] * pb_y[j] * fl1_fx - 5.0 * pc_yyy[j] * pa_z[j] * fl1_fx - 9.0 * pc_yz[j] * pb_yy[j] * fl1_fx - 12.0 * pc_yyz[j] * pb_y[j] * fl1_fx - 4.0 * pa_yz[j] * pb_y[j] * pc_yyy[j] - 6.0 * pa_y[j] * pc_yyz[j] * pb_yy[j] - 6.0 * pc_yyy[j] * pa_z[j] * pb_yy[j] - 4.0 * pc_yyz[j] * pb_yyy[j]);

                t_yz_yyyy[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 3.0 * pa_y[j] * pc_yyz[j] * fl1_fx + 5.0 * pc_yyy[j] * pa_z[j] * fl1_fx + 12.0 * pc_yyz[j] * pb_y[j] * fl1_fx + 5.0 * pc_yyyz[j] * fl1_fx + pa_yz[j] * pc_yyyy[j] + 4.0 * pa_y[j] * pc_yyyz[j] * pb_y[j] + 4.0 * pc_yyyy[j] * pa_z[j] * pb_y[j] + 6.0 * pc_yyyz[j] * pb_yy[j]);

                t_yz_yyyy[j] += fl_s_0_0_5 * (-5.0 * pc_yyyz[j] * fl1_fx - pa_y[j] * pc_yyyyz[j] - pc_yyyyy[j] * pa_z[j] - 4.0 * pc_yyyyz[j] * pb_y[j]);

                t_yz_yyyy[j] += fl_s_0_0_6 * pc_yyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_71_72(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (71,72)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyz = pbDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyzz = pcDistances.data(83 * idx + 78);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_yyyz = primBuffer.data(90 * idx + 71);

            // Batch of Integrals (71,72)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_y, pb_yy, pb_yyy, pb_yyyz, pb_yyz, pb_yz, pb_z, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyyzz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yz_yyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yz_yyyz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_yy[j] + 1.5 * pa_yz[j] * pb_yz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pb_yyy[j] + 1.5 * fl1_fx * pa_z[j] * pb_yyz[j] + pa_yz[j] * pb_yyyz[j]);

                t_yz_yyyz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_y[j] * fl2_fx * pb_y[j] - 0.75 * pa_y[j] * fl2_fx * pc_y[j] - 2.25 * pc_y[j] * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * fl2_fx * pb_yy[j] - 1.5 * pa_yz[j] * pb_y[j] * fl1_fx * pc_z[j] - 1.5 * pa_yz[j] * pb_yz[j] * fl1_fx - 1.5 * pa_yz[j] * pc_y[j] * fl1_fx * pb_z[j] - 1.5 * pa_y[j] * pc_z[j] * pb_yz[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pb_yy[j] * pc_y[j] - 0.5 * pa_y[j] * fl1_fx * pb_yyy[j] - 4.5 * pc_y[j] * pa_z[j] * pb_yz[j] * fl1_fx - 0.5 * pc_y[j] * fl1_fx * pb_yyy[j] - 1.5 * fl1_fx * pa_z[j] * pb_yy[j] * pc_z[j] - 1.5 * fl1_fx * pc_z[j] * pb_yyz[j] - 1.5 * fl1_fx * pa_z[j] * pb_yyz[j] - pa_yz[j] * pb_yyy[j] * pc_z[j] - 3.0 * pa_yz[j] * pb_yyz[j] * pc_y[j] - pa_y[j] * pc_z[j] * pb_yyyz[j] - pc_y[j] * pa_z[j] * pb_yyyz[j]);

                t_yz_yyyz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_y[j] * fl2_fx * pc_y[j] + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 4.5 * pc_y[j] * fl2_fx * pb_y[j] + 1.5 * pc_yy[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pc_z[j] + 0.75 * fl2_fx * pc_zz[j] + 1.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_yy[j] + 1.5 * pa_yz[j] * pb_y[j] * fl1_fx * pc_z[j] + 1.5 * pa_yz[j] * pc_yz[j] * fl1_fx + 1.5 * pa_yz[j] * pc_y[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * pc_zz[j] * pb_y[j] * fl1_fx + 1.5 * pa_y[j] * pc_z[j] * pb_yz[j] * fl1_fx + 1.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pb_y[j] * pc_yy[j] + 1.5 * pa_y[j] * fl1_fx * pb_yy[j] * pc_y[j] + 4.5 * pc_yz[j] * pa_z[j] * pb_y[j] * fl1_fx + 4.5 * pc_y[j] * pa_z[j] * pb_yz[j] * fl1_fx + 3.0 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] + 4.5 * pc_yz[j] * pb_yz[j] * fl1_fx + 1.5 * pc_yy[j] * fl1_fx * pb_yy[j] + 0.5 * pc_y[j] * fl1_fx * pb_yyy[j] + 1.5 * fl1_fx * pc_zz[j] * pb_yy[j] + 1.5 * fl1_fx * pa_z[j] * pb_yy[j] * pc_z[j] + 1.5 * fl1_fx * pc_z[j] * pb_yyz[j] + 3.0 * pa_yz[j] * pb_yy[j] * pc_yz[j] + 3.0 * pa_yz[j] * pb_yz[j] * pc_yy[j] + pa_y[j] * pc_zz[j] * pb_yyy[j] + 3.0 * pa_y[j] * pc_yz[j] * pb_yyz[j] + pc_yz[j] * pa_z[j] * pb_yyy[j] + 3.0 * pc_yy[j] * pa_z[j] * pb_yyz[j] + pc_yz[j] * pb_yyyz[j]);

                t_yz_yyyz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 0.75 * pa_y[j] * fl2_fx * pc_y[j] - 3.0 * pc_yy[j] * fl2_fx - 2.25 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pc_zz[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_yz[j] * pc_yz[j] * fl1_fx - 1.5 * pa_y[j] * pc_zz[j] * pb_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_yzz[j] * fl1_fx - 1.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_y[j] * fl1_fx * pc_yyy[j] - 1.5 * pa_y[j] * fl1_fx * pb_y[j] * pc_yy[j] - 4.5 * pc_yz[j] * pa_z[j] * pb_y[j] * fl1_fx - 3.0 * pc_yyz[j] * pa_z[j] * fl1_fx - 3.0 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] - 4.5 * pc_yzz[j] * pb_y[j] * fl1_fx - 4.5 * pc_yz[j] * pb_yz[j] * fl1_fx - 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_yy[j] * fl1_fx * pb_yy[j] - 1.5 * fl1_fx * pc_zz[j] * pb_yy[j] - 3.0 * pa_yz[j] * pb_y[j] * pc_yyz[j] - pa_yz[j] * pc_yyy[j] * pb_z[j] - 3.0 * pa_y[j] * pc_yzz[j] * pb_yy[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_yz[j] - 3.0 * pc_yyz[j] * pa_z[j] * pb_yy[j] - 3.0 * pc_yyy[j] * pa_z[j] * pb_yz[j] - pc_yzz[j] * pb_yyy[j] - 3.0 * pc_yyz[j] * pb_yyz[j]);

                t_yz_yyyz[j] += fl_s_0_0_4 * (1.5 * pc_yy[j] * fl2_fx + 0.75 * fl2_fx * pc_zz[j] + 1.5 * pa_y[j] * pc_yzz[j] * fl1_fx + 0.5 * pa_y[j] * fl1_fx * pc_yyy[j] + 3.0 * pc_yyz[j] * pa_z[j] * fl1_fx + 4.5 * pc_yzz[j] * pb_y[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_yyyy[j] * fl1_fx + 1.5 * pc_yyy[j] * fl1_fx * pb_y[j] + pa_yz[j] * pc_yyyz[j] + 3.0 * pa_y[j] * pc_yyzz[j] * pb_y[j] + pa_y[j] * pc_yyyz[j] * pb_z[j] + 3.0 * pc_yyyz[j] * pa_z[j] * pb_y[j] + pc_yyyy[j] * pa_z[j] * pb_z[j] + 3.0 * pc_yyzz[j] * pb_yy[j] + 3.0 * pc_yyyz[j] * pb_yz[j]);

                t_yz_yyyz[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * pc_yyyy[j] * fl1_fx - pa_y[j] * pc_yyyzz[j] - pc_yyyyz[j] * pa_z[j] - 3.0 * pc_yyyzz[j] * pb_y[j] - pc_yyyyz[j] * pb_z[j]);

                t_yz_yyyz[j] += fl_s_0_0_6 * pc_yyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_72_73(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (72,73)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyzz = pbDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyzzz = pcDistances.data(83 * idx + 79);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_yyzz = primBuffer.data(90 * idx + 72);

            // Batch of Integrals (72,73)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_y, pb_yy, pb_yyz, pb_yyzz, pb_yz, pb_yzz, pb_z, pb_zz, \
                                     pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyyzzz, pc_yyz, pc_yyzz, pc_yyzzz, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_yz_yyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_yyzz[j] = fl_s_0_0_0 * (0.25 * pa_yz[j] * fl2_fx + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + fl2_fx * pb_yz[j] + 0.5 * pa_yz[j] * pb_yy[j] * fl1_fx + 0.5 * pa_yz[j] * fl1_fx * pb_zz[j] + pa_y[j] * fl1_fx * pb_yyz[j] + fl1_fx * pa_z[j] * pb_yzz[j] + pa_yz[j] * pb_yyzz[j]);

                t_yz_yyzz[j] += fl_s_0_0_1 * (-0.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * pc_z[j] * fl2_fx - pa_y[j] * fl2_fx * pb_z[j] - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pb_z[j] - fl2_fx * pa_z[j] * pb_y[j] - 1.5 * fl2_fx * pc_z[j] * pb_y[j] - 2.0 * fl2_fx * pb_yz[j] - 0.5 * pa_yz[j] * pb_yy[j] * fl1_fx - pa_yz[j] * pb_y[j] * pc_y[j] * fl1_fx - pa_yz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_yz[j] * fl1_fx * pb_zz[j] - 1.5 * pa_y[j] * pc_z[j] * pb_yy[j] * fl1_fx - 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_y[j] * fl1_fx * pb_yz[j] * pc_y[j] - pa_y[j] * fl1_fx * pb_yyz[j] - 0.5 * pc_y[j] * pa_z[j] * pb_yy[j] * fl1_fx - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_zz[j] - pc_y[j] * fl1_fx * pb_yyz[j] - 2.0 * fl1_fx * pa_z[j] * pb_yz[j] * pc_z[j] - fl1_fx * pc_z[j] * pb_yzz[j] - fl1_fx * pa_z[j] * pb_yzz[j] - 2.0 * pa_yz[j] * pb_yyz[j] * pc_z[j] - 2.0 * pa_yz[j] * pb_yzz[j] * pc_y[j] - pa_y[j] * pc_z[j] * pb_yyzz[j] - pc_y[j] * pa_z[j] * pb_yyzz[j]);

                t_yz_yyzz[j] += fl_s_0_0_2 * (0.25 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_z[j] * fl2_fx + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 1.5 * pc_y[j] * pa_z[j] * fl2_fx + 2.25 * pc_yz[j] * fl2_fx + 3.0 * pc_y[j] * fl2_fx * pb_z[j] + 3.0 * fl2_fx * pc_z[j] * pb_y[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + fl2_fx * pb_yz[j] + pa_yz[j] * pb_y[j] * pc_y[j] * fl1_fx + 0.5 * pa_yz[j] * pc_yy[j] * fl1_fx + 0.5 * pa_yz[j] * fl1_fx * pc_zz[j] + pa_yz[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_y[j] * pc_z[j] * pb_yy[j] * fl1_fx + 3.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx + pa_y[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_zz[j] + pa_y[j] * fl1_fx * pc_yy[j] * pb_z[j] + 2.0 * pa_y[j] * fl1_fx * pb_yz[j] * pc_y[j] + 0.5 * pc_y[j] * pa_z[j] * pb_yy[j] * fl1_fx + pc_yy[j] * pa_z[j] * pb_y[j] * fl1_fx + 3.0 * pc_yz[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_yz[j] * pb_yy[j] * fl1_fx + 1.5 * pc_yz[j] * fl1_fx * pb_zz[j] + 2.0 * pc_yy[j] * fl1_fx * pb_yz[j] + pc_y[j] * fl1_fx * pb_yyz[j] + fl1_fx * pa_z[j] * pb_y[j] * pc_zz[j] + 2.0 * fl1_fx * pc_zz[j] * pb_yz[j] + 2.0 * fl1_fx * pa_z[j] * pb_yz[j] * pc_z[j] + fl1_fx * pc_z[j] * pb_yzz[j] + pa_yz[j] * pb_yy[j] * pc_zz[j] + 4.0 * pa_yz[j] * pb_yz[j] * pc_yz[j] + pa_yz[j] * pc_yy[j] * pb_zz[j] + 2.0 * pa_y[j] * pc_zz[j] * pb_yyz[j] + 2.0 * pa_y[j] * pc_yz[j] * pb_yzz[j] + 2.0 * pc_yz[j] * pa_z[j] * pb_yyz[j] + 2.0 * pc_yy[j] * pa_z[j] * pb_yzz[j] + pc_yz[j] * pb_yyzz[j]);

                t_yz_yyzz[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 4.5 * pc_yz[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * pa_yz[j] * pc_yy[j] * fl1_fx - 0.5 * pa_yz[j] * fl1_fx * pc_zz[j] - 3.0 * pa_y[j] * pc_yz[j] * pb_y[j] * fl1_fx - 1.5 * pa_y[j] * pc_yyz[j] * fl1_fx - 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx - pa_y[j] * pc_zz[j] * fl1_fx * pb_z[j] - pa_y[j] * fl1_fx * pc_yy[j] * pb_z[j] - pc_yy[j] * pa_z[j] * pb_y[j] * fl1_fx - 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yzz[j] * pa_z[j] * fl1_fx - 3.0 * pc_yz[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * pb_yy[j] * fl1_fx - 3.0 * pc_yyz[j] * pb_y[j] * fl1_fx - 3.0 * pc_yzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_zz[j] - pc_yyy[j] * fl1_fx * pb_z[j] - 2.0 * pc_yy[j] * fl1_fx * pb_yz[j] - fl1_fx * pc_zzz[j] * pb_y[j] - fl1_fx * pa_z[j] * pb_y[j] * pc_zz[j] - 2.0 * fl1_fx * pc_zz[j] * pb_yz[j] - 2.0 * pa_yz[j] * pb_y[j] * pc_yzz[j] - 2.0 * pa_yz[j] * pc_yyz[j] * pb_z[j] - pa_y[j] * pc_zzz[j] * pb_yy[j] - 4.0 * pa_y[j] * pc_yzz[j] * pb_yz[j] - pa_y[j] * pc_yyz[j] * pb_zz[j] - pc_yzz[j] * pa_z[j] * pb_yy[j] - 4.0 * pc_yyz[j] * pa_z[j] * pb_yz[j] - pc_yyy[j] * pa_z[j] * pb_zz[j] - 2.0 * pc_yzz[j] * pb_yyz[j] - 2.0 * pc_yyz[j] * pb_yzz[j]);

                t_yz_yyzz[j] += fl_s_0_0_4 * (2.25 * pc_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_yyz[j] * fl1_fx + 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx + 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yzz[j] * pa_z[j] * fl1_fx + 3.0 * pc_yyz[j] * pb_y[j] * fl1_fx + 1.5 * pc_yyyz[j] * fl1_fx + 1.5 * pc_yzzz[j] * fl1_fx + 3.0 * pc_yzz[j] * fl1_fx * pb_z[j] + pc_yyy[j] * fl1_fx * pb_z[j] + fl1_fx * pc_zzz[j] * pb_y[j] + pa_yz[j] * pc_yyzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yyzz[j] * pb_z[j] + 2.0 * pc_yyzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_yyyz[j] * pa_z[j] * pb_z[j] + pc_yzzz[j] * pb_yy[j] + 4.0 * pc_yyzz[j] * pb_yz[j] + pc_yyyz[j] * pb_zz[j]);

                t_yz_yyzz[j] += fl_s_0_0_5 * (-1.5 * pc_yyyz[j] * fl1_fx - 1.5 * pc_yzzz[j] * fl1_fx - pa_y[j] * pc_yyzzz[j] - pc_yyyzz[j] * pa_z[j] - 2.0 * pc_yyzzz[j] * pb_y[j] - 2.0 * pc_yyyzz[j] * pb_z[j]);

                t_yz_yyzz[j] += fl_s_0_0_6 * pc_yyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_73_74(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (73,74)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yzzz = pbDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyzzzz = pcDistances.data(83 * idx + 80);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_yzzz = primBuffer.data(90 * idx + 73);

            // Batch of Integrals (73,74)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_y, pb_yz, pb_yzz, pb_yzzz, pb_z, pb_zz, pb_zzz, pc_y, \
                                     pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yyzzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yz_yzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yz_yzzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_zz[j] + 1.5 * pa_yz[j] * pb_yz[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pa_z[j] * pb_zzz[j] + pa_yz[j] * pb_yzzz[j]);

                t_yz_yzzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_y[j] * fl2_fx * pb_y[j] - 0.75 * pa_y[j] * fl2_fx * pc_y[j] - 0.75 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 2.25 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * fl2_fx * pb_zz[j] - 1.5 * pa_yz[j] * pb_yz[j] * fl1_fx - 1.5 * pa_yz[j] * pb_y[j] * pc_z[j] * fl1_fx - 1.5 * pa_yz[j] * pc_y[j] * pb_z[j] * fl1_fx - 4.5 * pa_y[j] * pc_z[j] * pb_yz[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pc_y[j] * pb_zz[j] - 1.5 * pa_y[j] * fl1_fx * pb_yzz[j] - 1.5 * pc_y[j] * pa_z[j] * pb_yz[j] * fl1_fx - 1.5 * pc_y[j] * fl1_fx * pb_yzz[j] - 1.5 * fl1_fx * pa_z[j] * pb_zz[j] * pc_z[j] - 0.5 * fl1_fx * pc_z[j] * pb_zzz[j] - 0.5 * fl1_fx * pa_z[j] * pb_zzz[j] - 3.0 * pa_yz[j] * pb_yzz[j] * pc_z[j] - pa_yz[j] * pc_y[j] * pb_zzz[j] - pa_y[j] * pc_z[j] * pb_yzzz[j] - pc_y[j] * pa_z[j] * pb_yzzz[j]);

                t_yz_yzzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_y[j] * fl2_fx * pc_y[j] + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 1.5 * pc_y[j] * fl2_fx * pb_y[j] + 0.75 * pc_yy[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pc_z[j] + 4.5 * fl2_fx * pc_z[j] * pb_z[j] + 1.5 * fl2_fx * pc_zz[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.75 * fl2_fx * pb_zz[j] + 1.5 * pa_yz[j] * pb_y[j] * pc_z[j] * fl1_fx + 1.5 * pa_yz[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_yz[j] * pc_yz[j] * fl1_fx + 4.5 * pa_y[j] * pc_z[j] * pb_yz[j] * fl1_fx + 3.0 * pa_y[j] * pc_zz[j] * pb_y[j] * fl1_fx + 4.5 * pa_y[j] * pc_yz[j] * pb_z[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pc_y[j] * pb_zz[j] + 1.5 * pc_y[j] * pa_z[j] * pb_yz[j] * fl1_fx + 1.5 * pc_yz[j] * pa_z[j] * pb_y[j] * fl1_fx + 1.5 * pc_yy[j] * pa_z[j] * pb_z[j] * fl1_fx + 4.5 * pc_yz[j] * pb_yz[j] * fl1_fx + 1.5 * pc_yy[j] * fl1_fx * pb_zz[j] + 1.5 * pc_y[j] * fl1_fx * pb_yzz[j] + 1.5 * fl1_fx * pa_z[j] * pb_z[j] * pc_zz[j] + 1.5 * fl1_fx * pc_zz[j] * pb_zz[j] + 1.5 * fl1_fx * pa_z[j] * pb_zz[j] * pc_z[j] + 0.5 * fl1_fx * pc_z[j] * pb_zzz[j] + 3.0 * pa_yz[j] * pb_yz[j] * pc_zz[j] + 3.0 * pa_yz[j] * pc_yz[j] * pb_zz[j] + 3.0 * pa_y[j] * pc_zz[j] * pb_yzz[j] + pa_y[j] * pc_yz[j] * pb_zzz[j] + 3.0 * pc_yz[j] * pa_z[j] * pb_yzz[j] + pc_yy[j] * pa_z[j] * pb_zzz[j] + pc_yz[j] * pb_yzzz[j]);

                t_yz_yzzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 0.75 * pa_y[j] * fl2_fx * pc_y[j] - 1.5 * pc_yy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_y[j] - 3.0 * fl2_fx * pc_zz[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 2.25 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_yz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_y[j] * pc_zz[j] * pb_y[j] * fl1_fx - 4.5 * pa_y[j] * pc_yz[j] * pb_z[j] * fl1_fx - 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 1.5 * pc_yz[j] * pa_z[j] * pb_y[j] * fl1_fx - 1.5 * pc_yy[j] * pa_z[j] * pb_z[j] * fl1_fx - 1.5 * pc_yyz[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pb_yz[j] * fl1_fx - 3.0 * pc_yzz[j] * pb_y[j] * fl1_fx - 4.5 * pc_yyz[j] * pb_z[j] * fl1_fx - 1.5 * pc_yy[j] * fl1_fx * pb_zz[j] - 0.5 * fl1_fx * pa_z[j] * pc_zzz[j] - 1.5 * fl1_fx * pc_zzz[j] * pb_z[j] - 1.5 * fl1_fx * pa_z[j] * pb_z[j] * pc_zz[j] - 1.5 * fl1_fx * pc_zz[j] * pb_zz[j] - pa_yz[j] * pb_y[j] * pc_zzz[j] - 3.0 * pa_yz[j] * pc_yzz[j] * pb_z[j] - 3.0 * pa_y[j] * pc_zzz[j] * pb_yz[j] - 3.0 * pa_y[j] * pc_yzz[j] * pb_zz[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_yz[j] - 3.0 * pc_yyz[j] * pa_z[j] * pb_zz[j] - 3.0 * pc_yzz[j] * pb_yzz[j] - pc_yyz[j] * pb_zzz[j]);

                t_yz_yzzz[j] += fl_s_0_0_4 * (0.75 * pc_yy[j] * fl2_fx + 1.5 * fl2_fx * pc_zz[j] + 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx + 1.5 * pc_yyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_yzz[j] * pb_y[j] * fl1_fx + 4.5 * pc_yyz[j] * pb_z[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 0.5 * fl1_fx * pc_zzzz[j] + 0.5 * fl1_fx * pa_z[j] * pc_zzz[j] + 1.5 * fl1_fx * pc_zzz[j] * pb_z[j] + pa_yz[j] * pc_yzzz[j] + pa_y[j] * pc_zzzz[j] * pb_y[j] + 3.0 * pa_y[j] * pc_yzzz[j] * pb_z[j] + pc_yzzz[j] * pa_z[j] * pb_y[j] + 3.0 * pc_yyzz[j] * pa_z[j] * pb_z[j] + 3.0 * pc_yzzz[j] * pb_yz[j] + 3.0 * pc_yyzz[j] * pb_zz[j]);

                t_yz_yzzz[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - pa_y[j] * pc_yzzzz[j] - pc_yyzzz[j] * pa_z[j] - pc_yzzzz[j] * pb_y[j] - 3.0 * pc_yyzzz[j] * pb_z[j]);

                t_yz_yzzz[j] += fl_s_0_0_6 * pc_yyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_74_75(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (74,75)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(9 * idx + 1);

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_zzzz = pbDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yzzzzz = pcDistances.data(83 * idx + 81);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yz_zzzz = primBuffer.data(90 * idx + 74);

            // Batch of Integrals (74,75)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_z, pb_z, pb_zz, pb_zzz, pb_zzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, \
                                     pc_yzzzz, pc_yzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yz_zzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yz_zzzz[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 3.0 * pa_y[j] * fl2_fx * pb_z[j] + 3.0 * pa_yz[j] * pb_zz[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pb_zzz[j] + pa_yz[j] * pb_zzzz[j]);

                t_yz_zzzz[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 3.75 * pa_y[j] * pc_z[j] * fl2_fx - 6.0 * pa_y[j] * fl2_fx * pb_z[j] - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 3.0 * pc_y[j] * fl2_fx * pb_z[j] - 3.0 * pa_yz[j] * pb_zz[j] * fl1_fx - 6.0 * pa_yz[j] * pb_z[j] * pc_z[j] * fl1_fx - 9.0 * pa_y[j] * pc_z[j] * pb_zz[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pb_zzz[j] - 3.0 * pc_y[j] * pa_z[j] * pb_zz[j] * fl1_fx - 2.0 * pc_y[j] * fl1_fx * pb_zzz[j] - 4.0 * pa_yz[j] * pb_zzz[j] * pc_z[j] - pa_y[j] * pc_z[j] * pb_zzzz[j] - pc_y[j] * pa_z[j] * pb_zzzz[j]);

                t_yz_zzzz[j] += fl_s_0_0_2 * (0.75 * pa_yz[j] * fl2_fx + 7.5 * pa_y[j] * pc_z[j] * fl2_fx + 3.0 * pa_y[j] * fl2_fx * pb_z[j] + 1.5 * pc_y[j] * pa_z[j] * fl2_fx + 3.75 * pc_yz[j] * fl2_fx + 6.0 * pc_y[j] * fl2_fx * pb_z[j] + 6.0 * pa_yz[j] * pb_z[j] * pc_z[j] * fl1_fx + 3.0 * pa_yz[j] * pc_zz[j] * fl1_fx + 9.0 * pa_y[j] * pc_z[j] * pb_zz[j] * fl1_fx + 12.0 * pa_y[j] * pc_zz[j] * pb_z[j] * fl1_fx + 3.0 * pc_y[j] * pa_z[j] * pb_zz[j] * fl1_fx + 6.0 * pc_yz[j] * pa_z[j] * pb_z[j] * fl1_fx + 9.0 * pc_yz[j] * pb_zz[j] * fl1_fx + 2.0 * pc_y[j] * fl1_fx * pb_zzz[j] + 6.0 * pa_yz[j] * pb_zz[j] * pc_zz[j] + 4.0 * pa_y[j] * pc_zz[j] * pb_zzz[j] + 4.0 * pc_yz[j] * pa_z[j] * pb_zzz[j] + pc_yz[j] * pb_zzzz[j]);

                t_yz_zzzz[j] += fl_s_0_0_3 * (-3.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 7.5 * pc_yz[j] * fl2_fx - 3.0 * pc_y[j] * fl2_fx * pb_z[j] - 3.0 * pa_yz[j] * pc_zz[j] * fl1_fx - 12.0 * pa_y[j] * pc_zz[j] * pb_z[j] * fl1_fx - 5.0 * pa_y[j] * pc_zzz[j] * fl1_fx - 6.0 * pc_yz[j] * pa_z[j] * pb_z[j] * fl1_fx - 3.0 * pc_yzz[j] * pa_z[j] * fl1_fx - 9.0 * pc_yz[j] * pb_zz[j] * fl1_fx - 12.0 * pc_yzz[j] * pb_z[j] * fl1_fx - 4.0 * pa_yz[j] * pb_z[j] * pc_zzz[j] - 6.0 * pa_y[j] * pc_zzz[j] * pb_zz[j] - 6.0 * pc_yzz[j] * pa_z[j] * pb_zz[j] - 4.0 * pc_yzz[j] * pb_zzz[j]);

                t_yz_zzzz[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 5.0 * pa_y[j] * pc_zzz[j] * fl1_fx + 3.0 * pc_yzz[j] * pa_z[j] * fl1_fx + 12.0 * pc_yzz[j] * pb_z[j] * fl1_fx + 5.0 * pc_yzzz[j] * fl1_fx + pa_yz[j] * pc_zzzz[j] + 4.0 * pa_y[j] * pc_zzzz[j] * pb_z[j] + 4.0 * pc_yzzz[j] * pa_z[j] * pb_z[j] + 6.0 * pc_yzzz[j] * pb_zz[j]);

                t_yz_zzzz[j] += fl_s_0_0_5 * (-5.0 * pc_yzzz[j] * fl1_fx - pa_y[j] * pc_zzzzz[j] - pc_yzzzz[j] * pa_z[j] - 4.0 * pc_yzzzz[j] * pb_z[j]);

                t_yz_zzzz[j] += fl_s_0_0_6 * pc_yzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_75_76(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (75,76)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxx = pbDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxzz = pcDistances.data(83 * idx + 60);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xxxx = primBuffer.data(90 * idx + 75);

            // Batch of Integrals (75,76)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxx, pb_xxxx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxz, pc_xxxxzz, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, pc_xz, pc_xzz, pc_z, pc_zz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_xxxx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zz_xxxx[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_zz[j] * fl2_fx + 1.5 * fl2_fx * pb_xx[j] + 3.0 * pa_zz[j] * pb_xx[j] * fl1_fx + 0.5 * fl1_fx * pb_xxxx[j] + pa_zz[j] * pb_xxxx[j]);

                t_zz_xxxx[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_zz[j] * fl2_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 3.0 * fl2_fx * pb_xx[j] - 3.0 * fl2_fx * pb_x[j] * pc_x[j] - 3.0 * pa_zz[j] * pb_xx[j] * fl1_fx - 6.0 * pa_zz[j] * pb_x[j] * pc_x[j] * fl1_fx - 6.0 * pa_z[j] * pc_z[j] * pb_xx[j] * fl1_fx - 2.0 * fl1_fx * pb_xxx[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxxx[j] - 4.0 * pa_zz[j] * pb_xxx[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxxx[j]);

                t_zz_xxxx[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_zz[j] * fl2_fx + 3.0 * pa_z[j] * pc_z[j] * fl2_fx + 0.75 * pc_zz[j] * fl2_fx + 6.0 * fl2_fx * pb_x[j] * pc_x[j] + 1.5 * fl2_fx * pc_xx[j] + 1.5 * fl2_fx * pb_xx[j] + 6.0 * pa_zz[j] * pb_x[j] * pc_x[j] * fl1_fx + 3.0 * pa_zz[j] * pc_xx[j] * fl1_fx + 6.0 * pa_z[j] * pc_z[j] * pb_xx[j] * fl1_fx + 12.0 * pa_z[j] * pc_xz[j] * pb_x[j] * fl1_fx + 3.0 * pc_zz[j] * pb_xx[j] * fl1_fx + 3.0 * fl1_fx * pb_xx[j] * pc_xx[j] + 2.0 * fl1_fx * pb_xxx[j] * pc_x[j] + 6.0 * pa_zz[j] * pb_xx[j] * pc_xx[j] + 8.0 * pa_z[j] * pc_xz[j] * pb_xxx[j] + pc_zz[j] * pb_xxxx[j]);

                t_zz_xxxx[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 1.5 * pc_zz[j] * fl2_fx - 3.0 * fl2_fx * pc_xx[j] - 3.0 * fl2_fx * pb_x[j] * pc_x[j] - 3.0 * pa_zz[j] * pc_xx[j] * fl1_fx - 12.0 * pa_z[j] * pc_xz[j] * pb_x[j] * fl1_fx - 6.0 * pa_z[j] * pc_xxz[j] * fl1_fx - 3.0 * pc_zz[j] * pb_xx[j] * fl1_fx - 6.0 * pc_xzz[j] * pb_x[j] * fl1_fx - 2.0 * fl1_fx * pb_x[j] * pc_xxx[j] - 3.0 * fl1_fx * pb_xx[j] * pc_xx[j] - 4.0 * pa_zz[j] * pb_x[j] * pc_xxx[j] - 12.0 * pa_z[j] * pc_xxz[j] * pb_xx[j] - 4.0 * pc_xzz[j] * pb_xxx[j]);

                t_zz_xxxx[j] += fl_s_0_0_4 * (0.75 * pc_zz[j] * fl2_fx + 1.5 * fl2_fx * pc_xx[j] + 6.0 * pa_z[j] * pc_xxz[j] * fl1_fx + 6.0 * pc_xzz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 0.5 * fl1_fx * pc_xxxx[j] + 2.0 * fl1_fx * pb_x[j] * pc_xxx[j] + pa_zz[j] * pc_xxxx[j] + 8.0 * pa_z[j] * pc_xxxz[j] * pb_x[j] + 6.0 * pc_xxzz[j] * pb_xx[j]);

                t_zz_xxxx[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxxx[j] - 2.0 * pa_z[j] * pc_xxxxz[j] - 4.0 * pc_xxxzz[j] * pb_x[j]);

                t_zz_xxxx[j] += fl_s_0_0_6 * pc_xxxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_76_77(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (76,77)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxy = pbDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xxxy = primBuffer.data(90 * idx + 76);

            // Batch of Integrals (76,77)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxx, pb_xxxy, pb_xxy, pb_xy, pb_y, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, pc_xxy, pc_xxyz, pc_xxyzz, \
                                     pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_xxxy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xxxy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_zz[j] * pb_xy[j] * fl1_fx + 0.5 * fl1_fx * pb_xxxy[j] + pa_zz[j] * pb_xxxy[j]);

                t_zz_xxxy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_x[j] * pc_y[j] - 1.5 * fl2_fx * pb_xy[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_zz[j] * pb_x[j] * fl1_fx * pc_y[j] - 1.5 * pa_zz[j] * pb_xy[j] * fl1_fx - 1.5 * pa_zz[j] * pc_x[j] * fl1_fx * pb_y[j] - 3.0 * pa_z[j] * pc_z[j] * pb_xy[j] * fl1_fx - 0.5 * fl1_fx * pb_xxx[j] * pc_y[j] - 1.5 * fl1_fx * pb_xxy[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxxy[j] - pa_zz[j] * pb_xxx[j] * pc_y[j] - 3.0 * pa_zz[j] * pb_xxy[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxxy[j]);

                t_zz_xxxy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pb_x[j] * pc_y[j] + 0.75 * fl2_fx * pc_xy[j] + 1.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_zz[j] * pb_x[j] * fl1_fx * pc_y[j] + 1.5 * pa_zz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_zz[j] * pc_x[j] * fl1_fx * pb_y[j] + 3.0 * pa_z[j] * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_xy[j] * fl1_fx + 3.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pc_zz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pb_xx[j] * pc_xy[j] + 1.5 * fl1_fx * pb_xy[j] * pc_xx[j] + 0.5 * fl1_fx * pb_xxx[j] * pc_y[j] + 1.5 * fl1_fx * pb_xxy[j] * pc_x[j] + 3.0 * pa_zz[j] * pb_xx[j] * pc_xy[j] + 3.0 * pa_zz[j] * pb_xy[j] * pc_xx[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_xxx[j] + 6.0 * pa_z[j] * pc_xz[j] * pb_xxy[j] + pc_zz[j] * pb_xxxy[j]);

                t_zz_xxxy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xy[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_zz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_z[j] * pc_yz[j] * pb_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx - 1.5 * pc_zz[j] * pb_xy[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] - 1.5 * fl1_fx * pb_x[j] * pc_xxy[j] - 0.5 * fl1_fx * pc_xxx[j] * pb_y[j] - 1.5 * fl1_fx * pb_xx[j] * pc_xy[j] - 1.5 * fl1_fx * pb_xy[j] * pc_xx[j] - 3.0 * pa_zz[j] * pb_x[j] * pc_xxy[j] - pa_zz[j] * pc_xxx[j] * pb_y[j] - 6.0 * pa_z[j] * pc_xyz[j] * pb_xx[j] - 6.0 * pa_z[j] * pc_xxz[j] * pb_xy[j] - pc_yzz[j] * pb_xxx[j] - 3.0 * pc_xzz[j] * pb_xxy[j]);

                t_zz_xxxy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xy[j] + 3.0 * pa_z[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xxxy[j] + 1.5 * fl1_fx * pb_x[j] * pc_xxy[j] + 0.5 * fl1_fx * pc_xxx[j] * pb_y[j] + pa_zz[j] * pc_xxxy[j] + 6.0 * pa_z[j] * pc_xxyz[j] * pb_x[j] + 2.0 * pa_z[j] * pc_xxxz[j] * pb_y[j] + 3.0 * pc_xyzz[j] * pb_xx[j] + 3.0 * pc_xxzz[j] * pb_xy[j]);

                t_zz_xxxy[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxxy[j] - 2.0 * pa_z[j] * pc_xxxyz[j] - 3.0 * pc_xxyzz[j] * pb_x[j] - pc_xxxzz[j] * pb_y[j]);

                t_zz_xxxy[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_77_78(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (77,78)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxx = pbDistances.data(34 * idx + 9);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxxz = pbDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxzzz = pcDistances.data(83 * idx + 64);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xxxz = primBuffer.data(90 * idx + 77);

            // Batch of Integrals (77,78)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxx, pb_xxxz, pb_xxz, pb_xz, pb_z, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxz, pc_xxxzz, pc_xxxzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_zz_xxxz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xxxz[j] = fl_s_0_0_0 * (1.5 * pa_z[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_zz[j] * pb_xz[j] * fl1_fx + pa_z[j] * fl1_fx * pb_xxx[j] + 0.5 * fl1_fx * pb_xxxz[j] + pa_zz[j] * pb_xxxz[j]);

                t_zz_xxxz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx * pb_x[j] - 1.5 * pa_z[j] * fl2_fx * pc_x[j] - 2.25 * pc_z[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pb_xz[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_zz[j] * pb_x[j] * fl1_fx * pc_z[j] - 1.5 * pa_zz[j] * pb_xz[j] * fl1_fx - 1.5 * pa_zz[j] * pc_x[j] * fl1_fx * pb_z[j] - 3.0 * pa_z[j] * pc_z[j] * pb_xz[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pb_xx[j] * pc_x[j] - pa_z[j] * fl1_fx * pb_xxx[j] - 1.5 * pc_z[j] * fl1_fx * pb_xxx[j] - 1.5 * fl1_fx * pb_xxz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxxz[j] - pa_zz[j] * pb_xxx[j] * pc_z[j] - 3.0 * pa_zz[j] * pb_xxz[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxxz[j]);

                t_zz_xxxz[j] += fl_s_0_0_2 * (3.0 * pa_z[j] * fl2_fx * pc_x[j] + 1.5 * pa_z[j] * fl2_fx * pb_x[j] + 4.5 * pc_z[j] * fl2_fx * pb_x[j] + 2.25 * pc_xz[j] * fl2_fx + 1.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 1.5 * pa_zz[j] * pb_x[j] * fl1_fx * pc_z[j] + 1.5 * pa_zz[j] * pc_xz[j] * fl1_fx + 1.5 * pa_zz[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_xz[j] * fl1_fx + 3.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_z[j] + 3.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_xx[j] + 3.0 * pa_z[j] * fl1_fx * pb_xx[j] * pc_x[j] + 1.5 * pc_zz[j] * pb_xz[j] * fl1_fx + 4.5 * pc_xz[j] * fl1_fx * pb_xx[j] + 1.5 * pc_z[j] * fl1_fx * pb_xxx[j] + 1.5 * fl1_fx * pb_xz[j] * pc_xx[j] + 1.5 * fl1_fx * pb_xxz[j] * pc_x[j] + 3.0 * pa_zz[j] * pb_xx[j] * pc_xz[j] + 3.0 * pa_zz[j] * pb_xz[j] * pc_xx[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_xxx[j] + 6.0 * pa_z[j] * pc_xz[j] * pb_xxz[j] + pc_zz[j] * pb_xxxz[j]);

                t_zz_xxxz[j] += fl_s_0_0_3 * (-1.5 * pa_z[j] * fl2_fx * pc_x[j] - 4.5 * pc_xz[j] * fl2_fx - 2.25 * pc_z[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_zz[j] * pc_xz[j] * fl1_fx - 3.0 * pa_z[j] * pc_zz[j] * pb_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_xzz[j] * fl1_fx - 3.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_z[j] - pa_z[j] * fl1_fx * pc_xxx[j] - 3.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_xx[j] - 1.5 * pc_zzz[j] * pb_x[j] * fl1_fx - 1.5 * pc_zz[j] * pb_xz[j] * fl1_fx - 1.5 * pc_xzz[j] * fl1_fx * pb_z[j] - 4.5 * pc_xxz[j] * fl1_fx * pb_x[j] - 4.5 * pc_xz[j] * fl1_fx * pb_xx[j] - 0.5 * fl1_fx * pc_xxx[j] * pb_z[j] - 1.5 * fl1_fx * pb_xz[j] * pc_xx[j] - 3.0 * pa_zz[j] * pb_x[j] * pc_xxz[j] - pa_zz[j] * pc_xxx[j] * pb_z[j] - 6.0 * pa_z[j] * pc_xzz[j] * pb_xx[j] - 6.0 * pa_z[j] * pc_xxz[j] * pb_xz[j] - pc_zzz[j] * pb_xxx[j] - 3.0 * pc_xzz[j] * pb_xxz[j]);

                t_zz_xxxz[j] += fl_s_0_0_4 * (2.25 * pc_xz[j] * fl2_fx + 3.0 * pa_z[j] * pc_xzz[j] * fl1_fx + pa_z[j] * fl1_fx * pc_xxx[j] + 1.5 * pc_zzz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xzzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pb_z[j] + 1.5 * pc_xxxz[j] * fl1_fx + 4.5 * pc_xxz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_xxx[j] * pb_z[j] + pa_zz[j] * pc_xxxz[j] + 6.0 * pa_z[j] * pc_xxzz[j] * pb_x[j] + 2.0 * pa_z[j] * pc_xxxz[j] * pb_z[j] + 3.0 * pc_xzzz[j] * pb_xx[j] + 3.0 * pc_xxzz[j] * pb_xz[j]);

                t_zz_xxxz[j] += fl_s_0_0_5 * (-1.5 * pc_xzzz[j] * fl1_fx - 1.5 * pc_xxxz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xxxzz[j] - 3.0 * pc_xxzzz[j] * pb_x[j] - pc_xxxzz[j] * pb_z[j]);

                t_zz_xxxz[j] += fl_s_0_0_6 * pc_xxxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_78_79(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (78,79)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyy = pbDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xxyy = primBuffer.data(90 * idx + 78);

            // Batch of Integrals (78,79)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxy, pb_xxyy, pb_xy, pb_xyy, pb_y, pb_yy, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_zz_xxyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zz_xxyy[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_zz[j] * fl2_fx + 0.25 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_zz[j] * pb_xx[j] * fl1_fx + 0.5 * pa_zz[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pb_xxyy[j] + pa_zz[j] * pb_xxyy[j]);

                t_zz_xxyy[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_zz[j] * fl2_fx - 0.5 * pa_z[j] * pc_z[j] * fl2_fx - 0.5 * fl2_fx * pb_xx[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * fl2_fx * pb_yy[j] - 0.5 * pa_zz[j] * pb_xx[j] * fl1_fx - pa_zz[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_zz[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_zz[j] * fl1_fx * pb_yy[j] - pa_z[j] * pc_z[j] * pb_xx[j] * fl1_fx - pa_z[j] * pc_z[j] * fl1_fx * pb_yy[j] - fl1_fx * pb_xxy[j] * pc_y[j] - fl1_fx * pb_xyy[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxyy[j] - 2.0 * pa_zz[j] * pb_xxy[j] * pc_y[j] - 2.0 * pa_zz[j] * pb_xyy[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxyy[j]);

                t_zz_xxyy[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_zz[j] * fl2_fx + pa_z[j] * pc_z[j] * fl2_fx + 0.25 * pc_zz[j] * fl2_fx + fl2_fx * pb_x[j] * pc_x[j] + 0.25 * fl2_fx * pc_xx[j] + 0.25 * fl2_fx * pc_yy[j] + fl2_fx * pb_y[j] * pc_y[j] + 0.25 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_yy[j] + pa_zz[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_zz[j] * pc_xx[j] * fl1_fx + 0.5 * pa_zz[j] * fl1_fx * pc_yy[j] + pa_zz[j] * fl1_fx * pb_y[j] * pc_y[j] + pa_z[j] * pc_z[j] * pb_xx[j] * fl1_fx + 2.0 * pa_z[j] * pc_xz[j] * pb_x[j] * fl1_fx + 2.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_y[j] + pa_z[j] * pc_z[j] * fl1_fx * pb_yy[j] + 0.5 * pc_zz[j] * pb_xx[j] * fl1_fx + 0.5 * pc_zz[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pb_xx[j] * pc_yy[j] + 2.0 * fl1_fx * pb_xy[j] * pc_xy[j] + 0.5 * fl1_fx * pc_xx[j] * pb_yy[j] + fl1_fx * pb_xxy[j] * pc_y[j] + fl1_fx * pb_xyy[j] * pc_x[j] + pa_zz[j] * pb_xx[j] * pc_yy[j] + 4.0 * pa_zz[j] * pb_xy[j] * pc_xy[j] + pa_zz[j] * pc_xx[j] * pb_yy[j] + 4.0 * pa_z[j] * pc_yz[j] * pb_xxy[j] + 4.0 * pa_z[j] * pc_xz[j] * pb_xyy[j] + pc_zz[j] * pb_xxyy[j]);

                t_zz_xxyy[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_z[j] * pc_z[j] * fl2_fx - 0.5 * pc_zz[j] * fl2_fx - 0.5 * fl2_fx * pc_xx[j] - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * pa_zz[j] * pc_xx[j] * fl1_fx - 0.5 * pa_zz[j] * fl1_fx * pc_yy[j] - 2.0 * pa_z[j] * pc_xz[j] * pb_x[j] * fl1_fx - pa_z[j] * pc_xxz[j] * fl1_fx - pa_z[j] * pc_yyz[j] * fl1_fx - 2.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * pc_zz[j] * pb_xx[j] * fl1_fx - pc_xzz[j] * pb_x[j] * fl1_fx - pc_yzz[j] * fl1_fx * pb_y[j] - 0.5 * pc_zz[j] * fl1_fx * pb_yy[j] - fl1_fx * pb_x[j] * pc_xyy[j] - fl1_fx * pc_xxy[j] * pb_y[j] - 0.5 * fl1_fx * pb_xx[j] * pc_yy[j] - 2.0 * fl1_fx * pb_xy[j] * pc_xy[j] - 0.5 * fl1_fx * pc_xx[j] * pb_yy[j] - 2.0 * pa_zz[j] * pb_x[j] * pc_xyy[j] - 2.0 * pa_zz[j] * pc_xxy[j] * pb_y[j] - 2.0 * pa_z[j] * pc_yyz[j] * pb_xx[j] - 8.0 * pa_z[j] * pc_xyz[j] * pb_xy[j] - 2.0 * pa_z[j] * pc_xxz[j] * pb_yy[j] - 2.0 * pc_yzz[j] * pb_xxy[j] - 2.0 * pc_xzz[j] * pb_xyy[j]);

                t_zz_xxyy[j] += fl_s_0_0_4 * (0.25 * pc_zz[j] * fl2_fx + 0.25 * fl2_fx * pc_xx[j] + 0.25 * fl2_fx * pc_yy[j] + pa_z[j] * pc_xxz[j] * fl1_fx + pa_z[j] * pc_yyz[j] * fl1_fx + pc_xzz[j] * pb_x[j] * fl1_fx + 0.5 * pc_xxzz[j] * fl1_fx + 0.5 * pc_yyzz[j] * fl1_fx + pc_yzz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xxyy[j] + fl1_fx * pb_x[j] * pc_xyy[j] + fl1_fx * pc_xxy[j] * pb_y[j] + pa_zz[j] * pc_xxyy[j] + 4.0 * pa_z[j] * pc_xyyz[j] * pb_x[j] + 4.0 * pa_z[j] * pc_xxyz[j] * pb_y[j] + pc_yyzz[j] * pb_xx[j] + 4.0 * pc_xyzz[j] * pb_xy[j] + pc_xxzz[j] * pb_yy[j]);

                t_zz_xxyy[j] += fl_s_0_0_5 * (-0.5 * pc_xxzz[j] * fl1_fx - 0.5 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xxyy[j] - 2.0 * pa_z[j] * pc_xxyyz[j] - 2.0 * pc_xyyzz[j] * pb_x[j] - 2.0 * pc_xxyzz[j] * pb_y[j]);

                t_zz_xxyy[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_79_80(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (79,80)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxy = pbDistances.data(34 * idx + 10);

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxyz = pbDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xxyz = primBuffer.data(90 * idx + 79);

            // Batch of Integrals (79,80)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxy, pb_xxyz, pb_xxz, pb_xy, pb_xyz, pb_xz, pb_y, \
                                     pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, \
                                     pc_xxzzz, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_zz_xxyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xxyz[j] = fl_s_0_0_0 * (0.5 * pa_z[j] * fl2_fx * pb_y[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_zz[j] * fl1_fx * pb_yz[j] + pa_z[j] * fl1_fx * pb_xxy[j] + 0.5 * fl1_fx * pb_xxyz[j] + pa_zz[j] * pb_xxyz[j]);

                t_zz_xxyz[j] += fl_s_0_0_1 * (-0.5 * pa_z[j] * fl2_fx * pc_y[j] - pa_z[j] * fl2_fx * pb_y[j] - 0.75 * pc_z[j] * fl2_fx * pb_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * fl2_fx * pb_yz[j] - 0.5 * pa_zz[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_zz[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_zz[j] * fl1_fx * pb_yz[j] - pa_z[j] * pc_z[j] * fl1_fx * pb_yz[j] - pa_z[j] * fl1_fx * pb_xx[j] * pc_y[j] - 2.0 * pa_z[j] * fl1_fx * pb_xy[j] * pc_x[j] - pa_z[j] * fl1_fx * pb_xxy[j] - 1.5 * pc_z[j] * fl1_fx * pb_xxy[j] - 0.5 * fl1_fx * pb_xxz[j] * pc_y[j] - fl1_fx * pb_xyz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxyz[j] - pa_zz[j] * pb_xxy[j] * pc_z[j] - pa_zz[j] * pb_xxz[j] * pc_y[j] - 2.0 * pa_zz[j] * pb_xyz[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxyz[j]);

                t_zz_xxyz[j] += fl_s_0_0_2 * (pa_z[j] * fl2_fx * pc_y[j] + 0.5 * pa_z[j] * fl2_fx * pb_y[j] + 0.75 * pc_yz[j] * fl2_fx + 1.5 * pc_z[j] * fl2_fx * pb_y[j] + 0.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_zz[j] * fl1_fx * pc_yz[j] + 0.5 * pa_zz[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_zz[j] * fl1_fx * pc_y[j] * pb_z[j] + pa_z[j] * pc_zz[j] * fl1_fx * pb_y[j] + pa_z[j] * pc_yz[j] * fl1_fx * pb_z[j] + pa_z[j] * pc_z[j] * fl1_fx * pb_yz[j] + 2.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_xy[j] + pa_z[j] * fl1_fx * pc_xx[j] * pb_y[j] + pa_z[j] * fl1_fx * pb_xx[j] * pc_y[j] + 2.0 * pa_z[j] * fl1_fx * pb_xy[j] * pc_x[j] + 0.5 * pc_zz[j] * fl1_fx * pb_yz[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] + 3.0 * pc_xz[j] * fl1_fx * pb_xy[j] + 1.5 * pc_z[j] * fl1_fx * pb_xxy[j] + fl1_fx * pb_xz[j] * pc_xy[j] + 0.5 * fl1_fx * pc_xx[j] * pb_yz[j] + 0.5 * fl1_fx * pb_xxz[j] * pc_y[j] + fl1_fx * pb_xyz[j] * pc_x[j] + pa_zz[j] * pb_xx[j] * pc_yz[j] + 2.0 * pa_zz[j] * pb_xy[j] * pc_xz[j] + 2.0 * pa_zz[j] * pb_xz[j] * pc_xy[j] + pa_zz[j] * pc_xx[j] * pb_yz[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_xxy[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_xxz[j] + 4.0 * pa_z[j] * pc_xz[j] * pb_xyz[j] + pc_zz[j] * pb_xxyz[j]);

                t_zz_xxyz[j] += fl_s_0_0_3 * (-0.5 * pa_z[j] * fl2_fx * pc_y[j] - 1.5 * pc_yz[j] * fl2_fx - 0.75 * pc_z[j] * fl2_fx * pb_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * pa_zz[j] * fl1_fx * pc_yz[j] - pa_z[j] * pc_yzz[j] * fl1_fx - pa_z[j] * pc_zz[j] * fl1_fx * pb_y[j] - pa_z[j] * pc_yz[j] * fl1_fx * pb_z[j] - pa_z[j] * fl1_fx * pc_xxy[j] - 2.0 * pa_z[j] * fl1_fx * pb_x[j] * pc_xy[j] - pa_z[j] * fl1_fx * pc_xx[j] * pb_y[j] - 0.5 * pc_zzz[j] * fl1_fx * pb_y[j] - 0.5 * pc_yzz[j] * fl1_fx * pb_z[j] - 0.5 * pc_zz[j] * fl1_fx * pb_yz[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] - 3.0 * pc_xz[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pc_xxy[j] * pb_z[j] - fl1_fx * pb_xz[j] * pc_xy[j] - 0.5 * fl1_fx * pc_xx[j] * pb_yz[j] - 2.0 * pa_zz[j] * pb_x[j] * pc_xyz[j] - pa_zz[j] * pc_xxz[j] * pb_y[j] - pa_zz[j] * pc_xxy[j] * pb_z[j] - 2.0 * pa_z[j] * pc_yzz[j] * pb_xx[j] - 4.0 * pa_z[j] * pc_xzz[j] * pb_xy[j] - 4.0 * pa_z[j] * pc_xyz[j] * pb_xz[j] - 2.0 * pa_z[j] * pc_xxz[j] * pb_yz[j] - pc_zzz[j] * pb_xxy[j] - pc_yzz[j] * pb_xxz[j] - 2.0 * pc_xzz[j] * pb_xyz[j]);

                t_zz_xxyz[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + pa_z[j] * pc_yzz[j] * fl1_fx + pa_z[j] * fl1_fx * pc_xxy[j] + 0.5 * pc_yzzz[j] * fl1_fx + 0.5 * pc_zzz[j] * fl1_fx * pb_y[j] + 0.5 * pc_yzz[j] * fl1_fx * pb_z[j] + 1.5 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xxz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xxy[j] * pb_z[j] + pa_zz[j] * pc_xxyz[j] + 4.0 * pa_z[j] * pc_xyzz[j] * pb_x[j] + 2.0 * pa_z[j] * pc_xxzz[j] * pb_y[j] + 2.0 * pa_z[j] * pc_xxyz[j] * pb_z[j] + pc_yzzz[j] * pb_xx[j] + 2.0 * pc_xzzz[j] * pb_xy[j] + 2.0 * pc_xyzz[j] * pb_xz[j] + pc_xxzz[j] * pb_yz[j]);

                t_zz_xxyz[j] += fl_s_0_0_5 * (-0.5 * pc_yzzz[j] * fl1_fx - 1.5 * pc_xxyz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xxyzz[j] - 2.0 * pc_xyzzz[j] * pb_x[j] - pc_xxzzz[j] * pb_y[j] - pc_xxyzz[j] * pb_z[j]);

                t_zz_xxyz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_80_81(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (80,81)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(34 * idx + 3);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xxz = pbDistances.data(34 * idx + 11);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xxzz = pbDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxzzzz = pcDistances.data(83 * idx + 69);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xxzz = primBuffer.data(90 * idx + 80);

            // Batch of Integrals (80,81)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xx, pb_xxz, pb_xxzz, pb_xz, pb_xzz, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxz, pc_xxzz, pc_xxzzz, pc_xxzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_zz_xxzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zz_xxzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.25 * pa_zz[j] * fl2_fx + pa_z[j] * fl2_fx * pb_z[j] + 0.75 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_zz[j] * pb_xx[j] * fl1_fx + 0.5 * pa_zz[j] * fl1_fx * pb_zz[j] + 2.0 * pa_z[j] * fl1_fx * pb_xxz[j] + 0.5 * fl1_fx * pb_xxzz[j] + pa_zz[j] * pb_xxzz[j]);

                t_zz_xxzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 0.5 * pa_zz[j] * fl2_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 2.0 * pa_z[j] * fl2_fx * pb_z[j] - 1.5 * pc_z[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 1.5 * fl2_fx * pb_xx[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_zz[j] * pb_xx[j] * fl1_fx - pa_zz[j] * pb_x[j] * pc_x[j] * fl1_fx - pa_zz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_zz[j] * fl1_fx * pb_zz[j] - 3.0 * pa_z[j] * pc_z[j] * pb_xx[j] * fl1_fx - pa_z[j] * pc_z[j] * fl1_fx * pb_zz[j] - 4.0 * pa_z[j] * fl1_fx * pb_xz[j] * pc_x[j] - 2.0 * pa_z[j] * fl1_fx * pb_xxz[j] - 3.0 * pc_z[j] * fl1_fx * pb_xxz[j] - fl1_fx * pb_xzz[j] * pc_x[j] - 0.5 * fl1_fx * pb_xxzz[j] - 2.0 * pa_zz[j] * pb_xxz[j] * pc_z[j] - 2.0 * pa_zz[j] * pb_xzz[j] * pc_x[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xxzz[j]);

                t_zz_xxzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.25 * pa_zz[j] * fl2_fx + 3.0 * pa_z[j] * pc_z[j] * fl2_fx + pa_z[j] * fl2_fx * pb_z[j] + 1.5 * pc_zz[j] * fl2_fx + 3.0 * pc_z[j] * fl2_fx * pb_z[j] + 0.75 * fl2_fx * pc_xx[j] + 3.0 * fl2_fx * pb_x[j] * pc_x[j] + 0.75 * fl2_fx * pb_xx[j] + 0.25 * fl2_fx * pb_zz[j] + pa_zz[j] * pb_x[j] * pc_x[j] * fl1_fx + 0.5 * pa_zz[j] * pc_xx[j] * fl1_fx + 0.5 * pa_zz[j] * fl1_fx * pc_zz[j] + pa_zz[j] * fl1_fx * pb_z[j] * pc_z[j] + 3.0 * pa_z[j] * pc_z[j] * pb_xx[j] * fl1_fx + 6.0 * pa_z[j] * pc_xz[j] * pb_x[j] * fl1_fx + 2.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_z[j] + pa_z[j] * pc_z[j] * fl1_fx * pb_zz[j] + 2.0 * pa_z[j] * fl1_fx * pc_xx[j] * pb_z[j] + 4.0 * pa_z[j] * fl1_fx * pb_xz[j] * pc_x[j] + 3.0 * pc_zz[j] * pb_xx[j] * fl1_fx + 0.5 * pc_zz[j] * fl1_fx * pb_zz[j] + 6.0 * pc_xz[j] * fl1_fx * pb_xz[j] + 3.0 * pc_z[j] * fl1_fx * pb_xxz[j] + 0.5 * fl1_fx * pc_xx[j] * pb_zz[j] + fl1_fx * pb_xzz[j] * pc_x[j] + pa_zz[j] * pb_xx[j] * pc_zz[j] + 4.0 * pa_zz[j] * pb_xz[j] * pc_xz[j] + pa_zz[j] * pc_xx[j] * pb_zz[j] + 4.0 * pa_z[j] * pc_zz[j] * pb_xxz[j] + 4.0 * pa_z[j] * pc_xz[j] * pb_xzz[j] + pc_zz[j] * pb_xxzz[j]);

                t_zz_xxzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 3.0 * pc_zz[j] * fl2_fx - 1.5 * pc_z[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pc_xx[j] - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * pa_zz[j] * pc_xx[j] * fl1_fx - 0.5 * pa_zz[j] * fl1_fx * pc_zz[j] - 6.0 * pa_z[j] * pc_xz[j] * pb_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_xxz[j] * fl1_fx - pa_z[j] * pc_zzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_z[j] - 2.0 * pa_z[j] * fl1_fx * pc_xx[j] * pb_z[j] - 3.0 * pc_zz[j] * pb_xx[j] * fl1_fx - 6.0 * pc_xzz[j] * pb_x[j] * fl1_fx - pc_zzz[j] * fl1_fx * pb_z[j] - 0.5 * pc_zz[j] * fl1_fx * pb_zz[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] - 6.0 * pc_xz[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pc_xx[j] * pb_zz[j] - 2.0 * pa_zz[j] * pb_x[j] * pc_xzz[j] - 2.0 * pa_zz[j] * pc_xxz[j] * pb_z[j] - 2.0 * pa_z[j] * pc_zzz[j] * pb_xx[j] - 8.0 * pa_z[j] * pc_xzz[j] * pb_xz[j] - 2.0 * pa_z[j] * pc_xxz[j] * pb_zz[j] - 2.0 * pc_zzz[j] * pb_xxz[j] - 2.0 * pc_xzz[j] * pb_xzz[j]);

                t_zz_xxzz[j] += fl_s_0_0_4 * (1.5 * pc_zz[j] * fl2_fx + 0.75 * fl2_fx * pc_xx[j] + 3.0 * pa_z[j] * pc_xxz[j] * fl1_fx + pa_z[j] * pc_zzz[j] * fl1_fx + 6.0 * pc_xzz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 0.5 * pc_zzzz[j] * fl1_fx + pc_zzz[j] * fl1_fx * pb_z[j] + 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] + pa_zz[j] * pc_xxzz[j] + 4.0 * pa_z[j] * pc_xzzz[j] * pb_x[j] + 4.0 * pa_z[j] * pc_xxzz[j] * pb_z[j] + pc_zzzz[j] * pb_xx[j] + 4.0 * pc_xzzz[j] * pb_xz[j] + pc_xxzz[j] * pb_zz[j]);

                t_zz_xxzz[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * pc_zzzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xxzzz[j] - 2.0 * pc_xzzzz[j] * pb_x[j] - 2.0 * pc_xxzzz[j] * pb_z[j]);

                t_zz_xxzz[j] += fl_s_0_0_6 * pc_xxzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_81_82(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (81,82)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyy = pbDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xyyy = primBuffer.data(90 * idx + 81);

            // Batch of Integrals (81,82)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xy, pb_xyy, pb_xyyy, pb_y, pb_yy, pb_yyy, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, \
                                     pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_xyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xyyy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_zz[j] * pb_xy[j] * fl1_fx + 0.5 * fl1_fx * pb_xyyy[j] + pa_zz[j] * pb_xyyy[j]);

                t_zz_xyyy[j] += fl_s_0_0_1 * (-1.5 * fl2_fx * pb_xy[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_zz[j] * pb_xy[j] * fl1_fx - 1.5 * pa_zz[j] * pb_x[j] * pc_y[j] * fl1_fx - 1.5 * pa_zz[j] * pc_x[j] * pb_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * pb_xy[j] * fl1_fx - 1.5 * fl1_fx * pb_xyy[j] * pc_y[j] - 0.5 * fl1_fx * pc_x[j] * pb_yyy[j] - 0.5 * fl1_fx * pb_xyyy[j] - 3.0 * pa_zz[j] * pb_xyy[j] * pc_y[j] - pa_zz[j] * pc_x[j] * pb_yyy[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xyyy[j]);

                t_zz_xyyy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pb_x[j] * pc_y[j] + 1.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.75 * fl2_fx * pc_xy[j] + 0.75 * fl2_fx * pb_xy[j] + 1.5 * pa_zz[j] * pb_x[j] * pc_y[j] * fl1_fx + 1.5 * pa_zz[j] * pc_x[j] * pb_y[j] * fl1_fx + 1.5 * pa_zz[j] * pc_xy[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_xy[j] * fl1_fx + 3.0 * pa_z[j] * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_xz[j] * pb_y[j] * fl1_fx + 1.5 * pc_zz[j] * pb_xy[j] * fl1_fx + 1.5 * fl1_fx * pb_xy[j] * pc_yy[j] + 1.5 * fl1_fx * pc_xy[j] * pb_yy[j] + 1.5 * fl1_fx * pb_xyy[j] * pc_y[j] + 0.5 * fl1_fx * pc_x[j] * pb_yyy[j] + 3.0 * pa_zz[j] * pb_xy[j] * pc_yy[j] + 3.0 * pa_zz[j] * pc_xy[j] * pb_yy[j] + 6.0 * pa_z[j] * pc_yz[j] * pb_xyy[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_yyy[j] + pc_zz[j] * pb_xyyy[j]);

                t_zz_xyyy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xy[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * pa_zz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_z[j] * pc_yz[j] * pb_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_xz[j] * pb_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_xyz[j] * fl1_fx - 1.5 * pc_zz[j] * pb_xy[j] * fl1_fx - 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx - 1.5 * pc_xzz[j] * pb_y[j] * fl1_fx - 0.5 * fl1_fx * pb_x[j] * pc_yyy[j] - 1.5 * fl1_fx * pc_xyy[j] * pb_y[j] - 1.5 * fl1_fx * pb_xy[j] * pc_yy[j] - 1.5 * fl1_fx * pc_xy[j] * pb_yy[j] - pa_zz[j] * pb_x[j] * pc_yyy[j] - 3.0 * pa_zz[j] * pc_xyy[j] * pb_y[j] - 6.0 * pa_z[j] * pc_yyz[j] * pb_xy[j] - 6.0 * pa_z[j] * pc_xyz[j] * pb_yy[j] - 3.0 * pc_yzz[j] * pb_xyy[j] - pc_xzz[j] * pb_yyy[j]);

                t_zz_xyyy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xy[j] + 3.0 * pa_z[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_yzz[j] * pb_x[j] * fl1_fx + 1.5 * pc_xzz[j] * pb_y[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 0.5 * fl1_fx * pc_xyyy[j] + 0.5 * fl1_fx * pb_x[j] * pc_yyy[j] + 1.5 * fl1_fx * pc_xyy[j] * pb_y[j] + pa_zz[j] * pc_xyyy[j] + 2.0 * pa_z[j] * pc_yyyz[j] * pb_x[j] + 6.0 * pa_z[j] * pc_xyyz[j] * pb_y[j] + 3.0 * pc_yyzz[j] * pb_xy[j] + 3.0 * pc_xyzz[j] * pb_yy[j]);

                t_zz_xyyy[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_xyyy[j] - 2.0 * pa_z[j] * pc_xyyyz[j] - pc_yyyzz[j] * pb_x[j] - 3.0 * pc_xyyzz[j] * pb_y[j]);

                t_zz_xyyy[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_82_83(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (82,83)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyy = pbDistances.data(34 * idx + 12);

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyyz = pbDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xyyz = primBuffer.data(90 * idx + 82);

            // Batch of Integrals (82,83)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xy, pb_xyy, pb_xyyz, pb_xyz, pb_xz, pb_y, pb_yy, pb_yyz, \
                                     pb_yz, pb_z, pc_x, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, \
                                     pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_zz_xyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xyyz[j] = fl_s_0_0_0 * (0.5 * pa_z[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_zz[j] * pb_xz[j] * fl1_fx + pa_z[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pb_xyyz[j] + pa_zz[j] * pb_xyyz[j]);

                t_zz_xyyz[j] += fl_s_0_0_1 * (-pa_z[j] * fl2_fx * pb_x[j] - 0.5 * pa_z[j] * fl2_fx * pc_x[j] - 0.75 * pc_z[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pb_xz[j] - 0.25 * fl2_fx * pc_x[j] * pb_z[j] - 0.5 * pa_zz[j] * pb_x[j] * fl1_fx * pc_z[j] - 0.5 * pa_zz[j] * pb_xz[j] * fl1_fx - 0.5 * pa_zz[j] * pc_x[j] * fl1_fx * pb_z[j] - pa_z[j] * pc_z[j] * pb_xz[j] * fl1_fx - 2.0 * pa_z[j] * fl1_fx * pb_xy[j] * pc_y[j] - pa_z[j] * fl1_fx * pc_x[j] * pb_yy[j] - pa_z[j] * fl1_fx * pb_xyy[j] - 1.5 * pc_z[j] * fl1_fx * pb_xyy[j] - fl1_fx * pb_xyz[j] * pc_y[j] - 0.5 * fl1_fx * pc_x[j] * pb_yyz[j] - 0.5 * fl1_fx * pb_xyyz[j] - pa_zz[j] * pb_xyy[j] * pc_z[j] - 2.0 * pa_zz[j] * pb_xyz[j] * pc_y[j] - pa_zz[j] * pc_x[j] * pb_yyz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xyyz[j]);

                t_zz_xyyz[j] += fl_s_0_0_2 * (pa_z[j] * fl2_fx * pc_x[j] + 0.5 * pa_z[j] * fl2_fx * pb_x[j] + 1.5 * pc_z[j] * fl2_fx * pb_x[j] + 0.75 * pc_xz[j] * fl2_fx + 0.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_zz[j] * pb_x[j] * fl1_fx * pc_z[j] + 0.5 * pa_zz[j] * pc_xz[j] * fl1_fx + 0.5 * pa_zz[j] * pc_x[j] * fl1_fx * pb_z[j] + pa_z[j] * pc_zz[j] * pb_x[j] * fl1_fx + pa_z[j] * pc_z[j] * pb_xz[j] * fl1_fx + pa_z[j] * pc_xz[j] * fl1_fx * pb_z[j] + pa_z[j] * fl1_fx * pb_x[j] * pc_yy[j] + 2.0 * pa_z[j] * fl1_fx * pc_xy[j] * pb_y[j] + 2.0 * pa_z[j] * fl1_fx * pb_xy[j] * pc_y[j] + pa_z[j] * fl1_fx * pc_x[j] * pb_yy[j] + 0.5 * pc_zz[j] * pb_xz[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_xy[j] + 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] + 1.5 * pc_z[j] * fl1_fx * pb_xyy[j] + 0.5 * fl1_fx * pb_xz[j] * pc_yy[j] + fl1_fx * pc_xy[j] * pb_yz[j] + fl1_fx * pb_xyz[j] * pc_y[j] + 0.5 * fl1_fx * pc_x[j] * pb_yyz[j] + 2.0 * pa_zz[j] * pb_xy[j] * pc_yz[j] + pa_zz[j] * pb_xz[j] * pc_yy[j] + pa_zz[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_zz[j] * pc_xy[j] * pb_yz[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_xyy[j] + 4.0 * pa_z[j] * pc_yz[j] * pb_xyz[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_yyz[j] + pc_zz[j] * pb_xyyz[j]);

                t_zz_xyyz[j] += fl_s_0_0_3 * (-0.5 * pa_z[j] * fl2_fx * pc_x[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_z[j] * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pc_x[j] * pb_z[j] - 0.5 * pa_zz[j] * pc_xz[j] * fl1_fx - pa_z[j] * pc_zz[j] * pb_x[j] * fl1_fx - pa_z[j] * pc_xzz[j] * fl1_fx - pa_z[j] * pc_xz[j] * fl1_fx * pb_z[j] - pa_z[j] * fl1_fx * pc_xyy[j] - pa_z[j] * fl1_fx * pb_x[j] * pc_yy[j] - 2.0 * pa_z[j] * fl1_fx * pc_xy[j] * pb_y[j] - 0.5 * pc_zzz[j] * pb_x[j] * fl1_fx - 0.5 * pc_zz[j] * pb_xz[j] * fl1_fx - 0.5 * pc_xzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 3.0 * pc_yz[j] * fl1_fx * pb_xy[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pc_xyy[j] * pb_z[j] - 0.5 * fl1_fx * pb_xz[j] * pc_yy[j] - fl1_fx * pc_xy[j] * pb_yz[j] - pa_zz[j] * pb_x[j] * pc_yyz[j] - 2.0 * pa_zz[j] * pc_xyz[j] * pb_y[j] - pa_zz[j] * pc_xyy[j] * pb_z[j] - 4.0 * pa_z[j] * pc_yzz[j] * pb_xy[j] - 2.0 * pa_z[j] * pc_yyz[j] * pb_xz[j] - 2.0 * pa_z[j] * pc_xzz[j] * pb_yy[j] - 4.0 * pa_z[j] * pc_xyz[j] * pb_yz[j] - pc_zzz[j] * pb_xyy[j] - 2.0 * pc_yzz[j] * pb_xyz[j] - pc_xzz[j] * pb_yyz[j]);

                t_zz_xyyz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + pa_z[j] * pc_xzz[j] * fl1_fx + pa_z[j] * fl1_fx * pc_xyy[j] + 0.5 * pc_zzz[j] * pb_x[j] * fl1_fx + 0.5 * pc_xzzz[j] * fl1_fx + 0.5 * pc_xzz[j] * fl1_fx * pb_z[j] + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_yyz[j] * fl1_fx * pb_x[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xyy[j] * pb_z[j] + pa_zz[j] * pc_xyyz[j] + 2.0 * pa_z[j] * pc_yyzz[j] * pb_x[j] + 4.0 * pa_z[j] * pc_xyzz[j] * pb_y[j] + 2.0 * pa_z[j] * pc_xyyz[j] * pb_z[j] + 2.0 * pc_yzzz[j] * pb_xy[j] + pc_yyzz[j] * pb_xz[j] + pc_xzzz[j] * pb_yy[j] + 2.0 * pc_xyzz[j] * pb_yz[j]);

                t_zz_xyyz[j] += fl_s_0_0_5 * (-0.5 * pc_xzzz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xyyzz[j] - pc_yyzzz[j] * pb_x[j] - 2.0 * pc_xyzzz[j] * pb_y[j] - pc_xyyzz[j] * pb_z[j]);

                t_zz_xyyz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_83_84(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (83,84)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(34 * idx + 4);

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xyz = pbDistances.data(34 * idx + 13);

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xyzz = pbDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xyzz = primBuffer.data(90 * idx + 83);

            // Batch of Integrals (83,84)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xy, pb_xyz, pb_xyzz, pb_xz, pb_xzz, pb_y, pb_yz, pb_yzz, \
                                     pb_z, pb_zz, pc_x, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_xzzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_xyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xyzz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xy[j] + 0.5 * pa_zz[j] * pb_xy[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pb_xyzz[j] + pa_zz[j] * pb_xyzz[j]);

                t_zz_xyzz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * fl2_fx * pb_xy[j] - 0.5 * pa_zz[j] * pb_xy[j] * fl1_fx - 0.5 * pa_zz[j] * pb_x[j] * pc_y[j] * fl1_fx - 0.5 * pa_zz[j] * pc_x[j] * pb_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_z[j] * pb_xy[j] * fl1_fx - 2.0 * pa_z[j] * fl1_fx * pb_xz[j] * pc_y[j] - 2.0 * pa_z[j] * fl1_fx * pc_x[j] * pb_yz[j] - 2.0 * pa_z[j] * fl1_fx * pb_xyz[j] - 3.0 * pc_z[j] * fl1_fx * pb_xyz[j] - 0.5 * fl1_fx * pb_xzz[j] * pc_y[j] - 0.5 * fl1_fx * pc_x[j] * pb_yzz[j] - 0.5 * fl1_fx * pb_xyzz[j] - 2.0 * pa_zz[j] * pb_xyz[j] * pc_z[j] - pa_zz[j] * pb_xzz[j] * pc_y[j] - pa_zz[j] * pc_x[j] * pb_yzz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xyzz[j]);

                t_zz_xyzz[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_xy[j] + 1.5 * fl2_fx * pb_x[j] * pc_y[j] + 1.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 0.5 * pa_zz[j] * pb_x[j] * pc_y[j] * fl1_fx + 0.5 * pa_zz[j] * pc_x[j] * pb_y[j] * fl1_fx + 0.5 * pa_zz[j] * pc_xy[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_xy[j] * fl1_fx + 3.0 * pa_z[j] * pc_yz[j] * pb_x[j] * fl1_fx + 3.0 * pa_z[j] * pc_xz[j] * pb_y[j] * fl1_fx + 2.0 * pa_z[j] * fl1_fx * pc_xy[j] * pb_z[j] + 2.0 * pa_z[j] * fl1_fx * pb_xz[j] * pc_y[j] + 2.0 * pa_z[j] * fl1_fx * pc_x[j] * pb_yz[j] + 3.0 * pc_zz[j] * pb_xy[j] * fl1_fx + 3.0 * pc_yz[j] * fl1_fx * pb_xz[j] + 3.0 * pc_xz[j] * fl1_fx * pb_yz[j] + 3.0 * pc_z[j] * fl1_fx * pb_xyz[j] + 0.5 * fl1_fx * pc_xy[j] * pb_zz[j] + 0.5 * fl1_fx * pb_xzz[j] * pc_y[j] + 0.5 * fl1_fx * pc_x[j] * pb_yzz[j] + pa_zz[j] * pb_xy[j] * pc_zz[j] + 2.0 * pa_zz[j] * pb_xz[j] * pc_yz[j] + 2.0 * pa_zz[j] * pc_xz[j] * pb_yz[j] + pa_zz[j] * pc_xy[j] * pb_zz[j] + 4.0 * pa_z[j] * pc_zz[j] * pb_xyz[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_xzz[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_yzz[j] + pc_zz[j] * pb_xyzz[j]);

                t_zz_xyzz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xy[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 0.5 * pa_zz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_z[j] * pc_yz[j] * pb_x[j] * fl1_fx - 3.0 * pa_z[j] * pc_xz[j] * pb_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_xyz[j] * fl1_fx - 2.0 * pa_z[j] * fl1_fx * pc_xy[j] * pb_z[j] - 3.0 * pc_zz[j] * pb_xy[j] * fl1_fx - 3.0 * pc_yzz[j] * pb_x[j] * fl1_fx - 3.0 * pc_xzz[j] * pb_y[j] * fl1_fx - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yz[j] * fl1_fx * pb_xz[j] - 3.0 * pc_xz[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pc_xy[j] * pb_zz[j] - pa_zz[j] * pb_x[j] * pc_yzz[j] - pa_zz[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_zz[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_z[j] * pc_zzz[j] * pb_xy[j] - 4.0 * pa_z[j] * pc_yzz[j] * pb_xz[j] - 4.0 * pa_z[j] * pc_xzz[j] * pb_yz[j] - 2.0 * pa_z[j] * pc_xyz[j] * pb_zz[j] - 2.0 * pc_zzz[j] * pb_xyz[j] - pc_yzz[j] * pb_xzz[j] - pc_xzz[j] * pb_yzz[j]);

                t_zz_xyzz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xy[j] + 3.0 * pa_z[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_yzz[j] * pb_x[j] * fl1_fx + 3.0 * pc_xzz[j] * pb_y[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + pa_zz[j] * pc_xyzz[j] + 2.0 * pa_z[j] * pc_yzzz[j] * pb_x[j] + 2.0 * pa_z[j] * pc_xzzz[j] * pb_y[j] + 4.0 * pa_z[j] * pc_xyzz[j] * pb_z[j] + pc_zzzz[j] * pb_xy[j] + 2.0 * pc_yzzz[j] * pb_xz[j] + 2.0 * pc_xzzz[j] * pb_yz[j] + pc_xyzz[j] * pb_zz[j]);

                t_zz_xyzz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xyzzz[j] - pc_yzzzz[j] * pb_x[j] - pc_xzzzz[j] * pb_y[j] - 2.0 * pc_xyzzz[j] * pb_z[j]);

                t_zz_xyzz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_84_85(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (84,85)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(34 * idx);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(34 * idx + 5);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_xzz = pbDistances.data(34 * idx + 14);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_xzzz = pbDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xzzzzz = pcDistances.data(83 * idx + 75);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_xzzz = primBuffer.data(90 * idx + 84);

            // Batch of Integrals (84,85)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_x, pb_xz, pb_xzz, pb_xzzz, pb_z, pb_zz, pb_zzz, pc_x, pc_xz, \
                                     pc_xzz, pc_xzzz, pc_xzzzz, pc_xzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_xzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_xzzz[j] = fl_s_0_0_0 * (1.5 * pa_z[j] * fl2_fx * pb_x[j] + 2.25 * fl2_fx * pb_xz[j] + 1.5 * pa_zz[j] * pb_xz[j] * fl1_fx + 3.0 * pa_z[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pb_xzzz[j] + pa_zz[j] * pb_xzzz[j]);

                t_zz_xzzz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx * pb_x[j] - 1.5 * pa_z[j] * fl2_fx * pc_x[j] - 3.75 * pc_z[j] * fl2_fx * pb_x[j] - 2.25 * fl2_fx * pc_x[j] * pb_z[j] - 4.5 * fl2_fx * pb_xz[j] - 1.5 * pa_zz[j] * pb_xz[j] * fl1_fx - 1.5 * pa_zz[j] * pb_x[j] * pc_z[j] * fl1_fx - 1.5 * pa_zz[j] * pc_x[j] * pb_z[j] * fl1_fx - 9.0 * pa_z[j] * pc_z[j] * pb_xz[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pc_x[j] * pb_zz[j] - 3.0 * pa_z[j] * fl1_fx * pb_xzz[j] - 4.5 * pc_z[j] * fl1_fx * pb_xzz[j] - 0.5 * fl1_fx * pc_x[j] * pb_zzz[j] - 0.5 * fl1_fx * pb_xzzz[j] - 3.0 * pa_zz[j] * pb_xzz[j] * pc_z[j] - pa_zz[j] * pc_x[j] * pb_zzz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_xzzz[j]);

                t_zz_xzzz[j] += fl_s_0_0_2 * (3.0 * pa_z[j] * fl2_fx * pc_x[j] + 1.5 * pa_z[j] * fl2_fx * pb_x[j] + 7.5 * pc_z[j] * fl2_fx * pb_x[j] + 3.75 * pc_xz[j] * fl2_fx + 4.5 * fl2_fx * pc_x[j] * pb_z[j] + 2.25 * fl2_fx * pb_xz[j] + 1.5 * pa_zz[j] * pb_x[j] * pc_z[j] * fl1_fx + 1.5 * pa_zz[j] * pc_x[j] * pb_z[j] * fl1_fx + 1.5 * pa_zz[j] * pc_xz[j] * fl1_fx + 9.0 * pa_z[j] * pc_z[j] * pb_xz[j] * fl1_fx + 6.0 * pa_z[j] * pc_zz[j] * pb_x[j] * fl1_fx + 9.0 * pa_z[j] * pc_xz[j] * pb_z[j] * fl1_fx + 3.0 * pa_z[j] * fl1_fx * pc_x[j] * pb_zz[j] + 9.0 * pc_zz[j] * pb_xz[j] * fl1_fx + 4.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 4.5 * pc_z[j] * fl1_fx * pb_xzz[j] + 0.5 * fl1_fx * pc_x[j] * pb_zzz[j] + 3.0 * pa_zz[j] * pb_xz[j] * pc_zz[j] + 3.0 * pa_zz[j] * pc_xz[j] * pb_zz[j] + 6.0 * pa_z[j] * pc_zz[j] * pb_xzz[j] + 2.0 * pa_z[j] * pc_xz[j] * pb_zzz[j] + pc_zz[j] * pb_xzzz[j]);

                t_zz_xzzz[j] += fl_s_0_0_3 * (-1.5 * pa_z[j] * fl2_fx * pc_x[j] - 7.5 * pc_xz[j] * fl2_fx - 3.75 * pc_z[j] * fl2_fx * pb_x[j] - 2.25 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * pa_zz[j] * pc_xz[j] * fl1_fx - 6.0 * pa_z[j] * pc_zz[j] * pb_x[j] * fl1_fx - 9.0 * pa_z[j] * pc_xz[j] * pb_z[j] * fl1_fx - 6.0 * pa_z[j] * pc_xzz[j] * fl1_fx - 9.0 * pc_zz[j] * pb_xz[j] * fl1_fx - 5.0 * pc_zzz[j] * pb_x[j] * fl1_fx - 9.0 * pc_xzz[j] * pb_z[j] * fl1_fx - 4.5 * pc_xz[j] * fl1_fx * pb_zz[j] - pa_zz[j] * pb_x[j] * pc_zzz[j] - 3.0 * pa_zz[j] * pc_xzz[j] * pb_z[j] - 6.0 * pa_z[j] * pc_zzz[j] * pb_xz[j] - 6.0 * pa_z[j] * pc_xzz[j] * pb_zz[j] - 3.0 * pc_zzz[j] * pb_xzz[j] - pc_xzz[j] * pb_zzz[j]);

                t_zz_xzzz[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 6.0 * pa_z[j] * pc_xzz[j] * fl1_fx + 5.0 * pc_zzz[j] * pb_x[j] * fl1_fx + 9.0 * pc_xzz[j] * pb_z[j] * fl1_fx + 5.0 * pc_xzzz[j] * fl1_fx + pa_zz[j] * pc_xzzz[j] + 2.0 * pa_z[j] * pc_zzzz[j] * pb_x[j] + 6.0 * pa_z[j] * pc_xzzz[j] * pb_z[j] + 3.0 * pc_zzzz[j] * pb_xz[j] + 3.0 * pc_xzzz[j] * pb_zz[j]);

                t_zz_xzzz[j] += fl_s_0_0_5 * (-5.0 * pc_xzzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_xzzzz[j] - pc_zzzzz[j] * pb_x[j] - 3.0 * pc_xzzzz[j] * pb_z[j]);

                t_zz_xzzz[j] += fl_s_0_0_6 * pc_xzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_85_86(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (85,86)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyy = pbDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyzz = pcDistances.data(83 * idx + 78);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_yyyy = primBuffer.data(90 * idx + 85);

            // Batch of Integrals (85,86)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_y, pb_yy, pb_yyy, pb_yyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyz, pc_yyyyzz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_yyyy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zz_yyyy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_zz[j] * fl2_fx + 1.5 * fl2_fx * pb_yy[j] + 3.0 * pa_zz[j] * pb_yy[j] * fl1_fx + 0.5 * fl1_fx * pb_yyyy[j] + pa_zz[j] * pb_yyyy[j]);

                t_zz_yyyy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_zz[j] * fl2_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 3.0 * fl2_fx * pb_yy[j] - 3.0 * fl2_fx * pb_y[j] * pc_y[j] - 3.0 * pa_zz[j] * pb_yy[j] * fl1_fx - 6.0 * pa_zz[j] * pb_y[j] * pc_y[j] * fl1_fx - 6.0 * pa_z[j] * pc_z[j] * pb_yy[j] * fl1_fx - 2.0 * fl1_fx * pb_yyy[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyyy[j] - 4.0 * pa_zz[j] * pb_yyy[j] * pc_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yyyy[j]);

                t_zz_yyyy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_zz[j] * fl2_fx + 3.0 * pa_z[j] * pc_z[j] * fl2_fx + 0.75 * pc_zz[j] * fl2_fx + 6.0 * fl2_fx * pb_y[j] * pc_y[j] + 1.5 * fl2_fx * pc_yy[j] + 1.5 * fl2_fx * pb_yy[j] + 6.0 * pa_zz[j] * pb_y[j] * pc_y[j] * fl1_fx + 3.0 * pa_zz[j] * pc_yy[j] * fl1_fx + 6.0 * pa_z[j] * pc_z[j] * pb_yy[j] * fl1_fx + 12.0 * pa_z[j] * pc_yz[j] * pb_y[j] * fl1_fx + 3.0 * pc_zz[j] * pb_yy[j] * fl1_fx + 3.0 * fl1_fx * pb_yy[j] * pc_yy[j] + 2.0 * fl1_fx * pb_yyy[j] * pc_y[j] + 6.0 * pa_zz[j] * pb_yy[j] * pc_yy[j] + 8.0 * pa_z[j] * pc_yz[j] * pb_yyy[j] + pc_zz[j] * pb_yyyy[j]);

                t_zz_yyyy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 1.5 * pc_zz[j] * fl2_fx - 3.0 * fl2_fx * pc_yy[j] - 3.0 * fl2_fx * pb_y[j] * pc_y[j] - 3.0 * pa_zz[j] * pc_yy[j] * fl1_fx - 12.0 * pa_z[j] * pc_yz[j] * pb_y[j] * fl1_fx - 6.0 * pa_z[j] * pc_yyz[j] * fl1_fx - 3.0 * pc_zz[j] * pb_yy[j] * fl1_fx - 6.0 * pc_yzz[j] * pb_y[j] * fl1_fx - 2.0 * fl1_fx * pb_y[j] * pc_yyy[j] - 3.0 * fl1_fx * pb_yy[j] * pc_yy[j] - 4.0 * pa_zz[j] * pb_y[j] * pc_yyy[j] - 12.0 * pa_z[j] * pc_yyz[j] * pb_yy[j] - 4.0 * pc_yzz[j] * pb_yyy[j]);

                t_zz_yyyy[j] += fl_s_0_0_4 * (0.75 * pc_zz[j] * fl2_fx + 1.5 * fl2_fx * pc_yy[j] + 6.0 * pa_z[j] * pc_yyz[j] * fl1_fx + 6.0 * pc_yzz[j] * pb_y[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 0.5 * fl1_fx * pc_yyyy[j] + 2.0 * fl1_fx * pb_y[j] * pc_yyy[j] + pa_zz[j] * pc_yyyy[j] + 8.0 * pa_z[j] * pc_yyyz[j] * pb_y[j] + 6.0 * pc_yyzz[j] * pb_yy[j]);

                t_zz_yyyy[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyy[j] - 2.0 * pa_z[j] * pc_yyyyz[j] - 4.0 * pc_yyyzz[j] * pb_y[j]);

                t_zz_yyyy[j] += fl_s_0_0_6 * pc_yyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_86_87(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (86,87)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyy = pbDistances.data(34 * idx + 15);

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyyz = pbDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyzzz = pcDistances.data(83 * idx + 79);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_yyyz = primBuffer.data(90 * idx + 86);

            // Batch of Integrals (86,87)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_y, pb_yy, pb_yyy, pb_yyyz, pb_yyz, pb_yz, pb_z, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyyzz, pc_yyyzzz, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_zz_yyyz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_yyyz[j] = fl_s_0_0_0 * (1.5 * pa_z[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_zz[j] * pb_yz[j] * fl1_fx + pa_z[j] * fl1_fx * pb_yyy[j] + 0.5 * fl1_fx * pb_yyyz[j] + pa_zz[j] * pb_yyyz[j]);

                t_zz_yyyz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx * pb_y[j] - 1.5 * pa_z[j] * fl2_fx * pc_y[j] - 2.25 * pc_z[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pb_yz[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_zz[j] * pb_y[j] * fl1_fx * pc_z[j] - 1.5 * pa_zz[j] * pb_yz[j] * fl1_fx - 1.5 * pa_zz[j] * pc_y[j] * fl1_fx * pb_z[j] - 3.0 * pa_z[j] * pc_z[j] * pb_yz[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pb_yy[j] * pc_y[j] - pa_z[j] * fl1_fx * pb_yyy[j] - 1.5 * pc_z[j] * fl1_fx * pb_yyy[j] - 1.5 * fl1_fx * pb_yyz[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyyz[j] - pa_zz[j] * pb_yyy[j] * pc_z[j] - 3.0 * pa_zz[j] * pb_yyz[j] * pc_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yyyz[j]);

                t_zz_yyyz[j] += fl_s_0_0_2 * (3.0 * pa_z[j] * fl2_fx * pc_y[j] + 1.5 * pa_z[j] * fl2_fx * pb_y[j] + 4.5 * pc_z[j] * fl2_fx * pb_y[j] + 2.25 * pc_yz[j] * fl2_fx + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 1.5 * pa_zz[j] * pb_y[j] * fl1_fx * pc_z[j] + 1.5 * pa_zz[j] * pc_yz[j] * fl1_fx + 1.5 * pa_zz[j] * pc_y[j] * fl1_fx * pb_z[j] + 3.0 * pa_z[j] * pc_zz[j] * pb_y[j] * fl1_fx + 3.0 * pa_z[j] * pc_z[j] * pb_yz[j] * fl1_fx + 3.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_z[j] + 3.0 * pa_z[j] * fl1_fx * pb_y[j] * pc_yy[j] + 3.0 * pa_z[j] * fl1_fx * pb_yy[j] * pc_y[j] + 1.5 * pc_zz[j] * pb_yz[j] * fl1_fx + 4.5 * pc_yz[j] * fl1_fx * pb_yy[j] + 1.5 * pc_z[j] * fl1_fx * pb_yyy[j] + 1.5 * fl1_fx * pb_yz[j] * pc_yy[j] + 1.5 * fl1_fx * pb_yyz[j] * pc_y[j] + 3.0 * pa_zz[j] * pb_yy[j] * pc_yz[j] + 3.0 * pa_zz[j] * pb_yz[j] * pc_yy[j] + 2.0 * pa_z[j] * pc_zz[j] * pb_yyy[j] + 6.0 * pa_z[j] * pc_yz[j] * pb_yyz[j] + pc_zz[j] * pb_yyyz[j]);

                t_zz_yyyz[j] += fl_s_0_0_3 * (-1.5 * pa_z[j] * fl2_fx * pc_y[j] - 4.5 * pc_yz[j] * fl2_fx - 2.25 * pc_z[j] * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_zz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_z[j] * pc_zz[j] * pb_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_yzz[j] * fl1_fx - 3.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_z[j] - pa_z[j] * fl1_fx * pc_yyy[j] - 3.0 * pa_z[j] * fl1_fx * pb_y[j] * pc_yy[j] - 1.5 * pc_zzz[j] * pb_y[j] * fl1_fx - 1.5 * pc_zz[j] * pb_yz[j] * fl1_fx - 1.5 * pc_yzz[j] * fl1_fx * pb_z[j] - 4.5 * pc_yyz[j] * fl1_fx * pb_y[j] - 4.5 * pc_yz[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] - 1.5 * fl1_fx * pb_yz[j] * pc_yy[j] - 3.0 * pa_zz[j] * pb_y[j] * pc_yyz[j] - pa_zz[j] * pc_yyy[j] * pb_z[j] - 6.0 * pa_z[j] * pc_yzz[j] * pb_yy[j] - 6.0 * pa_z[j] * pc_yyz[j] * pb_yz[j] - pc_zzz[j] * pb_yyy[j] - 3.0 * pc_yzz[j] * pb_yyz[j]);

                t_zz_yyyz[j] += fl_s_0_0_4 * (2.25 * pc_yz[j] * fl2_fx + 3.0 * pa_z[j] * pc_yzz[j] * fl1_fx + pa_z[j] * fl1_fx * pc_yyy[j] + 1.5 * pc_zzz[j] * pb_y[j] * fl1_fx + 1.5 * pc_yzzz[j] * fl1_fx + 1.5 * pc_yzz[j] * fl1_fx * pb_z[j] + 1.5 * pc_yyyz[j] * fl1_fx + 4.5 * pc_yyz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] + pa_zz[j] * pc_yyyz[j] + 6.0 * pa_z[j] * pc_yyzz[j] * pb_y[j] + 2.0 * pa_z[j] * pc_yyyz[j] * pb_z[j] + 3.0 * pc_yzzz[j] * pb_yy[j] + 3.0 * pc_yyzz[j] * pb_yz[j]);

                t_zz_yyyz[j] += fl_s_0_0_5 * (-1.5 * pc_yzzz[j] * fl1_fx - 1.5 * pc_yyyz[j] * fl1_fx - 2.0 * pa_z[j] * pc_yyyzz[j] - 3.0 * pc_yyzzz[j] * pb_y[j] - pc_yyyzz[j] * pb_z[j]);

                t_zz_yyyz[j] += fl_s_0_0_6 * pc_yyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_87_88(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (87,88)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(34 * idx + 6);

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yyz = pbDistances.data(34 * idx + 16);

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yyzz = pbDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyzzzz = pcDistances.data(83 * idx + 80);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_yyzz = primBuffer.data(90 * idx + 87);

            // Batch of Integrals (87,88)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_y, pb_yy, pb_yyz, pb_yyzz, pb_yz, pb_yzz, pb_z, pb_zz, pc_y, \
                                     pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yyzzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_zz_yyzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zz_yyzz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.25 * pa_zz[j] * fl2_fx + pa_z[j] * fl2_fx * pb_z[j] + 0.75 * fl2_fx * pb_yy[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_zz[j] * pb_yy[j] * fl1_fx + 0.5 * pa_zz[j] * fl1_fx * pb_zz[j] + 2.0 * pa_z[j] * fl1_fx * pb_yyz[j] + 0.5 * fl1_fx * pb_yyzz[j] + pa_zz[j] * pb_yyzz[j]);

                t_zz_yyzz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 0.5 * pa_zz[j] * fl2_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 2.0 * pa_z[j] * fl2_fx * pb_z[j] - 1.5 * pc_z[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 1.5 * fl2_fx * pb_yy[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_zz[j] * pb_yy[j] * fl1_fx - pa_zz[j] * pb_y[j] * pc_y[j] * fl1_fx - pa_zz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_zz[j] * fl1_fx * pb_zz[j] - 3.0 * pa_z[j] * pc_z[j] * pb_yy[j] * fl1_fx - pa_z[j] * pc_z[j] * fl1_fx * pb_zz[j] - 4.0 * pa_z[j] * fl1_fx * pb_yz[j] * pc_y[j] - 2.0 * pa_z[j] * fl1_fx * pb_yyz[j] - 3.0 * pc_z[j] * fl1_fx * pb_yyz[j] - fl1_fx * pb_yzz[j] * pc_y[j] - 0.5 * fl1_fx * pb_yyzz[j] - 2.0 * pa_zz[j] * pb_yyz[j] * pc_z[j] - 2.0 * pa_zz[j] * pb_yzz[j] * pc_y[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yyzz[j]);

                t_zz_yyzz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.25 * pa_zz[j] * fl2_fx + 3.0 * pa_z[j] * pc_z[j] * fl2_fx + pa_z[j] * fl2_fx * pb_z[j] + 1.5 * pc_zz[j] * fl2_fx + 3.0 * pc_z[j] * fl2_fx * pb_z[j] + 0.75 * fl2_fx * pc_yy[j] + 3.0 * fl2_fx * pb_y[j] * pc_y[j] + 0.75 * fl2_fx * pb_yy[j] + 0.25 * fl2_fx * pb_zz[j] + pa_zz[j] * pb_y[j] * pc_y[j] * fl1_fx + 0.5 * pa_zz[j] * pc_yy[j] * fl1_fx + 0.5 * pa_zz[j] * fl1_fx * pc_zz[j] + pa_zz[j] * fl1_fx * pb_z[j] * pc_z[j] + 3.0 * pa_z[j] * pc_z[j] * pb_yy[j] * fl1_fx + 6.0 * pa_z[j] * pc_yz[j] * pb_y[j] * fl1_fx + 2.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_z[j] + pa_z[j] * pc_z[j] * fl1_fx * pb_zz[j] + 2.0 * pa_z[j] * fl1_fx * pc_yy[j] * pb_z[j] + 4.0 * pa_z[j] * fl1_fx * pb_yz[j] * pc_y[j] + 3.0 * pc_zz[j] * pb_yy[j] * fl1_fx + 0.5 * pc_zz[j] * fl1_fx * pb_zz[j] + 6.0 * pc_yz[j] * fl1_fx * pb_yz[j] + 3.0 * pc_z[j] * fl1_fx * pb_yyz[j] + 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] + fl1_fx * pb_yzz[j] * pc_y[j] + pa_zz[j] * pb_yy[j] * pc_zz[j] + 4.0 * pa_zz[j] * pb_yz[j] * pc_yz[j] + pa_zz[j] * pc_yy[j] * pb_zz[j] + 4.0 * pa_z[j] * pc_zz[j] * pb_yyz[j] + 4.0 * pa_z[j] * pc_yz[j] * pb_yzz[j] + pc_zz[j] * pb_yyzz[j]);

                t_zz_yyzz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_z[j] * pc_z[j] * fl2_fx - 3.0 * pc_zz[j] * fl2_fx - 1.5 * pc_z[j] * fl2_fx * pb_z[j] - 1.5 * fl2_fx * pc_yy[j] - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * pa_zz[j] * pc_yy[j] * fl1_fx - 0.5 * pa_zz[j] * fl1_fx * pc_zz[j] - 6.0 * pa_z[j] * pc_yz[j] * pb_y[j] * fl1_fx - 3.0 * pa_z[j] * pc_yyz[j] * fl1_fx - pa_z[j] * pc_zzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_z[j] - 2.0 * pa_z[j] * fl1_fx * pc_yy[j] * pb_z[j] - 3.0 * pc_zz[j] * pb_yy[j] * fl1_fx - 6.0 * pc_yzz[j] * pb_y[j] * fl1_fx - pc_zzz[j] * fl1_fx * pb_z[j] - 0.5 * pc_zz[j] * fl1_fx * pb_zz[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] - 6.0 * pc_yz[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] - 2.0 * pa_zz[j] * pb_y[j] * pc_yzz[j] - 2.0 * pa_zz[j] * pc_yyz[j] * pb_z[j] - 2.0 * pa_z[j] * pc_zzz[j] * pb_yy[j] - 8.0 * pa_z[j] * pc_yzz[j] * pb_yz[j] - 2.0 * pa_z[j] * pc_yyz[j] * pb_zz[j] - 2.0 * pc_zzz[j] * pb_yyz[j] - 2.0 * pc_yzz[j] * pb_yzz[j]);

                t_zz_yyzz[j] += fl_s_0_0_4 * (1.5 * pc_zz[j] * fl2_fx + 0.75 * fl2_fx * pc_yy[j] + 3.0 * pa_z[j] * pc_yyz[j] * fl1_fx + pa_z[j] * pc_zzz[j] * fl1_fx + 6.0 * pc_yzz[j] * pb_y[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 0.5 * pc_zzzz[j] * fl1_fx + pc_zzz[j] * fl1_fx * pb_z[j] + 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] + pa_zz[j] * pc_yyzz[j] + 4.0 * pa_z[j] * pc_yzzz[j] * pb_y[j] + 4.0 * pa_z[j] * pc_yyzz[j] * pb_z[j] + pc_zzzz[j] * pb_yy[j] + 4.0 * pc_yzzz[j] * pb_yz[j] + pc_yyzz[j] * pb_zz[j]);

                t_zz_yyzz[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * pc_zzzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_yyzzz[j] - 2.0 * pc_yzzzz[j] * pb_y[j] - 2.0 * pc_yyzzz[j] * pb_z[j]);

                t_zz_yyzz[j] += fl_s_0_0_6 * pc_yyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_88_89(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (88,89)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(34 * idx + 1);

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(34 * idx + 7);

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_yzz = pbDistances.data(34 * idx + 17);

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_yzzz = pbDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yzzzzz = pcDistances.data(83 * idx + 81);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_yzzz = primBuffer.data(90 * idx + 88);

            // Batch of Integrals (88,89)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_y, pb_yz, pb_yzz, pb_yzzz, pb_z, pb_zz, pb_zzz, pc_y, pc_yz, \
                                     pc_yzz, pc_yzzz, pc_yzzzz, pc_yzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zz_yzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zz_yzzz[j] = fl_s_0_0_0 * (1.5 * pa_z[j] * fl2_fx * pb_y[j] + 2.25 * fl2_fx * pb_yz[j] + 1.5 * pa_zz[j] * pb_yz[j] * fl1_fx + 3.0 * pa_z[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pb_yzzz[j] + pa_zz[j] * pb_yzzz[j]);

                t_zz_yzzz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx * pb_y[j] - 1.5 * pa_z[j] * fl2_fx * pc_y[j] - 3.75 * pc_z[j] * fl2_fx * pb_y[j] - 2.25 * fl2_fx * pc_y[j] * pb_z[j] - 4.5 * fl2_fx * pb_yz[j] - 1.5 * pa_zz[j] * pb_yz[j] * fl1_fx - 1.5 * pa_zz[j] * pb_y[j] * pc_z[j] * fl1_fx - 1.5 * pa_zz[j] * pc_y[j] * pb_z[j] * fl1_fx - 9.0 * pa_z[j] * pc_z[j] * pb_yz[j] * fl1_fx - 3.0 * pa_z[j] * fl1_fx * pc_y[j] * pb_zz[j] - 3.0 * pa_z[j] * fl1_fx * pb_yzz[j] - 4.5 * pc_z[j] * fl1_fx * pb_yzz[j] - 0.5 * fl1_fx * pc_y[j] * pb_zzz[j] - 0.5 * fl1_fx * pb_yzzz[j] - 3.0 * pa_zz[j] * pb_yzz[j] * pc_z[j] - pa_zz[j] * pc_y[j] * pb_zzz[j] - 2.0 * pa_z[j] * pc_z[j] * pb_yzzz[j]);

                t_zz_yzzz[j] += fl_s_0_0_2 * (3.0 * pa_z[j] * fl2_fx * pc_y[j] + 1.5 * pa_z[j] * fl2_fx * pb_y[j] + 7.5 * pc_z[j] * fl2_fx * pb_y[j] + 3.75 * pc_yz[j] * fl2_fx + 4.5 * fl2_fx * pc_y[j] * pb_z[j] + 2.25 * fl2_fx * pb_yz[j] + 1.5 * pa_zz[j] * pb_y[j] * pc_z[j] * fl1_fx + 1.5 * pa_zz[j] * pc_y[j] * pb_z[j] * fl1_fx + 1.5 * pa_zz[j] * pc_yz[j] * fl1_fx + 9.0 * pa_z[j] * pc_z[j] * pb_yz[j] * fl1_fx + 6.0 * pa_z[j] * pc_zz[j] * pb_y[j] * fl1_fx + 9.0 * pa_z[j] * pc_yz[j] * pb_z[j] * fl1_fx + 3.0 * pa_z[j] * fl1_fx * pc_y[j] * pb_zz[j] + 9.0 * pc_zz[j] * pb_yz[j] * fl1_fx + 4.5 * pc_yz[j] * fl1_fx * pb_zz[j] + 4.5 * pc_z[j] * fl1_fx * pb_yzz[j] + 0.5 * fl1_fx * pc_y[j] * pb_zzz[j] + 3.0 * pa_zz[j] * pb_yz[j] * pc_zz[j] + 3.0 * pa_zz[j] * pc_yz[j] * pb_zz[j] + 6.0 * pa_z[j] * pc_zz[j] * pb_yzz[j] + 2.0 * pa_z[j] * pc_yz[j] * pb_zzz[j] + pc_zz[j] * pb_yzzz[j]);

                t_zz_yzzz[j] += fl_s_0_0_3 * (-1.5 * pa_z[j] * fl2_fx * pc_y[j] - 7.5 * pc_yz[j] * fl2_fx - 3.75 * pc_z[j] * fl2_fx * pb_y[j] - 2.25 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_zz[j] * pc_yz[j] * fl1_fx - 6.0 * pa_z[j] * pc_zz[j] * pb_y[j] * fl1_fx - 9.0 * pa_z[j] * pc_yz[j] * pb_z[j] * fl1_fx - 6.0 * pa_z[j] * pc_yzz[j] * fl1_fx - 9.0 * pc_zz[j] * pb_yz[j] * fl1_fx - 5.0 * pc_zzz[j] * pb_y[j] * fl1_fx - 9.0 * pc_yzz[j] * pb_z[j] * fl1_fx - 4.5 * pc_yz[j] * fl1_fx * pb_zz[j] - pa_zz[j] * pb_y[j] * pc_zzz[j] - 3.0 * pa_zz[j] * pc_yzz[j] * pb_z[j] - 6.0 * pa_z[j] * pc_zzz[j] * pb_yz[j] - 6.0 * pa_z[j] * pc_yzz[j] * pb_zz[j] - 3.0 * pc_zzz[j] * pb_yzz[j] - pc_yzz[j] * pb_zzz[j]);

                t_zz_yzzz[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 6.0 * pa_z[j] * pc_yzz[j] * fl1_fx + 5.0 * pc_zzz[j] * pb_y[j] * fl1_fx + 9.0 * pc_yzz[j] * pb_z[j] * fl1_fx + 5.0 * pc_yzzz[j] * fl1_fx + pa_zz[j] * pc_yzzz[j] + 2.0 * pa_z[j] * pc_zzzz[j] * pb_y[j] + 6.0 * pa_z[j] * pc_yzzz[j] * pb_z[j] + 3.0 * pc_zzzz[j] * pb_yz[j] + 3.0 * pc_yzzz[j] * pb_zz[j]);

                t_zz_yzzz[j] += fl_s_0_0_5 * (-5.0 * pc_yzzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_yzzzz[j] - pc_zzzzz[j] * pb_y[j] - 3.0 * pc_yzzzz[j] * pb_z[j]);

                t_zz_yzzz[j] += fl_s_0_0_6 * pc_yzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForDG_89_90(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (89,90)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PB)

            auto pb_zzz = pbDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PB)

            auto pb_zzzz = pbDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_zzzzzz = pcDistances.data(83 * idx + 82);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zz_zzzz = primBuffer.data(90 * idx + 89);

            // Batch of Integrals (89,90)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pb_z, pb_zz, pb_zzz, pb_zzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     pc_zzzzz, pc_zzzzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_zz_zzzz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zz_zzzz[j] = fl_s_0_0_0 * (1.875 * fl3_fx + 0.75 * pa_zz[j] * fl2_fx + 6.0 * pa_z[j] * fl2_fx * pb_z[j] + 4.5 * fl2_fx * pb_zz[j] + 3.0 * pa_zz[j] * pb_zz[j] * fl1_fx + 4.0 * pa_z[j] * fl1_fx * pb_zzz[j] + 0.5 * fl1_fx * pb_zzzz[j] + pa_zz[j] * pb_zzzz[j]);

                t_zz_zzzz[j] += fl_s_0_0_1 * (-5.625 * fl3_fx - 1.5 * pa_zz[j] * fl2_fx - 7.5 * pa_z[j] * pc_z[j] * fl2_fx - 12.0 * pa_z[j] * fl2_fx * pb_z[j] - 15.0 * pc_z[j] * fl2_fx * pb_z[j] - 9.0 * fl2_fx * pb_zz[j] - 3.0 * pa_zz[j] * pb_zz[j] * fl1_fx - 6.0 * pa_zz[j] * pb_z[j] * pc_z[j] * fl1_fx - 18.0 * pa_z[j] * pc_z[j] * pb_zz[j] * fl1_fx - 4.0 * pa_z[j] * fl1_fx * pb_zzz[j] - 6.0 * pc_z[j] * fl1_fx * pb_zzz[j] - 0.5 * fl1_fx * pb_zzzz[j] - 4.0 * pa_zz[j] * pb_zzz[j] * pc_z[j] - 2.0 * pa_z[j] * pc_z[j] * pb_zzzz[j]);

                t_zz_zzzz[j] += fl_s_0_0_2 * (5.625 * fl3_fx + 0.75 * pa_zz[j] * fl2_fx + 15.0 * pa_z[j] * pc_z[j] * fl2_fx + 6.0 * pa_z[j] * fl2_fx * pb_z[j] + 11.25 * pc_zz[j] * fl2_fx + 30.0 * pc_z[j] * fl2_fx * pb_z[j] + 4.5 * fl2_fx * pb_zz[j] + 6.0 * pa_zz[j] * pb_z[j] * pc_z[j] * fl1_fx + 3.0 * pa_zz[j] * pc_zz[j] * fl1_fx + 18.0 * pa_z[j] * pc_z[j] * pb_zz[j] * fl1_fx + 24.0 * pa_z[j] * pc_zz[j] * pb_z[j] * fl1_fx + 18.0 * pc_zz[j] * pb_zz[j] * fl1_fx + 6.0 * pc_z[j] * fl1_fx * pb_zzz[j] + 6.0 * pa_zz[j] * pb_zz[j] * pc_zz[j] + 8.0 * pa_z[j] * pc_zz[j] * pb_zzz[j] + pc_zz[j] * pb_zzzz[j]);

                t_zz_zzzz[j] += fl_s_0_0_3 * (-1.875 * fl3_fx - 7.5 * pa_z[j] * pc_z[j] * fl2_fx - 22.5 * pc_zz[j] * fl2_fx - 15.0 * pc_z[j] * fl2_fx * pb_z[j] - 3.0 * pa_zz[j] * pc_zz[j] * fl1_fx - 24.0 * pa_z[j] * pc_zz[j] * pb_z[j] * fl1_fx - 10.0 * pa_z[j] * pc_zzz[j] * fl1_fx - 18.0 * pc_zz[j] * pb_zz[j] * fl1_fx - 20.0 * pc_zzz[j] * pb_z[j] * fl1_fx - 4.0 * pa_zz[j] * pb_z[j] * pc_zzz[j] - 12.0 * pa_z[j] * pc_zzz[j] * pb_zz[j] - 4.0 * pc_zzz[j] * pb_zzz[j]);

                t_zz_zzzz[j] += fl_s_0_0_4 * (11.25 * pc_zz[j] * fl2_fx + 10.0 * pa_z[j] * pc_zzz[j] * fl1_fx + 20.0 * pc_zzz[j] * pb_z[j] * fl1_fx + 7.5 * pc_zzzz[j] * fl1_fx + pa_zz[j] * pc_zzzz[j] + 8.0 * pa_z[j] * pc_zzzz[j] * pb_z[j] + 6.0 * pc_zzzz[j] * pb_zz[j]);

                t_zz_zzzz[j] += fl_s_0_0_5 * (-7.5 * pc_zzzz[j] * fl1_fx - 2.0 * pa_z[j] * pc_zzzzz[j] - 4.0 * pc_zzzzz[j] * pb_z[j]);

                t_zz_zzzz[j] += fl_s_0_0_6 * pc_zzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD(      CMemBlock2D<double>& primBuffer,
                              const CMemBlock2D<double>& auxBuffer,
                              const CMemBlock2D<double>& osFactors,
                              const CMemBlock2D<double>& paDistances,
                              const CMemBlock2D<double>& pbDistances,
                              const CMemBlock2D<double>& pcDistances,
                              const CGtoBlock&           braGtoBlock,
                              const CGtoBlock&           ketGtoBlock,
                              const int32_t              iContrGto)
    {
        npotrecfunc::compNuclearPotentialForGD_0_1(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_1_2(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_2_3(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_3_4(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_4_5(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_5_6(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_6_7(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_7_8(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_8_9(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                   braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_9_10(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                    braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_10_11(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_11_12(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_12_13(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_13_14(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_14_15(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_15_16(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_16_17(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_17_18(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_18_19(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_19_20(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_20_21(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_21_22(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_22_23(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_23_24(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_24_25(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_25_26(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_26_27(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_27_28(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_28_29(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_29_30(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_30_31(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_31_32(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_32_33(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_33_34(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_34_35(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_35_36(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_36_37(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_37_38(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_38_39(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_39_40(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_40_41(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_41_42(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_42_43(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_43_44(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_44_45(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_45_46(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_46_47(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_47_48(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_48_49(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_49_50(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_50_51(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_51_52(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_52_53(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_53_54(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_54_55(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_55_56(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_56_57(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_57_58(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_58_59(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_59_60(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_60_61(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_61_62(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_62_63(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_63_64(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_64_65(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_65_66(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_66_67(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_67_68(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_68_69(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_69_70(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_70_71(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_71_72(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_72_73(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_73_74(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_74_75(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_75_76(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_76_77(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_77_78(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_78_79(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_79_80(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_80_81(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_81_82(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_82_83(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_83_84(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_84_85(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_85_86(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_86_87(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_87_88(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_88_89(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 

        npotrecfunc::compNuclearPotentialForGD_89_90(primBuffer, auxBuffer, osFactors, paDistances, pbDistances, pcDistances, 
                                                     braGtoBlock, ketGtoBlock, iContrGto); 
    }

    void
    compNuclearPotentialForGD_0_1(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (0,1)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxx = paDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxx = pcDistances.data(83 * idx + 55);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxx_xx = primBuffer.data(90 * idx);

            // Batch of Integrals (0,1)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxx, pb_x, pb_xx, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxx, pc_xxxxxx, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xxxx_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxxx_xx[j] = fl_s_0_0_0 * (1.875 * fl3_fx + 4.5 * pa_xx[j] * fl2_fx + 6.0 * pa_x[j] * fl2_fx * pb_x[j] + 0.5 * pa_xxxx[j] * fl1_fx + 4.0 * pa_xxx[j] * fl1_fx * pb_x[j] + 0.75 * fl2_fx * pb_xx[j] + 3.0 * pa_xx[j] * fl1_fx * pb_xx[j] + pa_xxxx[j] * pb_xx[j]);

                t_xxxx_xx[j] += fl_s_0_0_1 * (-5.625 * fl3_fx - 9.0 * pa_xx[j] * fl2_fx - 15.0 * pa_x[j] * pc_x[j] * fl2_fx - 12.0 * pa_x[j] * fl2_fx * pb_x[j] - 7.5 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * pa_xxxx[j] * fl1_fx - 6.0 * pa_xxx[j] * pc_x[j] * fl1_fx - 4.0 * pa_xxx[j] * fl1_fx * pb_x[j] - 18.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_x[j] - 1.5 * fl2_fx * pb_xx[j] - 3.0 * pa_xx[j] * fl1_fx * pb_xx[j] - 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xxxx[j] * pb_x[j] * pc_x[j] - 4.0 * pa_xxx[j] * pc_x[j] * pb_xx[j]);

                t_xxxx_xx[j] += fl_s_0_0_2 * (5.625 * fl3_fx + 4.5 * pa_xx[j] * fl2_fx + 30.0 * pa_x[j] * pc_x[j] * fl2_fx + 11.25 * pc_xx[j] * fl2_fx + 6.0 * pa_x[j] * fl2_fx * pb_x[j] + 15.0 * pc_x[j] * fl2_fx * pb_x[j] + 6.0 * pa_xxx[j] * pc_x[j] * fl1_fx + 18.0 * pa_xx[j] * pc_xx[j] * fl1_fx + 18.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_x[j] + 24.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] + 0.75 * fl2_fx * pb_xx[j] + 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_xx[j] + 3.0 * pc_xx[j] * fl1_fx * pb_xx[j] + pa_xxxx[j] * pc_xx[j] + 8.0 * pa_xxx[j] * pc_xx[j] * pb_x[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_xx[j]);

                t_xxxx_xx[j] += fl_s_0_0_3 * (-1.875 * fl3_fx - 15.0 * pa_x[j] * pc_x[j] * fl2_fx - 22.5 * pc_xx[j] * fl2_fx - 7.5 * pc_x[j] * fl2_fx * pb_x[j] - 18.0 * pa_xx[j] * pc_xx[j] * fl1_fx - 20.0 * pa_x[j] * pc_xxx[j] * fl1_fx - 24.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] - 10.0 * pc_xxx[j] * fl1_fx * pb_x[j] - 3.0 * pc_xx[j] * fl1_fx * pb_xx[j] - 4.0 * pa_xxx[j] * pc_xxx[j] - 12.0 * pa_xx[j] * pc_xxx[j] * pb_x[j] - 4.0 * pa_x[j] * pc_xxx[j] * pb_xx[j]);

                t_xxxx_xx[j] += fl_s_0_0_4 * (11.25 * pc_xx[j] * fl2_fx + 20.0 * pa_x[j] * pc_xxx[j] * fl1_fx + 7.5 * pc_xxxx[j] * fl1_fx + 10.0 * pc_xxx[j] * fl1_fx * pb_x[j] + 6.0 * pa_xx[j] * pc_xxxx[j] + 8.0 * pa_x[j] * pc_xxxx[j] * pb_x[j] + pc_xxxx[j] * pb_xx[j]);

                t_xxxx_xx[j] += fl_s_0_0_5 * (-7.5 * pc_xxxx[j] * fl1_fx - 4.0 * pa_x[j] * pc_xxxxx[j] - 2.0 * pc_xxxxx[j] * pb_x[j]);

                t_xxxx_xx[j] += fl_s_0_0_6 * pc_xxxxxx[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_1_2(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (1,2)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxx = paDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxy = pcDistances.data(83 * idx + 56);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxx_xy = primBuffer.data(90 * idx + 1);

            // Batch of Integrals (1,2)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxx, pb_x, pb_xy, pb_y, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxx, pc_xxxxxy, pc_xxxxy, pc_xxxy, pc_xxy, pc_xy, pc_y, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxx_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxx_xy[j] = fl_s_0_0_0 * (3.0 * pa_x[j] * fl2_fx * pb_y[j] + 2.0 * pa_xxx[j] * fl1_fx * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 3.0 * pa_xx[j] * fl1_fx * pb_xy[j] + pa_xxxx[j] * pb_xy[j]);

                t_xxxx_xy[j] += fl_s_0_0_1 * (-3.0 * pa_x[j] * fl2_fx * pc_y[j] - 6.0 * pa_x[j] * fl2_fx * pb_y[j] - 3.75 * pc_x[j] * fl2_fx * pb_y[j] - 2.0 * pa_xxx[j] * fl1_fx * pc_y[j] - 2.0 * pa_xxx[j] * fl1_fx * pb_y[j] - 9.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 1.5 * fl2_fx * pb_xy[j] - 3.0 * pa_xx[j] * fl1_fx * pb_x[j] * pc_y[j] - 3.0 * pa_xx[j] * fl1_fx * pb_xy[j] - 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_xy[j] - pa_xxxx[j] * pb_x[j] * pc_y[j] - pa_xxxx[j] * pc_x[j] * pb_y[j] - 4.0 * pa_xxx[j] * pc_x[j] * pb_xy[j]);

                t_xxxx_xy[j] += fl_s_0_0_2 * (6.0 * pa_x[j] * fl2_fx * pc_y[j] + 3.0 * pa_x[j] * fl2_fx * pb_y[j] + 3.75 * pc_xy[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx * pb_y[j] + 2.0 * pa_xxx[j] * fl1_fx * pc_y[j] + 9.0 * pa_xx[j] * pc_xy[j] * fl1_fx + 9.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] + 12.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] + 1.5 * fl2_fx * pb_x[j] * pc_y[j] + 0.75 * fl2_fx * pb_xy[j] + 3.0 * pa_xx[j] * fl1_fx * pb_x[j] * pc_y[j] + 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_xy[j] + 3.0 * pc_xx[j] * fl1_fx * pb_xy[j] + pa_xxxx[j] * pc_xy[j] + 4.0 * pa_xxx[j] * pc_xy[j] * pb_x[j] + 4.0 * pa_xxx[j] * pc_xx[j] * pb_y[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_xy[j]);

                t_xxxx_xy[j] += fl_s_0_0_3 * (-3.0 * pa_x[j] * fl2_fx * pc_y[j] - 7.5 * pc_xy[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pb_y[j] - 9.0 * pa_xx[j] * pc_xy[j] * fl1_fx - 12.0 * pa_x[j] * pc_xxy[j] * fl1_fx - 12.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] - 5.0 * pc_xxx[j] * fl1_fx * pb_y[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_x[j] - 3.0 * pc_xx[j] * fl1_fx * pb_xy[j] - 4.0 * pa_xxx[j] * pc_xxy[j] - 6.0 * pa_xx[j] * pc_xxy[j] * pb_x[j] - 6.0 * pa_xx[j] * pc_xxx[j] * pb_y[j] - 4.0 * pa_x[j] * pc_xxx[j] * pb_xy[j]);

                t_xxxx_xy[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 12.0 * pa_x[j] * pc_xxy[j] * fl1_fx + 5.0 * pc_xxxy[j] * fl1_fx + 5.0 * pc_xxx[j] * fl1_fx * pb_y[j] + 3.0 * pc_xxy[j] * fl1_fx * pb_x[j] + 6.0 * pa_xx[j] * pc_xxxy[j] + 4.0 * pa_x[j] * pc_xxxy[j] * pb_x[j] + 4.0 * pa_x[j] * pc_xxxx[j] * pb_y[j] + pc_xxxx[j] * pb_xy[j]);

                t_xxxx_xy[j] += fl_s_0_0_5 * (-5.0 * pc_xxxy[j] * fl1_fx - 4.0 * pa_x[j] * pc_xxxxy[j] - pc_xxxxy[j] * pb_x[j] - pc_xxxxx[j] * pb_y[j]);

                t_xxxx_xy[j] += fl_s_0_0_6 * pc_xxxxxy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_2_3(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (2,3)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxx = paDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxz = pcDistances.data(83 * idx + 57);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxx_xz = primBuffer.data(90 * idx + 2);

            // Batch of Integrals (2,3)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxx, pb_x, pb_xz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxx, pc_xxxxxz, pc_xxxxz, pc_xxxz, pc_xxz, pc_xz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxx_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxx_xz[j] = fl_s_0_0_0 * (3.0 * pa_x[j] * fl2_fx * pb_z[j] + 2.0 * pa_xxx[j] * fl1_fx * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 3.0 * pa_xx[j] * fl1_fx * pb_xz[j] + pa_xxxx[j] * pb_xz[j]);

                t_xxxx_xz[j] += fl_s_0_0_1 * (-3.0 * pa_x[j] * fl2_fx * pc_z[j] - 6.0 * pa_x[j] * fl2_fx * pb_z[j] - 3.75 * pc_x[j] * fl2_fx * pb_z[j] - 2.0 * pa_xxx[j] * fl1_fx * pc_z[j] - 2.0 * pa_xxx[j] * fl1_fx * pb_z[j] - 9.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 1.5 * fl2_fx * pb_xz[j] - 3.0 * pa_xx[j] * fl1_fx * pb_x[j] * pc_z[j] - 3.0 * pa_xx[j] * fl1_fx * pb_xz[j] - 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_xz[j] - pa_xxxx[j] * pb_x[j] * pc_z[j] - pa_xxxx[j] * pc_x[j] * pb_z[j] - 4.0 * pa_xxx[j] * pc_x[j] * pb_xz[j]);

                t_xxxx_xz[j] += fl_s_0_0_2 * (6.0 * pa_x[j] * fl2_fx * pc_z[j] + 3.0 * pa_x[j] * fl2_fx * pb_z[j] + 3.75 * pc_xz[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx * pb_z[j] + 2.0 * pa_xxx[j] * fl1_fx * pc_z[j] + 9.0 * pa_xx[j] * pc_xz[j] * fl1_fx + 9.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] + 12.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + 1.5 * fl2_fx * pb_x[j] * pc_z[j] + 0.75 * fl2_fx * pb_xz[j] + 3.0 * pa_xx[j] * fl1_fx * pb_x[j] * pc_z[j] + 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] + 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_xz[j] + 3.0 * pc_xx[j] * fl1_fx * pb_xz[j] + pa_xxxx[j] * pc_xz[j] + 4.0 * pa_xxx[j] * pc_xz[j] * pb_x[j] + 4.0 * pa_xxx[j] * pc_xx[j] * pb_z[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_xz[j]);

                t_xxxx_xz[j] += fl_s_0_0_3 * (-3.0 * pa_x[j] * fl2_fx * pc_z[j] - 7.5 * pc_xz[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pb_z[j] - 9.0 * pa_xx[j] * pc_xz[j] * fl1_fx - 12.0 * pa_x[j] * pc_xxz[j] * fl1_fx - 12.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - 5.0 * pc_xxx[j] * fl1_fx * pb_z[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xx[j] * fl1_fx * pb_xz[j] - 4.0 * pa_xxx[j] * pc_xxz[j] - 6.0 * pa_xx[j] * pc_xxz[j] * pb_x[j] - 6.0 * pa_xx[j] * pc_xxx[j] * pb_z[j] - 4.0 * pa_x[j] * pc_xxx[j] * pb_xz[j]);

                t_xxxx_xz[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 12.0 * pa_x[j] * pc_xxz[j] * fl1_fx + 5.0 * pc_xxxz[j] * fl1_fx + 5.0 * pc_xxx[j] * fl1_fx * pb_z[j] + 3.0 * pc_xxz[j] * fl1_fx * pb_x[j] + 6.0 * pa_xx[j] * pc_xxxz[j] + 4.0 * pa_x[j] * pc_xxxz[j] * pb_x[j] + 4.0 * pa_x[j] * pc_xxxx[j] * pb_z[j] + pc_xxxx[j] * pb_xz[j]);

                t_xxxx_xz[j] += fl_s_0_0_5 * (-5.0 * pc_xxxz[j] * fl1_fx - 4.0 * pa_x[j] * pc_xxxxz[j] - pc_xxxxz[j] * pb_x[j] - pc_xxxxx[j] * pb_z[j]);

                t_xxxx_xz[j] += fl_s_0_0_6 * pc_xxxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_3_4(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (3,4)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxx = paDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyy = pcDistances.data(83 * idx + 58);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxx_yy = primBuffer.data(90 * idx + 3);

            // Batch of Integrals (3,4)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxx, pb_y, pb_yy, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxy, pc_xxxxyy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, pc_xy, pc_xyy, pc_y, pc_yy, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxx_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxxx_yy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 1.5 * pa_xx[j] * fl2_fx + 0.5 * pa_xxxx[j] * fl1_fx + 0.75 * fl2_fx * pb_yy[j] + 3.0 * pa_xx[j] * fl1_fx * pb_yy[j] + pa_xxxx[j] * pb_yy[j]);

                t_xxxx_yy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 3.0 * pa_xx[j] * fl2_fx - 3.0 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * pa_xxxx[j] * fl1_fx - 2.0 * pa_xxx[j] * pc_x[j] * fl1_fx - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 1.5 * fl2_fx * pb_yy[j] - 6.0 * pa_xx[j] * fl1_fx * pb_y[j] * pc_y[j] - 3.0 * pa_xx[j] * fl1_fx * pb_yy[j] - 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xxxx[j] * pb_y[j] * pc_y[j] - 4.0 * pa_xxx[j] * pc_x[j] * pb_yy[j]);

                t_xxxx_yy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_xx[j] * fl2_fx + 6.0 * pa_x[j] * pc_x[j] * fl2_fx + 1.5 * pc_xx[j] * fl2_fx + 2.0 * pa_xxx[j] * pc_x[j] * fl1_fx + 3.0 * pa_xx[j] * pc_xx[j] * fl1_fx + 0.75 * fl2_fx * pc_yy[j] + 3.0 * fl2_fx * pb_y[j] * pc_y[j] + 0.75 * fl2_fx * pb_yy[j] + 3.0 * pa_xx[j] * fl1_fx * pc_yy[j] + 6.0 * pa_xx[j] * fl1_fx * pb_y[j] * pc_y[j] + 12.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] + 3.0 * pc_xx[j] * fl1_fx * pb_yy[j] + pa_xxxx[j] * pc_yy[j] + 8.0 * pa_xxx[j] * pc_xy[j] * pb_y[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_yy[j]);

                t_xxxx_yy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 3.0 * pa_xx[j] * pc_xx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxx[j] * fl1_fx - 1.5 * fl2_fx * pc_yy[j] - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 3.0 * pa_xx[j] * fl1_fx * pc_yy[j] - 6.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 12.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 6.0 * pc_xxy[j] * fl1_fx * pb_y[j] - 3.0 * pc_xx[j] * fl1_fx * pb_yy[j] - 4.0 * pa_xxx[j] * pc_xyy[j] - 12.0 * pa_xx[j] * pc_xxy[j] * pb_y[j] - 4.0 * pa_x[j] * pc_xxx[j] * pb_yy[j]);

                t_xxxx_yy[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 2.0 * pa_x[j] * pc_xxx[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + 0.75 * fl2_fx * pc_yy[j] + 6.0 * pa_x[j] * pc_xyy[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 6.0 * pc_xxy[j] * fl1_fx * pb_y[j] + 6.0 * pa_xx[j] * pc_xxyy[j] + 8.0 * pa_x[j] * pc_xxxy[j] * pb_y[j] + pc_xxxx[j] * pb_yy[j]);

                t_xxxx_yy[j] += fl_s_0_0_5 * (-0.5 * pc_xxxx[j] * fl1_fx - 3.0 * pc_xxyy[j] * fl1_fx - 4.0 * pa_x[j] * pc_xxxyy[j] - 2.0 * pc_xxxxy[j] * pb_y[j]);

                t_xxxx_yy[j] += fl_s_0_0_6 * pc_xxxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_4_5(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (4,5)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxx = paDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxx_yz = primBuffer.data(90 * idx + 4);

            // Batch of Integrals (4,5)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxx, pb_y, pb_yz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyz, pc_xxz, \
                                     pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xxxx_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxx_yz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_yz[j] + 3.0 * pa_xx[j] * fl1_fx * pb_yz[j] + pa_xxxx[j] * pb_yz[j]);

                t_xxxx_yz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * fl2_fx * pb_yz[j] - 3.0 * pa_xx[j] * fl1_fx * pb_y[j] * pc_z[j] - 3.0 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] - 3.0 * pa_xx[j] * fl1_fx * pb_yz[j] - 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] - pa_xxxx[j] * pb_y[j] * pc_z[j] - pa_xxxx[j] * pc_y[j] * pb_z[j] - 4.0 * pa_xxx[j] * pc_x[j] * pb_yz[j]);

                t_xxxx_yz[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pb_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 3.0 * pa_xx[j] * fl1_fx * pc_yz[j] + 3.0 * pa_xx[j] * fl1_fx * pb_y[j] * pc_z[j] + 3.0 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] + 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] + 3.0 * pc_xx[j] * fl1_fx * pb_yz[j] + pa_xxxx[j] * pc_yz[j] + 4.0 * pa_xxx[j] * pc_xz[j] * pb_y[j] + 4.0 * pa_xxx[j] * pc_xy[j] * pb_z[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_yz[j]);

                t_xxxx_yz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 3.0 * pa_xx[j] * fl1_fx * pc_yz[j] - 6.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] - 3.0 * pc_xx[j] * fl1_fx * pb_yz[j] - 4.0 * pa_xxx[j] * pc_xyz[j] - 6.0 * pa_xx[j] * pc_xxz[j] * pb_y[j] - 6.0 * pa_xx[j] * pc_xxy[j] * pb_z[j] - 4.0 * pa_x[j] * pc_xxx[j] * pb_yz[j]);

                t_xxxx_yz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 6.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] + 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] + 6.0 * pa_xx[j] * pc_xxyz[j] + 4.0 * pa_x[j] * pc_xxxz[j] * pb_y[j] + 4.0 * pa_x[j] * pc_xxxy[j] * pb_z[j] + pc_xxxx[j] * pb_yz[j]);

                t_xxxx_yz[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - 4.0 * pa_x[j] * pc_xxxyz[j] - pc_xxxxz[j] * pb_y[j] - pc_xxxxy[j] * pb_z[j]);

                t_xxxx_yz[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_5_6(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (5,6)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxx = paDistances.data(34 * idx + 19);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxzz = pcDistances.data(83 * idx + 60);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxx_zz = primBuffer.data(90 * idx + 5);

            // Batch of Integrals (5,6)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxx, pb_z, pb_zz, pc_x, pc_xx, pc_xxx, pc_xxxx, \
                                     pc_xxxxz, pc_xxxxzz, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, pc_xz, pc_xzz, pc_z, pc_zz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxx_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxxx_zz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 1.5 * pa_xx[j] * fl2_fx + 0.5 * pa_xxxx[j] * fl1_fx + 0.75 * fl2_fx * pb_zz[j] + 3.0 * pa_xx[j] * fl1_fx * pb_zz[j] + pa_xxxx[j] * pb_zz[j]);

                t_xxxx_zz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 3.0 * pa_xx[j] * fl2_fx - 3.0 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * pa_xxxx[j] * fl1_fx - 2.0 * pa_xxx[j] * pc_x[j] * fl1_fx - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 1.5 * fl2_fx * pb_zz[j] - 6.0 * pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] - 3.0 * pa_xx[j] * fl1_fx * pb_zz[j] - 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xxxx[j] * pb_z[j] * pc_z[j] - 4.0 * pa_xxx[j] * pc_x[j] * pb_zz[j]);

                t_xxxx_zz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_xx[j] * fl2_fx + 6.0 * pa_x[j] * pc_x[j] * fl2_fx + 1.5 * pc_xx[j] * fl2_fx + 2.0 * pa_xxx[j] * pc_x[j] * fl1_fx + 3.0 * pa_xx[j] * pc_xx[j] * fl1_fx + 0.75 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pb_z[j] * pc_z[j] + 0.75 * fl2_fx * pb_zz[j] + 3.0 * pa_xx[j] * fl1_fx * pc_zz[j] + 6.0 * pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] + 12.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 6.0 * pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] + 3.0 * pc_xx[j] * fl1_fx * pb_zz[j] + pa_xxxx[j] * pc_zz[j] + 8.0 * pa_xxx[j] * pc_xz[j] * pb_z[j] + 6.0 * pa_xx[j] * pc_xx[j] * pb_zz[j]);

                t_xxxx_zz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 3.0 * pa_xx[j] * pc_xx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxx[j] * fl1_fx - 1.5 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 3.0 * pa_xx[j] * fl1_fx * pc_zz[j] - 6.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 12.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 6.0 * pc_xxz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xx[j] * fl1_fx * pb_zz[j] - 4.0 * pa_xxx[j] * pc_xzz[j] - 12.0 * pa_xx[j] * pc_xxz[j] * pb_z[j] - 4.0 * pa_x[j] * pc_xxx[j] * pb_zz[j]);

                t_xxxx_zz[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 2.0 * pa_x[j] * pc_xxx[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + 0.75 * fl2_fx * pc_zz[j] + 6.0 * pa_x[j] * pc_xzz[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 6.0 * pc_xxz[j] * fl1_fx * pb_z[j] + 6.0 * pa_xx[j] * pc_xxzz[j] + 8.0 * pa_x[j] * pc_xxxz[j] * pb_z[j] + pc_xxxx[j] * pb_zz[j]);

                t_xxxx_zz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxx[j] * fl1_fx - 3.0 * pc_xxzz[j] * fl1_fx - 4.0 * pa_x[j] * pc_xxxzz[j] - 2.0 * pc_xxxxz[j] * pb_z[j]);

                t_xxxx_zz[j] += fl_s_0_0_6 * pc_xxxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_6_7(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (6,7)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxy = paDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxy = paDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxy = pcDistances.data(83 * idx + 56);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxy_xx = primBuffer.data(90 * idx + 6);

            // Batch of Integrals (6,7)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxy, pa_xxy, pa_xy, pa_y, pb_x, pb_xx, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxx, pc_xxxxx, pc_xxxxxy, pc_xxxxy, pc_xxxy, pc_xxy, pc_xy, pc_y, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxy_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxy_xx[j] = fl_s_0_0_0 * (2.25 * pa_xy[j] * fl2_fx + 1.5 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xxxy[j] * fl1_fx + 3.0 * pa_xxy[j] * fl1_fx * pb_x[j] + 1.5 * pa_xy[j] * fl1_fx * pb_xx[j] + pa_xxxy[j] * pb_xx[j]);

                t_xxxy_xx[j] += fl_s_0_0_1 * (-2.25 * pa_x[j] * fl2_fx * pc_y[j] - 4.5 * pa_xy[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pa_y[j] - 1.5 * fl2_fx * pc_y[j] * pb_x[j] - 3.0 * fl2_fx * pa_y[j] * pb_x[j] - 0.5 * pa_xxxy[j] * fl1_fx - 0.5 * pa_xxx[j] * pc_y[j] * fl1_fx - 4.5 * pa_xxy[j] * pc_x[j] * fl1_fx - 3.0 * pa_xx[j] * fl1_fx * pc_y[j] * pb_x[j] - 3.0 * pa_xxy[j] * fl1_fx * pb_x[j] - 9.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_xx[j] - 1.5 * pa_xy[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_xx[j] - 2.0 * pa_xxxy[j] * pb_x[j] * pc_x[j] - pa_xxx[j] * pc_y[j] * pb_xx[j] - 3.0 * pa_xxy[j] * pc_x[j] * pb_xx[j]);

                t_xxxy_xx[j] += fl_s_0_0_2 * (4.5 * pa_x[j] * fl2_fx * pc_y[j] + 2.25 * pa_xy[j] * fl2_fx + 3.75 * pc_xy[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx * pa_y[j] + 3.0 * fl2_fx * pc_y[j] * pb_x[j] + 1.5 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xxx[j] * pc_y[j] * fl1_fx + 4.5 * pa_xxy[j] * pc_x[j] * fl1_fx + 4.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 3.0 * pa_xx[j] * fl1_fx * pc_y[j] * pb_x[j] + 9.0 * pa_xy[j] * pc_xx[j] * fl1_fx + 9.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + 9.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_x[j] + 6.0 * pc_xx[j] * fl1_fx * pa_y[j] * pb_x[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_xx[j] + 1.5 * pc_xy[j] * fl1_fx * pb_xx[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_xx[j] + pa_xxxy[j] * pc_xx[j] + 2.0 * pa_xxx[j] * pc_xy[j] * pb_x[j] + 6.0 * pa_xxy[j] * pc_xx[j] * pb_x[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_xx[j] + 3.0 * pa_xy[j] * pc_xx[j] * pb_xx[j]);

                t_xxxy_xx[j] += fl_s_0_0_3 * (-2.25 * pa_x[j] * fl2_fx * pc_y[j] - 7.5 * pc_xy[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pa_y[j] - 1.5 * fl2_fx * pc_y[j] * pb_x[j] - 4.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 9.0 * pa_xy[j] * pc_xx[j] * fl1_fx - 9.0 * pa_x[j] * pc_xxy[j] * fl1_fx - 9.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - 5.0 * pc_xxx[j] * pa_y[j] * fl1_fx - 6.0 * pc_xxy[j] * fl1_fx * pb_x[j] - 6.0 * pc_xx[j] * fl1_fx * pa_y[j] * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xx[j] - pa_xxx[j] * pc_xxy[j] - 3.0 * pa_xxy[j] * pc_xxx[j] - 6.0 * pa_xx[j] * pc_xxy[j] * pb_x[j] - 6.0 * pa_xy[j] * pc_xxx[j] * pb_x[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_xx[j] - pc_xxx[j] * pa_y[j] * pb_xx[j]);

                t_xxxy_xx[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 9.0 * pa_x[j] * pc_xxy[j] * fl1_fx + 5.0 * pc_xxx[j] * pa_y[j] * fl1_fx + 5.0 * pc_xxxy[j] * fl1_fx + 6.0 * pc_xxy[j] * fl1_fx * pb_x[j] + 3.0 * pa_xx[j] * pc_xxxy[j] + 3.0 * pa_xy[j] * pc_xxxx[j] + 6.0 * pa_x[j] * pc_xxxy[j] * pb_x[j] + 2.0 * pc_xxxx[j] * pa_y[j] * pb_x[j] + pc_xxxy[j] * pb_xx[j]);

                t_xxxy_xx[j] += fl_s_0_0_5 * (-5.0 * pc_xxxy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxxxy[j] - pc_xxxxx[j] * pa_y[j] - 2.0 * pc_xxxxy[j] * pb_x[j]);

                t_xxxy_xx[j] += fl_s_0_0_6 * pc_xxxxxy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_7_8(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (7,8)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxy = paDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxy = paDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyy = pcDistances.data(83 * idx + 58);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxy_xy = primBuffer.data(90 * idx + 7);

            // Batch of Integrals (7,8)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxy, pa_xxy, pa_xy, pa_y, pb_x, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, \
                                     pc_xy, pc_xyy, pc_y, pc_yy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxxy_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxxy_xy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 0.5 * pa_xxx[j] * fl1_fx * pb_x[j] + 1.5 * pa_xxy[j] * fl1_fx * pb_y[j] + 1.5 * pa_xy[j] * fl1_fx * pb_xy[j] + pa_xxxy[j] * pb_xy[j]);

                t_xxxy_xy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 2.25 * pa_x[j] * pc_x[j] * fl2_fx - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pa_y[j] * pc_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.5 * pa_xxx[j] * fl1_fx * pc_x[j] - 0.5 * pa_xxx[j] * fl1_fx * pb_x[j] - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_x[j] - 1.5 * pa_xxy[j] * fl1_fx * pc_y[j] - 1.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_y[j] - 1.5 * pa_xxy[j] * fl1_fx * pb_y[j] - 4.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_xy[j] - 1.5 * pa_xy[j] * fl1_fx * pb_xy[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_xy[j] - pa_xxxy[j] * pb_x[j] * pc_y[j] - pa_xxxy[j] * pc_x[j] * pb_y[j] - pa_xxx[j] * pc_y[j] * pb_xy[j] - 3.0 * pa_xxy[j] * pc_x[j] * pb_xy[j]);

                t_xxxy_xy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 4.5 * pa_x[j] * pc_x[j] * fl2_fx + 1.5 * pc_xx[j] * fl2_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pc_yy[j] + 1.5 * fl2_fx * pa_y[j] * pc_y[j] + 1.5 * fl2_fx * pc_y[j] * pb_y[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 0.5 * pa_xxx[j] * fl1_fx * pc_x[j] + 1.5 * pa_xx[j] * pc_xx[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_x[j] + 1.5 * pa_xx[j] * fl1_fx * pc_yy[j] + 1.5 * pa_xxy[j] * fl1_fx * pc_y[j] + 1.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_y[j] + 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] + 4.5 * pa_xy[j] * pc_xy[j] * fl1_fx + 4.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 4.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] + 3.0 * pc_xx[j] * fl1_fx * pa_y[j] * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_yy[j] * pb_x[j] + 1.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_xy[j] + 1.5 * pc_xy[j] * fl1_fx * pa_y[j] * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pb_xy[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_xy[j] + pa_xxxy[j] * pc_xy[j] + pa_xxx[j] * pc_yy[j] * pb_x[j] + pa_xxx[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_xxy[j] * pc_xy[j] * pb_x[j] + 3.0 * pa_xxy[j] * pc_xx[j] * pb_y[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_xy[j] + 3.0 * pa_xy[j] * pc_xx[j] * pb_xy[j]);

                t_xxxy_xy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 2.25 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pc_yy[j] - 0.75 * fl2_fx * pa_y[j] * pc_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * pa_xx[j] * pc_xx[j] * fl1_fx - 1.5 * pa_xx[j] * fl1_fx * pc_yy[j] - 1.5 * pa_x[j] * pc_xxx[j] * fl1_fx - 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] - 4.5 * pa_x[j] * pc_xyy[j] * fl1_fx - 4.5 * pa_xy[j] * pc_xy[j] * fl1_fx - 4.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_x[j] - 3.0 * pc_xxy[j] * fl1_fx * pa_y[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] - 3.0 * pc_xx[j] * fl1_fx * pa_y[j] * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_yy[j] * pb_x[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pa_y[j] * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xy[j] - pa_xxx[j] * pc_xyy[j] - 3.0 * pa_xxy[j] * pc_xxy[j] - 3.0 * pa_xx[j] * pc_xyy[j] * pb_x[j] - 3.0 * pa_xx[j] * pc_xxy[j] * pb_y[j] - 3.0 * pa_xy[j] * pc_xxy[j] * pb_x[j] - 3.0 * pa_xy[j] * pc_xxx[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_xy[j] - pc_xxx[j] * pa_y[j] * pb_xy[j]);

                t_xxxy_xy[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 0.75 * fl2_fx * pc_yy[j] + 1.5 * pa_x[j] * pc_xxx[j] * fl1_fx + 4.5 * pa_x[j] * pc_xyy[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pb_x[j] + 3.0 * pc_xxyy[j] * fl1_fx + 3.0 * pc_xxy[j] * fl1_fx * pa_y[j] + 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pb_x[j] + 3.0 * pa_xx[j] * pc_xxyy[j] + 3.0 * pa_xy[j] * pc_xxxy[j] + 3.0 * pa_x[j] * pc_xxyy[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xxxy[j] * pb_y[j] + pc_xxxy[j] * pa_y[j] * pb_x[j] + pc_xxxx[j] * pa_y[j] * pb_y[j] + pc_xxxy[j] * pb_xy[j]);

                t_xxxy_xy[j] += fl_s_0_0_5 * (-0.5 * pc_xxxx[j] * fl1_fx - 3.0 * pc_xxyy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxxyy[j] - pc_xxxxy[j] * pa_y[j] - pc_xxxyy[j] * pb_x[j] - pc_xxxxy[j] * pb_y[j]);

                t_xxxy_xy[j] += fl_s_0_0_6 * pc_xxxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_8_9(      CMemBlock2D<double>& primBuffer,
                                  const CMemBlock2D<double>& auxBuffer,
                                  const CMemBlock2D<double>& osFactors,
                                  const CMemBlock2D<double>& paDistances,
                                  const CMemBlock2D<double>& pbDistances,
                                  const CMemBlock2D<double>& pcDistances,
                                  const CGtoBlock&           braGtoBlock,
                                  const CGtoBlock&           ketGtoBlock,
                                  const int32_t              iContrGto)
    {
        // Batch of Integrals (8,9)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxy = paDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxy = paDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxy_xz = primBuffer.data(90 * idx + 8);

            // Batch of Integrals (8,9)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxy, pa_xxy, pa_xy, pa_y, pb_x, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, \
                                     pc_xxy, pc_xxyz, pc_xxz, pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxy_xz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xxy[j] * fl1_fx * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pb_xz[j] + pa_xxxy[j] * pb_xz[j]);

                t_xxxy_xz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * fl2_fx * pa_y[j] * pb_z[j] - 1.5 * pa_xxy[j] * fl1_fx * pc_z[j] - 1.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xxy[j] * fl1_fx * pb_z[j] - 4.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_xz[j] - 1.5 * pa_xy[j] * fl1_fx * pb_xz[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_xz[j] - pa_xxxy[j] * pb_x[j] * pc_z[j] - pa_xxxy[j] * pc_x[j] * pb_z[j] - pa_xxx[j] * pc_y[j] * pb_xz[j] - 3.0 * pa_xxy[j] * pc_x[j] * pb_xz[j]);

                t_xxxy_xz[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pa_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xx[j] * fl1_fx * pc_yz[j] + 1.5 * pa_xxy[j] * fl1_fx * pc_z[j] + 1.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] + 4.5 * pa_xy[j] * pc_xz[j] * fl1_fx + 4.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 4.5 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pc_xx[j] * fl1_fx * pa_y[j] * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_x[j] + 1.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_xz[j] + 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pb_xz[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_xz[j] + pa_xxxy[j] * pc_xz[j] + pa_xxx[j] * pc_yz[j] * pb_x[j] + pa_xxx[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_xxy[j] * pc_xz[j] * pb_x[j] + 3.0 * pa_xxy[j] * pc_xx[j] * pb_z[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_xz[j] + 3.0 * pa_xy[j] * pc_xx[j] * pb_xz[j]);

                t_xxxy_xz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * fl1_fx * pc_yz[j] - 4.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 4.5 * pa_xy[j] * pc_xz[j] * fl1_fx - 4.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 3.0 * pc_xxz[j] * fl1_fx * pa_y[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] - 3.0 * pc_xx[j] * fl1_fx * pa_y[j] * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_x[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xz[j] - pa_xxx[j] * pc_xyz[j] - 3.0 * pa_xxy[j] * pc_xxz[j] - 3.0 * pa_xx[j] * pc_xyz[j] * pb_x[j] - 3.0 * pa_xx[j] * pc_xxy[j] * pb_z[j] - 3.0 * pa_xy[j] * pc_xxz[j] * pb_x[j] - 3.0 * pa_xy[j] * pc_xxx[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_xz[j] - pc_xxx[j] * pa_y[j] * pb_xz[j]);

                t_xxxy_xz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 4.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pa_y[j] + 3.0 * pc_xxy[j] * fl1_fx * pb_z[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] + 3.0 * pa_xx[j] * pc_xxyz[j] + 3.0 * pa_xy[j] * pc_xxxz[j] + 3.0 * pa_x[j] * pc_xxyz[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xxxy[j] * pb_z[j] + pc_xxxz[j] * pa_y[j] * pb_x[j] + pc_xxxx[j] * pa_y[j] * pb_z[j] + pc_xxxy[j] * pb_xz[j]);

                t_xxxy_xz[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxxyz[j] - pc_xxxxz[j] * pa_y[j] - pc_xxxyz[j] * pb_x[j] - pc_xxxxy[j] * pb_z[j]);

                t_xxxy_xz[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_9_10(      CMemBlock2D<double>& primBuffer,
                                   const CMemBlock2D<double>& auxBuffer,
                                   const CMemBlock2D<double>& osFactors,
                                   const CMemBlock2D<double>& paDistances,
                                   const CMemBlock2D<double>& pbDistances,
                                   const CMemBlock2D<double>& pcDistances,
                                   const CGtoBlock&           braGtoBlock,
                                   const CGtoBlock&           ketGtoBlock,
                                   const int32_t              iContrGto)
    {
        // Batch of Integrals (9,10)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxy = paDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxy = paDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyy = pcDistances.data(83 * idx + 61);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxy_yy = primBuffer.data(90 * idx + 9);

            // Batch of Integrals (9,10)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxy, pa_xxy, pa_xy, pa_y, pb_y, pb_yy, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyy, pc_xxy, pc_xxyy, pc_xxyyy, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_y, pc_yy, pc_yyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxxy_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxy_yy[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xxxy[j] * fl1_fx + pa_xxx[j] * fl1_fx * pb_y[j] + 1.5 * pa_xy[j] * fl1_fx * pb_yy[j] + pa_xxxy[j] * pb_yy[j]);

                t_xxxy_yy[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 2.25 * pa_x[j] * fl2_fx * pc_y[j] - 3.0 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * fl2_fx * pa_y[j] - 1.5 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xxxy[j] * fl1_fx - 1.5 * pa_xxx[j] * pc_y[j] * fl1_fx - pa_xxx[j] * fl1_fx * pb_y[j] - 1.5 * pa_xxy[j] * pc_x[j] * fl1_fx - 3.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] - 3.0 * pa_xy[j] * fl1_fx * pb_y[j] * pc_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_yy[j] - 1.5 * pa_xy[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_yy[j] - 2.0 * pa_xxxy[j] * pb_y[j] * pc_y[j] - pa_xxx[j] * pc_y[j] * pb_yy[j] - 3.0 * pa_xxy[j] * pc_x[j] * pb_yy[j]);

                t_xxxy_yy[j] += fl_s_0_0_2 * (4.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * fl2_fx * pa_y[j] + 2.25 * pc_xy[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_y[j] + 1.5 * pa_xxx[j] * pc_y[j] * fl1_fx + 1.5 * pa_xxy[j] * pc_x[j] * fl1_fx + 4.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 3.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] + 1.5 * pa_xy[j] * pc_xx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] + 1.5 * pa_xy[j] * fl1_fx * pc_yy[j] + 3.0 * pa_x[j] * fl1_fx * pc_yy[j] * pb_y[j] + 3.0 * pa_xy[j] * fl1_fx * pb_y[j] * pc_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_yy[j] + 3.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_yy[j] + pa_xxxy[j] * pc_yy[j] + 2.0 * pa_xxx[j] * pc_yy[j] * pb_y[j] + 6.0 * pa_xxy[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_yy[j] + 3.0 * pa_xy[j] * pc_xx[j] * pb_yy[j]);

                t_xxxy_yy[j] += fl_s_0_0_3 * (-2.25 * pa_x[j] * fl2_fx * pc_y[j] - 4.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_y[j] - 1.5 * pc_x[j] * fl2_fx * pb_y[j] - 4.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 1.5 * pa_xy[j] * pc_xx[j] * fl1_fx - 4.5 * pa_x[j] * pc_xxy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx - pc_xxx[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_yyy[j] - 1.5 * pa_xy[j] * fl1_fx * pc_yy[j] - 3.0 * pa_x[j] * fl1_fx * pc_yy[j] * pb_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pa_y[j] - 3.0 * pc_xyy[j] * fl1_fx * pb_y[j] - 3.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] - pa_xxx[j] * pc_yyy[j] - 3.0 * pa_xxy[j] * pc_xyy[j] - 6.0 * pa_xx[j] * pc_xyy[j] * pb_y[j] - 6.0 * pa_xy[j] * pc_xxy[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_yy[j] - pc_xxx[j] * pa_y[j] * pb_yy[j]);

                t_xxxy_yy[j] += fl_s_0_0_4 * (2.25 * pc_xy[j] * fl2_fx + 4.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxxy[j] * fl1_fx + pc_xxx[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_yyy[j] + 1.5 * pc_xyyy[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx * pa_y[j] + 3.0 * pc_xyy[j] * fl1_fx * pb_y[j] + 3.0 * pa_xx[j] * pc_xyyy[j] + 3.0 * pa_xy[j] * pc_xxyy[j] + 6.0 * pa_x[j] * pc_xxyy[j] * pb_y[j] + 2.0 * pc_xxxy[j] * pa_y[j] * pb_y[j] + pc_xxxy[j] * pb_yy[j]);

                t_xxxy_yy[j] += fl_s_0_0_5 * (-1.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyyy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxyyy[j] - pc_xxxyy[j] * pa_y[j] - 2.0 * pc_xxxyy[j] * pb_y[j]);

                t_xxxy_yy[j] += fl_s_0_0_6 * pc_xxxyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_10_11(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (10,11)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxy = paDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxy = paDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxy_yz = primBuffer.data(90 * idx + 10);

            // Batch of Integrals (10,11)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxy, pa_xxy, pa_xy, pa_y, pb_y, pb_yz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, \
                                     pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyz, \
                                     pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xxxy_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxy_yz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pa_xxx[j] * fl1_fx * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pb_yz[j] + pa_xxxy[j] * pb_yz[j]);

                t_xxxy_yz[j] += fl_s_0_0_1 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * pa_xxx[j] * fl1_fx * pc_z[j] - 0.5 * pa_xxx[j] * fl1_fx * pb_z[j] - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_y[j] * pc_z[j] - 1.5 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_yz[j] - 1.5 * pa_xy[j] * fl1_fx * pb_yz[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_yz[j] - pa_xxxy[j] * pb_y[j] * pc_z[j] - pa_xxxy[j] * pc_y[j] * pb_z[j] - pa_xxx[j] * pc_y[j] * pb_yz[j] - 3.0 * pa_xxy[j] * pc_x[j] * pb_yz[j]);

                t_xxxy_yz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 0.5 * pa_xxx[j] * fl1_fx * pc_z[j] + 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pc_yz[j] + 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pb_y[j] * pc_z[j] + 1.5 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_yz[j] + 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pa_y[j] * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pb_yz[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_yz[j] + pa_xxxy[j] * pc_yz[j] + pa_xxx[j] * pc_yz[j] * pb_y[j] + pa_xxx[j] * pc_yy[j] * pb_z[j] + 3.0 * pa_xxy[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_xxy[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_yz[j] + 3.0 * pa_xy[j] * pc_xx[j] * pb_yz[j]);

                t_xxxy_yz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx - 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_yyz[j] - 1.5 * pa_xy[j] * fl1_fx * pc_yz[j] - 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pa_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_y[j] * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yz[j] - pa_xxx[j] * pc_yyz[j] - 3.0 * pa_xxy[j] * pc_xyz[j] - 3.0 * pa_xx[j] * pc_xyz[j] * pb_y[j] - 3.0 * pa_xx[j] * pc_xyy[j] * pb_z[j] - 3.0 * pa_xy[j] * pc_xxz[j] * pb_y[j] - 3.0 * pa_xy[j] * pc_xxy[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_yz[j] - pc_xxx[j] * pa_y[j] * pb_yz[j]);

                t_xxxy_yz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx + 0.5 * pc_xxxz[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_yyz[j] + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pa_y[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] + 3.0 * pa_xx[j] * pc_xyyz[j] + 3.0 * pa_xy[j] * pc_xxyz[j] + 3.0 * pa_x[j] * pc_xxyz[j] * pb_y[j] + 3.0 * pa_x[j] * pc_xxyy[j] * pb_z[j] + pc_xxxz[j] * pa_y[j] * pb_y[j] + pc_xxxy[j] * pa_y[j] * pb_z[j] + pc_xxxy[j] * pb_yz[j]);

                t_xxxy_yz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxyyz[j] - pc_xxxyz[j] * pa_y[j] - pc_xxxyz[j] * pb_y[j] - pc_xxxyy[j] * pb_z[j]);

                t_xxxy_yz[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_11_12(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (11,12)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxy = paDistances.data(34 * idx + 10);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxy = paDistances.data(34 * idx + 20);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxy_zz = primBuffer.data(90 * idx + 11);

            // Batch of Integrals (11,12)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxy, pa_xxy, pa_xy, pa_y, pb_z, pb_zz, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, pc_xxy, pc_xxyz, pc_xxyzz, \
                                     pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxy_zz[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 0.5 * pa_xxxy[j] * fl1_fx + 1.5 * pa_xy[j] * fl1_fx * pb_zz[j] + pa_xxxy[j] * pb_zz[j]);

                t_xxxy_zz[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * fl2_fx * pc_y[j] - 0.75 * pc_x[j] * fl2_fx * pa_y[j] - 0.5 * pa_xxxy[j] * fl1_fx - 0.5 * pa_xxx[j] * pc_y[j] * fl1_fx - 1.5 * pa_xxy[j] * pc_x[j] * fl1_fx - 3.0 * pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_zz[j] - 1.5 * pa_xy[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_zz[j] - 2.0 * pa_xxxy[j] * pb_z[j] * pc_z[j] - pa_xxx[j] * pc_y[j] * pb_zz[j] - 3.0 * pa_xxy[j] * pc_x[j] * pb_zz[j]);

                t_xxxy_zz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.75 * pa_xy[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pa_y[j] + 0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_xxx[j] * pc_y[j] * fl1_fx + 1.5 * pa_xxy[j] * pc_x[j] * fl1_fx + 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 1.5 * pa_xy[j] * pc_xx[j] * fl1_fx + 1.5 * pa_xy[j] * fl1_fx * pc_zz[j] + 3.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] + 3.0 * pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_y[j] * pb_zz[j] + 3.0 * pc_xz[j] * fl1_fx * pa_y[j] * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * fl1_fx * pa_y[j] * pb_zz[j] + pa_xxxy[j] * pc_zz[j] + 2.0 * pa_xxx[j] * pc_yz[j] * pb_z[j] + 6.0 * pa_xxy[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_xx[j] * pc_xy[j] * pb_zz[j] + 3.0 * pa_xy[j] * pc_xx[j] * pb_zz[j]);

                t_xxxy_zz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_y[j] - 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 1.5 * pa_xy[j] * pc_xx[j] * fl1_fx - 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx - 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_yzz[j] - 1.5 * pa_xy[j] * fl1_fx * pc_zz[j] - 3.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] - 1.5 * pc_xzz[j] * fl1_fx * pa_y[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xz[j] * fl1_fx * pa_y[j] * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - pa_xxx[j] * pc_yzz[j] - 3.0 * pa_xxy[j] * pc_xzz[j] - 6.0 * pa_xx[j] * pc_xyz[j] * pb_z[j] - 6.0 * pa_xy[j] * pc_xxz[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xxy[j] * pb_zz[j] - pc_xxx[j] * pa_y[j] * pb_zz[j]);

                t_xxxy_zz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_yzz[j] + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pa_y[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xx[j] * pc_xyzz[j] + 3.0 * pa_xy[j] * pc_xxzz[j] + 6.0 * pa_x[j] * pc_xxyz[j] * pb_z[j] + 2.0 * pc_xxxz[j] * pa_y[j] * pb_z[j] + pc_xxxy[j] * pb_zz[j]);

                t_xxxy_zz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxyzz[j] - pc_xxxzz[j] * pa_y[j] - 2.0 * pc_xxxyz[j] * pb_z[j]);

                t_xxxy_zz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_12_13(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (12,13)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxz = paDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxx = pcDistances.data(83 * idx + 34);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxxz = pcDistances.data(83 * idx + 57);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxz_xx = primBuffer.data(90 * idx + 12);

            // Batch of Integrals (12,13)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxz, pa_xxz, pa_xz, pa_z, pb_x, pb_xx, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxx, pc_xxxxx, pc_xxxxxz, pc_xxxxz, pc_xxxz, pc_xxz, pc_xz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxz_xx[j] = fl_s_0_0_0 * (2.25 * pa_xz[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xxxz[j] * fl1_fx + 3.0 * pa_xxz[j] * fl1_fx * pb_x[j] + 1.5 * pa_xz[j] * fl1_fx * pb_xx[j] + pa_xxxz[j] * pb_xx[j]);

                t_xxxz_xx[j] += fl_s_0_0_1 * (-2.25 * pa_x[j] * fl2_fx * pc_z[j] - 4.5 * pa_xz[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pa_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_x[j] - 3.0 * fl2_fx * pa_z[j] * pb_x[j] - 0.5 * pa_xxxz[j] * fl1_fx - 0.5 * pa_xxx[j] * pc_z[j] * fl1_fx - 4.5 * pa_xxz[j] * pc_x[j] * fl1_fx - 3.0 * pa_xx[j] * fl1_fx * pc_z[j] * pb_x[j] - 3.0 * pa_xxz[j] * fl1_fx * pb_x[j] - 9.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xx[j] - 1.5 * pa_xz[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xx[j] - 2.0 * pa_xxxz[j] * pb_x[j] * pc_x[j] - pa_xxx[j] * pc_z[j] * pb_xx[j] - 3.0 * pa_xxz[j] * pc_x[j] * pb_xx[j]);

                t_xxxz_xx[j] += fl_s_0_0_2 * (4.5 * pa_x[j] * fl2_fx * pc_z[j] + 2.25 * pa_xz[j] * fl2_fx + 3.75 * pc_xz[j] * fl2_fx + 7.5 * pc_x[j] * fl2_fx * pa_z[j] + 3.0 * fl2_fx * pc_z[j] * pb_x[j] + 1.5 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xxx[j] * pc_z[j] * fl1_fx + 4.5 * pa_xxz[j] * pc_x[j] * fl1_fx + 4.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 3.0 * pa_xx[j] * fl1_fx * pc_z[j] * pb_x[j] + 9.0 * pa_xz[j] * pc_xx[j] * fl1_fx + 9.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] + 9.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_x[j] + 6.0 * pc_xx[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xx[j] + 1.5 * pc_xz[j] * fl1_fx * pb_xx[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xx[j] + pa_xxxz[j] * pc_xx[j] + 2.0 * pa_xxx[j] * pc_xz[j] * pb_x[j] + 6.0 * pa_xxz[j] * pc_xx[j] * pb_x[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_xx[j] + 3.0 * pa_xz[j] * pc_xx[j] * pb_xx[j]);

                t_xxxz_xx[j] += fl_s_0_0_3 * (-2.25 * pa_x[j] * fl2_fx * pc_z[j] - 7.5 * pc_xz[j] * fl2_fx - 3.75 * pc_x[j] * fl2_fx * pa_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_x[j] - 4.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 9.0 * pa_xz[j] * pc_xx[j] * fl1_fx - 9.0 * pa_x[j] * pc_xxz[j] * fl1_fx - 9.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] - 5.0 * pc_xxx[j] * pa_z[j] * fl1_fx - 6.0 * pc_xxz[j] * fl1_fx * pb_x[j] - 6.0 * pc_xx[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_xx[j] - pa_xxx[j] * pc_xxz[j] - 3.0 * pa_xxz[j] * pc_xxx[j] - 6.0 * pa_xx[j] * pc_xxz[j] * pb_x[j] - 6.0 * pa_xz[j] * pc_xxx[j] * pb_x[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_xx[j] - pc_xxx[j] * pa_z[j] * pb_xx[j]);

                t_xxxz_xx[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 9.0 * pa_x[j] * pc_xxz[j] * fl1_fx + 5.0 * pc_xxx[j] * pa_z[j] * fl1_fx + 5.0 * pc_xxxz[j] * fl1_fx + 6.0 * pc_xxz[j] * fl1_fx * pb_x[j] + 3.0 * pa_xx[j] * pc_xxxz[j] + 3.0 * pa_xz[j] * pc_xxxx[j] + 6.0 * pa_x[j] * pc_xxxz[j] * pb_x[j] + 2.0 * pc_xxxx[j] * pa_z[j] * pb_x[j] + pc_xxxz[j] * pb_xx[j]);

                t_xxxz_xx[j] += fl_s_0_0_5 * (-5.0 * pc_xxxz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxxxz[j] - pc_xxxxx[j] * pa_z[j] - 2.0 * pc_xxxxz[j] * pb_x[j]);

                t_xxxz_xx[j] += fl_s_0_0_6 * pc_xxxxxz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_13_14(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (13,14)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxz = paDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxz_xy = primBuffer.data(90 * idx + 13);

            // Batch of Integrals (13,14)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxz, pa_xxz, pa_xz, pa_z, pb_x, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, pc_xxxyz, pc_xxxz, \
                                     pc_xxy, pc_xxyz, pc_xxz, pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxz_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_xxz[j] * fl1_fx * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pb_xy[j] + pa_xxxz[j] * pb_xy[j]);

                t_xxxz_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * fl2_fx * pa_z[j] * pb_y[j] - 1.5 * pa_xxz[j] * fl1_fx * pc_y[j] - 1.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xxz[j] * fl1_fx * pb_y[j] - 4.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xy[j] - 1.5 * pa_xz[j] * fl1_fx * pb_xy[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xy[j] - pa_xxxz[j] * pb_x[j] * pc_y[j] - pa_xxxz[j] * pc_x[j] * pb_y[j] - pa_xxx[j] * pc_z[j] * pb_xy[j] - 3.0 * pa_xxz[j] * pc_x[j] * pb_xy[j]);

                t_xxxz_xy[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pa_z[j] * pc_y[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_xx[j] * fl1_fx * pc_yz[j] + 1.5 * pa_xxz[j] * fl1_fx * pc_y[j] + 1.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_y[j] + 4.5 * pa_xz[j] * pc_xy[j] * fl1_fx + 4.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + 4.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] + 3.0 * pc_xx[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_x[j] + 1.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xy[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pb_xy[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xy[j] + pa_xxxz[j] * pc_xy[j] + pa_xxx[j] * pc_yz[j] * pb_x[j] + pa_xxx[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_xxz[j] * pc_xy[j] * pb_x[j] + 3.0 * pa_xxz[j] * pc_xx[j] * pb_y[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_xy[j] + 3.0 * pa_xz[j] * pc_xx[j] * pb_xy[j]);

                t_xxxz_xy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xx[j] * fl1_fx * pc_yz[j] - 4.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 4.5 * pa_xz[j] * pc_xy[j] * fl1_fx - 4.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xxy[j] * fl1_fx * pa_z[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xx[j] * fl1_fx * pa_z[j] * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_x[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_xy[j] - pa_xxx[j] * pc_xyz[j] - 3.0 * pa_xxz[j] * pc_xxy[j] - 3.0 * pa_xx[j] * pc_xyz[j] * pb_x[j] - 3.0 * pa_xx[j] * pc_xxz[j] * pb_y[j] - 3.0 * pa_xz[j] * pc_xxy[j] * pb_x[j] - 3.0 * pa_xz[j] * pc_xxx[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_xy[j] - pc_xxx[j] * pa_z[j] * pb_xy[j]);

                t_xxxz_xy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 4.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xxy[j] * fl1_fx * pa_z[j] + 3.0 * pc_xxz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] + 3.0 * pa_xx[j] * pc_xxyz[j] + 3.0 * pa_xz[j] * pc_xxxy[j] + 3.0 * pa_x[j] * pc_xxyz[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xxxz[j] * pb_y[j] + pc_xxxy[j] * pa_z[j] * pb_x[j] + pc_xxxx[j] * pa_z[j] * pb_y[j] + pc_xxxz[j] * pb_xy[j]);

                t_xxxz_xy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxxyz[j] - pc_xxxxy[j] * pa_z[j] - pc_xxxyz[j] * pb_x[j] - pc_xxxxz[j] * pb_y[j]);

                t_xxxz_xy[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_14_15(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (14,15)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxz = paDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxzz = pcDistances.data(83 * idx + 60);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxz_xz = primBuffer.data(90 * idx + 14);

            // Batch of Integrals (14,15)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxz, pa_xxz, pa_xz, pa_z, pb_x, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxz, pc_xxxxzz, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, \
                                     pc_xz, pc_xzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxxz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxxz_xz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xxx[j] * fl1_fx * pb_x[j] + 1.5 * pa_xxz[j] * fl1_fx * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pb_xz[j] + pa_xxxz[j] * pb_xz[j]);

                t_xxxz_xz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 2.25 * pa_x[j] * pc_x[j] * fl2_fx - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.5 * pa_xxx[j] * fl1_fx * pc_x[j] - 0.5 * pa_xxx[j] * fl1_fx * pb_x[j] - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_x[j] - 1.5 * pa_xxz[j] * fl1_fx * pc_z[j] - 1.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_z[j] - 1.5 * pa_xxz[j] * fl1_fx * pb_z[j] - 4.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] - 1.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xz[j] - 1.5 * pa_xz[j] * fl1_fx * pb_xz[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xz[j] - pa_xxxz[j] * pb_x[j] * pc_z[j] - pa_xxxz[j] * pc_x[j] * pb_z[j] - pa_xxx[j] * pc_z[j] * pb_xz[j] - 3.0 * pa_xxz[j] * pc_x[j] * pb_xz[j]);

                t_xxxz_xz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 4.5 * pa_x[j] * pc_x[j] * fl2_fx + 1.5 * pc_xx[j] * fl2_fx + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pc_zz[j] + 1.5 * fl2_fx * pa_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xxx[j] * fl1_fx * pc_x[j] + 1.5 * pa_xx[j] * pc_xx[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_x[j] + 1.5 * pa_xx[j] * fl1_fx * pc_zz[j] + 1.5 * pa_xxz[j] * fl1_fx * pc_z[j] + 1.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_z[j] + 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] + 4.5 * pa_xz[j] * pc_xz[j] * fl1_fx + 4.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 4.5 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pc_xx[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] + 1.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xz[j] + 1.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pb_xz[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xz[j] + pa_xxxz[j] * pc_xz[j] + pa_xxx[j] * pc_zz[j] * pb_x[j] + pa_xxx[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_xxz[j] * pc_xz[j] * pb_x[j] + 3.0 * pa_xxz[j] * pc_xx[j] * pb_z[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_xz[j] + 3.0 * pa_xz[j] * pc_xx[j] * pb_xz[j]);

                t_xxxz_xz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 2.25 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pc_zz[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_xx[j] * pc_xx[j] * fl1_fx - 1.5 * pa_xx[j] * fl1_fx * pc_zz[j] - 1.5 * pa_x[j] * pc_xxx[j] * fl1_fx - 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] - 4.5 * pa_x[j] * pc_xzz[j] * fl1_fx - 4.5 * pa_xz[j] * pc_xz[j] * fl1_fx - 4.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_x[j] - 3.0 * pc_xxz[j] * fl1_fx * pa_z[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xx[j] * fl1_fx * pa_z[j] * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] - 1.5 * pc_xzz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_xz[j] - pa_xxx[j] * pc_xzz[j] - 3.0 * pa_xxz[j] * pc_xxz[j] - 3.0 * pa_xx[j] * pc_xzz[j] * pb_x[j] - 3.0 * pa_xx[j] * pc_xxz[j] * pb_z[j] - 3.0 * pa_xz[j] * pc_xxz[j] * pb_x[j] - 3.0 * pa_xz[j] * pc_xxx[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_xz[j] - pc_xxx[j] * pa_z[j] * pb_xz[j]);

                t_xxxz_xz[j] += fl_s_0_0_4 * (1.5 * pc_xx[j] * fl2_fx + 0.75 * fl2_fx * pc_zz[j] + 1.5 * pa_x[j] * pc_xxx[j] * fl1_fx + 4.5 * pa_x[j] * pc_xzz[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pb_x[j] + 3.0 * pc_xxzz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pa_z[j] + 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] + 1.5 * pc_xzz[j] * fl1_fx * pb_x[j] + 3.0 * pa_xx[j] * pc_xxzz[j] + 3.0 * pa_xz[j] * pc_xxxz[j] + 3.0 * pa_x[j] * pc_xxzz[j] * pb_x[j] + 3.0 * pa_x[j] * pc_xxxz[j] * pb_z[j] + pc_xxxz[j] * pa_z[j] * pb_x[j] + pc_xxxx[j] * pa_z[j] * pb_z[j] + pc_xxxz[j] * pb_xz[j]);

                t_xxxz_xz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxx[j] * fl1_fx - 3.0 * pc_xxzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxxzz[j] - pc_xxxxz[j] * pa_z[j] - pc_xxxzz[j] * pb_x[j] - pc_xxxxz[j] * pb_z[j]);

                t_xxxz_xz[j] += fl_s_0_0_6 * pc_xxxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_15_16(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (15,16)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxz = paDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxz_yy = primBuffer.data(90 * idx + 15);

            // Batch of Integrals (15,16)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxz, pa_xxz, pa_xz, pa_z, pb_y, pb_yy, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyy, pc_xxyyz, \
                                     pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyz, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxxz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxz_yy[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 0.5 * pa_xxxz[j] * fl1_fx + 1.5 * pa_xz[j] * fl1_fx * pb_yy[j] + pa_xxxz[j] * pb_yy[j]);

                t_xxxz_yy[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * fl2_fx * pc_z[j] - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * pa_xxxz[j] * fl1_fx - 0.5 * pa_xxx[j] * pc_z[j] * fl1_fx - 1.5 * pa_xxz[j] * pc_x[j] * fl1_fx - 3.0 * pa_xz[j] * fl1_fx * pb_y[j] * pc_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yy[j] - 1.5 * pa_xz[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yy[j] - 2.0 * pa_xxxz[j] * pb_y[j] * pc_y[j] - pa_xxx[j] * pc_z[j] * pb_yy[j] - 3.0 * pa_xxz[j] * pc_x[j] * pb_yy[j]);

                t_xxxz_yy[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pa_z[j] + 0.75 * pc_xz[j] * fl2_fx + 0.5 * pa_xxx[j] * pc_z[j] * fl1_fx + 1.5 * pa_xxz[j] * pc_x[j] * fl1_fx + 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xz[j] * pc_xx[j] * fl1_fx + 1.5 * pa_xz[j] * fl1_fx * pc_yy[j] + 3.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_y[j] + 3.0 * pa_xz[j] * fl1_fx * pb_y[j] * pc_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yy[j] + 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yy[j] + pa_xxxz[j] * pc_yy[j] + 2.0 * pa_xxx[j] * pc_yz[j] * pb_y[j] + 6.0 * pa_xxz[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_yy[j] + 3.0 * pa_xz[j] * pc_xx[j] * pb_yy[j]);

                t_xxxz_yy[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 1.5 * pa_xz[j] * pc_xx[j] * fl1_fx - 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx - 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx - 1.5 * pa_x[j] * fl1_fx * pc_yyz[j] - 1.5 * pa_xz[j] * fl1_fx * pc_yy[j] - 3.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pa_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] - pa_xxx[j] * pc_yyz[j] - 3.0 * pa_xxz[j] * pc_xyy[j] - 6.0 * pa_xx[j] * pc_xyz[j] * pb_y[j] - 6.0 * pa_xz[j] * pc_xxy[j] * pb_y[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_yy[j] - pc_xxx[j] * pa_z[j] * pb_yy[j]);

                t_xxxz_yy[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx + 0.5 * pc_xxxz[j] * fl1_fx + 1.5 * pa_x[j] * fl1_fx * pc_yyz[j] + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyy[j] * fl1_fx * pa_z[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_xx[j] * pc_xyyz[j] + 3.0 * pa_xz[j] * pc_xxyy[j] + 6.0 * pa_x[j] * pc_xxyz[j] * pb_y[j] + 2.0 * pc_xxxy[j] * pa_z[j] * pb_y[j] + pc_xxxz[j] * pb_yy[j]);

                t_xxxz_yy[j] += fl_s_0_0_5 * (-0.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxyyz[j] - pc_xxxyy[j] * pa_z[j] - 2.0 * pc_xxxyz[j] * pb_y[j]);

                t_xxxz_yy[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_16_17(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (16,17)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxz = paDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxz_yz = primBuffer.data(90 * idx + 16);

            // Batch of Integrals (16,17)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxz, pa_xxz, pa_xz, pa_z, pb_y, pb_yz, pb_z, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, pc_xxy, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yz, pc_yzz, \
                                     pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xxxz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxz_yz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xxx[j] * fl1_fx * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pb_yz[j] + pa_xxxz[j] * pb_yz[j]);

                t_xxxz_yz[j] += fl_s_0_0_1 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xxx[j] * fl1_fx * pc_y[j] - 0.5 * pa_xxx[j] * fl1_fx * pb_y[j] - 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] - 1.5 * pa_xz[j] * fl1_fx * pb_y[j] * pc_z[j] - 1.5 * pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yz[j] - 1.5 * pa_xz[j] * fl1_fx * pb_yz[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yz[j] - pa_xxxz[j] * pb_y[j] * pc_z[j] - pa_xxxz[j] * pc_y[j] * pb_z[j] - pa_xxx[j] * pc_z[j] * pb_yz[j] - 3.0 * pa_xxz[j] * pc_x[j] * pb_yz[j]);

                t_xxxz_yz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.75 * pa_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xxx[j] * fl1_fx * pc_y[j] + 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 1.5 * pa_xx[j] * pc_x[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pc_yz[j] + 1.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pb_y[j] * pc_z[j] + 1.5 * pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yz[j] + 1.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_yz[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yz[j] + pa_xxxz[j] * pc_yz[j] + pa_xxx[j] * pc_zz[j] * pb_y[j] + pa_xxx[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_xxz[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_xxz[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_yz[j] + 3.0 * pa_xz[j] * pc_xx[j] * pb_yz[j]);

                t_xxxz_yz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx - 1.5 * pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_yzz[j] - 1.5 * pa_xz[j] * fl1_fx * pc_yz[j] - 1.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] - 1.5 * pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] - 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yz[j] - pa_xxx[j] * pc_yzz[j] - 3.0 * pa_xxz[j] * pc_xyz[j] - 3.0 * pa_xx[j] * pc_xzz[j] * pb_y[j] - 3.0 * pa_xx[j] * pc_xyz[j] * pb_z[j] - 3.0 * pa_xz[j] * pc_xxz[j] * pb_y[j] - 3.0 * pa_xz[j] * pc_xxy[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_yz[j] - pc_xxx[j] * pa_z[j] * pb_yz[j]);

                t_xxxz_yz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * fl1_fx * pc_yzz[j] + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] + 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xx[j] * pc_xyzz[j] + 3.0 * pa_xz[j] * pc_xxyz[j] + 3.0 * pa_x[j] * pc_xxzz[j] * pb_y[j] + 3.0 * pa_x[j] * pc_xxyz[j] * pb_z[j] + pc_xxxz[j] * pa_z[j] * pb_y[j] + pc_xxxy[j] * pa_z[j] * pb_z[j] + pc_xxxz[j] * pb_yz[j]);

                t_xxxz_yz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxyzz[j] - pc_xxxyz[j] * pa_z[j] - pc_xxxzz[j] * pb_y[j] - pc_xxxyz[j] * pb_z[j]);

                t_xxxz_yz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_17_18(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (17,18)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxx = paDistances.data(34 * idx + 9);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxxz = paDistances.data(34 * idx + 21);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxzzz = pcDistances.data(83 * idx + 64);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxxz_zz = primBuffer.data(90 * idx + 17);

            // Batch of Integrals (17,18)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxx, pa_xxxz, pa_xxz, pa_xz, pa_z, pb_z, pb_zz, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxz, pc_xxxzz, pc_xxxzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxxz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxxz_zz[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pa_xxxz[j] * fl1_fx + pa_xxx[j] * fl1_fx * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pb_zz[j] + pa_xxxz[j] * pb_zz[j]);

                t_xxxz_zz[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 2.25 * pa_x[j] * fl2_fx * pc_z[j] - 3.0 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 1.5 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * pa_xxxz[j] * fl1_fx - 1.5 * pa_xxx[j] * pc_z[j] * fl1_fx - pa_xxx[j] * fl1_fx * pb_z[j] - 1.5 * pa_xxz[j] * pc_x[j] * fl1_fx - 3.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] - 3.0 * pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_zz[j] - 1.5 * pa_xz[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_xxxz[j] * pb_z[j] * pc_z[j] - pa_xxx[j] * pc_z[j] * pb_zz[j] - 3.0 * pa_xxz[j] * pc_x[j] * pb_zz[j]);

                t_xxxz_zz[j] += fl_s_0_0_2 * (4.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pc_x[j] * fl2_fx * pa_z[j] + 2.25 * pc_xz[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xxx[j] * pc_z[j] * fl1_fx + 1.5 * pa_xxz[j] * pc_x[j] * fl1_fx + 4.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 3.0 * pa_xx[j] * pc_x[j] * fl1_fx * pb_z[j] + 1.5 * pa_xz[j] * pc_xx[j] * fl1_fx + 3.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pc_zz[j] + 3.0 * pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] + 3.0 * pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_zz[j] + 3.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_zz[j] + pa_xxxz[j] * pc_zz[j] + 2.0 * pa_xxx[j] * pc_zz[j] * pb_z[j] + 6.0 * pa_xxz[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_xx[j] * pc_xz[j] * pb_zz[j] + 3.0 * pa_xz[j] * pc_xx[j] * pb_zz[j]);

                t_xxxz_zz[j] += fl_s_0_0_3 * (-2.25 * pa_x[j] * fl2_fx * pc_z[j] - 4.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 1.5 * pc_x[j] * fl2_fx * pb_z[j] - 4.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 1.5 * pa_xz[j] * pc_xx[j] * fl1_fx - 4.5 * pa_x[j] * pc_xxz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx - pc_xxx[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * fl1_fx * pc_zzz[j] - 1.5 * pa_xz[j] * fl1_fx * pc_zz[j] - 3.0 * pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] - 1.5 * pc_xzz[j] * fl1_fx * pa_z[j] - 3.0 * pc_xzz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] - pa_xxx[j] * pc_zzz[j] - 3.0 * pa_xxz[j] * pc_xzz[j] - 6.0 * pa_xx[j] * pc_xzz[j] * pb_z[j] - 6.0 * pa_xz[j] * pc_xxz[j] * pb_z[j] - 3.0 * pa_x[j] * pc_xxz[j] * pb_zz[j] - pc_xxx[j] * pa_z[j] * pb_zz[j]);

                t_xxxz_zz[j] += fl_s_0_0_4 * (2.25 * pc_xz[j] * fl2_fx + 4.5 * pa_x[j] * pc_xxz[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxxz[j] * fl1_fx + pc_xxx[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * fl1_fx * pc_zzz[j] + 1.5 * pc_xzzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pa_z[j] + 3.0 * pc_xzz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xx[j] * pc_xzzz[j] + 3.0 * pa_xz[j] * pc_xxzz[j] + 6.0 * pa_x[j] * pc_xxzz[j] * pb_z[j] + 2.0 * pc_xxxz[j] * pa_z[j] * pb_z[j] + pc_xxxz[j] * pb_zz[j]);

                t_xxxz_zz[j] += fl_s_0_0_5 * (-1.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xzzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxzzz[j] - pc_xxxzz[j] * pa_z[j] - 2.0 * pc_xxxzz[j] * pb_z[j]);

                t_xxxz_zz[j] += fl_s_0_0_6 * pc_xxxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_18_19(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (18,19)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xyy = paDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyy = paDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyy = pcDistances.data(83 * idx + 58);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyy_xx = primBuffer.data(90 * idx + 18);

            // Batch of Integrals (18,19)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyy, pa_xy, pa_xyy, pa_y, pa_yy, pb_x, pb_xx, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyy, pc_xxxy, pc_xxxyy, pc_xxy, pc_xxyy, \
                                     pc_xy, pc_xyy, pc_y, pc_yy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxyy_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxyy_xx[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * fl2_fx * pa_yy[j] + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 0.5 * pa_xxyy[j] * fl1_fx + 2.0 * pa_xyy[j] * fl1_fx * pb_x[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_xx[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pa_yy[j] * pb_xx[j] + pa_xxyy[j] * pb_xx[j]);

                t_xxyy_xx[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * fl2_fx * pa_y[j] * pc_y[j] - 1.5 * fl2_fx * pa_yy[j] - 0.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 2.0 * pa_x[j] * fl2_fx * pb_x[j] - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * pa_xxyy[j] * fl1_fx - pa_xxy[j] * pc_y[j] * fl1_fx - 3.0 * pa_xyy[j] * pc_x[j] * fl1_fx - 4.0 * pa_xy[j] * fl1_fx * pc_y[j] * pb_x[j] - 2.0 * pa_xyy[j] * fl1_fx * pb_x[j] - 3.0 * pc_x[j] * fl1_fx * pa_yy[j] * pb_x[j] - 0.5 * fl2_fx * pb_xx[j] - pa_xx[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_xx[j] * fl1_fx * pb_xx[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_xx[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_xx[j] - 0.5 * fl1_fx * pa_yy[j] * pb_xx[j] - 2.0 * pa_xxyy[j] * pb_x[j] * pc_x[j] - 2.0 * pa_xxy[j] * pc_y[j] * pb_xx[j] - 2.0 * pa_xyy[j] * pc_x[j] * pb_xx[j]);

                t_xxyy_xx[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * fl2_fx * pc_yy[j] + 3.0 * fl2_fx * pa_y[j] * pc_y[j] + 0.75 * fl2_fx * pa_yy[j] + 0.25 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_xx[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_x[j] + pa_xxy[j] * pc_y[j] * fl1_fx + 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx + 3.0 * pa_xyy[j] * pc_x[j] * fl1_fx + 6.0 * pa_xy[j] * pc_xy[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pc_yy[j] * pb_x[j] + 4.0 * pa_xy[j] * fl1_fx * pc_y[j] * pb_x[j] + 3.0 * pc_xx[j] * pa_yy[j] * fl1_fx + 6.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pa_yy[j] * pb_x[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_xx[j] * fl1_fx * pc_xx[j] + pa_xx[j] * fl1_fx * pb_x[j] * pc_x[j] + 2.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_xx[j] + 0.5 * pc_xx[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pc_yy[j] * pb_xx[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_xx[j] + pa_xxyy[j] * pc_xx[j] + 4.0 * pa_xxy[j] * pc_xy[j] * pb_x[j] + pa_xx[j] * pc_yy[j] * pb_xx[j] + 4.0 * pa_xyy[j] * pc_xx[j] * pb_x[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_xx[j] + pc_xx[j] * pa_yy[j] * pb_xx[j]);

                t_xxyy_xx[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * fl2_fx * pc_yy[j] - 1.5 * fl2_fx * pa_y[j] * pc_y[j] - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx - 6.0 * pa_xy[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pc_yy[j] * pb_x[j] - 3.0 * pc_xx[j] * pa_yy[j] * fl1_fx - 6.0 * pc_xxy[j] * pa_y[j] * fl1_fx - 3.0 * pc_xyy[j] * fl1_fx * pb_x[j] - 6.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_x[j] - 0.5 * pa_xx[j] * fl1_fx * pc_xx[j] - pa_x[j] * pc_xxx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] - pc_xxx[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pb_xx[j] - 0.5 * fl1_fx * pc_yy[j] * pb_xx[j] - 2.0 * pa_xxy[j] * pc_xxy[j] - 2.0 * pa_xx[j] * pc_xyy[j] * pb_x[j] - 2.0 * pa_xyy[j] * pc_xxx[j] - 8.0 * pa_xy[j] * pc_xxy[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_xx[j] - 2.0 * pc_xxx[j] * pa_yy[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_xx[j]);

                t_xxyy_xx[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yy[j] + 1.5 * pc_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx + 6.0 * pc_xxy[j] * pa_y[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_xxx[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + pc_xxx[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xxyy[j] + 4.0 * pa_xy[j] * pc_xxxy[j] + 4.0 * pa_x[j] * pc_xxyy[j] * pb_x[j] + pc_xxxx[j] * pa_yy[j] + 4.0 * pc_xxxy[j] * pa_y[j] * pb_x[j] + pc_xxyy[j] * pb_xx[j]);

                t_xxyy_xx[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * pc_xxxx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxyy[j] - 2.0 * pc_xxxxy[j] * pa_y[j] - 2.0 * pc_xxxyy[j] * pb_x[j]);

                t_xxyy_xx[j] += fl_s_0_0_6 * pc_xxxxyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_19_20(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (19,20)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xyy = paDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyy = paDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyy = pcDistances.data(83 * idx + 61);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyy_xy = primBuffer.data(90 * idx + 19);

            // Batch of Integrals (19,20)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyy, pa_xy, pa_xyy, pa_y, pa_yy, pb_x, pb_xy, pb_y, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyy, pc_xxy, pc_xxyy, pc_xxyyy, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_y, pc_yy, pc_yyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xxyy_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyy_xy[j] = fl_s_0_0_0 * (pa_xy[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + pa_xxy[j] * fl1_fx * pb_x[j] + pa_xyy[j] * fl1_fx * pb_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_xx[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_yy[j] * pb_xy[j] + pa_xxyy[j] * pb_xy[j]);

                t_xxyy_xy[j] += fl_s_0_0_1 * (-2.0 * pa_xy[j] * fl2_fx - 1.5 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_x[j] * fl2_fx * pa_y[j] - pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - fl2_fx * pa_y[j] * pb_x[j] - 0.75 * fl2_fx * pc_y[j] * pb_x[j] - pa_xxy[j] * fl1_fx * pc_x[j] - pa_xxy[j] * fl1_fx * pb_x[j] - 1.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_x[j] - 2.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_x[j] - pa_xyy[j] * fl1_fx * pc_y[j] - 2.0 * pa_xy[j] * fl1_fx * pc_y[j] * pb_y[j] - pa_xyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * fl1_fx * pa_yy[j] * pb_y[j] - 0.5 * fl2_fx * pb_xy[j] - 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_xx[j] * fl1_fx * pb_xy[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pa_yy[j] * pb_x[j] * pc_y[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_xy[j] - 0.5 * fl1_fx * pa_yy[j] * pb_xy[j] - pa_xxyy[j] * pb_x[j] * pc_y[j] - pa_xxyy[j] * pc_x[j] * pb_y[j] - 2.0 * pa_xxy[j] * pc_y[j] * pb_xy[j] - 2.0 * pa_xyy[j] * pc_x[j] * pb_xy[j]);

                t_xxyy_xy[j] += fl_s_0_0_2 * (3.0 * pa_x[j] * fl2_fx * pc_y[j] + pa_xy[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pa_y[j] + 2.25 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 1.5 * fl2_fx * pc_y[j] * pb_x[j] + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + pa_xxy[j] * fl1_fx * pc_x[j] + 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 1.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_x[j] + 2.0 * pa_xy[j] * pc_xx[j] * fl1_fx + 2.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_x[j] + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + 2.0 * pa_xy[j] * fl1_fx * pc_yy[j] + pa_x[j] * fl1_fx * pc_yy[j] * pb_y[j] + pa_xyy[j] * fl1_fx * pc_y[j] + 2.0 * pa_xy[j] * fl1_fx * pc_y[j] * pb_y[j] + pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_yy[j] + 3.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pa_yy[j] * pb_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_y[j] + pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_xy[j] + 0.5 * pc_xx[j] * fl1_fx * pb_xy[j] + fl1_fx * pa_y[j] * pc_yy[j] * pb_x[j] + 0.5 * fl1_fx * pc_yy[j] * pb_xy[j] + 0.5 * fl1_fx * pa_yy[j] * pb_x[j] * pc_y[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_xy[j] + pa_xxyy[j] * pc_xy[j] + 2.0 * pa_xxy[j] * pc_yy[j] * pb_x[j] + 2.0 * pa_xxy[j] * pc_xy[j] * pb_y[j] + pa_xx[j] * pc_yy[j] * pb_xy[j] + 2.0 * pa_xyy[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xyy[j] * pc_xx[j] * pb_y[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_xy[j] + pc_xx[j] * pa_yy[j] * pb_xy[j]);

                t_xxyy_xy[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl2_fx * pc_y[j] - 4.5 * pc_xy[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pa_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_x[j] - 1.5 * pa_xx[j] * pc_xy[j] * fl1_fx - 2.0 * pa_xy[j] * pc_xx[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - pa_x[j] * fl1_fx * pc_yyy[j] - 2.0 * pa_xy[j] * fl1_fx * pc_yy[j] - pa_x[j] * fl1_fx * pc_yy[j] * pb_y[j] - pc_xxx[j] * pa_y[j] * fl1_fx - pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxy[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyy[j] * fl1_fx * pa_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_yy[j] - 3.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_y[j] - pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_x[j] - fl1_fx * pa_y[j] * pc_yy[j] * pb_x[j] - 0.5 * fl1_fx * pc_yy[j] * pb_xy[j] - 2.0 * pa_xxy[j] * pc_xyy[j] - pa_xx[j] * pc_yyy[j] * pb_x[j] - pa_xx[j] * pc_xyy[j] * pb_y[j] - 2.0 * pa_xyy[j] * pc_xxy[j] - 4.0 * pa_xy[j] * pc_xyy[j] * pb_x[j] - 4.0 * pa_xy[j] * pc_xxy[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_xy[j] - pc_xxy[j] * pa_yy[j] * pb_x[j] - pc_xxx[j] * pa_yy[j] * pb_y[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_xy[j]);

                t_xxyy_xy[j] += fl_s_0_0_4 * (2.25 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_xxy[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yyy[j] + pc_xxx[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxxy[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyyy[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pa_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pb_y[j] + 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_x[j] + pa_xx[j] * pc_xyyy[j] + 4.0 * pa_xy[j] * pc_xxyy[j] + 2.0 * pa_x[j] * pc_xyyy[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyy[j] * pb_y[j] + pc_xxxy[j] * pa_yy[j] + 2.0 * pc_xxyy[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxxy[j] * pa_y[j] * pb_y[j] + pc_xxyy[j] * pb_xy[j]);

                t_xxyy_xy[j] += fl_s_0_0_5 * (-1.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyyy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyyy[j] - 2.0 * pc_xxxyy[j] * pa_y[j] - pc_xxyyy[j] * pb_x[j] - pc_xxxyy[j] * pb_y[j]);

                t_xxyy_xy[j] += fl_s_0_0_6 * pc_xxxyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_20_21(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (20,21)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xyy = paDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyy = paDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyy_xz = primBuffer.data(90 * idx + 20);

            // Batch of Integrals (20,21)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyy, pa_xy, pa_xyy, pa_y, pa_yy, pb_x, pb_xz, pb_z, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, pc_xxy, \
                                     pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, \
                                     pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xxyy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyy_xz[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx * pb_z[j] + pa_xyy[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_yy[j] * pb_xz[j] + pa_xxyy[j] * pb_xz[j]);

                t_xxyy_xz[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx * pc_z[j] - pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - pa_xyy[j] * fl1_fx * pc_z[j] - 2.0 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] - pa_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * fl1_fx * pa_yy[j] * pb_z[j] - 0.25 * fl2_fx * pb_x[j] * pc_z[j] - 0.5 * fl2_fx * pb_xz[j] - 0.5 * pa_xx[j] * fl1_fx * pb_x[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_xz[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pa_yy[j] * pb_x[j] * pc_z[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_xz[j] - 0.5 * fl1_fx * pa_yy[j] * pb_xz[j] - pa_xxyy[j] * pb_x[j] * pc_z[j] - pa_xxyy[j] * pc_x[j] * pb_z[j] - 2.0 * pa_xxy[j] * pc_y[j] * pb_xz[j] - 2.0 * pa_xyy[j] * pc_x[j] * pb_xz[j]);

                t_xxyy_xz[j] += fl_s_0_0_2 * (pa_x[j] * fl2_fx * pc_z[j] + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 2.0 * pa_xy[j] * fl1_fx * pc_yz[j] + pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] + pa_xyy[j] * fl1_fx * pc_z[j] + 2.0 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pc_xz[j] * fl1_fx * pa_yy[j] + 3.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pa_yy[j] * pb_z[j] + 0.5 * fl2_fx * pb_x[j] * pc_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_xx[j] * fl1_fx * pc_xz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_x[j] * pc_z[j] + 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_z[j] + pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_xz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_xz[j] + fl1_fx * pa_y[j] * pc_yz[j] * pb_x[j] + 0.5 * fl1_fx * pc_yy[j] * pb_xz[j] + 0.5 * fl1_fx * pa_yy[j] * pb_x[j] * pc_z[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_xz[j] + pa_xxyy[j] * pc_xz[j] + 2.0 * pa_xxy[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_xxy[j] * pc_xy[j] * pb_z[j] + pa_xx[j] * pc_yy[j] * pb_xz[j] + 2.0 * pa_xyy[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xyy[j] * pc_xx[j] * pb_z[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_xz[j] + pc_xx[j] * pa_yy[j] * pb_xz[j]);

                t_xxyy_xz[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - pa_x[j] * fl1_fx * pc_yyz[j] - 2.0 * pa_xy[j] * fl1_fx * pc_yz[j] - pa_x[j] * fl1_fx * pc_yy[j] * pb_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pa_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pa_yy[j] - 3.0 * pc_xy[j] * fl1_fx * pa_y[j] * pb_z[j] - 0.25 * fl2_fx * pb_x[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_xz[j] - pa_x[j] * pc_xxz[j] * fl1_fx - pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] - pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_x[j] - fl1_fx * pa_y[j] * pc_yz[j] * pb_x[j] - 0.5 * fl1_fx * pc_yy[j] * pb_xz[j] - 2.0 * pa_xxy[j] * pc_xyz[j] - pa_xx[j] * pc_yyz[j] * pb_x[j] - pa_xx[j] * pc_xyy[j] * pb_z[j] - 2.0 * pa_xyy[j] * pc_xxz[j] - 4.0 * pa_xy[j] * pc_xyz[j] * pb_x[j] - 4.0 * pa_xy[j] * pc_xxy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_xz[j] - pc_xxz[j] * pa_yy[j] * pb_x[j] - pc_xxx[j] * pa_yy[j] * pb_z[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_xz[j]);

                t_xxyy_xz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + pa_x[j] * fl1_fx * pc_yyz[j] + 1.5 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pa_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_xxz[j] * fl1_fx + 0.5 * pc_xxxz[j] * fl1_fx + 0.5 * pc_xxz[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_x[j] + pa_xx[j] * pc_xyyz[j] + 4.0 * pa_xy[j] * pc_xxyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyy[j] * pb_z[j] + pc_xxxz[j] * pa_yy[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxxy[j] * pa_y[j] * pb_z[j] + pc_xxyy[j] * pb_xz[j]);

                t_xxyy_xz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xxxz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyyz[j] - 2.0 * pc_xxxyz[j] * pa_y[j] - pc_xxyyz[j] * pb_x[j] - pc_xxxyy[j] * pb_z[j]);

                t_xxyy_xz[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_21_22(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (21,22)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xyy = paDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyy = paDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyy = pcDistances.data(83 * idx + 65);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyy_yy = primBuffer.data(90 * idx + 21);

            // Batch of Integrals (21,22)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyy, pa_xy, pa_xyy, pa_y, pa_yy, pb_y, pb_yy, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxyy_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxyy_yy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 0.25 * fl2_fx * pa_yy[j] + fl2_fx * pa_y[j] * pb_y[j] + 0.5 * pa_xxyy[j] * fl1_fx + 2.0 * pa_xxy[j] * fl1_fx * pb_y[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_xx[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pa_yy[j] * pb_yy[j] + pa_xxyy[j] * pb_yy[j]);

                t_xxyy_yy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pa_yy[j] - 1.5 * fl2_fx * pa_y[j] * pc_y[j] - 2.0 * fl2_fx * pa_y[j] * pb_y[j] - 1.5 * fl2_fx * pc_y[j] * pb_y[j] - 0.5 * pa_xxyy[j] * fl1_fx - 3.0 * pa_xxy[j] * pc_y[j] * fl1_fx - 2.0 * pa_xxy[j] * fl1_fx * pb_y[j] - 3.0 * pa_xx[j] * pc_y[j] * fl1_fx * pb_y[j] - pa_xyy[j] * pc_x[j] * fl1_fx - 4.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] - 0.5 * fl2_fx * pb_yy[j] - 0.5 * pa_xx[j] * fl1_fx * pb_yy[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] - fl1_fx * pa_yy[j] * pb_y[j] * pc_y[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_yy[j] - 0.5 * fl1_fx * pa_yy[j] * pb_yy[j] - 2.0 * pa_xxyy[j] * pb_y[j] * pc_y[j] - 2.0 * pa_xxy[j] * pc_y[j] * pb_yy[j] - 2.0 * pa_xyy[j] * pc_x[j] * pb_yy[j]);

                t_xxyy_yy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + 0.75 * pc_xx[j] * fl2_fx + 3.0 * fl2_fx * pa_y[j] * pc_y[j] + 1.5 * fl2_fx * pc_yy[j] + 3.0 * fl2_fx * pc_y[j] * pb_y[j] + 0.25 * fl2_fx * pa_yy[j] + fl2_fx * pa_y[j] * pb_y[j] + 3.0 * pa_xxy[j] * pc_y[j] * fl1_fx + 3.0 * pa_xx[j] * pc_yy[j] * fl1_fx + 3.0 * pa_xx[j] * pc_y[j] * fl1_fx * pb_y[j] + pa_xyy[j] * pc_x[j] * fl1_fx + 6.0 * pa_xy[j] * pc_xy[j] * fl1_fx + 4.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] + 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pc_xx[j] * pa_yy[j] * fl1_fx + 2.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] + 0.25 * fl2_fx * pb_yy[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] + 0.5 * pc_xx[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pa_yy[j] * pc_yy[j] + 2.0 * fl1_fx * pa_y[j] * pc_yy[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pb_yy[j] + fl1_fx * pa_yy[j] * pb_y[j] * pc_y[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_yy[j] + pa_xxyy[j] * pc_yy[j] + 4.0 * pa_xxy[j] * pc_yy[j] * pb_y[j] + pa_xx[j] * pc_yy[j] * pb_yy[j] + 4.0 * pa_xyy[j] * pc_xy[j] * pb_y[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_yy[j] + pc_xx[j] * pa_yy[j] * pb_yy[j]);

                t_xxyy_yy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 1.5 * pc_xx[j] * fl2_fx - 3.0 * fl2_fx * pc_yy[j] - 1.5 * fl2_fx * pa_y[j] * pc_y[j] - 1.5 * fl2_fx * pc_y[j] * pb_y[j] - 3.0 * pa_xx[j] * pc_yy[j] * fl1_fx - 6.0 * pa_xy[j] * pc_xy[j] * fl1_fx - 6.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 6.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * pa_yy[j] * fl1_fx - 3.0 * pc_xxy[j] * pa_y[j] * fl1_fx - 2.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pb_yy[j] - fl1_fx * pa_y[j] * pc_yyy[j] - fl1_fx * pc_yyy[j] * pb_y[j] - 0.5 * fl1_fx * pa_yy[j] * pc_yy[j] - 2.0 * fl1_fx * pa_y[j] * pc_yy[j] * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pb_yy[j] - 2.0 * pa_xxy[j] * pc_yyy[j] - 2.0 * pa_xx[j] * pc_yyy[j] * pb_y[j] - 2.0 * pa_xyy[j] * pc_xyy[j] - 8.0 * pa_xy[j] * pc_xyy[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pa_yy[j] * pb_y[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_yy[j]);

                t_xxyy_yy[j] += fl_s_0_0_4 * (0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pc_yy[j] + 6.0 * pa_x[j] * pc_xyy[j] * fl1_fx + 3.0 * pc_xxy[j] * pa_y[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 3.0 * pc_xxy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyyy[j] + fl1_fx * pa_y[j] * pc_yyy[j] + fl1_fx * pc_yyy[j] * pb_y[j] + pa_xx[j] * pc_yyyy[j] + 4.0 * pa_xy[j] * pc_xyyy[j] + 4.0 * pa_x[j] * pc_xyyy[j] * pb_y[j] + pc_xxyy[j] * pa_yy[j] + 4.0 * pc_xxyy[j] * pa_y[j] * pb_y[j] + pc_xxyy[j] * pb_yy[j]);

                t_xxyy_yy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyy[j] - 2.0 * pa_x[j] * pc_xyyyy[j] - 2.0 * pc_xxyyy[j] * pa_y[j] - 2.0 * pc_xxyyy[j] * pb_y[j]);

                t_xxyy_yy[j] += fl_s_0_0_6 * pc_xxyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_22_23(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (22,23)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xyy = paDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyy = paDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyy_yz = primBuffer.data(90 * idx + 22);

            // Batch of Integrals (22,23)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyy, pa_xy, pa_xyy, pa_y, pa_yy, pb_y, pb_yz, pb_z, \
                                     pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, pc_xxz, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, \
                                     pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxyy_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyy_yz[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_y[j] * pb_z[j] + pa_xxy[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_yy[j] * pb_yz[j] + pa_xxyy[j] * pb_yz[j]);

                t_xxyy_yz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] * pc_z[j] - fl2_fx * pa_y[j] * pb_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - pa_xxy[j] * fl1_fx * pc_z[j] - pa_xxy[j] * fl1_fx * pb_z[j] - 1.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_z[j] - 2.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.25 * fl2_fx * pb_y[j] * pc_z[j] - 0.5 * fl2_fx * pb_yz[j] - 0.5 * pa_xx[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_yz[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pa_yy[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_yy[j] * pc_y[j] * pb_z[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_yz[j] - 0.5 * fl1_fx * pa_yy[j] * pb_yz[j] - pa_xxyy[j] * pb_y[j] * pc_z[j] - pa_xxyy[j] * pc_y[j] * pb_z[j] - 2.0 * pa_xxy[j] * pc_y[j] * pb_yz[j] - 2.0 * pa_xyy[j] * pc_x[j] * pb_yz[j]);

                t_xxyy_yz[j] += fl_s_0_0_2 * (fl2_fx * pa_y[j] * pc_z[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.5 * fl2_fx * pa_y[j] * pb_z[j] + pa_xxy[j] * fl1_fx * pc_z[j] + 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx + 1.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_z[j] + 2.0 * pa_xy[j] * pc_xz[j] * fl1_fx + 2.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * fl2_fx * pb_y[j] * pc_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_y[j] * pc_z[j] + pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_yy[j] * pc_yz[j] + fl1_fx * pa_y[j] * pc_yz[j] * pb_y[j] + fl1_fx * pa_y[j] * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pc_yy[j] * pb_yz[j] + 0.5 * fl1_fx * pa_yy[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_yy[j] * pc_y[j] * pb_z[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_yz[j] + pa_xxyy[j] * pc_yz[j] + 2.0 * pa_xxy[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_xxy[j] * pc_yy[j] * pb_z[j] + pa_xx[j] * pc_yy[j] * pb_yz[j] + 2.0 * pa_xyy[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xyy[j] * pc_xy[j] * pb_z[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_yz[j] + pc_xx[j] * pa_yy[j] * pb_yz[j]);

                t_xxyy_yz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.5 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx - 2.0 * pa_xy[j] * pc_xz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - pc_xxz[j] * pa_y[j] * fl1_fx - pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] - 0.25 * fl2_fx * pb_y[j] * pc_z[j] - pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pb_yz[j] - fl1_fx * pa_y[j] * pc_yyz[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] - 0.5 * fl1_fx * pa_yy[j] * pc_yz[j] - fl1_fx * pa_y[j] * pc_yz[j] * pb_y[j] - fl1_fx * pa_y[j] * pc_yy[j] * pb_z[j] - 0.5 * fl1_fx * pc_yy[j] * pb_yz[j] - 2.0 * pa_xxy[j] * pc_yyz[j] - pa_xx[j] * pc_yyz[j] * pb_y[j] - pa_xx[j] * pc_yyy[j] * pb_z[j] - 2.0 * pa_xyy[j] * pc_xyz[j] - 4.0 * pa_xy[j] * pc_xyz[j] * pb_y[j] - 4.0 * pa_xy[j] * pc_xyy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_yz[j] - pc_xxz[j] * pa_yy[j] * pb_y[j] - pc_xxy[j] * pa_yy[j] * pb_z[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_yz[j]);

                t_xxyy_yz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + pc_xxz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyyz[j] + fl1_fx * pa_y[j] * pc_yyz[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] + pa_xx[j] * pc_yyyz[j] + 4.0 * pa_xy[j] * pc_xyyz[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xyyy[j] * pb_z[j] + pc_xxyz[j] * pa_yy[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_y[j] + 2.0 * pc_xxyy[j] * pa_y[j] * pb_z[j] + pc_xxyy[j] * pb_yz[j]);

                t_xxyy_yz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyz[j] - 2.0 * pa_x[j] * pc_xyyyz[j] - 2.0 * pc_xxyyz[j] * pa_y[j] - pc_xxyyz[j] * pb_y[j] - pc_xxyyy[j] * pb_z[j]);

                t_xxyy_yz[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_23_24(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (23,24)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xyy = paDistances.data(34 * idx + 12);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyy = paDistances.data(34 * idx + 22);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyy_zz = primBuffer.data(90 * idx + 23);

            // Batch of Integrals (23,24)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyy, pa_xy, pa_xyy, pa_y, pa_yy, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xxyy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxyy_zz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + 0.25 * fl2_fx * pa_yy[j] + 0.5 * pa_xxyy[j] * fl1_fx + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pa_yy[j] * pb_zz[j] + pa_xxyy[j] * pb_zz[j]);

                t_xxyy_zz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_xx[j] * fl2_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pa_yy[j] - 0.5 * fl2_fx * pa_y[j] * pc_y[j] - 0.5 * pa_xxyy[j] * fl1_fx - pa_xxy[j] * pc_y[j] * fl1_fx - pa_xyy[j] * pc_x[j] * fl1_fx - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * fl2_fx * pb_zz[j] - pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] - fl1_fx * pa_yy[j] * pb_z[j] * pc_z[j] - fl1_fx * pa_y[j] * pc_y[j] * pb_zz[j] - 0.5 * fl1_fx * pa_yy[j] * pb_zz[j] - 2.0 * pa_xxyy[j] * pb_z[j] * pc_z[j] - 2.0 * pa_xxy[j] * pc_y[j] * pb_zz[j] - 2.0 * pa_xyy[j] * pc_x[j] * pb_zz[j]);

                t_xxyy_zz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * pc_x[j] * fl2_fx + 0.25 * pc_xx[j] * fl2_fx + fl2_fx * pa_y[j] * pc_y[j] + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pa_yy[j] + pa_xxy[j] * pc_y[j] * fl1_fx + 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx + pa_xyy[j] * pc_x[j] * fl1_fx + 2.0 * pa_xy[j] * pc_xy[j] * fl1_fx + 0.5 * pc_xx[j] * pa_yy[j] * fl1_fx + 0.25 * fl2_fx * pc_zz[j] + fl2_fx * pb_z[j] * pc_z[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] + pa_xx[j] * fl1_fx * pb_z[j] * pc_z[j] + 2.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pa_yy[j] * pc_zz[j] + 2.0 * fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] + fl1_fx * pa_yy[j] * pb_z[j] * pc_z[j] + fl1_fx * pa_y[j] * pc_y[j] * pb_zz[j] + pa_xxyy[j] * pc_zz[j] + 4.0 * pa_xxy[j] * pc_yz[j] * pb_z[j] + pa_xx[j] * pc_yy[j] * pb_zz[j] + 4.0 * pa_xyy[j] * pc_xz[j] * pb_z[j] + 4.0 * pa_xy[j] * pc_xy[j] * pb_zz[j] + pc_xx[j] * pa_yy[j] * pb_zz[j]);

                t_xxyy_zz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * pc_xx[j] * fl2_fx - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pa_y[j] * pc_y[j] - 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx - 2.0 * pa_xy[j] * pc_xy[j] * fl1_fx - pa_x[j] * pc_xyy[j] * fl1_fx - 0.5 * pc_xx[j] * pa_yy[j] * fl1_fx - pc_xxy[j] * pa_y[j] * fl1_fx - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pb_z[j] * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] - pa_x[j] * pc_xzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - pc_xxz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] - fl1_fx * pa_y[j] * pc_yzz[j] - fl1_fx * pc_yyz[j] * pb_z[j] - 0.5 * fl1_fx * pa_yy[j] * pc_zz[j] - 2.0 * fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] - 0.5 * fl1_fx * pc_yy[j] * pb_zz[j] - 2.0 * pa_xxy[j] * pc_yzz[j] - 2.0 * pa_xx[j] * pc_yyz[j] * pb_z[j] - 2.0 * pa_xyy[j] * pc_xzz[j] - 8.0 * pa_xy[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyy[j] * pb_zz[j] - 2.0 * pc_xxz[j] * pa_yy[j] * pb_z[j] - 2.0 * pc_xxy[j] * pa_y[j] * pb_zz[j]);

                t_xxyy_zz[j] += fl_s_0_0_4 * (0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_yy[j] + pa_x[j] * pc_xyy[j] * fl1_fx + pc_xxy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.25 * fl2_fx * pc_zz[j] + pa_x[j] * pc_xzz[j] * fl1_fx + 0.5 * pc_xxzz[j] * fl1_fx + pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yyzz[j] + fl1_fx * pa_y[j] * pc_yzz[j] + fl1_fx * pc_yyz[j] * pb_z[j] + pa_xx[j] * pc_yyzz[j] + 4.0 * pa_xy[j] * pc_xyzz[j] + 4.0 * pa_x[j] * pc_xyyz[j] * pb_z[j] + pc_xxzz[j] * pa_yy[j] + 4.0 * pc_xxyz[j] * pa_y[j] * pb_z[j] + pc_xxyy[j] * pb_zz[j]);

                t_xxyy_zz[j] += fl_s_0_0_5 * (-0.5 * pc_xxyy[j] * fl1_fx - 0.5 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - 2.0 * pa_x[j] * pc_xyyzz[j] - 2.0 * pc_xxyzz[j] * pa_y[j] - 2.0 * pc_xxyyz[j] * pb_z[j]);

                t_xxyy_zz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_24_25(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (24,25)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyz = paDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxy = pcDistances.data(83 * idx + 35);

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxyz = pcDistances.data(83 * idx + 59);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyz_xx = primBuffer.data(90 * idx + 24);

            // Batch of Integrals (24,25)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyz, pa_xxz, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, \
                                     pb_x, pb_xx, pc_x, pc_xx, pc_xxx, pc_xxxx, pc_xxxxy, pc_xxxxyz, pc_xxxxz, pc_xxxy, \
                                     pc_xxxyz, pc_xxxz, pc_xxy, pc_xxyz, pc_xxz, pc_xy, pc_xyz, pc_xz, pc_y, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxyz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyz_xx[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_yz[j] + 0.5 * pa_xxyz[j] * fl1_fx + 2.0 * pa_xyz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yz[j] * pb_xx[j] + pa_xxyz[j] * pb_xx[j]);

                t_xxyz_xx[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pa_z[j] - 1.5 * fl2_fx * pa_yz[j] - 0.5 * pa_xxyz[j] * fl1_fx - 0.5 * pa_xxy[j] * pc_z[j] * fl1_fx - 0.5 * pa_xxz[j] * pc_y[j] * fl1_fx - 3.0 * pa_xyz[j] * pc_x[j] * fl1_fx - 2.0 * pa_xy[j] * fl1_fx * pc_z[j] * pb_x[j] - 2.0 * pa_xz[j] * fl1_fx * pc_y[j] * pb_x[j] - 2.0 * pa_xyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_x[j] * fl1_fx * pa_yz[j] * pb_x[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_xx[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_xx[j] - 0.5 * fl1_fx * pa_yz[j] * pb_xx[j] - 2.0 * pa_xxyz[j] * pb_x[j] * pc_x[j] - pa_xxy[j] * pc_z[j] * pb_xx[j] - pa_xxz[j] * pc_y[j] * pb_xx[j] - 2.0 * pa_xyz[j] * pc_x[j] * pb_xx[j]);

                t_xxyz_xx[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pa_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pa_z[j] + 0.75 * fl2_fx * pa_yz[j] + 0.5 * pa_xxy[j] * pc_z[j] * fl1_fx + 0.5 * pa_xxz[j] * pc_y[j] * fl1_fx + 0.5 * pa_xx[j] * pc_yz[j] * fl1_fx + 3.0 * pa_xyz[j] * pc_x[j] * fl1_fx + 3.0 * pa_xy[j] * pc_xz[j] * fl1_fx + 3.0 * pa_xz[j] * pc_xy[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_x[j] + 2.0 * pa_xy[j] * fl1_fx * pc_z[j] * pb_x[j] + 2.0 * pa_xz[j] * fl1_fx * pc_y[j] * pb_x[j] + 3.0 * pc_xx[j] * pa_yz[j] * fl1_fx + 3.0 * pc_xz[j] * fl1_fx * pa_y[j] * pb_x[j] + 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pa_yz[j] * pb_x[j] + 0.5 * fl1_fx * pc_yz[j] * pb_xx[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_xx[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_xx[j] + pa_xxyz[j] * pc_xx[j] + 2.0 * pa_xxy[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xxz[j] * pc_xy[j] * pb_x[j] + pa_xx[j] * pc_yz[j] * pb_xx[j] + 4.0 * pa_xyz[j] * pc_xx[j] * pb_x[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_xx[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_xx[j] + pc_xx[j] * pa_yz[j] * pb_xx[j]);

                t_xxyz_xx[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pa_z[j] - 0.5 * pa_xx[j] * pc_yz[j] * fl1_fx - 3.0 * pa_xy[j] * pc_xz[j] * fl1_fx - 3.0 * pa_xz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pc_yz[j] * pb_x[j] - 3.0 * pc_xx[j] * pa_yz[j] * fl1_fx - 3.0 * pc_xxz[j] * pa_y[j] * fl1_fx - 3.0 * pc_xxy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xz[j] * fl1_fx * pa_y[j] * pb_x[j] - 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pc_yz[j] * pb_xx[j] - pa_xxy[j] * pc_xxz[j] - pa_xxz[j] * pc_xxy[j] - 2.0 * pa_xx[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_xyz[j] * pc_xxx[j] - 4.0 * pa_xy[j] * pc_xxz[j] * pb_x[j] - 4.0 * pa_xz[j] * pc_xxy[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_xx[j] - 2.0 * pc_xxx[j] * pa_yz[j] * pb_x[j] - pc_xxz[j] * pa_y[j] * pb_xx[j] - pc_xxy[j] * pa_z[j] * pb_xx[j]);

                t_xxyz_xx[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xxz[j] * pa_y[j] * fl1_fx + 3.0 * pc_xxy[j] * pa_z[j] * fl1_fx + 3.0 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xxyz[j] + 2.0 * pa_xy[j] * pc_xxxz[j] + 2.0 * pa_xz[j] * pc_xxxy[j] + 4.0 * pa_x[j] * pc_xxyz[j] * pb_x[j] + pc_xxxx[j] * pa_yz[j] + 2.0 * pc_xxxz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxxy[j] * pa_z[j] * pb_x[j] + pc_xxyz[j] * pb_xx[j]);

                t_xxyz_xx[j] += fl_s_0_0_5 * (-3.0 * pc_xxyz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxyz[j] - pc_xxxxz[j] * pa_y[j] - pc_xxxxy[j] * pa_z[j] - 2.0 * pc_xxxyz[j] * pb_x[j]);

                t_xxyz_xx[j] += fl_s_0_0_6 * pc_xxxxyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_25_26(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (25,26)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyz = paDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyz_xy = primBuffer.data(90 * idx + 25);

            // Batch of Integrals (25,26)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyz, pa_xxz, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, \
                                     pb_x, pb_xy, pb_y, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, \
                                     pc_xxxz, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, \
                                     pc_xz, pc_y, pc_yy, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xxyz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyz_xy[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * fl2_fx + 0.25 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xxz[j] * fl1_fx * pb_x[j] + pa_xyz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_yz[j] * pb_xy[j] + pa_xxyz[j] * pb_xy[j]);

                t_xxyz_xy[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx * pc_z[j] - pa_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * fl2_fx * pa_z[j] * pb_x[j] - 0.5 * pa_xxz[j] * fl1_fx * pc_x[j] - 0.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xxz[j] * fl1_fx * pb_x[j] - pa_xz[j] * pc_x[j] * fl1_fx * pb_x[j] - pa_xyz[j] * fl1_fx * pc_y[j] - pa_xy[j] * fl1_fx * pc_z[j] * pb_y[j] - pa_xz[j] * fl1_fx * pc_y[j] * pb_y[j] - pa_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * fl1_fx * pa_yz[j] * pb_y[j] - 0.5 * fl1_fx * pa_yz[j] * pb_x[j] * pc_y[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_xy[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_xy[j] - 0.5 * fl1_fx * pa_yz[j] * pb_xy[j] - pa_xxyz[j] * pb_x[j] * pc_y[j] - pa_xxyz[j] * pc_x[j] * pb_y[j] - pa_xxy[j] * pc_z[j] * pb_xy[j] - pa_xxz[j] * pc_y[j] * pb_xy[j] - 2.0 * pa_xyz[j] * pc_x[j] * pb_xy[j]);

                t_xxyz_xy[j] += fl_s_0_0_2 * (pa_x[j] * fl2_fx * pc_z[j] + 0.5 * pa_xz[j] * fl2_fx + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pa_z[j] + 0.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.25 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xx[j] * fl1_fx * pc_xz[j] + 0.5 * pa_xxz[j] * fl1_fx * pc_x[j] + 0.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_x[j] + pa_xz[j] * pc_xx[j] * fl1_fx + pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] + pa_xz[j] * pc_x[j] * fl1_fx * pb_x[j] + pa_xy[j] * fl1_fx * pc_yz[j] + pa_xz[j] * fl1_fx * pc_yy[j] + pa_x[j] * fl1_fx * pc_yz[j] * pb_y[j] + pa_xyz[j] * fl1_fx * pc_y[j] + pa_xy[j] * fl1_fx * pc_z[j] * pb_y[j] + pa_xz[j] * fl1_fx * pc_y[j] * pb_y[j] + 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_yz[j] + 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pa_yz[j] * pb_y[j] + 0.5 * fl1_fx * pa_y[j] * pc_yz[j] * pb_x[j] + 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pc_yz[j] * pb_xy[j] + 0.5 * fl1_fx * pa_yz[j] * pb_x[j] * pc_y[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_xy[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_xy[j] + pa_xxyz[j] * pc_xy[j] + pa_xxy[j] * pc_yz[j] * pb_x[j] + pa_xxy[j] * pc_xz[j] * pb_y[j] + pa_xxz[j] * pc_yy[j] * pb_x[j] + pa_xxz[j] * pc_xy[j] * pb_y[j] + pa_xx[j] * pc_yz[j] * pb_xy[j] + 2.0 * pa_xyz[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xyz[j] * pc_xx[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_xy[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_xy[j] + pc_xx[j] * pa_yz[j] * pb_xy[j]);

                t_xxyz_xy[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xx[j] * fl1_fx * pc_xz[j] - pa_x[j] * pc_xxz[j] * fl1_fx - pa_xz[j] * pc_xx[j] * fl1_fx - pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] - pa_x[j] * fl1_fx * pc_yyz[j] - pa_xy[j] * fl1_fx * pc_yz[j] - pa_xz[j] * fl1_fx * pc_yy[j] - pa_x[j] * fl1_fx * pc_yz[j] * pb_y[j] - 0.5 * pc_xxx[j] * fl1_fx * pa_z[j] - 0.5 * pc_xxz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pc_xyz[j] * fl1_fx * pa_y[j] - 1.5 * pc_xyy[j] * fl1_fx * pa_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_yz[j] - 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_x[j] - 0.5 * fl1_fx * pa_y[j] * pc_yz[j] * pb_x[j] - 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pc_yz[j] * pb_xy[j] - pa_xxy[j] * pc_xyz[j] - pa_xxz[j] * pc_xyy[j] - pa_xx[j] * pc_yyz[j] * pb_x[j] - pa_xx[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_xyz[j] * pc_xxy[j] - 2.0 * pa_xy[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_xy[j] * pc_xxz[j] * pb_y[j] - 2.0 * pa_xz[j] * pc_xyy[j] * pb_x[j] - 2.0 * pa_xz[j] * pc_xxy[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_xy[j] - pc_xxy[j] * pa_yz[j] * pb_x[j] - pc_xxx[j] * pa_yz[j] * pb_y[j] - pc_xxz[j] * pa_y[j] * pb_xy[j] - pc_xxy[j] * pa_z[j] * pb_xy[j]);

                t_xxyz_xy[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + pa_x[j] * pc_xxz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yyz[j] + 0.5 * pc_xxxz[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pa_z[j] + 0.5 * pc_xxz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pa_y[j] + 1.5 * pc_xyy[j] * fl1_fx * pa_z[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_x[j] + pa_xx[j] * pc_xyyz[j] + 2.0 * pa_xy[j] * pc_xxyz[j] + 2.0 * pa_xz[j] * pc_xxyy[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyz[j] * pb_y[j] + pc_xxxy[j] * pa_yz[j] + pc_xxyz[j] * pa_y[j] * pb_x[j] + pc_xxxz[j] * pa_y[j] * pb_y[j] + pc_xxyy[j] * pa_z[j] * pb_x[j] + pc_xxxy[j] * pa_z[j] * pb_y[j] + pc_xxyz[j] * pb_xy[j]);

                t_xxyz_xy[j] += fl_s_0_0_5 * (-0.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyyz[j] - pc_xxxyz[j] * pa_y[j] - pc_xxxyy[j] * pa_z[j] - pc_xxyyz[j] * pb_x[j] - pc_xxxyz[j] * pb_y[j]);

                t_xxyz_xy[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_26_27(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (26,27)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyz = paDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyz_xz = primBuffer.data(90 * idx + 26);

            // Batch of Integrals (26,27)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyz, pa_xxz, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, \
                                     pb_x, pb_xz, pb_z, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, \
                                     pc_xxxzz, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xxyz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyz_xz[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl2_fx + 0.25 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xxy[j] * fl1_fx * pb_x[j] + pa_xyz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_yz[j] * pb_xz[j] + pa_xxyz[j] * pb_xz[j]);

                t_xxyz_xz[j] += fl_s_0_0_1 * (-pa_xy[j] * fl2_fx - 0.5 * pa_x[j] * fl2_fx * pc_y[j] - 0.75 * pc_x[j] * fl2_fx * pa_y[j] - 0.5 * fl2_fx * pa_y[j] * pb_x[j] - 0.25 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xxy[j] * fl1_fx * pc_x[j] - 0.5 * pa_xxy[j] * fl1_fx * pb_x[j] - 0.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_x[j] - pa_xy[j] * pc_x[j] * fl1_fx * pb_x[j] - pa_xyz[j] * fl1_fx * pc_z[j] - pa_xy[j] * fl1_fx * pc_z[j] * pb_z[j] - pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] - pa_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * fl1_fx * pa_yz[j] * pb_z[j] - 0.5 * fl1_fx * pa_yz[j] * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_xz[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_xz[j] - 0.5 * fl1_fx * pa_yz[j] * pb_xz[j] - pa_xxyz[j] * pb_x[j] * pc_z[j] - pa_xxyz[j] * pc_x[j] * pb_z[j] - pa_xxy[j] * pc_z[j] * pb_xz[j] - pa_xxz[j] * pc_y[j] * pb_xz[j] - 2.0 * pa_xyz[j] * pc_x[j] * pb_xz[j]);

                t_xxyz_xz[j] += fl_s_0_0_2 * (pa_x[j] * fl2_fx * pc_y[j] + 0.5 * pa_xy[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pa_y[j] + 0.75 * pc_xy[j] * fl2_fx + 0.5 * fl2_fx * pc_y[j] * pb_x[j] + 0.25 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xxy[j] * fl1_fx * pc_x[j] + 0.5 * pa_xx[j] * pc_xy[j] * fl1_fx + 0.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_x[j] + pa_xy[j] * pc_xx[j] * fl1_fx + pa_xy[j] * pc_x[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + pa_xy[j] * fl1_fx * pc_zz[j] + pa_xz[j] * fl1_fx * pc_yz[j] + pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] + pa_xyz[j] * fl1_fx * pc_z[j] + pa_xy[j] * fl1_fx * pc_z[j] * pb_z[j] + pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pa_yz[j] + 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pa_yz[j] * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pc_yz[j] * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pc_yz[j] * pb_xz[j] + 0.5 * fl1_fx * pa_yz[j] * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_xz[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_xz[j] + pa_xxyz[j] * pc_xz[j] + pa_xxy[j] * pc_zz[j] * pb_x[j] + pa_xxy[j] * pc_xz[j] * pb_z[j] + pa_xxz[j] * pc_yz[j] * pb_x[j] + pa_xxz[j] * pc_xy[j] * pb_z[j] + pa_xx[j] * pc_yz[j] * pb_xz[j] + 2.0 * pa_xyz[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xyz[j] * pc_xx[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_xz[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_xz[j] + pc_xx[j] * pa_yz[j] * pb_xz[j]);

                t_xxyz_xz[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xx[j] * pc_xy[j] * fl1_fx - pa_xy[j] * pc_xx[j] * fl1_fx - pa_x[j] * pc_xxy[j] * fl1_fx - pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - pa_x[j] * fl1_fx * pc_yzz[j] - pa_xy[j] * fl1_fx * pc_zz[j] - pa_xz[j] * fl1_fx * pc_yz[j] - pa_x[j] * fl1_fx * pc_yz[j] * pb_z[j] - 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xzz[j] * fl1_fx * pa_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pa_yz[j] - 1.5 * pc_xz[j] * fl1_fx * pa_y[j] * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_x[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_x[j] - 0.5 * fl1_fx * pc_yz[j] * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pc_yz[j] * pb_xz[j] - pa_xxy[j] * pc_xzz[j] - pa_xxz[j] * pc_xyz[j] - pa_xx[j] * pc_yzz[j] * pb_x[j] - pa_xx[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_xyz[j] * pc_xxz[j] - 2.0 * pa_xy[j] * pc_xzz[j] * pb_x[j] - 2.0 * pa_xy[j] * pc_xxz[j] * pb_z[j] - 2.0 * pa_xz[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_xz[j] * pc_xxy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_xz[j] - pc_xxz[j] * pa_yz[j] * pb_x[j] - pc_xxx[j] * pa_yz[j] * pb_z[j] - pc_xxz[j] * pa_y[j] * pb_xz[j] - pc_xxy[j] * pa_z[j] * pb_xz[j]);

                t_xxyz_xz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + pa_x[j] * pc_xxy[j] * fl1_fx + pa_x[j] * fl1_fx * pc_yzz[j] + 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + 0.5 * pc_xxy[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xzz[j] * fl1_fx * pa_y[j] + 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_x[j] + pa_xx[j] * pc_xyzz[j] + 2.0 * pa_xy[j] * pc_xxzz[j] + 2.0 * pa_xz[j] * pc_xxyz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxyz[j] * pb_z[j] + pc_xxxz[j] * pa_yz[j] + pc_xxzz[j] * pa_y[j] * pb_x[j] + pc_xxxz[j] * pa_y[j] * pb_z[j] + pc_xxyz[j] * pa_z[j] * pb_x[j] + pc_xxxy[j] * pa_z[j] * pb_z[j] + pc_xxyz[j] * pb_xz[j]);

                t_xxyz_xz[j] += fl_s_0_0_5 * (-0.5 * pc_xxxy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyzz[j] - pc_xxxzz[j] * pa_y[j] - pc_xxxyz[j] * pa_z[j] - pc_xxyzz[j] * pb_x[j] - pc_xxxyz[j] * pb_z[j]);

                t_xxyz_xz[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_27_28(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (27,28)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyz = paDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyz_yy = primBuffer.data(90 * idx + 27);

            // Batch of Integrals (27,28)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyz, pa_xxz, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, \
                                     pb_y, pb_yy, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, \
                                     pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, \
                                     pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxyz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyz_yy[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_yz[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * pa_xxyz[j] * fl1_fx + pa_xxz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_yz[j] * pb_yy[j] + pa_xxyz[j] * pb_yy[j]);

                t_xxyz_yy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_yz[j] - 0.25 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pa_z[j] - 0.5 * fl2_fx * pc_z[j] * pb_y[j] - fl2_fx * pa_z[j] * pb_y[j] - 0.5 * pa_xxyz[j] * fl1_fx - 0.5 * pa_xxy[j] * pc_z[j] * fl1_fx - 1.5 * pa_xxz[j] * pc_y[j] * fl1_fx - pa_xx[j] * fl1_fx * pc_z[j] * pb_y[j] - pa_xxz[j] * fl1_fx * pb_y[j] - pa_xyz[j] * pc_x[j] * fl1_fx - 2.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] - fl1_fx * pa_yz[j] * pb_y[j] * pc_y[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_yy[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_yy[j] - 0.5 * fl1_fx * pa_yz[j] * pb_yy[j] - 2.0 * pa_xxyz[j] * pb_y[j] * pc_y[j] - pa_xxy[j] * pc_z[j] * pb_yy[j] - pa_xxz[j] * pc_y[j] * pb_yy[j] - 2.0 * pa_xyz[j] * pc_x[j] * pb_yy[j]);

                t_xxyz_yy[j] += fl_s_0_0_2 * (0.5 * fl2_fx * pa_y[j] * pc_z[j] + 1.5 * fl2_fx * pc_y[j] * pa_z[j] + 0.75 * fl2_fx * pc_yz[j] + fl2_fx * pc_z[j] * pb_y[j] + 0.25 * fl2_fx * pa_yz[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * pa_xxy[j] * pc_z[j] * fl1_fx + 1.5 * pa_xxz[j] * pc_y[j] * fl1_fx + 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx + pa_xx[j] * fl1_fx * pc_z[j] * pb_y[j] + pa_xyz[j] * pc_x[j] * fl1_fx + pa_xy[j] * pc_xz[j] * fl1_fx + 3.0 * pa_xz[j] * pc_xy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + 2.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] + 0.5 * pc_xx[j] * pa_yz[j] * fl1_fx + pc_xx[j] * fl1_fx * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pa_yz[j] * pc_yy[j] + fl1_fx * pa_y[j] * pc_yz[j] * pb_y[j] + fl1_fx * pc_yy[j] * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pc_yz[j] * pb_yy[j] + fl1_fx * pa_yz[j] * pb_y[j] * pc_y[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_yy[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_yy[j] + pa_xxyz[j] * pc_yy[j] + 2.0 * pa_xxy[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_xxz[j] * pc_yy[j] * pb_y[j] + pa_xx[j] * pc_yz[j] * pb_yy[j] + 4.0 * pa_xyz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_yy[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_yy[j] + pc_xx[j] * pa_yz[j] * pb_yy[j]);

                t_xxyz_yy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.25 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pa_z[j] - 0.5 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx - pa_xy[j] * pc_xz[j] * fl1_fx - 3.0 * pa_xz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * pa_yz[j] * fl1_fx - 0.5 * pc_xxz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx - pc_xxz[j] * fl1_fx * pb_y[j] - pc_xx[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_y[j] * pc_yyz[j] - 0.5 * fl1_fx * pc_yyy[j] * pa_z[j] - fl1_fx * pc_yyz[j] * pb_y[j] - 0.5 * fl1_fx * pa_yz[j] * pc_yy[j] - fl1_fx * pa_y[j] * pc_yz[j] * pb_y[j] - fl1_fx * pc_yy[j] * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pc_yz[j] * pb_yy[j] - pa_xxy[j] * pc_yyz[j] - pa_xxz[j] * pc_yyy[j] - 2.0 * pa_xx[j] * pc_yyz[j] * pb_y[j] - 2.0 * pa_xyz[j] * pc_xyy[j] - 4.0 * pa_xy[j] * pc_xyz[j] * pb_y[j] - 4.0 * pa_xz[j] * pc_xyy[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pa_yz[j] * pb_y[j] - pc_xxz[j] * pa_y[j] * pb_yy[j] - pc_xxy[j] * pa_z[j] * pb_yy[j]);

                t_xxyz_yy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 0.5 * pc_xxz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + pc_xxz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyyz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yyz[j] + 0.5 * fl1_fx * pc_yyy[j] * pa_z[j] + fl1_fx * pc_yyz[j] * pb_y[j] + pa_xx[j] * pc_yyyz[j] + 2.0 * pa_xy[j] * pc_xyyz[j] + 2.0 * pa_xz[j] * pc_xyyy[j] + 4.0 * pa_x[j] * pc_xyyz[j] * pb_y[j] + pc_xxyy[j] * pa_yz[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_y[j] + 2.0 * pc_xxyy[j] * pa_z[j] * pb_y[j] + pc_xxyz[j] * pb_yy[j]);

                t_xxyz_yy[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyz[j] - 2.0 * pa_x[j] * pc_xyyyz[j] - pc_xxyyz[j] * pa_y[j] - pc_xxyyy[j] * pa_z[j] - 2.0 * pc_xxyyz[j] * pb_y[j]);

                t_xxyz_yy[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_28_29(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (28,29)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyz = paDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyz_yz = primBuffer.data(90 * idx + 28);

            // Batch of Integrals (28,29)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyz, pa_xxz, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, \
                                     pb_y, pb_yz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xxyz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxyz_yz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + 0.25 * fl2_fx * pa_y[j] * pb_y[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xxy[j] * fl1_fx * pb_y[j] + 0.5 * pa_xxz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_yz[j] * pb_yz[j] + pa_xxyz[j] * pb_yz[j]);

                t_xxyz_yz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_xx[j] * fl2_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_y[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.5 * pa_xxy[j] * fl1_fx * pc_y[j] - 0.5 * pa_xxy[j] * fl1_fx * pb_y[j] - 0.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * pa_xxz[j] * fl1_fx * pc_z[j] - 0.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_z[j] - 0.5 * pa_xxz[j] * fl1_fx * pb_z[j] - pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] - pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pa_yz[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_yz[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_yz[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_yz[j] - 0.5 * fl1_fx * pa_yz[j] * pb_yz[j] - pa_xxyz[j] * pb_y[j] * pc_z[j] - pa_xxyz[j] * pc_y[j] * pb_z[j] - pa_xxy[j] * pc_z[j] * pb_yz[j] - pa_xxz[j] * pc_y[j] * pb_yz[j] - 2.0 * pa_xyz[j] * pc_x[j] * pb_yz[j]);

                t_xxyz_yz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * pc_x[j] * fl2_fx + 0.25 * pc_xx[j] * fl2_fx + 0.5 * fl2_fx * pa_y[j] * pc_y[j] + 0.25 * fl2_fx * pc_yy[j] + 0.5 * fl2_fx * pc_y[j] * pb_y[j] + 0.25 * fl2_fx * pc_zz[j] + 0.5 * fl2_fx * pa_z[j] * pc_z[j] + 0.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.25 * fl2_fx * pa_y[j] * pb_y[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xxy[j] * fl1_fx * pc_y[j] + 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx + 0.5 * pa_xx[j] * pc_y[j] * fl1_fx * pb_y[j] + 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] + 0.5 * pa_xxz[j] * fl1_fx * pc_z[j] + 0.5 * pa_xx[j] * fl1_fx * pc_z[j] * pb_z[j] + pa_xy[j] * pc_xy[j] * fl1_fx + pa_xy[j] * pc_x[j] * fl1_fx * pb_y[j] + pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + pa_xz[j] * pc_xz[j] * fl1_fx + pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] + 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pa_yz[j] * pc_yz[j] + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pc_yz[j] * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pc_yz[j] * pb_yz[j] + 0.5 * fl1_fx * pa_yz[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_yz[j] * pc_y[j] * pb_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_yz[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_yz[j] + pa_xxyz[j] * pc_yz[j] + pa_xxy[j] * pc_zz[j] * pb_y[j] + pa_xxy[j] * pc_yz[j] * pb_z[j] + pa_xxz[j] * pc_yz[j] * pb_y[j] + pa_xxz[j] * pc_yy[j] * pb_z[j] + pa_xx[j] * pc_yz[j] * pb_yz[j] + 2.0 * pa_xyz[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xyz[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_yz[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_yz[j] + pc_xx[j] * pa_yz[j] * pb_yz[j]);

                t_xxyz_yz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * pc_xx[j] * fl2_fx - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pc_zz[j] - 0.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_y[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * pa_xx[j] * pc_yy[j] * fl1_fx - 0.5 * pa_xx[j] * fl1_fx * pc_zz[j] - pa_xy[j] * pc_xy[j] * fl1_fx - pa_x[j] * pc_xyy[j] * fl1_fx - pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - pa_x[j] * pc_xzz[j] * fl1_fx - pa_xz[j] * pc_xz[j] * fl1_fx - pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxz[j] * fl1_fx * pa_z[j] - 0.5 * pc_xxz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_yzz[j] - 0.5 * fl1_fx * pc_yyz[j] * pa_z[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_z[j] - 0.5 * fl1_fx * pa_yz[j] * pc_yz[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_y[j] - 0.5 * fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] - 0.5 * fl1_fx * pc_yz[j] * pa_z[j] * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pc_yz[j] * pb_yz[j] - pa_xxy[j] * pc_yzz[j] - pa_xxz[j] * pc_yyz[j] - pa_xx[j] * pc_yzz[j] * pb_y[j] - pa_xx[j] * pc_yyz[j] * pb_z[j] - 2.0 * pa_xyz[j] * pc_xyz[j] - 2.0 * pa_xy[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_xy[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_xz[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_xz[j] * pc_xyy[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_yz[j] - pc_xxz[j] * pa_yz[j] * pb_y[j] - pc_xxy[j] * pa_yz[j] * pb_z[j] - pc_xxz[j] * pa_y[j] * pb_yz[j] - pc_xxy[j] * pa_z[j] * pb_yz[j]);

                t_xxyz_yz[j] += fl_s_0_0_4 * (0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pc_zz[j] + pa_x[j] * pc_xyy[j] * fl1_fx + pa_x[j] * pc_xzz[j] * fl1_fx + 0.5 * pc_xxy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_xxy[j] * fl1_fx * pb_y[j] + 0.5 * pc_xxzz[j] * fl1_fx + 0.5 * pc_xxz[j] * fl1_fx * pa_z[j] + 0.5 * pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yyzz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yzz[j] + 0.5 * fl1_fx * pc_yyz[j] * pa_z[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_z[j] + pa_xx[j] * pc_yyzz[j] + 2.0 * pa_xy[j] * pc_xyzz[j] + 2.0 * pa_xz[j] * pc_xyyz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_z[j] + pc_xxyz[j] * pa_yz[j] + pc_xxzz[j] * pa_y[j] * pb_y[j] + pc_xxyz[j] * pa_y[j] * pb_z[j] + pc_xxyz[j] * pa_z[j] * pb_y[j] + pc_xxyy[j] * pa_z[j] * pb_z[j] + pc_xxyz[j] * pb_yz[j]);

                t_xxyz_yz[j] += fl_s_0_0_5 * (-0.5 * pc_xxyy[j] * fl1_fx - 0.5 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - 2.0 * pa_x[j] * pc_xyyzz[j] - pc_xxyzz[j] * pa_y[j] - pc_xxyyz[j] * pa_z[j] - pc_xxyzz[j] * pb_y[j] - pc_xxyyz[j] * pb_z[j]);

                t_xxyz_yz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_29_30(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (29,30)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxy = paDistances.data(34 * idx + 10);

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxyz = paDistances.data(34 * idx + 23);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxyz_zz = primBuffer.data(90 * idx + 29);

            // Batch of Integrals (29,30)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxy, pa_xxyz, pa_xxz, pa_xy, pa_xyz, pa_xz, pa_y, pa_yz, pa_z, \
                                     pb_z, pb_zz, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, \
                                     pc_xxzzz, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxyz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxyz_zz[j] = fl_s_0_0_0 * (0.25 * fl2_fx * pa_yz[j] + 0.5 * fl2_fx * pa_y[j] * pb_z[j] + 0.5 * pa_xxyz[j] * fl1_fx + pa_xxy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_yz[j] * pb_zz[j] + pa_xxyz[j] * pb_zz[j]);

                t_xxyz_zz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - fl2_fx * pa_y[j] * pb_z[j] - 0.25 * fl2_fx * pc_y[j] * pa_z[j] - 0.5 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xxyz[j] * fl1_fx - 1.5 * pa_xxy[j] * pc_z[j] * fl1_fx - pa_xxy[j] * fl1_fx * pb_z[j] - 0.5 * pa_xxz[j] * pc_y[j] * fl1_fx - pa_xx[j] * pc_y[j] * fl1_fx * pb_z[j] - pa_xyz[j] * pc_x[j] * fl1_fx - 2.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] - fl1_fx * pa_yz[j] * pb_z[j] * pc_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_yz[j] * pb_zz[j] - 2.0 * pa_xxyz[j] * pb_z[j] * pc_z[j] - pa_xxy[j] * pc_z[j] * pb_zz[j] - pa_xxz[j] * pc_y[j] * pb_zz[j] - 2.0 * pa_xyz[j] * pc_x[j] * pb_zz[j]);

                t_xxyz_zz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_y[j] * pc_z[j] + 0.5 * fl2_fx * pc_y[j] * pa_z[j] + 0.75 * fl2_fx * pc_yz[j] + fl2_fx * pc_y[j] * pb_z[j] + 0.25 * fl2_fx * pa_yz[j] + 0.5 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * pa_xxy[j] * pc_z[j] * fl1_fx + 0.5 * pa_xxz[j] * pc_y[j] * fl1_fx + 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx + pa_xx[j] * pc_y[j] * fl1_fx * pb_z[j] + pa_xyz[j] * pc_x[j] * fl1_fx + 3.0 * pa_xy[j] * pc_xz[j] * fl1_fx + 2.0 * pa_xy[j] * pc_x[j] * fl1_fx * pb_z[j] + pa_xz[j] * pc_xy[j] * fl1_fx + 2.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 0.5 * pc_xx[j] * pa_yz[j] * fl1_fx + pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pa_yz[j] * pc_zz[j] + fl1_fx * pa_y[j] * pc_zz[j] * pb_z[j] + fl1_fx * pc_yz[j] * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pc_yz[j] * pb_zz[j] + fl1_fx * pa_yz[j] * pb_z[j] * pc_z[j] + 0.5 * fl1_fx * pa_y[j] * pc_z[j] * pb_zz[j] + 0.5 * fl1_fx * pc_y[j] * pa_z[j] * pb_zz[j] + pa_xxyz[j] * pc_zz[j] + 2.0 * pa_xxy[j] * pc_zz[j] * pb_z[j] + 2.0 * pa_xxz[j] * pc_yz[j] * pb_z[j] + pa_xx[j] * pc_yz[j] * pb_zz[j] + 4.0 * pa_xyz[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_xz[j] * pb_zz[j] + 2.0 * pa_xz[j] * pc_xy[j] * pb_zz[j] + pc_xx[j] * pa_yz[j] * pb_zz[j]);

                t_xxyz_zz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.25 * fl2_fx * pc_y[j] * pa_z[j] - 0.5 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx - 3.0 * pa_xy[j] * pc_xz[j] * fl1_fx - pa_xz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * pa_yz[j] * fl1_fx - 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx - pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxy[j] * pa_z[j] * fl1_fx - pc_xxy[j] * fl1_fx * pb_z[j] - 0.5 * fl1_fx * pa_y[j] * pc_zzz[j] - 0.5 * fl1_fx * pc_yzz[j] * pa_z[j] - fl1_fx * pc_yzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_yz[j] * pc_zz[j] - fl1_fx * pa_y[j] * pc_zz[j] * pb_z[j] - fl1_fx * pc_yz[j] * pa_z[j] * pb_z[j] - 0.5 * fl1_fx * pc_yz[j] * pb_zz[j] - pa_xxy[j] * pc_zzz[j] - pa_xxz[j] * pc_yzz[j] - 2.0 * pa_xx[j] * pc_yzz[j] * pb_z[j] - 2.0 * pa_xyz[j] * pc_xzz[j] - 4.0 * pa_xy[j] * pc_xzz[j] * pb_z[j] - 4.0 * pa_xz[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xyz[j] * pb_zz[j] - 2.0 * pc_xxz[j] * pa_yz[j] * pb_z[j] - pc_xxz[j] * pa_y[j] * pb_zz[j] - pc_xxy[j] * pa_z[j] * pb_zz[j]);

                t_xxyz_zz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + pc_xxy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yzzz[j] + 0.5 * fl1_fx * pa_y[j] * pc_zzz[j] + 0.5 * fl1_fx * pc_yzz[j] * pa_z[j] + fl1_fx * pc_yzz[j] * pb_z[j] + pa_xx[j] * pc_yzzz[j] + 2.0 * pa_xy[j] * pc_xzzz[j] + 2.0 * pa_xz[j] * pc_xyzz[j] + 4.0 * pa_x[j] * pc_xyzz[j] * pb_z[j] + pc_xxzz[j] * pa_yz[j] + 2.0 * pc_xxzz[j] * pa_y[j] * pb_z[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_z[j] + pc_xxyz[j] * pb_zz[j]);

                t_xxyz_zz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yzzz[j] - 2.0 * pa_x[j] * pc_xyzzz[j] - pc_xxzzz[j] * pa_y[j] - pc_xxyzz[j] * pa_z[j] - 2.0 * pc_xxyzz[j] * pb_z[j]);

                t_xxyz_zz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_30_31(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (30,31)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxzz = paDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxx = pcDistances.data(83 * idx + 19);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxxz = pcDistances.data(83 * idx + 36);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxxzz = pcDistances.data(83 * idx + 60);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxzz_xx = primBuffer.data(90 * idx + 30);

            // Batch of Integrals (30,31)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xxzz, pa_xz, pa_xzz, pa_z, pa_zz, pb_x, pb_xx, pc_x, \
                                     pc_xx, pc_xxx, pc_xxxx, pc_xxxxz, pc_xxxxzz, pc_xxxz, pc_xxxzz, pc_xxz, pc_xxzz, \
                                     pc_xz, pc_xzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxzz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxzz_xx[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * fl2_fx * pa_zz[j] + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 0.5 * pa_xxzz[j] * fl1_fx + 2.0 * pa_xzz[j] * fl1_fx * pb_x[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_xx[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pa_zz[j] * pb_xx[j] + pa_xxzz[j] * pb_xx[j]);

                t_xxzz_xx[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * fl2_fx * pa_zz[j] - 0.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 2.0 * pa_x[j] * fl2_fx * pb_x[j] - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * pa_xxzz[j] * fl1_fx - pa_xxz[j] * pc_z[j] * fl1_fx - 3.0 * pa_xzz[j] * pc_x[j] * fl1_fx - 4.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_x[j] - 2.0 * pa_xzz[j] * fl1_fx * pb_x[j] - 3.0 * pc_x[j] * fl1_fx * pa_zz[j] * pb_x[j] - 0.5 * fl2_fx * pb_xx[j] - pa_xx[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_xx[j] * fl1_fx * pb_xx[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_xx[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_xx[j] - 0.5 * fl1_fx * pa_zz[j] * pb_xx[j] - 2.0 * pa_xxzz[j] * pb_x[j] * pc_x[j] - 2.0 * pa_xxz[j] * pc_z[j] * pb_xx[j] - 2.0 * pa_xzz[j] * pc_x[j] * pb_xx[j]);

                t_xxzz_xx[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pa_z[j] * pc_z[j] + 0.75 * fl2_fx * pa_zz[j] + 0.25 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + pa_x[j] * fl2_fx * pb_x[j] + 1.5 * pc_xx[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pb_x[j] + pa_xxz[j] * pc_z[j] * fl1_fx + 0.5 * pa_xx[j] * pc_zz[j] * fl1_fx + 3.0 * pa_xzz[j] * pc_x[j] * fl1_fx + 6.0 * pa_xz[j] * pc_xz[j] * fl1_fx + 2.0 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] + 4.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_x[j] + 3.0 * pc_xx[j] * pa_zz[j] * fl1_fx + 6.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] + 3.0 * pc_x[j] * fl1_fx * pa_zz[j] * pb_x[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_xx[j] * fl1_fx * pc_xx[j] + pa_xx[j] * fl1_fx * pb_x[j] * pc_x[j] + 2.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_xx[j] + 0.5 * pc_xx[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xx[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_xx[j] + pa_xxzz[j] * pc_xx[j] + 4.0 * pa_xxz[j] * pc_xz[j] * pb_x[j] + pa_xx[j] * pc_zz[j] * pb_xx[j] + 4.0 * pa_xzz[j] * pc_xx[j] * pb_x[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_xx[j] + pc_xx[j] * pa_zz[j] * pb_xx[j]);

                t_xxzz_xx[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 3.0 * pc_xx[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * pa_xx[j] * pc_zz[j] * fl1_fx - 6.0 * pa_xz[j] * pc_xz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 2.0 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] - 3.0 * pc_xx[j] * pa_zz[j] * fl1_fx - 6.0 * pc_xxz[j] * pa_z[j] * fl1_fx - 3.0 * pc_xzz[j] * fl1_fx * pb_x[j] - 6.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * pa_xx[j] * fl1_fx * pc_xx[j] - pa_x[j] * pc_xxx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xx[j] * fl1_fx * pb_x[j] - pc_xxx[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pb_xx[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xx[j] - 2.0 * pa_xxz[j] * pc_xxz[j] - 2.0 * pa_xx[j] * pc_xzz[j] * pb_x[j] - 2.0 * pa_xzz[j] * pc_xxx[j] - 8.0 * pa_xz[j] * pc_xxz[j] * pb_x[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_xx[j] - 2.0 * pc_xxx[j] * pa_zz[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_xx[j]);

                t_xxzz_xx[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_zz[j] + 1.5 * pc_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx + 6.0 * pc_xxz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 3.0 * pc_xzz[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_xxx[j] * fl1_fx + 0.5 * pc_xxxx[j] * fl1_fx + pc_xxx[j] * fl1_fx * pb_x[j] + pa_xx[j] * pc_xxzz[j] + 4.0 * pa_xz[j] * pc_xxxz[j] + 4.0 * pa_x[j] * pc_xxzz[j] * pb_x[j] + pc_xxxx[j] * pa_zz[j] + 4.0 * pc_xxxz[j] * pa_z[j] * pb_x[j] + pc_xxzz[j] * pb_xx[j]);

                t_xxzz_xx[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * pc_xxxx[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxxzz[j] - 2.0 * pc_xxxxz[j] * pa_z[j] - 2.0 * pc_xxxzz[j] * pb_x[j]);

                t_xxzz_xx[j] += fl_s_0_0_6 * pc_xxxxzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_31_32(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (31,32)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxzz = paDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxzz_xy = primBuffer.data(90 * idx + 31);

            // Batch of Integrals (31,32)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xxzz, pa_xz, pa_xzz, pa_z, pa_zz, pb_x, pb_xy, pb_y, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, pc_xxy, \
                                     pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yz, \
                                     pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xxzz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxzz_xy[j] = fl_s_0_0_0 * (0.5 * pa_x[j] * fl2_fx * pb_y[j] + pa_xzz[j] * fl1_fx * pb_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_xx[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_zz[j] * pb_xy[j] + pa_xxzz[j] * pb_xy[j]);

                t_xxzz_xy[j] += fl_s_0_0_1 * (-0.5 * pa_x[j] * fl2_fx * pc_y[j] - pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - pa_xzz[j] * fl1_fx * pc_y[j] - 2.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_y[j] - pa_xzz[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_y[j] - 0.25 * fl2_fx * pb_x[j] * pc_y[j] - 0.5 * fl2_fx * pb_xy[j] - 0.5 * pa_xx[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_xx[j] * fl1_fx * pb_xy[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pa_zz[j] * pb_x[j] * pc_y[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_xy[j] - 0.5 * fl1_fx * pa_zz[j] * pb_xy[j] - pa_xxzz[j] * pb_x[j] * pc_y[j] - pa_xxzz[j] * pc_x[j] * pb_y[j] - 2.0 * pa_xxz[j] * pc_z[j] * pb_xy[j] - 2.0 * pa_xzz[j] * pc_x[j] * pb_xy[j]);

                t_xxzz_xy[j] += fl_s_0_0_2 * (pa_x[j] * fl2_fx * pc_y[j] + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 2.0 * pa_xz[j] * fl1_fx * pc_yz[j] + pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] + pa_xzz[j] * fl1_fx * pc_y[j] + 2.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_y[j] + 1.5 * pc_xy[j] * fl1_fx * pa_zz[j] + 3.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_y[j] + 0.5 * fl2_fx * pb_x[j] * pc_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_xx[j] * fl1_fx * pc_xy[j] + 0.5 * pa_xx[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_y[j] + pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_xy[j] + 0.5 * pc_xx[j] * fl1_fx * pb_xy[j] + fl1_fx * pa_z[j] * pc_yz[j] * pb_x[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xy[j] + 0.5 * fl1_fx * pa_zz[j] * pb_x[j] * pc_y[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_xy[j] + pa_xxzz[j] * pc_xy[j] + 2.0 * pa_xxz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_xxz[j] * pc_xz[j] * pb_y[j] + pa_xx[j] * pc_zz[j] * pb_xy[j] + 2.0 * pa_xzz[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xzz[j] * pc_xx[j] * pb_y[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_xy[j] + pc_xx[j] * pa_zz[j] * pb_xy[j]);

                t_xxzz_xy[j] += fl_s_0_0_3 * (-0.5 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - pa_x[j] * fl1_fx * pc_yzz[j] - 2.0 * pa_xz[j] * fl1_fx * pc_yz[j] - pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] - 3.0 * pc_xyz[j] * fl1_fx * pa_z[j] - 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_zz[j] - 3.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.25 * fl2_fx * pb_x[j] * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pc_xy[j] - pa_x[j] * pc_xxy[j] * fl1_fx - pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - pa_x[j] * pc_xx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_x[j] - fl1_fx * pa_z[j] * pc_yz[j] * pb_x[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xy[j] - 2.0 * pa_xxz[j] * pc_xyz[j] - pa_xx[j] * pc_yzz[j] * pb_x[j] - pa_xx[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_xzz[j] * pc_xxy[j] - 4.0 * pa_xz[j] * pc_xyz[j] * pb_x[j] - 4.0 * pa_xz[j] * pc_xxz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_xy[j] - pc_xxy[j] * pa_zz[j] * pb_x[j] - pc_xxx[j] * pa_zz[j] * pb_y[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_xy[j]);

                t_xxzz_xy[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + pa_x[j] * fl1_fx * pc_yzz[j] + 1.5 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pa_z[j] + 1.5 * pc_xzz[j] * fl1_fx * pb_y[j] + pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + 0.5 * pc_xxy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxx[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_x[j] + pa_xx[j] * pc_xyzz[j] + 4.0 * pa_xz[j] * pc_xxyz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxzz[j] * pb_y[j] + pc_xxxy[j] * pa_zz[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxxz[j] * pa_z[j] * pb_y[j] + pc_xxzz[j] * pb_xy[j]);

                t_xxzz_xy[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xxxy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxyzz[j] - 2.0 * pc_xxxyz[j] * pa_z[j] - pc_xxyzz[j] * pb_x[j] - pc_xxxzz[j] * pb_y[j]);

                t_xxzz_xy[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_32_33(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (32,33)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxzz = paDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxzzz = pcDistances.data(83 * idx + 64);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxzz_xz = primBuffer.data(90 * idx + 32);

            // Batch of Integrals (32,33)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xxzz, pa_xz, pa_xzz, pa_z, pa_zz, pb_x, pb_xz, pb_z, \
                                     pc_x, pc_xx, pc_xxx, pc_xxxz, pc_xxxzz, pc_xxxzzz, pc_xxz, pc_xxzz, pc_xxzzz, \
                                     pc_xz, pc_xzz, pc_xzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xxzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxzz_xz[j] = fl_s_0_0_0 * (pa_xz[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + pa_xxz[j] * fl1_fx * pb_x[j] + pa_xzz[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_xz[j] + pa_xxzz[j] * pb_xz[j]);

                t_xxzz_xz[j] += fl_s_0_0_1 * (-2.0 * pa_xz[j] * fl2_fx - 1.5 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_x[j] * fl2_fx * pa_z[j] - pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - fl2_fx * pa_z[j] * pb_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - pa_xxz[j] * fl1_fx * pc_x[j] - pa_xxz[j] * fl1_fx * pb_x[j] - 1.5 * pa_xx[j] * pc_z[j] * fl1_fx * pb_x[j] - 2.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_x[j] - pa_xzz[j] * fl1_fx * pc_z[j] - 2.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_z[j] - pa_xzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_z[j] - 0.5 * fl2_fx * pb_xz[j] - 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_xz[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_x[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_xz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_xz[j] - pa_xxzz[j] * pb_x[j] * pc_z[j] - pa_xxzz[j] * pc_x[j] * pb_z[j] - 2.0 * pa_xxz[j] * pc_z[j] * pb_xz[j] - 2.0 * pa_xzz[j] * pc_x[j] * pb_xz[j]);

                t_xxzz_xz[j] += fl_s_0_0_2 * (3.0 * pa_x[j] * fl2_fx * pc_z[j] + pa_xz[j] * fl2_fx + 3.0 * pc_x[j] * fl2_fx * pa_z[j] + 2.25 * pc_xz[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + pa_xxz[j] * fl1_fx * pc_x[j] + 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xx[j] * pc_z[j] * fl1_fx * pb_x[j] + 2.0 * pa_xz[j] * pc_xx[j] * fl1_fx + 2.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_x[j] + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] + 2.0 * pa_xz[j] * fl1_fx * pc_zz[j] + pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] + pa_xzz[j] * fl1_fx * pc_z[j] + 2.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_z[j] + pc_xx[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * fl1_fx * pa_zz[j] + 3.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_xx[j] * fl1_fx * pc_x[j] * pb_z[j] + pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_xz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_xz[j] + fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_x[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_xz[j] + pa_xxzz[j] * pc_xz[j] + 2.0 * pa_xxz[j] * pc_zz[j] * pb_x[j] + 2.0 * pa_xxz[j] * pc_xz[j] * pb_z[j] + pa_xx[j] * pc_zz[j] * pb_xz[j] + 2.0 * pa_xzz[j] * pc_xz[j] * pb_x[j] + 2.0 * pa_xzz[j] * pc_xx[j] * pb_z[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_xz[j] + pc_xx[j] * pa_zz[j] * pb_xz[j]);

                t_xxzz_xz[j] += fl_s_0_0_3 * (-1.5 * pa_x[j] * fl2_fx * pc_z[j] - 4.5 * pc_xz[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pa_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_xx[j] * pc_xz[j] * fl1_fx - 2.0 * pa_xz[j] * pc_xx[j] * fl1_fx - 3.0 * pa_x[j] * pc_xxz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] - pa_x[j] * fl1_fx * pc_zzz[j] - 2.0 * pa_xz[j] * fl1_fx * pc_zz[j] - pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] - pc_xxx[j] * pa_z[j] * fl1_fx - pc_xx[j] * pa_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xzz[j] * fl1_fx * pa_z[j] - 1.5 * pc_xzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pa_zz[j] - 3.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] - pa_x[j] * pc_xx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] - fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xz[j] - 2.0 * pa_xxz[j] * pc_xzz[j] - pa_xx[j] * pc_zzz[j] * pb_x[j] - pa_xx[j] * pc_xzz[j] * pb_z[j] - 2.0 * pa_xzz[j] * pc_xxz[j] - 4.0 * pa_xz[j] * pc_xzz[j] * pb_x[j] - 4.0 * pa_xz[j] * pc_xxz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_xz[j] - pc_xxz[j] * pa_zz[j] * pb_x[j] - pc_xxx[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_xz[j]);

                t_xxzz_xz[j] += fl_s_0_0_4 * (2.25 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_xxz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_zzz[j] + pc_xxx[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxxz[j] * fl1_fx + 1.5 * pc_xxz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xzzz[j] * fl1_fx + 3.0 * pc_xzz[j] * fl1_fx * pa_z[j] + 1.5 * pc_xzz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xxx[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] + pa_xx[j] * pc_xzzz[j] + 4.0 * pa_xz[j] * pc_xxzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] * pb_x[j] + 2.0 * pa_x[j] * pc_xxzz[j] * pb_z[j] + pc_xxxz[j] * pa_zz[j] + 2.0 * pc_xxzz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxxz[j] * pa_z[j] * pb_z[j] + pc_xxzz[j] * pb_xz[j]);

                t_xxzz_xz[j] += fl_s_0_0_5 * (-1.5 * pc_xxxz[j] * fl1_fx - 1.5 * pc_xzzz[j] * fl1_fx - 2.0 * pa_x[j] * pc_xxzzz[j] - 2.0 * pc_xxxzz[j] * pa_z[j] - pc_xxzzz[j] * pb_x[j] - pc_xxxzz[j] * pb_z[j]);

                t_xxzz_xz[j] += fl_s_0_0_6 * pc_xxxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_33_34(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (33,34)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxzz = paDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxzz_yy = primBuffer.data(90 * idx + 33);

            // Batch of Integrals (33,34)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xxzz, pa_xz, pa_xzz, pa_z, pa_zz, pb_y, pb_yy, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xxzz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxzz_yy[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + 0.25 * fl2_fx * pa_zz[j] + 0.5 * pa_xxzz[j] * fl1_fx + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_xx[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pa_zz[j] * pb_yy[j] + pa_xxzz[j] * pb_yy[j]);

                t_xxzz_yy[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_xx[j] * fl2_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pa_zz[j] - 0.5 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * pa_xxzz[j] * fl1_fx - pa_xxz[j] * pc_z[j] * fl1_fx - pa_xzz[j] * pc_x[j] * fl1_fx - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * fl2_fx * pb_yy[j] - pa_xx[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pb_yy[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] - fl1_fx * pa_zz[j] * pb_y[j] * pc_y[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_yy[j] - 0.5 * fl1_fx * pa_zz[j] * pb_yy[j] - 2.0 * pa_xxzz[j] * pb_y[j] * pc_y[j] - 2.0 * pa_xxz[j] * pc_z[j] * pb_yy[j] - 2.0 * pa_xzz[j] * pc_x[j] * pb_yy[j]);

                t_xxzz_yy[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_xx[j] * fl2_fx + pa_x[j] * pc_x[j] * fl2_fx + 0.25 * pc_xx[j] * fl2_fx + fl2_fx * pa_z[j] * pc_z[j] + 0.25 * fl2_fx * pc_zz[j] + 0.25 * fl2_fx * pa_zz[j] + pa_xxz[j] * pc_z[j] * fl1_fx + 0.5 * pa_xx[j] * pc_zz[j] * fl1_fx + pa_xzz[j] * pc_x[j] * fl1_fx + 2.0 * pa_xz[j] * pc_xz[j] * fl1_fx + 0.5 * pc_xx[j] * pa_zz[j] * fl1_fx + 0.25 * fl2_fx * pc_yy[j] + fl2_fx * pb_y[j] * pc_y[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_xx[j] * fl1_fx * pc_yy[j] + pa_xx[j] * fl1_fx * pb_y[j] * pc_y[j] + 2.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_yy[j] + 0.5 * pc_xx[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pa_zz[j] * pc_yy[j] + 2.0 * fl1_fx * pa_z[j] * pc_yz[j] * pb_y[j] + 0.5 * fl1_fx * pc_zz[j] * pb_yy[j] + fl1_fx * pa_zz[j] * pb_y[j] * pc_y[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_yy[j] + pa_xxzz[j] * pc_yy[j] + 4.0 * pa_xxz[j] * pc_yz[j] * pb_y[j] + pa_xx[j] * pc_zz[j] * pb_yy[j] + 4.0 * pa_xzz[j] * pc_xy[j] * pb_y[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_yy[j] + pc_xx[j] * pa_zz[j] * pb_yy[j]);

                t_xxzz_yy[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * pc_xx[j] * fl2_fx - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * pa_xx[j] * pc_zz[j] * fl1_fx - 2.0 * pa_xz[j] * pc_xz[j] * fl1_fx - pa_x[j] * pc_xzz[j] * fl1_fx - 0.5 * pc_xx[j] * pa_zz[j] * fl1_fx - pc_xxz[j] * pa_z[j] * fl1_fx - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xx[j] * fl1_fx * pc_yy[j] - pa_x[j] * pc_xyy[j] * fl1_fx - 2.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - pc_xxy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pb_yy[j] - fl1_fx * pa_z[j] * pc_yyz[j] - fl1_fx * pc_yzz[j] * pb_y[j] - 0.5 * fl1_fx * pa_zz[j] * pc_yy[j] - 2.0 * fl1_fx * pa_z[j] * pc_yz[j] * pb_y[j] - 0.5 * fl1_fx * pc_zz[j] * pb_yy[j] - 2.0 * pa_xxz[j] * pc_yyz[j] - 2.0 * pa_xx[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_xzz[j] * pc_xyy[j] - 8.0 * pa_xz[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_yy[j] - 2.0 * pc_xxy[j] * pa_zz[j] * pb_y[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_yy[j]);

                t_xxzz_yy[j] += fl_s_0_0_4 * (0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_zz[j] + pa_x[j] * pc_xzz[j] * fl1_fx + pc_xxz[j] * pa_z[j] * fl1_fx + 0.5 * pc_xxzz[j] * fl1_fx + 0.25 * fl2_fx * pc_yy[j] + pa_x[j] * pc_xyy[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + pc_xxy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_yyzz[j] + fl1_fx * pa_z[j] * pc_yyz[j] + fl1_fx * pc_yzz[j] * pb_y[j] + pa_xx[j] * pc_yyzz[j] + 4.0 * pa_xz[j] * pc_xyyz[j] + 4.0 * pa_x[j] * pc_xyzz[j] * pb_y[j] + pc_xxyy[j] * pa_zz[j] + 4.0 * pc_xxyz[j] * pa_z[j] * pb_y[j] + pc_xxzz[j] * pb_yy[j]);

                t_xxzz_yy[j] += fl_s_0_0_5 * (-0.5 * pc_xxzz[j] * fl1_fx - 0.5 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - 2.0 * pa_x[j] * pc_xyyzz[j] - 2.0 * pc_xxyyz[j] * pa_z[j] - 2.0 * pc_xxyzz[j] * pb_y[j]);

                t_xxzz_yy[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_34_35(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (34,35)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxzz = paDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxzz_yz = primBuffer.data(90 * idx + 34);

            // Batch of Integrals (34,35)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xxzz, pa_xz, pa_xzz, pa_z, pa_zz, pb_y, pb_yz, pb_z, \
                                     pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, pc_xxzzz, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxzz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xxzz_yz[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_z[j] * pb_y[j] + pa_xxz[j] * fl1_fx * pb_y[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_yz[j] + pa_xxzz[j] * pb_yz[j]);

                t_xxzz_yz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] * pc_y[j] - fl2_fx * pa_z[j] * pb_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - pa_xxz[j] * fl1_fx * pc_y[j] - pa_xxz[j] * fl1_fx * pb_y[j] - 1.5 * pa_xx[j] * pc_z[j] * fl1_fx * pb_y[j] - 2.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * fl2_fx * pb_yz[j] - 0.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xx[j] * fl1_fx * pb_yz[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_y[j] * pc_z[j] - 0.5 * fl1_fx * pa_zz[j] * pc_y[j] * pb_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_yz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_yz[j] - pa_xxzz[j] * pb_y[j] * pc_z[j] - pa_xxzz[j] * pc_y[j] * pb_z[j] - 2.0 * pa_xxz[j] * pc_z[j] * pb_yz[j] - 2.0 * pa_xzz[j] * pc_x[j] * pb_yz[j]);

                t_xxzz_yz[j] += fl_s_0_0_2 * (fl2_fx * pa_z[j] * pc_y[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + pa_xxz[j] * fl1_fx * pc_y[j] + 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx + 1.5 * pa_xx[j] * pc_z[j] * fl1_fx * pb_y[j] + 2.0 * pa_xz[j] * pc_xy[j] * fl1_fx + 2.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_y[j] + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + pc_xx[j] * pa_z[j] * fl1_fx * pb_y[j] + 0.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_xx[j] * fl1_fx * pc_y[j] * pb_z[j] + pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_yz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_zz[j] * pc_yz[j] + fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] + fl1_fx * pa_z[j] * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_yz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_y[j] * pc_z[j] + 0.5 * fl1_fx * pa_zz[j] * pc_y[j] * pb_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_yz[j] + pa_xxzz[j] * pc_yz[j] + 2.0 * pa_xxz[j] * pc_zz[j] * pb_y[j] + 2.0 * pa_xxz[j] * pc_yz[j] * pb_z[j] + pa_xx[j] * pc_zz[j] * pb_yz[j] + 2.0 * pa_xzz[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xzz[j] * pc_xy[j] * pb_z[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_yz[j] + pc_xx[j] * pa_zz[j] * pb_yz[j]);

                t_xxzz_yz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.5 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_xx[j] * pc_yz[j] * fl1_fx - 2.0 * pa_xz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - pc_xxy[j] * pa_z[j] * fl1_fx - pc_xx[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_xxz[j] * fl1_fx * pb_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_z[j] - pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_yz[j] - fl1_fx * pa_z[j] * pc_yzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_zz[j] * pc_yz[j] - fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] - fl1_fx * pa_z[j] * pc_yz[j] * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_yz[j] - 2.0 * pa_xxz[j] * pc_yzz[j] - pa_xx[j] * pc_zzz[j] * pb_y[j] - pa_xx[j] * pc_yzz[j] * pb_z[j] - 2.0 * pa_xzz[j] * pc_xyz[j] - 4.0 * pa_xz[j] * pc_xzz[j] * pb_y[j] - 4.0 * pa_xz[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_yz[j] - pc_xxz[j] * pa_zz[j] * pb_y[j] - pc_xxy[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_yz[j]);

                t_xxzz_yz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 3.0 * pa_x[j] * pc_xyz[j] * fl1_fx + pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xxz[j] * fl1_fx * pb_y[j] + 0.5 * pc_xxy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_yzzz[j] + fl1_fx * pa_z[j] * pc_yzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_z[j] + pa_xx[j] * pc_yzzz[j] + 4.0 * pa_xz[j] * pc_xyzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] * pb_y[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_z[j] + pc_xxyz[j] * pa_zz[j] + 2.0 * pc_xxzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_z[j] + pc_xxzz[j] * pb_yz[j]);

                t_xxzz_yz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yzzz[j] - 2.0 * pa_x[j] * pc_xyzzz[j] - 2.0 * pc_xxyzz[j] * pa_z[j] - pc_xxzzz[j] * pb_y[j] - pc_xxyzz[j] * pb_z[j]);

                t_xxzz_yz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_35_36(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (35,36)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xx = paDistances.data(34 * idx + 3);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xxz = paDistances.data(34 * idx + 11);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xxzz = paDistances.data(34 * idx + 24);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxzzzz = pcDistances.data(83 * idx + 69);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xxzz_zz = primBuffer.data(90 * idx + 35);

            // Batch of Integrals (35,36)

            #pragma omp simd aligned(fx, pa_x, pa_xx, pa_xxz, pa_xxzz, pa_xz, pa_xzz, pa_z, pa_zz, pb_z, pb_zz, pc_x, \
                                     pc_xx, pc_xxz, pc_xxzz, pc_xxzzz, pc_xxzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xxzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xxzz_zz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 0.25 * fl2_fx * pa_zz[j] + fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xxzz[j] * fl1_fx + 2.0 * pa_xxz[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_zz[j] + pa_xxzz[j] * pb_zz[j]);

                t_xxzz_zz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_xx[j] * fl2_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 0.5 * fl2_fx * pa_zz[j] - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 2.0 * fl2_fx * pa_z[j] * pb_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * pa_xxzz[j] * fl1_fx - 3.0 * pa_xxz[j] * pc_z[j] * fl1_fx - 2.0 * pa_xxz[j] * fl1_fx * pb_z[j] - 3.0 * pa_xx[j] * pc_z[j] * fl1_fx * pb_z[j] - pa_xzz[j] * pc_x[j] * fl1_fx - 4.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_xx[j] * fl1_fx * pb_zz[j] - pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] - fl1_fx * pa_zz[j] * pb_z[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_zz[j] - 2.0 * pa_xxzz[j] * pb_z[j] * pc_z[j] - 2.0 * pa_xxz[j] * pc_z[j] * pb_zz[j] - 2.0 * pa_xzz[j] * pc_x[j] * pb_zz[j]);

                t_xxzz_zz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_x[j] * fl2_fx + 0.75 * pc_xx[j] * fl2_fx + 3.0 * fl2_fx * pa_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pc_z[j] * pb_z[j] + 0.25 * fl2_fx * pa_zz[j] + fl2_fx * pa_z[j] * pb_z[j] + 3.0 * pa_xxz[j] * pc_z[j] * fl1_fx + 3.0 * pa_xx[j] * pc_zz[j] * fl1_fx + 3.0 * pa_xx[j] * pc_z[j] * fl1_fx * pb_z[j] + pa_xzz[j] * pc_x[j] * fl1_fx + 6.0 * pa_xz[j] * pc_xz[j] * fl1_fx + 4.0 * pa_xz[j] * pc_x[j] * fl1_fx * pb_z[j] + 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xx[j] * pa_zz[j] * fl1_fx + 2.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_zz[j] + pa_x[j] * pc_x[j] * fl1_fx * pb_zz[j] + 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pa_zz[j] * pc_zz[j] + 2.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_zz[j] + fl1_fx * pa_zz[j] * pb_z[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_zz[j] + pa_xxzz[j] * pc_zz[j] + 4.0 * pa_xxz[j] * pc_zz[j] * pb_z[j] + pa_xx[j] * pc_zz[j] * pb_zz[j] + 4.0 * pa_xzz[j] * pc_xz[j] * pb_z[j] + 4.0 * pa_xz[j] * pc_xz[j] * pb_zz[j] + pc_xx[j] * pa_zz[j] * pb_zz[j]);

                t_xxzz_zz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_x[j] * pc_x[j] * fl2_fx - 1.5 * pc_xx[j] * fl2_fx - 3.0 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_z[j] - 3.0 * pa_xx[j] * pc_zz[j] * fl1_fx - 6.0 * pa_xz[j] * pc_xz[j] * fl1_fx - 6.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 6.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * pa_zz[j] * fl1_fx - 3.0 * pc_xxz[j] * pa_z[j] * fl1_fx - 2.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * fl1_fx * pb_zz[j] - fl1_fx * pa_z[j] * pc_zzz[j] - fl1_fx * pc_zzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_zz[j] * pc_zz[j] - 2.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_zz[j] - 2.0 * pa_xxz[j] * pc_zzz[j] - 2.0 * pa_xx[j] * pc_zzz[j] * pb_z[j] - 2.0 * pa_xzz[j] * pc_xzz[j] - 8.0 * pa_xz[j] * pc_xzz[j] * pb_z[j] - 2.0 * pa_x[j] * pc_xzz[j] * pb_zz[j] - 2.0 * pc_xxz[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_xxz[j] * pa_z[j] * pb_zz[j]);

                t_xxzz_zz[j] += fl_s_0_0_4 * (0.75 * pc_xx[j] * fl2_fx + 1.5 * fl2_fx * pc_zz[j] + 6.0 * pa_x[j] * pc_xzz[j] * fl1_fx + 3.0 * pc_xxz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_zzzz[j] + fl1_fx * pa_z[j] * pc_zzz[j] + fl1_fx * pc_zzz[j] * pb_z[j] + pa_xx[j] * pc_zzzz[j] + 4.0 * pa_xz[j] * pc_xzzz[j] + 4.0 * pa_x[j] * pc_xzzz[j] * pb_z[j] + pc_xxzz[j] * pa_zz[j] + 4.0 * pc_xxzz[j] * pa_z[j] * pb_z[j] + pc_xxzz[j] * pb_zz[j]);

                t_xxzz_zz[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - 2.0 * pa_x[j] * pc_xzzzz[j] - 2.0 * pc_xxzzz[j] * pa_z[j] - 2.0 * pc_xxzzz[j] * pb_z[j]);

                t_xxzz_zz[j] += fl_s_0_0_6 * pc_xxzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_36_37(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (36,37)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyy = paDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyy = pcDistances.data(83 * idx + 61);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyy_xx = primBuffer.data(90 * idx + 36);

            // Batch of Integrals (36,37)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyy, pa_y, pa_yy, pa_yyy, pb_x, pb_xx, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyy, pc_xxy, pc_xxyy, pc_xxyyy, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_y, pc_yy, pc_yyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xyyy_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyy_xx[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xyyy[j] * fl1_fx + fl1_fx * pa_yyy[j] * pb_x[j] + 1.5 * pa_xy[j] * fl1_fx * pb_xx[j] + pa_xyyy[j] * pb_xx[j]);

                t_xyyy_xx[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - 2.25 * pc_x[j] * pa_y[j] * fl2_fx - 3.0 * fl2_fx * pa_y[j] * pb_x[j] - 1.5 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xyyy[j] * fl1_fx - 1.5 * pa_xyy[j] * pc_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_yyy[j] * fl1_fx - 3.0 * fl1_fx * pa_yy[j] * pc_y[j] * pb_x[j] - fl1_fx * pa_yyy[j] * pb_x[j] - 3.0 * pa_xy[j] * fl1_fx * pb_x[j] * pc_x[j] - 1.5 * pa_xy[j] * fl1_fx * pb_xx[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xyyy[j] * pb_x[j] * pc_x[j] - 3.0 * pa_xyy[j] * pc_y[j] * pb_xx[j] - pc_x[j] * pa_yyy[j] * pb_xx[j]);

                t_xyyy_xx[j] += fl_s_0_0_2 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 4.5 * pc_x[j] * pa_y[j] * fl2_fx + 2.25 * pc_xy[j] * fl2_fx + 3.0 * fl2_fx * pc_y[j] * pb_x[j] + 1.5 * fl2_fx * pa_y[j] * pb_x[j] + 1.5 * pa_xyy[j] * pc_y[j] * fl1_fx + 1.5 * pa_xy[j] * pc_yy[j] * fl1_fx + 1.5 * pc_x[j] * pa_yyy[j] * fl1_fx + 4.5 * pc_xy[j] * pa_yy[j] * fl1_fx + 3.0 * fl1_fx * pa_y[j] * pc_yy[j] * pb_x[j] + 3.0 * fl1_fx * pa_yy[j] * pc_y[j] * pb_x[j] + 1.5 * pa_xy[j] * fl1_fx * pc_xx[j] + 3.0 * pa_xy[j] * fl1_fx * pb_x[j] * pc_x[j] + 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xx[j] + 3.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xx[j] + 1.5 * pc_xy[j] * fl1_fx * pb_xx[j] + pa_xyyy[j] * pc_xx[j] + 6.0 * pa_xyy[j] * pc_xy[j] * pb_x[j] + 3.0 * pa_xy[j] * pc_yy[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_yyy[j] * pb_x[j] + 3.0 * pc_xy[j] * pa_yy[j] * pb_xx[j]);

                t_xyyy_xx[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 2.25 * pc_x[j] * pa_y[j] * fl2_fx - 4.5 * pc_xy[j] * fl2_fx - 1.5 * fl2_fx * pc_y[j] * pb_x[j] - 1.5 * pa_xy[j] * pc_yy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx - 4.5 * pc_xy[j] * pa_yy[j] * fl1_fx - 4.5 * pc_xyy[j] * pa_y[j] * fl1_fx - fl1_fx * pc_yyy[j] * pb_x[j] - 3.0 * fl1_fx * pa_y[j] * pc_yy[j] * pb_x[j] - 1.5 * pa_xy[j] * fl1_fx * pc_xx[j] - 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxx[j] * pa_y[j] * fl1_fx - 3.0 * pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] - 3.0 * pc_xxy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xx[j] - 3.0 * pa_xyy[j] * pc_xxy[j] - 6.0 * pa_xy[j] * pc_xyy[j] * pb_x[j] - pa_x[j] * pc_yyy[j] * pb_xx[j] - pc_xxx[j] * pa_yyy[j] - 6.0 * pc_xxy[j] * pa_yy[j] * pb_x[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_xx[j]);

                t_xyyy_xx[j] += fl_s_0_0_4 * (2.25 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx + 4.5 * pc_xyy[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyyy[j] * fl1_fx + fl1_fx * pc_yyy[j] * pb_x[j] + 1.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 1.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxxy[j] * fl1_fx + 3.0 * pc_xxy[j] * fl1_fx * pb_x[j] + 3.0 * pa_xy[j] * pc_xxyy[j] + 2.0 * pa_x[j] * pc_xyyy[j] * pb_x[j] + 3.0 * pc_xxxy[j] * pa_yy[j] + 6.0 * pc_xxyy[j] * pa_y[j] * pb_x[j] + pc_xyyy[j] * pb_xx[j]);

                t_xyyy_xx[j] += fl_s_0_0_5 * (-1.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xxxy[j] * fl1_fx - pa_x[j] * pc_xxyyy[j] - 3.0 * pc_xxxyy[j] * pa_y[j] - 2.0 * pc_xxyyy[j] * pb_x[j]);

                t_xyyy_xx[j] += fl_s_0_0_6 * pc_xxxyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_37_38(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (37,38)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyy = paDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyy = pcDistances.data(83 * idx + 65);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyy_xy = primBuffer.data(90 * idx + 37);

            // Batch of Integrals (37,38)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyy, pa_y, pa_yy, pa_yyy, pb_x, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xyyy_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xyyy_xy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * fl2_fx * pa_yy[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 1.5 * pa_xyy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yyy[j] * pb_y[j] + 1.5 * pa_xy[j] * fl1_fx * pb_xy[j] + pa_xyyy[j] * pb_xy[j]);

                t_xyyy_xy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * fl2_fx * pa_yy[j] - 2.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_y[j] - 1.5 * pa_xyy[j] * fl1_fx * pc_x[j] - 1.5 * pa_xyy[j] * fl1_fx * pb_x[j] - 4.5 * pa_xy[j] * pc_y[j] * fl1_fx * pb_x[j] - 1.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_yyy[j] * pc_y[j] - 1.5 * fl1_fx * pa_yy[j] * pc_y[j] * pb_y[j] - 0.5 * fl1_fx * pa_yyy[j] * pb_y[j] - 1.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_y[j] - 1.5 * pa_xy[j] * fl1_fx * pb_xy[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xy[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xy[j] - pa_xyyy[j] * pb_x[j] * pc_y[j] - pa_xyyy[j] * pc_x[j] * pb_y[j] - 3.0 * pa_xyy[j] * pc_y[j] * pb_xy[j] - pc_x[j] * pa_yyy[j] * pb_xy[j]);

                t_xyyy_xy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 4.5 * fl2_fx * pa_y[j] * pc_y[j] + 1.5 * fl2_fx * pc_yy[j] + 0.75 * fl2_fx * pa_yy[j] + 1.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * pc_xx[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_x[j] + 1.5 * fl2_fx * pc_y[j] * pb_y[j] + 0.75 * fl2_fx * pa_y[j] * pb_y[j] + 1.5 * pa_xyy[j] * fl1_fx * pc_x[j] + 4.5 * pa_xy[j] * pc_xy[j] * fl1_fx + 4.5 * pa_xy[j] * pc_y[j] * fl1_fx * pb_x[j] + 3.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_x[j] + 1.5 * pc_xx[j] * pa_yy[j] * fl1_fx + 1.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_x[j] + 4.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_x[j] + 1.5 * fl1_fx * pa_yy[j] * pc_yy[j] + 1.5 * fl1_fx * pa_y[j] * pc_yy[j] * pb_y[j] + 0.5 * fl1_fx * pa_yyy[j] * pc_y[j] + 1.5 * fl1_fx * pa_yy[j] * pc_y[j] * pb_y[j] + 1.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xy[j] + 1.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xy[j] + 1.5 * pc_xy[j] * fl1_fx * pb_xy[j] + pa_xyyy[j] * pc_xy[j] + 3.0 * pa_xyy[j] * pc_yy[j] * pb_x[j] + 3.0 * pa_xyy[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_xy[j] * pc_yy[j] * pb_xy[j] + pc_xy[j] * pa_yyy[j] * pb_x[j] + pc_xx[j] * pa_yyy[j] * pb_y[j] + 3.0 * pc_xy[j] * pa_yy[j] * pb_xy[j]);

                t_xyyy_xy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * fl2_fx * pc_yy[j] - 2.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 1.5 * pc_xx[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pc_y[j] * pb_y[j] - 4.5 * pa_xy[j] * pc_xy[j] * fl1_fx - 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx - 3.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_x[j] - 1.5 * pc_xx[j] * pa_yy[j] * fl1_fx - 4.5 * pc_xxy[j] * pa_y[j] * fl1_fx - 4.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyy[j] * fl1_fx * pb_x[j] - 1.5 * fl1_fx * pa_y[j] * pc_yyy[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_y[j] - 1.5 * fl1_fx * pa_yy[j] * pc_yy[j] - 1.5 * fl1_fx * pa_y[j] * pc_yy[j] * pb_y[j] - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] - 1.5 * pc_xxy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xy[j] - 3.0 * pa_xyy[j] * pc_xyy[j] - 3.0 * pa_xy[j] * pc_yyy[j] * pb_x[j] - 3.0 * pa_xy[j] * pc_xyy[j] * pb_y[j] - pa_x[j] * pc_yyy[j] * pb_xy[j] - pc_xxy[j] * pa_yyy[j] - 3.0 * pc_xyy[j] * pa_yy[j] * pb_x[j] - 3.0 * pc_xxy[j] * pa_yy[j] * pb_y[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_xy[j]);

                t_xyyy_xy[j] += fl_s_0_0_4 * (1.5 * fl2_fx * pc_yy[j] + 0.75 * pc_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_xyy[j] * fl1_fx + 4.5 * pc_xxy[j] * pa_y[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_yyyy[j] + 1.5 * fl1_fx * pa_y[j] * pc_yyy[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_y[j] + 1.5 * pc_xxy[j] * fl1_fx * pb_y[j] + 3.0 * pa_xy[j] * pc_xyyy[j] + pa_x[j] * pc_yyyy[j] * pb_x[j] + pa_x[j] * pc_xyyy[j] * pb_y[j] + 3.0 * pc_xxyy[j] * pa_yy[j] + 3.0 * pc_xyyy[j] * pa_y[j] * pb_x[j] + 3.0 * pc_xxyy[j] * pa_y[j] * pb_y[j] + pc_xyyy[j] * pb_xy[j]);

                t_xyyy_xy[j] += fl_s_0_0_5 * (-3.0 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyy[j] - pa_x[j] * pc_xyyyy[j] - 3.0 * pc_xxyyy[j] * pa_y[j] - pc_xyyyy[j] * pb_x[j] - pc_xxyyy[j] * pb_y[j]);

                t_xyyy_xy[j] += fl_s_0_0_6 * pc_xxyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_38_39(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (38,39)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyy = paDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyy_xz = primBuffer.data(90 * idx + 38);

            // Batch of Integrals (38,39)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyy, pa_y, pa_yy, pa_yyy, pb_x, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyz, \
                                     pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xyyy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyy_xz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_y[j] * pb_z[j] + 0.5 * fl1_fx * pa_yyy[j] * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pb_xz[j] + pa_xyyy[j] * pb_xz[j]);

                t_xyyy_xz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_y[j] * pc_z[j] - 1.5 * fl2_fx * pa_y[j] * pb_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_yyy[j] * pc_z[j] - 1.5 * fl1_fx * pa_yy[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_yyy[j] * pb_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_z[j] - 1.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_xz[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xz[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xz[j] - pa_xyyy[j] * pb_x[j] * pc_z[j] - pa_xyyy[j] * pc_x[j] * pb_z[j] - 3.0 * pa_xyy[j] * pc_y[j] * pb_xz[j] - pc_x[j] * pa_yyy[j] * pb_xz[j]);

                t_xyyy_xz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_y[j] * pc_z[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pa_y[j] * pb_z[j] + 1.5 * fl1_fx * pa_yy[j] * pc_yz[j] + 1.5 * fl1_fx * pa_y[j] * pc_yy[j] * pb_z[j] + 0.5 * fl1_fx * pa_yyy[j] * pc_z[j] + 1.5 * fl1_fx * pa_yy[j] * pc_y[j] * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pc_xz[j] + 1.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_z[j] + 1.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xz[j] + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_x[j] + 1.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xz[j] + 1.5 * pc_xy[j] * fl1_fx * pb_xz[j] + pa_xyyy[j] * pc_xz[j] + 3.0 * pa_xyy[j] * pc_yz[j] * pb_x[j] + 3.0 * pa_xyy[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_xy[j] * pc_yy[j] * pb_xz[j] + pc_xz[j] * pa_yyy[j] * pb_x[j] + pc_xx[j] * pa_yyy[j] * pb_z[j] + 3.0 * pc_xy[j] * pa_yy[j] * pb_xz[j]);

                t_xyyy_xz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * fl1_fx * pa_y[j] * pc_yyz[j] - 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] - 1.5 * fl1_fx * pa_yy[j] * pc_yz[j] - 1.5 * fl1_fx * pa_y[j] * pc_yy[j] * pb_z[j] - 1.5 * pa_xy[j] * fl1_fx * pc_xz[j] - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_x[j] - 1.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_xz[j] - 3.0 * pa_xyy[j] * pc_xyz[j] - 3.0 * pa_xy[j] * pc_yyz[j] * pb_x[j] - 3.0 * pa_xy[j] * pc_xyy[j] * pb_z[j] - pa_x[j] * pc_yyy[j] * pb_xz[j] - pc_xxz[j] * pa_yyy[j] - 3.0 * pc_xyz[j] * pa_yy[j] * pb_x[j] - 3.0 * pc_xxy[j] * pa_yy[j] * pb_z[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_xz[j]);

                t_xyyy_xz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 0.5 * fl1_fx * pc_yyyz[j] + 1.5 * fl1_fx * pa_y[j] * pc_yyz[j] + 0.5 * fl1_fx * pc_yyy[j] * pb_z[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xxy[j] * fl1_fx * pb_z[j] + 3.0 * pa_xy[j] * pc_xyyz[j] + pa_x[j] * pc_yyyz[j] * pb_x[j] + pa_x[j] * pc_xyyy[j] * pb_z[j] + 3.0 * pc_xxyz[j] * pa_yy[j] + 3.0 * pc_xyyz[j] * pa_y[j] * pb_x[j] + 3.0 * pc_xxyy[j] * pa_y[j] * pb_z[j] + pc_xyyy[j] * pb_xz[j]);

                t_xyyy_xz[j] += fl_s_0_0_5 * (-0.5 * fl1_fx * pc_yyyz[j] - 1.5 * pc_xxyz[j] * fl1_fx - pa_x[j] * pc_xyyyz[j] - 3.0 * pc_xxyyz[j] * pa_y[j] - pc_xyyyz[j] * pb_x[j] - pc_xxyyy[j] * pb_z[j]);

                t_xyyy_xz[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_39_40(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (39,40)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyy = paDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyy = pcDistances.data(83 * idx + 70);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyy_yy = primBuffer.data(90 * idx + 39);

            // Batch of Integrals (39,40)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyy, pa_y, pa_yy, pa_yyy, pb_y, pb_yy, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyyy, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyyy_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyy_yy[j] = fl_s_0_0_0 * (2.25 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xyyy[j] * fl1_fx + 3.0 * pa_xyy[j] * fl1_fx * pb_y[j] + 1.5 * pa_xy[j] * fl1_fx * pb_yy[j] + pa_xyyy[j] * pb_yy[j]);

                t_xyyy_yy[j] += fl_s_0_0_1 * (-4.5 * pa_xy[j] * fl2_fx - 3.75 * pa_x[j] * pc_y[j] * fl2_fx - 2.25 * pc_x[j] * pa_y[j] * fl2_fx - 3.0 * pa_x[j] * fl2_fx * pb_y[j] - 1.5 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xyyy[j] * fl1_fx - 4.5 * pa_xyy[j] * pc_y[j] * fl1_fx - 3.0 * pa_xyy[j] * fl1_fx * pb_y[j] - 9.0 * pa_xy[j] * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * pa_yyy[j] * fl1_fx - 3.0 * pc_x[j] * pa_yy[j] * fl1_fx * pb_y[j] - 1.5 * pa_xy[j] * fl1_fx * pb_yy[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xyyy[j] * pb_y[j] * pc_y[j] - 3.0 * pa_xyy[j] * pc_y[j] * pb_yy[j] - pc_x[j] * pa_yyy[j] * pb_yy[j]);

                t_xyyy_yy[j] += fl_s_0_0_2 * (2.25 * pa_xy[j] * fl2_fx + 7.5 * pa_x[j] * pc_y[j] * fl2_fx + 4.5 * pc_x[j] * pa_y[j] * fl2_fx + 3.75 * pc_xy[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_y[j] + 3.0 * pc_x[j] * fl2_fx * pb_y[j] + 4.5 * pa_xyy[j] * pc_y[j] * fl1_fx + 9.0 * pa_xy[j] * pc_yy[j] * fl1_fx + 9.0 * pa_xy[j] * pc_y[j] * fl1_fx * pb_y[j] + 6.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * pa_yyy[j] * fl1_fx + 4.5 * pc_xy[j] * pa_yy[j] * fl1_fx + 3.0 * pc_x[j] * pa_yy[j] * fl1_fx * pb_y[j] + 9.0 * pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yy[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yy[j] + 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] + pa_xyyy[j] * pc_yy[j] + 6.0 * pa_xyy[j] * pc_yy[j] * pb_y[j] + 3.0 * pa_xy[j] * pc_yy[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_yyy[j] * pb_y[j] + 3.0 * pc_xy[j] * pa_yy[j] * pb_yy[j]);

                t_xyyy_yy[j] += fl_s_0_0_3 * (-3.75 * pa_x[j] * pc_y[j] * fl2_fx - 2.25 * pc_x[j] * pa_y[j] * fl2_fx - 7.5 * pc_xy[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_y[j] - 9.0 * pa_xy[j] * pc_yy[j] * fl1_fx - 5.0 * pa_x[j] * pc_yyy[j] * fl1_fx - 6.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] - 4.5 * pc_xy[j] * pa_yy[j] * fl1_fx - 9.0 * pc_xyy[j] * pa_y[j] * fl1_fx - 9.0 * pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] - 6.0 * pc_xyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yy[j] - 3.0 * pa_xyy[j] * pc_yyy[j] - 6.0 * pa_xy[j] * pc_yyy[j] * pb_y[j] - pa_x[j] * pc_yyy[j] * pb_yy[j] - pc_xyy[j] * pa_yyy[j] - 6.0 * pc_xyy[j] * pa_yy[j] * pb_y[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_yy[j]);

                t_xyyy_yy[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 5.0 * pa_x[j] * pc_yyy[j] * fl1_fx + 9.0 * pc_xyy[j] * pa_y[j] * fl1_fx + 5.0 * pc_xyyy[j] * fl1_fx + 6.0 * pc_xyy[j] * fl1_fx * pb_y[j] + 3.0 * pa_xy[j] * pc_yyyy[j] + 2.0 * pa_x[j] * pc_yyyy[j] * pb_y[j] + 3.0 * pc_xyyy[j] * pa_yy[j] + 6.0 * pc_xyyy[j] * pa_y[j] * pb_y[j] + pc_xyyy[j] * pb_yy[j]);

                t_xyyy_yy[j] += fl_s_0_0_5 * (-5.0 * pc_xyyy[j] * fl1_fx - pa_x[j] * pc_yyyyy[j] - 3.0 * pc_xyyyy[j] * pa_y[j] - 2.0 * pc_xyyyy[j] * pb_y[j]);

                t_xyyy_yy[j] += fl_s_0_0_6 * pc_xyyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_40_41(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (40,41)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyy = paDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyy_yz = primBuffer.data(90 * idx + 40);

            // Batch of Integrals (40,41)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyy, pa_y, pa_yy, pa_yyy, pb_y, pb_yz, pb_z, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyyy_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyy_yz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xyy[j] * fl1_fx * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pb_yz[j] + pa_xyyy[j] * pb_yz[j]);

                t_xyyy_yz[j] += fl_s_0_0_1 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pa_x[j] * fl2_fx * pb_z[j] - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xyy[j] * fl1_fx * pc_z[j] - 1.5 * pa_xyy[j] * fl1_fx * pb_z[j] - 4.5 * pa_xy[j] * pc_y[j] * fl1_fx * pb_z[j] - 1.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_y[j] * pc_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_yz[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yz[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yz[j] - pa_xyyy[j] * pb_y[j] * pc_z[j] - pa_xyyy[j] * pc_y[j] * pb_z[j] - 3.0 * pa_xyy[j] * pc_y[j] * pb_yz[j] - pc_x[j] * pa_yyy[j] * pb_yz[j]);

                t_xyyy_yz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_x[j] * fl2_fx * pb_z[j] + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xyy[j] * fl1_fx * pc_z[j] + 4.5 * pa_xy[j] * pc_yz[j] * fl1_fx + 4.5 * pa_xy[j] * pc_y[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] + 1.5 * pc_xz[j] * pa_yy[j] * fl1_fx + 1.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_z[j] + 4.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pa_xy[j] * fl1_fx * pb_y[j] * pc_z[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xy[j] * fl1_fx * pb_yz[j] + pa_xyyy[j] * pc_yz[j] + 3.0 * pa_xyy[j] * pc_yz[j] * pb_y[j] + 3.0 * pa_xyy[j] * pc_yy[j] * pb_z[j] + 3.0 * pa_xy[j] * pc_yy[j] * pb_yz[j] + pc_xz[j] * pa_yyy[j] * pb_y[j] + pc_xy[j] * pa_yyy[j] * pb_z[j] + 3.0 * pc_xy[j] * pa_yy[j] * pb_yz[j]);

                t_xyyy_yz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_z[j] - 4.5 * pa_xy[j] * pc_yz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * pa_yy[j] * fl1_fx - 4.5 * pc_xyz[j] * pa_y[j] * fl1_fx - 4.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] - 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pb_yz[j] - 3.0 * pa_xyy[j] * pc_yyz[j] - 3.0 * pa_xy[j] * pc_yyz[j] * pb_y[j] - 3.0 * pa_xy[j] * pc_yyy[j] * pb_z[j] - pa_x[j] * pc_yyy[j] * pb_yz[j] - pc_xyz[j] * pa_yyy[j] - 3.0 * pc_xyz[j] * pa_yy[j] * pb_y[j] - 3.0 * pc_xyy[j] * pa_yy[j] * pb_z[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_yz[j]);

                t_xyyy_yz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx + 4.5 * pc_xyz[j] * pa_y[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_xy[j] * pc_yyyz[j] + pa_x[j] * pc_yyyz[j] * pb_y[j] + pa_x[j] * pc_yyyy[j] * pb_z[j] + 3.0 * pc_xyyz[j] * pa_yy[j] + 3.0 * pc_xyyz[j] * pa_y[j] * pb_y[j] + 3.0 * pc_xyyy[j] * pa_y[j] * pb_z[j] + pc_xyyy[j] * pb_yz[j]);

                t_xyyy_yz[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - pa_x[j] * pc_yyyyz[j] - 3.0 * pc_xyyyz[j] * pa_y[j] - pc_xyyyz[j] * pb_y[j] - pc_xyyyy[j] * pb_z[j]);

                t_xyyy_yz[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_41_42(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (41,42)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyy = paDistances.data(34 * idx + 25);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyy_zz = primBuffer.data(90 * idx + 41);

            // Batch of Integrals (41,42)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyy, pa_y, pa_yy, pa_yyy, pb_z, pb_zz, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, \
                                     pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyyy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyy_zz[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 0.5 * pa_xyyy[j] * fl1_fx + 1.5 * pa_xy[j] * fl1_fx * pb_zz[j] + pa_xyyy[j] * pb_zz[j]);

                t_xyyy_zz[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 0.5 * pa_xyyy[j] * fl1_fx - 1.5 * pa_xyy[j] * pc_y[j] * fl1_fx - 0.5 * pc_x[j] * pa_yyy[j] * fl1_fx - 3.0 * pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] - 1.5 * pa_xy[j] * fl1_fx * pb_zz[j] - 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xyyy[j] * pb_z[j] * pc_z[j] - 3.0 * pa_xyy[j] * pc_y[j] * pb_zz[j] - pc_x[j] * pa_yyy[j] * pb_zz[j]);

                t_xyyy_zz[j] += fl_s_0_0_2 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_xyy[j] * pc_y[j] * fl1_fx + 1.5 * pa_xy[j] * pc_yy[j] * fl1_fx + 0.5 * pc_x[j] * pa_yyy[j] * fl1_fx + 1.5 * pc_xy[j] * pa_yy[j] * fl1_fx + 1.5 * pa_xy[j] * fl1_fx * pc_zz[j] + 3.0 * pa_xy[j] * fl1_fx * pb_z[j] * pc_z[j] + 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] + 3.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] + 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] + pa_xyyy[j] * pc_zz[j] + 6.0 * pa_xyy[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_xy[j] * pc_yy[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_yyy[j] * pb_z[j] + 3.0 * pc_xy[j] * pa_yy[j] * pb_zz[j]);

                t_xyyy_zz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 1.5 * pa_xy[j] * pc_yy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx - 1.5 * pc_xy[j] * pa_yy[j] * fl1_fx - 1.5 * pc_xyy[j] * pa_y[j] * fl1_fx - 1.5 * pa_xy[j] * fl1_fx * pc_zz[j] - 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xzz[j] * pa_y[j] * fl1_fx - 3.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pb_zz[j] - 3.0 * pa_xyy[j] * pc_yzz[j] - 6.0 * pa_xy[j] * pc_yyz[j] * pb_z[j] - pa_x[j] * pc_yyy[j] * pb_zz[j] - pc_xzz[j] * pa_yyy[j] - 6.0 * pc_xyz[j] * pa_yy[j] * pb_z[j] - 3.0 * pc_xyy[j] * pa_y[j] * pb_zz[j]);

                t_xyyy_zz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 1.5 * pc_xzz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xy[j] * pc_yyzz[j] + 2.0 * pa_x[j] * pc_yyyz[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pa_yy[j] + 6.0 * pc_xyyz[j] * pa_y[j] * pb_z[j] + pc_xyyy[j] * pb_zz[j]);

                t_xyyy_zz[j] += fl_s_0_0_5 * (-0.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yyyzz[j] - 3.0 * pc_xyyzz[j] * pa_y[j] - 2.0 * pc_xyyyz[j] * pb_z[j]);

                t_xyyy_zz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_42_43(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (42,43)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyz = paDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyy = pcDistances.data(83 * idx + 37);

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyyz = pcDistances.data(83 * idx + 62);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyz_xx = primBuffer.data(90 * idx + 42);

            // Batch of Integrals (42,43)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyz, pa_xyz, pa_xz, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, \
                                     pb_x, pb_xx, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyy, pc_xxxyyz, pc_xxxyz, pc_xxxz, \
                                     pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyz, pc_xyz, pc_xz, \
                                     pc_y, pc_yy, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xyyz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyz_xx[j] = fl_s_0_0_0 * (0.25 * pa_xz[j] * fl2_fx + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xyyz[j] * fl1_fx + fl1_fx * pa_yyz[j] * pb_x[j] + 0.5 * pa_xz[j] * fl1_fx * pb_xx[j] + pa_xyyz[j] * pb_xx[j]);

                t_xyyz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl2_fx - 0.25 * pa_x[j] * fl2_fx * pc_z[j] - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * fl2_fx * pc_z[j] * pb_x[j] - fl2_fx * pa_z[j] * pb_x[j] - 0.5 * pa_xyyz[j] * fl1_fx - 0.5 * pa_xyy[j] * pc_z[j] * fl1_fx - pa_xyz[j] * pc_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_yyz[j] * fl1_fx - fl1_fx * pa_yy[j] * pc_z[j] * pb_x[j] - 2.0 * fl1_fx * pa_yz[j] * pc_y[j] * pb_x[j] - fl1_fx * pa_yyz[j] * pb_x[j] - pa_xz[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xx[j] - 0.5 * pa_xz[j] * fl1_fx * pb_xx[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xx[j] - 2.0 * pa_xyyz[j] * pb_x[j] * pc_x[j] - pa_xyy[j] * pc_z[j] * pb_xx[j] - 2.0 * pa_xyz[j] * pc_y[j] * pb_xx[j] - pc_x[j] * pa_yyz[j] * pb_xx[j]);

                t_xyyz_xx[j] += fl_s_0_0_2 * (0.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.25 * pa_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pa_z[j] + 0.75 * pc_xz[j] * fl2_fx + fl2_fx * pc_z[j] * pb_x[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xyy[j] * pc_z[j] * fl1_fx + pa_xyz[j] * pc_y[j] * fl1_fx + pa_xy[j] * pc_yz[j] * fl1_fx + 0.5 * pa_xz[j] * pc_yy[j] * fl1_fx + 1.5 * pc_x[j] * pa_yyz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_yy[j] * fl1_fx + 3.0 * pc_xy[j] * pa_yz[j] * fl1_fx + 2.0 * fl1_fx * pa_y[j] * pc_yz[j] * pb_x[j] + fl1_fx * pc_yy[j] * pa_z[j] * pb_x[j] + fl1_fx * pa_yy[j] * pc_z[j] * pb_x[j] + 2.0 * fl1_fx * pa_yz[j] * pc_y[j] * pb_x[j] + 0.5 * pa_xz[j] * fl1_fx * pc_xx[j] + pa_x[j] * fl1_fx * pc_xz[j] * pb_x[j] + pa_xz[j] * fl1_fx * pb_x[j] * pc_x[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xx[j] + pc_xx[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * pc_xz[j] * fl1_fx * pb_xx[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xx[j] + pa_xyyz[j] * pc_xx[j] + 2.0 * pa_xyy[j] * pc_xz[j] * pb_x[j] + 4.0 * pa_xyz[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_xx[j] + pa_xz[j] * pc_yy[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_yyz[j] * pb_x[j] + pc_xz[j] * pa_yy[j] * pb_xx[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_xx[j]);

                t_xyyz_xx[j] += fl_s_0_0_3 * (-0.25 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * fl2_fx * pc_z[j] * pb_x[j] - pa_xy[j] * pc_yz[j] * fl1_fx - 0.5 * pa_xz[j] * pc_yy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yyz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_yy[j] * fl1_fx - 3.0 * pc_xy[j] * pa_yz[j] * fl1_fx - 3.0 * pc_xyz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx - fl1_fx * pc_yyz[j] * pb_x[j] - 2.0 * fl1_fx * pa_y[j] * pc_yz[j] * pb_x[j] - fl1_fx * pc_yy[j] * pa_z[j] * pb_x[j] - 0.5 * pa_x[j] * fl1_fx * pc_xxz[j] - 0.5 * pa_xz[j] * fl1_fx * pc_xx[j] - pa_x[j] * fl1_fx * pc_xz[j] * pb_x[j] - 0.5 * pc_xxx[j] * fl1_fx * pa_z[j] - pc_xxz[j] * fl1_fx * pb_x[j] - pc_xx[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * pc_xz[j] * fl1_fx * pb_xx[j] - pa_xyy[j] * pc_xxz[j] - 2.0 * pa_xyz[j] * pc_xxy[j] - 4.0 * pa_xy[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_xz[j] * pc_xyy[j] * pb_x[j] - pa_x[j] * pc_yyz[j] * pb_xx[j] - pc_xxx[j] * pa_yyz[j] - 2.0 * pc_xxz[j] * pa_yy[j] * pb_x[j] - 4.0 * pc_xxy[j] * pa_yz[j] * pb_x[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_xx[j] - pc_xyy[j] * pa_z[j] * pb_xx[j]);

                t_xyyz_xx[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 0.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 3.0 * pc_xyz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + fl1_fx * pc_yyz[j] * pb_x[j] + 0.5 * pa_x[j] * fl1_fx * pc_xxz[j] + 0.5 * pc_xxxz[j] * fl1_fx + 0.5 * pc_xxx[j] * fl1_fx * pa_z[j] + pc_xxz[j] * fl1_fx * pb_x[j] + 2.0 * pa_xy[j] * pc_xxyz[j] + pa_xz[j] * pc_xxyy[j] + 2.0 * pa_x[j] * pc_xyyz[j] * pb_x[j] + pc_xxxz[j] * pa_yy[j] + 2.0 * pc_xxxy[j] * pa_yz[j] + 4.0 * pc_xxyz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxyy[j] * pa_z[j] * pb_x[j] + pc_xyyz[j] * pb_xx[j]);

                t_xyyz_xx[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xxxz[j] * fl1_fx - pa_x[j] * pc_xxyyz[j] - 2.0 * pc_xxxyz[j] * pa_y[j] - pc_xxxyy[j] * pa_z[j] - 2.0 * pc_xxyyz[j] * pb_x[j]);

                t_xyyz_xx[j] += fl_s_0_0_6 * pc_xxxyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_43_44(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (43,44)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyz = paDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyz_xy = primBuffer.data(90 * idx + 43);

            // Batch of Integrals (43,44)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyz, pa_xyz, pa_xz, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, \
                                     pb_x, pb_xy, pb_y, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, \
                                     pc_xxyz, pc_xxz, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xyyz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyz_xy[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_yz[j] + 0.25 * fl2_fx * pa_z[j] * pb_y[j] + pa_xyz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yyz[j] * pb_y[j] + 0.5 * pa_xz[j] * fl1_fx * pb_xy[j] + pa_xyyz[j] * pb_xy[j]);

                t_xyyz_xy[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_y[j] * pc_z[j] - fl2_fx * pa_yz[j] - 0.75 * fl2_fx * pc_y[j] * pa_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * fl2_fx * pa_z[j] * pb_y[j] - pa_xyz[j] * fl1_fx * pc_x[j] - pa_xy[j] * fl1_fx * pc_z[j] * pb_x[j] - pa_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pa_xz[j] * pc_y[j] * fl1_fx * pb_x[j] - pc_x[j] * pa_yz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_yyz[j] * pc_y[j] - 0.5 * fl1_fx * pa_yy[j] * pc_z[j] * pb_y[j] - fl1_fx * pa_yz[j] * pc_y[j] * pb_y[j] - 0.5 * fl1_fx * pa_yyz[j] * pb_y[j] - 0.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xy[j] - 0.5 * pa_xz[j] * fl1_fx * pb_xy[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xy[j] - pa_xyyz[j] * pb_x[j] * pc_y[j] - pa_xyyz[j] * pc_x[j] * pb_y[j] - pa_xyy[j] * pc_z[j] * pb_xy[j] - 2.0 * pa_xyz[j] * pc_y[j] * pb_xy[j] - pc_x[j] * pa_yyz[j] * pb_xy[j]);

                t_xyyz_xy[j] += fl_s_0_0_2 * (fl2_fx * pa_y[j] * pc_z[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_y[j] * pa_z[j] + 0.5 * fl2_fx * pa_yz[j] + 0.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.25 * fl2_fx * pa_z[j] * pb_y[j] + pa_xy[j] * fl1_fx * pc_xz[j] + pa_xyz[j] * fl1_fx * pc_x[j] + pa_xy[j] * fl1_fx * pc_z[j] * pb_x[j] + 1.5 * pa_xz[j] * pc_xy[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pa_xz[j] * pc_y[j] * fl1_fx * pb_x[j] + pc_xx[j] * pa_yz[j] * fl1_fx + pc_xz[j] * pa_y[j] * fl1_fx * pb_x[j] + pc_x[j] * pa_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pa_yy[j] * pc_yz[j] + fl1_fx * pa_yz[j] * pc_yy[j] + fl1_fx * pa_y[j] * pc_yz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pa_yyz[j] * pc_y[j] + 0.5 * fl1_fx * pa_yy[j] * pc_z[j] * pb_y[j] + fl1_fx * pa_yz[j] * pc_y[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_xz[j] * pb_y[j] + 0.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xy[j] + 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_y[j] + 0.5 * pc_xz[j] * fl1_fx * pb_xy[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xy[j] + pa_xyyz[j] * pc_xy[j] + pa_xyy[j] * pc_yz[j] * pb_x[j] + pa_xyy[j] * pc_xz[j] * pb_y[j] + 2.0 * pa_xyz[j] * pc_yy[j] * pb_x[j] + 2.0 * pa_xyz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_xy[j] + pa_xz[j] * pc_yy[j] * pb_xy[j] + pc_xy[j] * pa_yyz[j] * pb_x[j] + pc_xx[j] * pa_yyz[j] * pb_y[j] + pc_xz[j] * pa_yy[j] * pb_xy[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_xy[j]);

                t_xyyz_xy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.5 * fl2_fx * pa_y[j] * pc_z[j] - 0.75 * fl2_fx * pc_y[j] * pa_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_y[j] - pa_xy[j] * fl1_fx * pc_xz[j] - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_xz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] - pc_xxz[j] * pa_y[j] * fl1_fx - pc_xx[j] * pa_yz[j] * fl1_fx - pc_xz[j] * pa_y[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxy[j] * fl1_fx * pa_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] - fl1_fx * pa_y[j] * pc_yyz[j] - 0.5 * fl1_fx * pc_yyy[j] * pa_z[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_y[j] - 0.5 * fl1_fx * pa_yy[j] * pc_yz[j] - fl1_fx * pa_yz[j] * pc_yy[j] - fl1_fx * pa_y[j] * pc_yz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_xz[j] * pb_y[j] - 0.5 * pc_xxz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * pc_xz[j] * fl1_fx * pb_xy[j] - pa_xyy[j] * pc_xyz[j] - 2.0 * pa_xyz[j] * pc_xyy[j] - 2.0 * pa_xy[j] * pc_yyz[j] * pb_x[j] - 2.0 * pa_xy[j] * pc_xyz[j] * pb_y[j] - pa_xz[j] * pc_yyy[j] * pb_x[j] - pa_xz[j] * pc_xyy[j] * pb_y[j] - pa_x[j] * pc_yyz[j] * pb_xy[j] - pc_xxy[j] * pa_yyz[j] - pc_xyz[j] * pa_yy[j] * pb_x[j] - pc_xxz[j] * pa_yy[j] * pb_y[j] - 2.0 * pc_xyy[j] * pa_yz[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_yz[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_xy[j] - pc_xyy[j] * pa_z[j] * pb_xy[j]);

                t_xyyz_xy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + pc_xxz[j] * pa_y[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pa_z[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_yyyz[j] + fl1_fx * pa_y[j] * pc_yyz[j] + 0.5 * fl1_fx * pc_yyy[j] * pa_z[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_y[j] + 0.5 * pc_xxz[j] * fl1_fx * pb_y[j] + 2.0 * pa_xy[j] * pc_xyyz[j] + pa_xz[j] * pc_xyyy[j] + pa_x[j] * pc_yyyz[j] * pb_x[j] + pa_x[j] * pc_xyyz[j] * pb_y[j] + pc_xxyz[j] * pa_yy[j] + 2.0 * pc_xxyy[j] * pa_yz[j] + 2.0 * pc_xyyz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_y[j] + pc_xyyy[j] * pa_z[j] * pb_x[j] + pc_xxyy[j] * pa_z[j] * pb_y[j] + pc_xyyz[j] * pb_xy[j]);

                t_xyyz_xy[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyyz[j] - pa_x[j] * pc_xyyyz[j] - 2.0 * pc_xxyyz[j] * pa_y[j] - pc_xxyyy[j] * pa_z[j] - pc_xyyyz[j] * pb_x[j] - pc_xxyyz[j] * pb_y[j]);

                t_xyyz_xy[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_44_45(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (44,45)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyz = paDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyz_xz = primBuffer.data(90 * idx + 44);

            // Batch of Integrals (44,45)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyz, pa_xyz, pa_xz, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, \
                                     pb_x, pb_xz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyyz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xyyz_xz[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * fl2_fx * pa_yy[j] + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xyy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yyz[j] * pb_z[j] + 0.5 * pa_xz[j] * fl1_fx * pb_xz[j] + pa_xyyz[j] * pb_xz[j]);

                t_xyyz_xz[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * fl2_fx * pa_yy[j] - 0.5 * fl2_fx * pa_y[j] * pc_y[j] - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.5 * pa_xyy[j] * fl1_fx * pc_x[j] - 0.5 * pa_xyy[j] * fl1_fx * pb_x[j] - pa_xy[j] * pc_y[j] * fl1_fx * pb_x[j] - 0.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_yyz[j] * pc_z[j] - 0.5 * fl1_fx * pa_yy[j] * pc_z[j] * pb_z[j] - fl1_fx * pa_yz[j] * pc_y[j] * pb_z[j] - 0.5 * fl1_fx * pa_yyz[j] * pb_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_z[j] - 0.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xz[j] - 0.5 * pa_xz[j] * fl1_fx * pb_xz[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xz[j] - pa_xyyz[j] * pb_x[j] * pc_z[j] - pa_xyyz[j] * pc_x[j] * pb_z[j] - pa_xyy[j] * pc_z[j] * pb_xz[j] - 2.0 * pa_xyz[j] * pc_y[j] * pb_xz[j] - pc_x[j] * pa_yyz[j] * pb_xz[j]);

                t_xyyz_xz[j] += fl_s_0_0_2 * (0.375 * fl3_fx + fl2_fx * pa_y[j] * pc_y[j] + 0.25 * fl2_fx * pc_yy[j] + 0.25 * fl2_fx * pa_yy[j] + 0.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.25 * pc_xx[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pc_zz[j] + 0.5 * fl2_fx * pa_z[j] * pc_z[j] + 0.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.25 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_xyy[j] * fl1_fx * pc_x[j] + pa_xy[j] * pc_xy[j] * fl1_fx + pa_xy[j] * pc_y[j] * fl1_fx * pb_x[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * pa_yy[j] * fl1_fx + 0.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_x[j] + pc_xy[j] * pa_y[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yy[j] * pc_zz[j] + fl1_fx * pa_yz[j] * pc_yz[j] + fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] + 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pa_yyz[j] * pc_z[j] + 0.5 * fl1_fx * pa_yy[j] * pc_z[j] * pb_z[j] + fl1_fx * pa_yz[j] * pc_y[j] * pb_z[j] + 0.5 * pa_xz[j] * fl1_fx * pc_xz[j] + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] + 0.5 * pa_x[j] * fl1_fx * pc_xz[j] * pb_z[j] + 0.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_z[j] + 0.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_xz[j] + 0.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_xz[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_xz[j] + pa_xyyz[j] * pc_xz[j] + pa_xyy[j] * pc_zz[j] * pb_x[j] + pa_xyy[j] * pc_xz[j] * pb_z[j] + 2.0 * pa_xyz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_xyz[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_xz[j] + pa_xz[j] * pc_yy[j] * pb_xz[j] + pc_xz[j] * pa_yyz[j] * pb_x[j] + pc_xx[j] * pa_yyz[j] * pb_z[j] + pc_xz[j] * pa_yy[j] * pb_xz[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_xz[j]);

                t_xyyz_xz[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * fl2_fx * pc_yy[j] - 0.5 * fl2_fx * pa_y[j] * pc_y[j] - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.5 * pc_xx[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pc_zz[j] - 0.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * fl2_fx * pc_z[j] * pb_z[j] - pa_xy[j] * pc_xy[j] * fl1_fx - 0.5 * pa_x[j] * pc_xyy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * pa_yy[j] * fl1_fx - pc_xxy[j] * pa_y[j] * fl1_fx - pc_xy[j] * pa_y[j] * fl1_fx * pb_x[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_x[j] - fl1_fx * pa_y[j] * pc_yzz[j] - 0.5 * fl1_fx * pc_yyz[j] * pa_z[j] - 0.5 * fl1_fx * pc_yyz[j] * pb_z[j] - 0.5 * fl1_fx * pa_yy[j] * pc_zz[j] - fl1_fx * pa_yz[j] * pc_yz[j] - fl1_fx * pa_y[j] * pc_yz[j] * pb_z[j] - 0.5 * fl1_fx * pc_yy[j] * pa_z[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_xzz[j] - 0.5 * pa_xz[j] * fl1_fx * pc_xz[j] - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] - 0.5 * pa_x[j] * fl1_fx * pc_xz[j] * pb_z[j] - 0.5 * pc_xxz[j] * fl1_fx * pa_z[j] - 0.5 * pc_xzz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_xz[j] - pa_xyy[j] * pc_xzz[j] - 2.0 * pa_xyz[j] * pc_xyz[j] - 2.0 * pa_xy[j] * pc_yzz[j] * pb_x[j] - 2.0 * pa_xy[j] * pc_xyz[j] * pb_z[j] - pa_xz[j] * pc_yyz[j] * pb_x[j] - pa_xz[j] * pc_xyy[j] * pb_z[j] - pa_x[j] * pc_yyz[j] * pb_xz[j] - pc_xxz[j] * pa_yyz[j] - pc_xzz[j] * pa_yy[j] * pb_x[j] - pc_xxz[j] * pa_yy[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_yz[j] * pb_x[j] - 2.0 * pc_xxy[j] * pa_yz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_xz[j] - pc_xyy[j] * pa_z[j] * pb_xz[j]);

                t_xyyz_xz[j] += fl_s_0_0_4 * (0.25 * fl2_fx * pc_yy[j] + 0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_zz[j] + 0.5 * pa_x[j] * pc_xyy[j] * fl1_fx + pc_xxy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_xyy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_yyzz[j] + fl1_fx * pa_y[j] * pc_yzz[j] + 0.5 * fl1_fx * pc_yyz[j] * pa_z[j] + 0.5 * fl1_fx * pc_yyz[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_xzz[j] + 0.5 * pc_xxzz[j] * fl1_fx + 0.5 * pc_xxz[j] * fl1_fx * pa_z[j] + 0.5 * pc_xzz[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxz[j] * fl1_fx * pb_z[j] + 2.0 * pa_xy[j] * pc_xyzz[j] + pa_xz[j] * pc_xyyz[j] + pa_x[j] * pc_yyzz[j] * pb_x[j] + pa_x[j] * pc_xyyz[j] * pb_z[j] + pc_xxzz[j] * pa_yy[j] + 2.0 * pc_xxyz[j] * pa_yz[j] + 2.0 * pc_xyzz[j] * pa_y[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_y[j] * pb_z[j] + pc_xyyz[j] * pa_z[j] * pb_x[j] + pc_xxyy[j] * pa_z[j] * pb_z[j] + pc_xyyz[j] * pb_xz[j]);

                t_xyyz_xz[j] += fl_s_0_0_5 * (-0.5 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - 0.5 * pc_xxzz[j] * fl1_fx - pa_x[j] * pc_xyyzz[j] - 2.0 * pc_xxyzz[j] * pa_y[j] - pc_xxyyz[j] * pa_z[j] - pc_xyyzz[j] * pb_x[j] - pc_xxyyz[j] * pb_z[j]);

                t_xyyz_xz[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_45_46(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (45,46)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyz = paDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyz_yy = primBuffer.data(90 * idx + 45);

            // Batch of Integrals (45,46)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyz, pa_xyz, pa_xz, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, \
                                     pb_y, pb_yy, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, \
                                     pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyyz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyz_yy[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 0.5 * pa_xyyz[j] * fl1_fx + 2.0 * pa_xyz[j] * fl1_fx * pb_y[j] + 0.5 * pa_xz[j] * fl1_fx * pb_yy[j] + pa_xyyz[j] * pb_yy[j]);

                t_xyyz_yy[j] += fl_s_0_0_1 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pa_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * pa_xyyz[j] * fl1_fx - 0.5 * pa_xyy[j] * pc_z[j] * fl1_fx - 3.0 * pa_xyz[j] * pc_y[j] * fl1_fx - 2.0 * pa_xy[j] * fl1_fx * pc_z[j] * pb_y[j] - 2.0 * pa_xyz[j] * fl1_fx * pb_y[j] - 3.0 * pa_xz[j] * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * pa_yyz[j] * fl1_fx - 2.0 * pc_x[j] * pa_yz[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yy[j] - 0.5 * pa_xz[j] * fl1_fx * pb_yy[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yy[j] - 2.0 * pa_xyyz[j] * pb_y[j] * pc_y[j] - pa_xyy[j] * pc_z[j] * pb_yy[j] - 2.0 * pa_xyz[j] * pc_y[j] * pb_yy[j] - pc_x[j] * pa_yyz[j] * pb_yy[j]);

                t_xyyz_yy[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.75 * pa_xz[j] * fl2_fx + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pa_z[j] + 0.5 * pa_xyy[j] * pc_z[j] * fl1_fx + 3.0 * pa_xyz[j] * pc_y[j] * fl1_fx + 3.0 * pa_xy[j] * pc_yz[j] * fl1_fx + 2.0 * pa_xy[j] * fl1_fx * pc_z[j] * pb_y[j] + 3.0 * pa_xz[j] * pc_yy[j] * fl1_fx + 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] + 3.0 * pa_xz[j] * pc_y[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * pa_yyz[j] * fl1_fx + 0.5 * pc_xz[j] * pa_yy[j] * fl1_fx + 3.0 * pc_xy[j] * pa_yz[j] * fl1_fx + 2.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] + 2.0 * pc_x[j] * pa_yz[j] * fl1_fx * pb_y[j] + 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yy[j] + 0.5 * pc_xz[j] * fl1_fx * pb_yy[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yy[j] + pa_xyyz[j] * pc_yy[j] + 2.0 * pa_xyy[j] * pc_yz[j] * pb_y[j] + 4.0 * pa_xyz[j] * pc_yy[j] * pb_y[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_yy[j] + pa_xz[j] * pc_yy[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_yyz[j] * pb_y[j] + pc_xz[j] * pa_yy[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_yy[j]);

                t_xyyz_yy[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pa_z[j] - 3.0 * pa_xy[j] * pc_yz[j] * fl1_fx - 3.0 * pa_xz[j] * pc_yy[j] * fl1_fx - 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xz[j] * pa_yy[j] * fl1_fx - 3.0 * pc_xy[j] * pa_yz[j] * fl1_fx - 3.0 * pc_xyz[j] * pa_y[j] * fl1_fx - 2.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] - 3.0 * pc_xyy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * pc_xz[j] * fl1_fx * pb_yy[j] - pa_xyy[j] * pc_yyz[j] - 2.0 * pa_xyz[j] * pc_yyy[j] - 4.0 * pa_xy[j] * pc_yyz[j] * pb_y[j] - 2.0 * pa_xz[j] * pc_yyy[j] * pb_y[j] - pa_x[j] * pc_yyz[j] * pb_yy[j] - pc_xyy[j] * pa_yyz[j] - 2.0 * pc_xyz[j] * pa_yy[j] * pb_y[j] - 4.0 * pc_xyy[j] * pa_yz[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_yy[j] - pc_xyy[j] * pa_z[j] * pb_yy[j]);

                t_xyyz_yy[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 3.0 * pa_x[j] * pc_yyz[j] * fl1_fx + 3.0 * pc_xyz[j] * pa_y[j] * fl1_fx + 3.0 * pc_xyy[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + 2.0 * pa_xy[j] * pc_yyyz[j] + pa_xz[j] * pc_yyyy[j] + 2.0 * pa_x[j] * pc_yyyz[j] * pb_y[j] + pc_xyyz[j] * pa_yy[j] + 2.0 * pc_xyyy[j] * pa_yz[j] + 4.0 * pc_xyyz[j] * pa_y[j] * pb_y[j] + 2.0 * pc_xyyy[j] * pa_z[j] * pb_y[j] + pc_xyyz[j] * pb_yy[j]);

                t_xyyz_yy[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - pa_x[j] * pc_yyyyz[j] - 2.0 * pc_xyyyz[j] * pa_y[j] - pc_xyyyy[j] * pa_z[j] - 2.0 * pc_xyyyz[j] * pb_y[j]);

                t_xyyz_yy[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_46_47(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (46,47)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyz = paDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyz_yz = primBuffer.data(90 * idx + 46);

            // Batch of Integrals (46,47)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyz, pa_xyz, pa_xz, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, \
                                     pb_y, pb_yz, pb_z, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, \
                                     pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xyyz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyz_yz[j] = fl_s_0_0_0 * (0.5 * pa_xy[j] * fl2_fx + 0.25 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xyy[j] * fl1_fx * pb_y[j] + pa_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pa_xz[j] * fl1_fx * pb_yz[j] + pa_xyyz[j] * pb_yz[j]);

                t_xyyz_yz[j] += fl_s_0_0_1 * (-pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.5 * pc_x[j] * pa_y[j] * fl2_fx - 0.5 * pa_x[j] * fl2_fx * pb_y[j] - 0.25 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xyy[j] * fl1_fx * pc_y[j] - 0.5 * pa_xyy[j] * fl1_fx * pb_y[j] - pa_xy[j] * pc_y[j] * fl1_fx * pb_y[j] - pa_xyz[j] * fl1_fx * pc_z[j] - pa_xy[j] * fl1_fx * pc_z[j] * pb_z[j] - pa_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pa_xz[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_y[j] - pc_x[j] * pa_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_xz[j] * fl1_fx * pb_y[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yz[j] - 0.5 * pa_xz[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yz[j] - pa_xyyz[j] * pb_y[j] * pc_z[j] - pa_xyyz[j] * pc_y[j] * pb_z[j] - pa_xyy[j] * pc_z[j] * pb_yz[j] - 2.0 * pa_xyz[j] * pc_y[j] * pb_yz[j] - pc_x[j] * pa_yyz[j] * pb_yz[j]);

                t_xyyz_yz[j] += fl_s_0_0_2 * (0.5 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + 0.25 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pc_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xyy[j] * fl1_fx * pc_y[j] + pa_xy[j] * pc_yy[j] * fl1_fx + pa_xy[j] * pc_y[j] * fl1_fx * pb_y[j] + pa_xy[j] * fl1_fx * pc_zz[j] + pa_xyz[j] * fl1_fx * pc_z[j] + pa_xy[j] * fl1_fx * pc_z[j] * pb_z[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] + 1.5 * pa_xz[j] * pc_yz[j] * fl1_fx + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_xz[j] * pc_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_xy[j] * pa_yy[j] * fl1_fx + 0.5 * pc_x[j] * pa_yy[j] * fl1_fx * pb_y[j] + pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] + pc_xz[j] * pa_yz[j] * fl1_fx + pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] + pc_x[j] * pa_yz[j] * fl1_fx * pb_z[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] + 0.5 * pa_xz[j] * fl1_fx * pb_y[j] * pc_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_yz[j] + 0.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] + 0.5 * pc_xz[j] * fl1_fx * pb_yz[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_yz[j] + pa_xyyz[j] * pc_yz[j] + pa_xyy[j] * pc_zz[j] * pb_y[j] + pa_xyy[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_xyz[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_xyz[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_yz[j] + pa_xz[j] * pc_yy[j] * pb_yz[j] + pc_xz[j] * pa_yyz[j] * pb_y[j] + pc_xy[j] * pa_yyz[j] * pb_z[j] + pc_xz[j] * pa_yy[j] * pb_yz[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_yz[j]);

                t_xyyz_yz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.5 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx * pb_y[j] - pa_xy[j] * pc_yy[j] * fl1_fx - pa_xy[j] * fl1_fx * pc_zz[j] - 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx - 1.5 * pa_xz[j] * pc_yz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * pa_yy[j] * fl1_fx - pc_xyy[j] * pa_y[j] * fl1_fx - pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] - pc_xzz[j] * pa_y[j] * fl1_fx - pc_xz[j] * pa_yz[j] * fl1_fx - pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] - 0.5 * pc_xzz[j] * fl1_fx * pb_y[j] - 0.5 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * pc_xz[j] * fl1_fx * pb_yz[j] - pa_xyy[j] * pc_yzz[j] - 2.0 * pa_xyz[j] * pc_yyz[j] - 2.0 * pa_xy[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_xy[j] * pc_yyz[j] * pb_z[j] - pa_xz[j] * pc_yyz[j] * pb_y[j] - pa_xz[j] * pc_yyy[j] * pb_z[j] - pa_x[j] * pc_yyz[j] * pb_yz[j] - pc_xyz[j] * pa_yyz[j] - pc_xzz[j] * pa_yy[j] * pb_y[j] - pc_xyz[j] * pa_yy[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_yz[j] * pb_y[j] - 2.0 * pc_xyy[j] * pa_yz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_yz[j] - pc_xyy[j] * pa_z[j] * pb_yz[j]);

                t_xyyz_yz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx + 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx + pc_xyy[j] * pa_y[j] * fl1_fx + pc_xzz[j] * pa_y[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + 0.5 * pc_xyy[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xzz[j] * fl1_fx * pb_y[j] + 2.0 * pa_xy[j] * pc_yyzz[j] + pa_xz[j] * pc_yyyz[j] + pa_x[j] * pc_yyzz[j] * pb_y[j] + pa_x[j] * pc_yyyz[j] * pb_z[j] + pc_xyzz[j] * pa_yy[j] + 2.0 * pc_xyyz[j] * pa_yz[j] + 2.0 * pc_xyzz[j] * pa_y[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pa_y[j] * pb_z[j] + pc_xyyz[j] * pa_z[j] * pb_y[j] + pc_xyyy[j] * pa_z[j] * pb_z[j] + pc_xyyz[j] * pb_yz[j]);

                t_xyyz_yz[j] += fl_s_0_0_5 * (-0.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yyyzz[j] - 2.0 * pc_xyyzz[j] * pa_y[j] - pc_xyyyz[j] * pa_z[j] - pc_xyyzz[j] * pb_y[j] - pc_xyyyz[j] * pb_z[j]);

                t_xyyz_yz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_47_48(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (47,48)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyy = paDistances.data(34 * idx + 12);

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyyz = paDistances.data(34 * idx + 26);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyyz_zz = primBuffer.data(90 * idx + 47);

            // Batch of Integrals (47,48)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyy, pa_xyyz, pa_xyz, pa_xz, pa_y, pa_yy, pa_yyz, pa_yz, pa_z, \
                                     pb_z, pb_zz, pc_x, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, \
                                     pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xyyz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyyz_zz[j] = fl_s_0_0_0 * (0.25 * pa_xz[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pa_xyyz[j] * fl1_fx + pa_xyy[j] * fl1_fx * pb_z[j] + 0.5 * pa_xz[j] * fl1_fx * pb_zz[j] + pa_xyyz[j] * pb_zz[j]);

                t_xyyz_zz[j] += fl_s_0_0_1 * (-0.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * fl2_fx * pc_z[j] - pa_x[j] * fl2_fx * pb_z[j] - 0.25 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * pa_xyyz[j] * fl1_fx - 1.5 * pa_xyy[j] * pc_z[j] * fl1_fx - pa_xyy[j] * fl1_fx * pb_z[j] - pa_xyz[j] * pc_y[j] * fl1_fx - 2.0 * pa_xy[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_yyz[j] * fl1_fx - pc_x[j] * pa_yy[j] * fl1_fx * pb_z[j] - pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_zz[j] - 0.5 * pa_xz[j] * fl1_fx * pb_zz[j] - 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_xyyz[j] * pb_z[j] * pc_z[j] - pa_xyy[j] * pc_z[j] * pb_zz[j] - 2.0 * pa_xyz[j] * pc_y[j] * pb_zz[j] - pc_x[j] * pa_yyz[j] * pb_zz[j]);

                t_xyyz_zz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.25 * pa_xz[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pc_x[j] * fl2_fx * pa_z[j] + 0.75 * pc_xz[j] * fl2_fx + pc_x[j] * fl2_fx * pb_z[j] + 1.5 * pa_xyy[j] * pc_z[j] * fl1_fx + pa_xyz[j] * pc_y[j] * fl1_fx + 3.0 * pa_xy[j] * pc_yz[j] * fl1_fx + 2.0 * pa_xy[j] * pc_y[j] * fl1_fx * pb_z[j] + 0.5 * pa_xz[j] * pc_yy[j] * fl1_fx + pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_yyz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_yy[j] * fl1_fx + pc_x[j] * pa_yy[j] * fl1_fx * pb_z[j] + pc_xy[j] * pa_yz[j] * fl1_fx + 2.0 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * pa_xz[j] * fl1_fx * pc_zz[j] + pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] + pa_xz[j] * fl1_fx * pb_z[j] * pc_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_z[j] * pb_zz[j] + pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * pc_xz[j] * fl1_fx * pb_zz[j] + 0.5 * pc_x[j] * fl1_fx * pa_z[j] * pb_zz[j] + pa_xyyz[j] * pc_zz[j] + 2.0 * pa_xyy[j] * pc_zz[j] * pb_z[j] + 4.0 * pa_xyz[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_xy[j] * pc_yz[j] * pb_zz[j] + pa_xz[j] * pc_yy[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_yyz[j] * pb_z[j] + pc_xz[j] * pa_yy[j] * pb_zz[j] + 2.0 * pc_xy[j] * pa_yz[j] * pb_zz[j]);

                t_xyyz_zz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * pc_x[j] * fl2_fx * pb_z[j] - 3.0 * pa_xy[j] * pc_yz[j] * fl1_fx - 0.5 * pa_xz[j] * pc_yy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx - pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * pa_yy[j] * fl1_fx - pc_xy[j] * pa_yz[j] * fl1_fx - 3.0 * pc_xyz[j] * pa_y[j] * fl1_fx - 2.0 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xyy[j] * pa_z[j] * fl1_fx - pc_xyy[j] * fl1_fx * pb_z[j] - 0.5 * pa_x[j] * fl1_fx * pc_zzz[j] - 0.5 * pa_xz[j] * fl1_fx * pc_zz[j] - pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] - 0.5 * pc_xzz[j] * fl1_fx * pa_z[j] - pc_xzz[j] * fl1_fx * pb_z[j] - pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pb_zz[j] - pa_xyy[j] * pc_zzz[j] - 2.0 * pa_xyz[j] * pc_yzz[j] - 4.0 * pa_xy[j] * pc_yzz[j] * pb_z[j] - 2.0 * pa_xz[j] * pc_yyz[j] * pb_z[j] - pa_x[j] * pc_yyz[j] * pb_zz[j] - pc_xzz[j] * pa_yyz[j] - 2.0 * pc_xzz[j] * pa_yy[j] * pb_z[j] - 4.0 * pc_xyz[j] * pa_yz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_y[j] * pb_zz[j] - pc_xyy[j] * pa_z[j] * pb_zz[j]);

                t_xyyz_zz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 3.0 * pc_xyz[j] * pa_y[j] * fl1_fx + 0.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + pc_xyy[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * fl1_fx * pc_zzz[j] + 0.5 * pc_xzzz[j] * fl1_fx + 0.5 * pc_xzz[j] * fl1_fx * pa_z[j] + pc_xzz[j] * fl1_fx * pb_z[j] + 2.0 * pa_xy[j] * pc_yzzz[j] + pa_xz[j] * pc_yyzz[j] + 2.0 * pa_x[j] * pc_yyzz[j] * pb_z[j] + pc_xzzz[j] * pa_yy[j] + 2.0 * pc_xyzz[j] * pa_yz[j] + 4.0 * pc_xyzz[j] * pa_y[j] * pb_z[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_z[j] + pc_xyyz[j] * pb_zz[j]);

                t_xyyz_zz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_yyzzz[j] - 2.0 * pc_xyzzz[j] * pa_y[j] - pc_xyyzz[j] * pa_z[j] - 2.0 * pc_xyyzz[j] * pb_z[j]);

                t_xyyz_zz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_48_49(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (48,49)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyzz = paDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxy = pcDistances.data(83 * idx + 20);

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxyz = pcDistances.data(83 * idx + 38);

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxyzz = pcDistances.data(83 * idx + 63);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyzz_xx = primBuffer.data(90 * idx + 48);

            // Batch of Integrals (48,49)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xyzz, pa_xz, pa_xzz, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, \
                                     pb_x, pb_xx, pc_x, pc_xx, pc_xxx, pc_xxxy, pc_xxxyz, pc_xxxyzz, pc_xxxz, pc_xxxzz, \
                                     pc_xxy, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyz, pc_xyzz, pc_xz, pc_xzz, \
                                     pc_y, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xyzz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyzz_xx[j] = fl_s_0_0_0 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + 0.5 * pa_xyzz[j] * fl1_fx + fl1_fx * pa_yzz[j] * pb_x[j] + 0.5 * pa_xy[j] * fl1_fx * pb_xx[j] + pa_xyzz[j] * pb_xx[j]);

                t_xyzz_xx[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl2_fx - 0.25 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - fl2_fx * pa_y[j] * pb_x[j] - 0.5 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xyzz[j] * fl1_fx - pa_xyz[j] * pc_z[j] * fl1_fx - 0.5 * pa_xzz[j] * pc_y[j] * fl1_fx - 1.5 * pc_x[j] * pa_yzz[j] * fl1_fx - 2.0 * fl1_fx * pa_yz[j] * pc_z[j] * pb_x[j] - fl1_fx * pc_y[j] * pa_zz[j] * pb_x[j] - fl1_fx * pa_yzz[j] * pb_x[j] - pa_xy[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_xy[j] * fl1_fx * pb_xx[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xx[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xyzz[j] * pb_x[j] * pc_x[j] - 2.0 * pa_xyz[j] * pc_z[j] * pb_xx[j] - pa_xzz[j] * pc_y[j] * pb_xx[j] - pc_x[j] * pa_yzz[j] * pb_xx[j]);

                t_xyzz_xx[j] += fl_s_0_0_2 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_y[j] * fl2_fx + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + fl2_fx * pc_y[j] * pb_x[j] + 0.5 * fl2_fx * pa_y[j] * pb_x[j] + pa_xyz[j] * pc_z[j] * fl1_fx + 0.5 * pa_xy[j] * pc_zz[j] * fl1_fx + 0.5 * pa_xzz[j] * pc_y[j] * fl1_fx + pa_xz[j] * pc_yz[j] * fl1_fx + 1.5 * pc_x[j] * pa_yzz[j] * fl1_fx + 3.0 * pc_xz[j] * pa_yz[j] * fl1_fx + 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx + fl1_fx * pa_y[j] * pc_zz[j] * pb_x[j] + 2.0 * fl1_fx * pc_yz[j] * pa_z[j] * pb_x[j] + 2.0 * fl1_fx * pa_yz[j] * pc_z[j] * pb_x[j] + fl1_fx * pc_y[j] * pa_zz[j] * pb_x[j] + 0.5 * pa_xy[j] * fl1_fx * pc_xx[j] + pa_xy[j] * fl1_fx * pb_x[j] * pc_x[j] + pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xx[j] + pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xx[j] + 0.5 * pc_xy[j] * fl1_fx * pb_xx[j] + pa_xyzz[j] * pc_xx[j] + 4.0 * pa_xyz[j] * pc_xz[j] * pb_x[j] + pa_xy[j] * pc_zz[j] * pb_xx[j] + 2.0 * pa_xzz[j] * pc_xy[j] * pb_x[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_yzz[j] * pb_x[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_xx[j] + pc_xy[j] * pa_zz[j] * pb_xx[j]);

                t_xyzz_xx[j] += fl_s_0_0_3 * (-0.25 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 0.5 * fl2_fx * pc_y[j] * pb_x[j] - 0.5 * pa_xy[j] * pc_zz[j] * fl1_fx - pa_xz[j] * pc_yz[j] * fl1_fx - 0.5 * pa_x[j] * pc_yzz[j] * fl1_fx - 3.0 * pc_xz[j] * pa_yz[j] * fl1_fx - 1.5 * pc_xzz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx - 3.0 * pc_xyz[j] * pa_z[j] * fl1_fx - fl1_fx * pc_yzz[j] * pb_x[j] - fl1_fx * pa_y[j] * pc_zz[j] * pb_x[j] - 2.0 * fl1_fx * pc_yz[j] * pa_z[j] * pb_x[j] - 0.5 * pa_xy[j] * fl1_fx * pc_xx[j] - 0.5 * pa_x[j] * pc_xxy[j] * fl1_fx - pa_x[j] * pc_xy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx - pc_xx[j] * pa_y[j] * fl1_fx * pb_x[j] - pc_xxy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xy[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xyz[j] * pc_xxz[j] - 2.0 * pa_xy[j] * pc_xzz[j] * pb_x[j] - pa_xzz[j] * pc_xxy[j] - 4.0 * pa_xz[j] * pc_xyz[j] * pb_x[j] - pa_x[j] * pc_yzz[j] * pb_xx[j] - pc_xxx[j] * pa_yzz[j] - 4.0 * pc_xxz[j] * pa_yz[j] * pb_x[j] - pc_xzz[j] * pa_y[j] * pb_xx[j] - 2.0 * pc_xxy[j] * pa_zz[j] * pb_x[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_xx[j]);

                t_xyzz_xx[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 0.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 1.5 * pc_xzz[j] * pa_y[j] * fl1_fx + 3.0 * pc_xyz[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + fl1_fx * pc_yzz[j] * pb_x[j] + 0.5 * pa_x[j] * pc_xxy[j] * fl1_fx + 0.5 * pc_xxx[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxxy[j] * fl1_fx + pc_xxy[j] * fl1_fx * pb_x[j] + pa_xy[j] * pc_xxzz[j] + 2.0 * pa_xz[j] * pc_xxyz[j] + 2.0 * pa_x[j] * pc_xyzz[j] * pb_x[j] + 2.0 * pc_xxxz[j] * pa_yz[j] + 2.0 * pc_xxzz[j] * pa_y[j] * pb_x[j] + pc_xxxy[j] * pa_zz[j] + 4.0 * pc_xxyz[j] * pa_z[j] * pb_x[j] + pc_xyzz[j] * pb_xx[j]);

                t_xyzz_xx[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xxxy[j] * fl1_fx - pa_x[j] * pc_xxyzz[j] - pc_xxxzz[j] * pa_y[j] - 2.0 * pc_xxxyz[j] * pa_z[j] - 2.0 * pc_xxyzz[j] * pb_x[j]);

                t_xyzz_xx[j] += fl_s_0_0_6 * pc_xxxyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_49_50(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (49,50)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyzz = paDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyzz_xy = primBuffer.data(90 * idx + 49);

            // Batch of Integrals (49,50)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xyzz, pa_xz, pa_xzz, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, \
                                     pb_x, pb_xy, pb_y, pc_x, pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, \
                                     pc_xxyzz, pc_xxz, pc_xxzz, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, \
                                     pc_xzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyzz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xyzz_xy[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * fl2_fx * pa_zz[j] + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.25 * fl2_fx * pa_y[j] * pb_y[j] + 0.5 * pa_xzz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yzz[j] * pb_y[j] + 0.5 * pa_xy[j] * fl1_fx * pb_xy[j] + pa_xyzz[j] * pb_xy[j]);

                t_xyzz_xy[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * fl2_fx * pa_zz[j] - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.5 * fl2_fx * pa_y[j] * pb_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_y[j] - 0.5 * pa_xzz[j] * fl1_fx * pc_x[j] - pa_xz[j] * fl1_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xzz[j] * fl1_fx * pb_x[j] - 0.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_x[j] - 0.5 * fl1_fx * pa_yzz[j] * pc_y[j] - fl1_fx * pa_yz[j] * pc_z[j] * pb_y[j] - 0.5 * fl1_fx * pc_y[j] * pa_zz[j] * pb_y[j] - 0.5 * fl1_fx * pa_yzz[j] * pb_y[j] - 0.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_xy[j] * fl1_fx * pb_xy[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xy[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xy[j] - pa_xyzz[j] * pb_x[j] * pc_y[j] - pa_xyzz[j] * pc_x[j] * pb_y[j] - 2.0 * pa_xyz[j] * pc_z[j] * pb_xy[j] - pa_xzz[j] * pc_y[j] * pb_xy[j] - pc_x[j] * pa_yzz[j] * pb_xy[j]);

                t_xyzz_xy[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * fl2_fx * pc_zz[j] + fl2_fx * pa_z[j] * pc_z[j] + 0.25 * fl2_fx * pa_zz[j] + 0.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.25 * pa_x[j] * fl2_fx * pb_x[j] + 0.25 * pc_xx[j] * fl2_fx + 0.5 * pc_x[j] * fl2_fx * pb_x[j] + 0.5 * fl2_fx * pa_y[j] * pc_y[j] + 0.25 * fl2_fx * pc_yy[j] + 0.5 * fl2_fx * pc_y[j] * pb_y[j] + 0.25 * fl2_fx * pa_y[j] * pb_y[j] + pa_xz[j] * fl1_fx * pc_xz[j] + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] + 0.5 * pa_xzz[j] * fl1_fx * pc_x[j] + pa_xz[j] * fl1_fx * pc_z[j] * pb_x[j] + 0.5 * pc_xx[j] * fl1_fx * pa_zz[j] + pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] + 0.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_x[j] + fl1_fx * pa_yz[j] * pc_yz[j] + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pc_yy[j] * pa_zz[j] + fl1_fx * pc_yz[j] * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pa_yzz[j] * pc_y[j] + fl1_fx * pa_yz[j] * pc_z[j] * pb_y[j] + 0.5 * fl1_fx * pc_y[j] * pa_zz[j] * pb_y[j] + 0.5 * pa_xy[j] * fl1_fx * pc_xy[j] + 0.5 * pa_xy[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_y[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_x[j] + 0.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xy[j] + 0.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_x[j] + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xy[j] + 0.5 * pc_xy[j] * fl1_fx * pb_xy[j] + pa_xyzz[j] * pc_xy[j] + 2.0 * pa_xyz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_xyz[j] * pc_xz[j] * pb_y[j] + pa_xy[j] * pc_zz[j] * pb_xy[j] + pa_xzz[j] * pc_yy[j] * pb_x[j] + pa_xzz[j] * pc_xy[j] * pb_y[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_xy[j] + pc_xy[j] * pa_yzz[j] * pb_x[j] + pc_xx[j] * pa_yzz[j] * pb_y[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_xy[j] + pc_xy[j] * pa_zz[j] * pb_xy[j]);

                t_xyzz_xy[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pa_z[j] * pc_z[j] - 0.25 * pa_x[j] * fl2_fx * pc_x[j] - 0.5 * pc_xx[j] * fl2_fx - 0.25 * pc_x[j] * fl2_fx * pb_x[j] - 0.5 * fl2_fx * pc_yy[j] - 0.25 * fl2_fx * pa_y[j] * pc_y[j] - 0.25 * fl2_fx * pc_y[j] * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_xzz[j] - pa_xz[j] * fl1_fx * pc_xz[j] - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_x[j] - pc_xxz[j] * fl1_fx * pa_z[j] - 0.5 * pc_xzz[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * fl1_fx * pa_zz[j] - pc_xz[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_y[j] * pc_yzz[j] - fl1_fx * pc_yyz[j] * pa_z[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_y[j] - fl1_fx * pa_yz[j] * pc_yz[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_y[j] - 0.5 * fl1_fx * pc_yy[j] * pa_zz[j] - fl1_fx * pc_yz[j] * pa_z[j] * pb_y[j] - 0.5 * pa_xy[j] * fl1_fx * pc_xy[j] - 0.5 * pa_x[j] * pc_xyy[j] * fl1_fx - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_x[j] - 0.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xxy[j] * pa_y[j] * fl1_fx - 0.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_x[j] - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_y[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xy[j] * fl1_fx * pb_xy[j] - 2.0 * pa_xyz[j] * pc_xyz[j] - pa_xy[j] * pc_yzz[j] * pb_x[j] - pa_xy[j] * pc_xzz[j] * pb_y[j] - pa_xzz[j] * pc_xyy[j] - 2.0 * pa_xz[j] * pc_yyz[j] * pb_x[j] - 2.0 * pa_xz[j] * pc_xyz[j] * pb_y[j] - pa_x[j] * pc_yzz[j] * pb_xy[j] - pc_xxy[j] * pa_yzz[j] - 2.0 * pc_xyz[j] * pa_yz[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_yz[j] * pb_y[j] - pc_xzz[j] * pa_y[j] * pb_xy[j] - pc_xyy[j] * pa_zz[j] * pb_x[j] - pc_xxy[j] * pa_zz[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_xy[j]);

                t_xyzz_xy[j] += fl_s_0_0_4 * (0.25 * fl2_fx * pc_zz[j] + 0.25 * pc_xx[j] * fl2_fx + 0.25 * fl2_fx * pc_yy[j] + 0.5 * pa_x[j] * fl1_fx * pc_xzz[j] + 0.5 * pc_xxzz[j] * fl1_fx + pc_xxz[j] * fl1_fx * pa_z[j] + 0.5 * pc_xzz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_yyzz[j] + 0.5 * fl1_fx * pa_y[j] * pc_yzz[j] + fl1_fx * pc_yyz[j] * pa_z[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_y[j] + 0.5 * pa_x[j] * pc_xyy[j] * fl1_fx + 0.5 * pc_xxy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + 0.5 * pc_xyy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xxy[j] * fl1_fx * pb_y[j] + pa_xy[j] * pc_xyzz[j] + 2.0 * pa_xz[j] * pc_xyyz[j] + pa_x[j] * pc_yyzz[j] * pb_x[j] + pa_x[j] * pc_xyzz[j] * pb_y[j] + 2.0 * pc_xxyz[j] * pa_yz[j] + pc_xyzz[j] * pa_y[j] * pb_x[j] + pc_xxzz[j] * pa_y[j] * pb_y[j] + pc_xxyy[j] * pa_zz[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_y[j] + pc_xyzz[j] * pb_xy[j]);

                t_xyzz_xy[j] += fl_s_0_0_5 * (-0.5 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_yyzz[j] - 0.5 * pc_xxyy[j] * fl1_fx - pa_x[j] * pc_xyyzz[j] - pc_xxyzz[j] * pa_y[j] - 2.0 * pc_xxyyz[j] * pa_z[j] - pc_xyyzz[j] * pb_x[j] - pc_xxyzz[j] * pb_y[j]);

                t_xyzz_xy[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_50_51(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (50,51)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyzz = paDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyzz_xz = primBuffer.data(90 * idx + 50);

            // Batch of Integrals (50,51)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xyzz, pa_xz, pa_xzz, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, \
                                     pb_x, pb_xz, pb_z, pc_x, pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, \
                                     pc_xxzz, pc_xxzzz, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xyzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyzz_xz[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_yz[j] + 0.25 * fl2_fx * pa_y[j] * pb_z[j] + pa_xyz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_yzz[j] * pb_z[j] + 0.5 * pa_xy[j] * fl1_fx * pb_xz[j] + pa_xyzz[j] * pb_xz[j]);

                t_xyzz_xz[j] += fl_s_0_0_1 * (-fl2_fx * pa_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.5 * fl2_fx * pc_y[j] * pa_z[j] - 0.5 * fl2_fx * pa_y[j] * pb_z[j] - 0.25 * fl2_fx * pc_y[j] * pb_z[j] - pa_xyz[j] * fl1_fx * pc_x[j] - pa_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pa_xy[j] * pc_z[j] * fl1_fx * pb_x[j] - pa_xz[j] * pc_y[j] * fl1_fx * pb_x[j] - pc_x[j] * pa_yz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_yzz[j] * pc_z[j] - fl1_fx * pa_yz[j] * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pc_y[j] * pa_zz[j] * pb_z[j] - 0.5 * fl1_fx * pa_yzz[j] * pb_z[j] - 0.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_xz[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xz[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xz[j] - pa_xyzz[j] * pb_x[j] * pc_z[j] - pa_xyzz[j] * pc_x[j] * pb_z[j] - 2.0 * pa_xyz[j] * pc_z[j] * pb_xz[j] - pa_xzz[j] * pc_y[j] * pb_xz[j] - pc_x[j] * pa_yzz[j] * pb_xz[j]);

                t_xyzz_xz[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_y[j] * pc_z[j] + fl2_fx * pc_y[j] * pa_z[j] + 0.75 * fl2_fx * pc_yz[j] + 0.5 * fl2_fx * pa_yz[j] + 0.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.25 * fl2_fx * pa_y[j] * pb_z[j] + pa_xyz[j] * fl1_fx * pc_x[j] + 1.5 * pa_xy[j] * pc_xz[j] * fl1_fx + 1.5 * pa_xy[j] * pc_z[j] * fl1_fx * pb_x[j] + pa_xz[j] * pc_xy[j] * fl1_fx + pa_xz[j] * pc_y[j] * fl1_fx * pb_x[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] + pc_xx[j] * pa_yz[j] * fl1_fx + pc_x[j] * pa_yz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_x[j] + pc_xy[j] * pa_z[j] * fl1_fx * pb_x[j] + fl1_fx * pa_yz[j] * pc_zz[j] + 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pc_yz[j] * pa_zz[j] + fl1_fx * pc_yz[j] * pa_z[j] * pb_z[j] + 0.5 * fl1_fx * pa_yzz[j] * pc_z[j] + fl1_fx * pa_yz[j] * pc_z[j] * pb_z[j] + 0.5 * fl1_fx * pc_y[j] * pa_zz[j] * pb_z[j] + 0.5 * pa_xy[j] * fl1_fx * pc_x[j] * pb_z[j] + 0.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_xz[j] + 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_xz[j] + 0.5 * pc_xy[j] * fl1_fx * pb_xz[j] + pa_xyzz[j] * pc_xz[j] + 2.0 * pa_xyz[j] * pc_zz[j] * pb_x[j] + 2.0 * pa_xyz[j] * pc_xz[j] * pb_z[j] + pa_xy[j] * pc_zz[j] * pb_xz[j] + pa_xzz[j] * pc_yz[j] * pb_x[j] + pa_xzz[j] * pc_xy[j] * pb_z[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_xz[j] + pc_xz[j] * pa_yzz[j] * pb_x[j] + pc_xx[j] * pa_yzz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_xz[j] + pc_xy[j] * pa_zz[j] * pb_xz[j]);

                t_xyzz_xz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_y[j] * pc_z[j] - 0.5 * fl2_fx * pc_y[j] * pa_z[j] - 0.25 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xy[j] * pc_xz[j] * fl1_fx - pa_xz[j] * pc_xy[j] * fl1_fx - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] - pc_xx[j] * pa_yz[j] * fl1_fx - 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_x[j] - pc_xxy[j] * pa_z[j] * fl1_fx - pc_xy[j] * pa_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_y[j] * pc_zzz[j] - fl1_fx * pc_yzz[j] * pa_z[j] - 0.5 * fl1_fx * pc_yzz[j] * pb_z[j] - fl1_fx * pa_yz[j] * pc_zz[j] - 0.5 * fl1_fx * pa_y[j] * pc_zz[j] * pb_z[j] - 0.5 * fl1_fx * pc_yz[j] * pa_zz[j] - fl1_fx * pc_yz[j] * pa_z[j] * pb_z[j] - 0.5 * pa_x[j] * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xx[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xxy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * fl1_fx * pb_xz[j] - 2.0 * pa_xyz[j] * pc_xzz[j] - pa_xy[j] * pc_zzz[j] * pb_x[j] - pa_xy[j] * pc_xzz[j] * pb_z[j] - pa_xzz[j] * pc_xyz[j] - 2.0 * pa_xz[j] * pc_yzz[j] * pb_x[j] - 2.0 * pa_xz[j] * pc_xyz[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_xz[j] - pc_xxz[j] * pa_yzz[j] - 2.0 * pc_xzz[j] * pa_yz[j] * pb_x[j] - 2.0 * pc_xxz[j] * pa_yz[j] * pb_z[j] - pc_xzz[j] * pa_y[j] * pb_xz[j] - pc_xyz[j] * pa_zz[j] * pb_x[j] - pc_xxy[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_xz[j]);

                t_xyzz_xz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxz[j] * pa_y[j] * fl1_fx + pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_yzzz[j] + 0.5 * fl1_fx * pa_y[j] * pc_zzz[j] + fl1_fx * pc_yzz[j] * pa_z[j] + 0.5 * fl1_fx * pc_yzz[j] * pb_z[j] + 0.5 * pc_xxy[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_xzzz[j] + 2.0 * pa_xz[j] * pc_xyzz[j] + pa_x[j] * pc_yzzz[j] * pb_x[j] + pa_x[j] * pc_xyzz[j] * pb_z[j] + 2.0 * pc_xxzz[j] * pa_yz[j] + pc_xzzz[j] * pa_y[j] * pb_x[j] + pc_xxzz[j] * pa_y[j] * pb_z[j] + pc_xxyz[j] * pa_zz[j] + 2.0 * pc_xyzz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xxyz[j] * pa_z[j] * pb_z[j] + pc_xyzz[j] * pb_xz[j]);

                t_xyzz_xz[j] += fl_s_0_0_5 * (-1.5 * pc_xxyz[j] * fl1_fx - 0.5 * fl1_fx * pc_yzzz[j] - pa_x[j] * pc_xyzzz[j] - pc_xxzzz[j] * pa_y[j] - 2.0 * pc_xxyzz[j] * pa_z[j] - pc_xyzzz[j] * pb_x[j] - pc_xxyzz[j] * pb_z[j]);

                t_xyzz_xz[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_51_52(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (51,52)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyzz = paDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyzz_yy = primBuffer.data(90 * idx + 51);

            // Batch of Integrals (51,52)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xyzz, pa_xz, pa_xzz, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, \
                                     pb_y, pb_yy, pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, \
                                     pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_xyzz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyzz_yy[j] = fl_s_0_0_0 * (0.25 * pa_xy[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pa_xyzz[j] * fl1_fx + pa_xzz[j] * fl1_fx * pb_y[j] + 0.5 * pa_xy[j] * fl1_fx * pb_yy[j] + pa_xyzz[j] * pb_yy[j]);

                t_xyzz_yy[j] += fl_s_0_0_1 * (-0.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - pa_x[j] * fl2_fx * pb_y[j] - 0.25 * pc_x[j] * pa_y[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xyzz[j] * fl1_fx - pa_xyz[j] * pc_z[j] * fl1_fx - 1.5 * pa_xzz[j] * pc_y[j] * fl1_fx - 2.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_y[j] - pa_xzz[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * pa_yzz[j] * fl1_fx - pc_x[j] * fl1_fx * pa_zz[j] * pb_y[j] - pa_xy[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_xy[j] * fl1_fx * pb_yy[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yy[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xyzz[j] * pb_y[j] * pc_y[j] - 2.0 * pa_xyz[j] * pc_z[j] * pb_yy[j] - pa_xzz[j] * pc_y[j] * pb_yy[j] - pc_x[j] * pa_yzz[j] * pb_yy[j]);

                t_xyzz_yy[j] += fl_s_0_0_2 * (0.25 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 0.5 * pa_x[j] * fl2_fx * pb_y[j] + 0.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + pc_x[j] * fl2_fx * pb_y[j] + pa_xyz[j] * pc_z[j] * fl1_fx + 0.5 * pa_xy[j] * pc_zz[j] * fl1_fx + 1.5 * pa_xzz[j] * pc_y[j] * fl1_fx + 3.0 * pa_xz[j] * pc_yz[j] * fl1_fx + pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] + 2.0 * pa_xz[j] * fl1_fx * pc_z[j] * pb_y[j] + 0.5 * pc_x[j] * pa_yzz[j] * fl1_fx + pc_xz[j] * pa_yz[j] * fl1_fx + 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx + 2.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] + pc_x[j] * fl1_fx * pa_zz[j] * pb_y[j] + 0.5 * pa_xy[j] * fl1_fx * pc_yy[j] + pa_xy[j] * fl1_fx * pb_y[j] * pc_y[j] + pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yy[j] + pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yy[j] + 0.5 * pc_xy[j] * fl1_fx * pb_yy[j] + pa_xyzz[j] * pc_yy[j] + 4.0 * pa_xyz[j] * pc_yz[j] * pb_y[j] + pa_xy[j] * pc_zz[j] * pb_yy[j] + 2.0 * pa_xzz[j] * pc_yy[j] * pb_y[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_yzz[j] * pb_y[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_yy[j] + pc_xy[j] * pa_zz[j] * pb_yy[j]);

                t_xyzz_yy[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.25 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pb_y[j] - 0.5 * pa_xy[j] * pc_zz[j] * fl1_fx - 3.0 * pa_xz[j] * pc_yz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx - pa_x[j] * fl1_fx * pc_zz[j] * pb_y[j] - pc_xz[j] * pa_yz[j] * fl1_fx - 0.5 * pc_xzz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx - 3.0 * pc_xyz[j] * pa_z[j] * fl1_fx - pc_xzz[j] * fl1_fx * pb_y[j] - 2.0 * pc_xz[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * pa_xy[j] * fl1_fx * pc_yy[j] - 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx - pa_x[j] * pc_yy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xyy[j] * pa_y[j] * fl1_fx - pc_xy[j] * pa_y[j] * fl1_fx * pb_y[j] - pc_xyy[j] * fl1_fx * pb_y[j] - 0.5 * pc_xy[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xyz[j] * pc_yyz[j] - 2.0 * pa_xy[j] * pc_yzz[j] * pb_y[j] - pa_xzz[j] * pc_yyy[j] - 4.0 * pa_xz[j] * pc_yyz[j] * pb_y[j] - pa_x[j] * pc_yzz[j] * pb_yy[j] - pc_xyy[j] * pa_yzz[j] - 4.0 * pc_xyz[j] * pa_yz[j] * pb_y[j] - pc_xzz[j] * pa_y[j] * pb_yy[j] - 2.0 * pc_xyy[j] * pa_zz[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_yy[j]);

                t_xyzz_yy[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_yzz[j] * fl1_fx + 0.5 * pc_xzz[j] * pa_y[j] * fl1_fx + 3.0 * pc_xyz[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyzz[j] * fl1_fx + pc_xzz[j] * fl1_fx * pb_y[j] + 0.5 * pa_x[j] * pc_yyy[j] * fl1_fx + 0.5 * pc_xyy[j] * pa_y[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + pc_xyy[j] * fl1_fx * pb_y[j] + pa_xy[j] * pc_yyzz[j] + 2.0 * pa_xz[j] * pc_yyyz[j] + 2.0 * pa_x[j] * pc_yyzz[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pa_yz[j] + 2.0 * pc_xyzz[j] * pa_y[j] * pb_y[j] + pc_xyyy[j] * pa_zz[j] + 4.0 * pc_xyyz[j] * pa_z[j] * pb_y[j] + pc_xyzz[j] * pb_yy[j]);

                t_xyzz_yy[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xyyy[j] * fl1_fx - pa_x[j] * pc_yyyzz[j] - pc_xyyzz[j] * pa_y[j] - 2.0 * pc_xyyyz[j] * pa_z[j] - 2.0 * pc_xyyzz[j] * pb_y[j]);

                t_xyzz_yy[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_52_53(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (52,53)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyzz = paDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyzz_yz = primBuffer.data(90 * idx + 52);

            // Batch of Integrals (52,53)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xyzz, pa_xz, pa_xzz, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, \
                                     pb_y, pb_yz, pb_z, pc_x, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, \
                                     pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_xyzz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyzz_yz[j] = fl_s_0_0_0 * (0.5 * pa_xz[j] * fl2_fx + 0.25 * pa_x[j] * fl2_fx * pb_z[j] + pa_xyz[j] * fl1_fx * pb_y[j] + 0.5 * pa_xzz[j] * fl1_fx * pb_z[j] + 0.5 * pa_xy[j] * fl1_fx * pb_yz[j] + pa_xyzz[j] * pb_yz[j]);

                t_xyzz_yz[j] += fl_s_0_0_1 * (-pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * fl2_fx * pc_z[j] - 0.5 * pc_x[j] * fl2_fx * pa_z[j] - 0.5 * pa_x[j] * fl2_fx * pb_z[j] - 0.25 * pc_x[j] * fl2_fx * pb_z[j] - pa_xyz[j] * fl1_fx * pc_y[j] - pa_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pa_xy[j] * pc_z[j] * fl1_fx * pb_y[j] - pa_xz[j] * pc_y[j] * fl1_fx * pb_y[j] - 0.5 * pa_xzz[j] * fl1_fx * pc_z[j] - pa_xz[j] * fl1_fx * pc_z[j] * pb_z[j] - 0.5 * pa_xzz[j] * fl1_fx * pb_z[j] - pc_x[j] * pa_yz[j] * fl1_fx * pb_y[j] - 0.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_z[j] - 0.5 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_yz[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yz[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yz[j] - pa_xyzz[j] * pb_y[j] * pc_z[j] - pa_xyzz[j] * pc_y[j] * pb_z[j] - 2.0 * pa_xyz[j] * pc_z[j] * pb_yz[j] - pa_xzz[j] * pc_y[j] * pb_yz[j] - pc_x[j] * pa_yzz[j] * pb_yz[j]);

                t_xyzz_yz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_z[j] + 0.5 * pa_xz[j] * fl2_fx + pc_x[j] * fl2_fx * pa_z[j] + 0.75 * pc_xz[j] * fl2_fx + 0.25 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pc_x[j] * fl2_fx * pb_z[j] + pa_xyz[j] * fl1_fx * pc_y[j] + 1.5 * pa_xy[j] * pc_yz[j] * fl1_fx + 1.5 * pa_xy[j] * pc_z[j] * fl1_fx * pb_y[j] + pa_xz[j] * pc_yy[j] * fl1_fx + pa_xz[j] * pc_y[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] + pa_xz[j] * fl1_fx * pc_zz[j] + 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] + 0.5 * pa_xzz[j] * fl1_fx * pc_z[j] + pa_xz[j] * fl1_fx * pc_z[j] * pb_z[j] + pc_xy[j] * pa_yz[j] * fl1_fx + pc_x[j] * pa_yz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] + pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] + 0.5 * pc_xz[j] * fl1_fx * pa_zz[j] + pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] + 0.5 * pc_x[j] * fl1_fx * pa_zz[j] * pb_z[j] + 0.5 * pa_xy[j] * fl1_fx * pc_y[j] * pb_z[j] + 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_yz[j] + 0.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_yz[j] + 0.5 * pc_xy[j] * fl1_fx * pb_yz[j] + pa_xyzz[j] * pc_yz[j] + 2.0 * pa_xyz[j] * pc_zz[j] * pb_y[j] + 2.0 * pa_xyz[j] * pc_yz[j] * pb_z[j] + pa_xy[j] * pc_zz[j] * pb_yz[j] + pa_xzz[j] * pc_yz[j] * pb_y[j] + pa_xzz[j] * pc_yy[j] * pb_z[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_yz[j] + pc_xz[j] * pa_yzz[j] * pb_y[j] + pc_xy[j] * pa_yzz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_yz[j] + pc_xy[j] * pa_zz[j] * pb_yz[j]);

                t_xyzz_yz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_z[j] - 1.5 * pc_xz[j] * fl2_fx - 0.5 * pc_x[j] * fl2_fx * pa_z[j] - 0.25 * pc_x[j] * fl2_fx * pb_z[j] - 1.5 * pa_xy[j] * pc_yz[j] * fl1_fx - pa_xz[j] * pc_yy[j] * fl1_fx - 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] - 0.5 * pa_x[j] * fl1_fx * pc_zzz[j] - pa_xz[j] * fl1_fx * pc_zz[j] - 0.5 * pa_x[j] * fl1_fx * pc_zz[j] * pb_z[j] - pc_xy[j] * pa_yz[j] * fl1_fx - 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx - 1.5 * pc_xz[j] * pa_y[j] * fl1_fx * pb_y[j] - pc_xyy[j] * pa_z[j] * fl1_fx - pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - pc_xzz[j] * fl1_fx * pa_z[j] - 0.5 * pc_xzz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xz[j] * fl1_fx * pa_zz[j] - pc_xz[j] * fl1_fx * pa_z[j] * pb_z[j] - 0.5 * pa_x[j] * pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * fl1_fx * pb_yz[j] - 2.0 * pa_xyz[j] * pc_yzz[j] - pa_xy[j] * pc_zzz[j] * pb_y[j] - pa_xy[j] * pc_yzz[j] * pb_z[j] - pa_xzz[j] * pc_yyz[j] - 2.0 * pa_xz[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_xz[j] * pc_yyz[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_yz[j] - pc_xyz[j] * pa_yzz[j] - 2.0 * pc_xzz[j] * pa_yz[j] * pb_y[j] - 2.0 * pc_xyz[j] * pa_yz[j] * pb_z[j] - pc_xzz[j] * pa_y[j] * pb_yz[j] - pc_xyz[j] * pa_zz[j] * pb_y[j] - pc_xyy[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_yz[j]);

                t_xyzz_yz[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 0.5 * pa_x[j] * fl1_fx * pc_zzz[j] + 1.5 * pc_xyz[j] * pa_y[j] * fl1_fx + pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 0.5 * pc_xzzz[j] * fl1_fx + pc_xzz[j] * fl1_fx * pa_z[j] + 0.5 * pc_xzz[j] * fl1_fx * pb_z[j] + 0.5 * pc_xyy[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_yzzz[j] + 2.0 * pa_xz[j] * pc_yyzz[j] + pa_x[j] * pc_yzzz[j] * pb_y[j] + pa_x[j] * pc_yyzz[j] * pb_z[j] + 2.0 * pc_xyzz[j] * pa_yz[j] + pc_xzzz[j] * pa_y[j] * pb_y[j] + pc_xyzz[j] * pa_y[j] * pb_z[j] + pc_xyyz[j] * pa_zz[j] + 2.0 * pc_xyzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_z[j] + pc_xyzz[j] * pb_yz[j]);

                t_xyzz_yz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_yyzzz[j] - pc_xyzzz[j] * pa_y[j] - 2.0 * pc_xyyzz[j] * pa_z[j] - pc_xyzzz[j] * pb_y[j] - pc_xyyzz[j] * pb_z[j]);

                t_xyzz_yz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_53_54(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (53,54)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xy = paDistances.data(34 * idx + 4);

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xyz = paDistances.data(34 * idx + 13);

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xyzz = paDistances.data(34 * idx + 27);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xyzz_zz = primBuffer.data(90 * idx + 53);

            // Batch of Integrals (53,54)

            #pragma omp simd aligned(fx, pa_x, pa_xy, pa_xyz, pa_xyzz, pa_xz, pa_xzz, pa_y, pa_yz, pa_yzz, pa_z, pa_zz, \
                                     pb_z, pb_zz, pc_x, pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_xzzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xyzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xyzz_zz[j] = fl_s_0_0_0 * (0.75 * pa_xy[j] * fl2_fx + 0.5 * pa_xyzz[j] * fl1_fx + 2.0 * pa_xyz[j] * fl1_fx * pb_z[j] + 0.5 * pa_xy[j] * fl1_fx * pb_zz[j] + pa_xyzz[j] * pb_zz[j]);

                t_xyzz_zz[j] += fl_s_0_0_1 * (-1.5 * pa_xy[j] * fl2_fx - 0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 0.5 * pa_xyzz[j] * fl1_fx - 3.0 * pa_xyz[j] * pc_z[j] * fl1_fx - 2.0 * pa_xyz[j] * fl1_fx * pb_z[j] - 3.0 * pa_xy[j] * pc_z[j] * fl1_fx * pb_z[j] - 0.5 * pa_xzz[j] * pc_y[j] * fl1_fx - 2.0 * pa_xz[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_yzz[j] * fl1_fx - 2.0 * pc_x[j] * pa_yz[j] * fl1_fx * pb_z[j] - 0.5 * pa_xy[j] * fl1_fx * pb_zz[j] - 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] - 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xyzz[j] * pb_z[j] * pc_z[j] - 2.0 * pa_xyz[j] * pc_z[j] * pb_zz[j] - pa_xzz[j] * pc_y[j] * pb_zz[j] - pc_x[j] * pa_yzz[j] * pb_zz[j]);

                t_xyzz_zz[j] += fl_s_0_0_2 * (0.75 * pa_xy[j] * fl2_fx + 1.5 * pa_x[j] * pc_y[j] * fl2_fx + 1.5 * pc_x[j] * pa_y[j] * fl2_fx + 0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_xyz[j] * pc_z[j] * fl1_fx + 3.0 * pa_xy[j] * pc_zz[j] * fl1_fx + 3.0 * pa_xy[j] * pc_z[j] * fl1_fx * pb_z[j] + 0.5 * pa_xzz[j] * pc_y[j] * fl1_fx + 3.0 * pa_xz[j] * pc_yz[j] * fl1_fx + 2.0 * pa_xz[j] * pc_y[j] * fl1_fx * pb_z[j] + 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_yzz[j] * fl1_fx + 3.0 * pc_xz[j] * pa_yz[j] * fl1_fx + 2.0 * pc_x[j] * pa_yz[j] * fl1_fx * pb_z[j] + 3.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] + 0.5 * pc_xy[j] * pa_zz[j] * fl1_fx + 2.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.5 * pa_x[j] * pc_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_x[j] * pa_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_xy[j] * fl1_fx * pb_zz[j] + pa_xyzz[j] * pc_zz[j] + 4.0 * pa_xyz[j] * pc_zz[j] * pb_z[j] + pa_xy[j] * pc_zz[j] * pb_zz[j] + 2.0 * pa_xzz[j] * pc_yz[j] * pb_z[j] + 2.0 * pa_xz[j] * pc_yz[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_yzz[j] * pb_z[j] + 2.0 * pc_xz[j] * pa_yz[j] * pb_zz[j] + pc_xy[j] * pa_zz[j] * pb_zz[j]);

                t_xyzz_zz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_y[j] * fl2_fx - 0.75 * pc_x[j] * pa_y[j] * fl2_fx - 1.5 * pc_xy[j] * fl2_fx - 3.0 * pa_xy[j] * pc_zz[j] * fl1_fx - 3.0 * pa_xz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xz[j] * pa_yz[j] * fl1_fx - 3.0 * pc_xzz[j] * pa_y[j] * fl1_fx - 3.0 * pc_xz[j] * pa_y[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * pa_zz[j] * fl1_fx - 3.0 * pc_xyz[j] * pa_z[j] * fl1_fx - 2.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] - 0.5 * pc_xy[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xyz[j] * pc_zzz[j] - 2.0 * pa_xy[j] * pc_zzz[j] * pb_z[j] - pa_xzz[j] * pc_yzz[j] - 4.0 * pa_xz[j] * pc_yzz[j] * pb_z[j] - pa_x[j] * pc_yzz[j] * pb_zz[j] - pc_xzz[j] * pa_yzz[j] - 4.0 * pc_xzz[j] * pa_yz[j] * pb_z[j] - pc_xzz[j] * pa_y[j] * pb_zz[j] - 2.0 * pc_xyz[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_xyz[j] * pa_z[j] * pb_zz[j]);

                t_xyzz_zz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx + 3.0 * pc_xzz[j] * pa_y[j] * fl1_fx + 3.0 * pc_xyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_z[j] + pa_xy[j] * pc_zzzz[j] + 2.0 * pa_xz[j] * pc_yzzz[j] + 2.0 * pa_x[j] * pc_yzzz[j] * pb_z[j] + 2.0 * pc_xzzz[j] * pa_yz[j] + 2.0 * pc_xzzz[j] * pa_y[j] * pb_z[j] + pc_xyzz[j] * pa_zz[j] + 4.0 * pc_xyzz[j] * pa_z[j] * pb_z[j] + pc_xyzz[j] * pb_zz[j]);

                t_xyzz_zz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yzzzz[j] - pc_xzzzz[j] * pa_y[j] - 2.0 * pc_xyzzz[j] * pa_z[j] - 2.0 * pc_xyzzz[j] * pb_z[j]);

                t_xyzz_zz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_54_55(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (54,55)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xzzz = paDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxx = pcDistances.data(83 * idx + 9);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxxz = pcDistances.data(83 * idx + 21);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxxzz = pcDistances.data(83 * idx + 39);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxxzzz = pcDistances.data(83 * idx + 64);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xzzz_xx = primBuffer.data(90 * idx + 54);

            // Batch of Integrals (54,55)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_xzzz, pa_z, pa_zz, pa_zzz, pb_x, pb_xx, pc_x, pc_xx, \
                                     pc_xxx, pc_xxxz, pc_xxxzz, pc_xxxzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xzzz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzzz_xx[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * pa_xzzz[j] * fl1_fx + fl1_fx * pa_zzz[j] * pb_x[j] + 1.5 * pa_xz[j] * fl1_fx * pb_xx[j] + pa_xzzz[j] * pb_xx[j]);

                t_xzzz_xx[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * pc_z[j] * fl2_fx - 2.25 * pc_x[j] * pa_z[j] * fl2_fx - 3.0 * fl2_fx * pa_z[j] * pb_x[j] - 1.5 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * pa_xzzz[j] * fl1_fx - 1.5 * pa_xzz[j] * pc_z[j] * fl1_fx - 1.5 * pc_x[j] * pa_zzz[j] * fl1_fx - 3.0 * fl1_fx * pa_zz[j] * pc_z[j] * pb_x[j] - fl1_fx * pa_zzz[j] * pb_x[j] - 3.0 * pa_xz[j] * fl1_fx * pb_x[j] * pc_x[j] - 1.5 * pa_xz[j] * fl1_fx * pb_xx[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_xx[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_xx[j] - 2.0 * pa_xzzz[j] * pb_x[j] * pc_x[j] - 3.0 * pa_xzz[j] * pc_z[j] * pb_xx[j] - pc_x[j] * pa_zzz[j] * pb_xx[j]);

                t_xzzz_xx[j] += fl_s_0_0_2 * (0.75 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_z[j] * fl2_fx + 4.5 * pc_x[j] * pa_z[j] * fl2_fx + 2.25 * pc_xz[j] * fl2_fx + 3.0 * fl2_fx * pc_z[j] * pb_x[j] + 1.5 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_xzz[j] * pc_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_zz[j] * fl1_fx + 1.5 * pc_x[j] * pa_zzz[j] * fl1_fx + 4.5 * pc_xz[j] * pa_zz[j] * fl1_fx + 3.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] + 3.0 * fl1_fx * pa_zz[j] * pc_z[j] * pb_x[j] + 1.5 * pa_xz[j] * fl1_fx * pc_xx[j] + 3.0 * pa_xz[j] * fl1_fx * pb_x[j] * pc_x[j] + 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_xx[j] + 3.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_xx[j] + 1.5 * pc_xz[j] * fl1_fx * pb_xx[j] + pa_xzzz[j] * pc_xx[j] + 6.0 * pa_xzz[j] * pc_xz[j] * pb_x[j] + 3.0 * pa_xz[j] * pc_zz[j] * pb_xx[j] + 2.0 * pc_xx[j] * pa_zzz[j] * pb_x[j] + 3.0 * pc_xz[j] * pa_zz[j] * pb_xx[j]);

                t_xzzz_xx[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_z[j] * fl2_fx - 2.25 * pc_x[j] * pa_z[j] * fl2_fx - 4.5 * pc_xz[j] * fl2_fx - 1.5 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_xz[j] * pc_zz[j] * fl1_fx - 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx - 4.5 * pc_xz[j] * pa_zz[j] * fl1_fx - 4.5 * pc_xzz[j] * pa_z[j] * fl1_fx - fl1_fx * pc_zzz[j] * pb_x[j] - 3.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] - 1.5 * pa_xz[j] * fl1_fx * pc_xx[j] - 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxx[j] * pa_z[j] * fl1_fx - 3.0 * pc_xx[j] * pa_z[j] * fl1_fx * pb_x[j] - 3.0 * pc_xxz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xz[j] * fl1_fx * pb_xx[j] - 3.0 * pa_xzz[j] * pc_xxz[j] - 6.0 * pa_xz[j] * pc_xzz[j] * pb_x[j] - pa_x[j] * pc_zzz[j] * pb_xx[j] - pc_xxx[j] * pa_zzz[j] - 6.0 * pc_xxz[j] * pa_zz[j] * pb_x[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_xx[j]);

                t_xzzz_xx[j] += fl_s_0_0_4 * (2.25 * pc_xz[j] * fl2_fx + 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx + 4.5 * pc_xzz[j] * pa_z[j] * fl1_fx + 1.5 * pc_xzzz[j] * fl1_fx + fl1_fx * pc_zzz[j] * pb_x[j] + 1.5 * pa_x[j] * pc_xxz[j] * fl1_fx + 1.5 * pc_xxx[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxxz[j] * fl1_fx + 3.0 * pc_xxz[j] * fl1_fx * pb_x[j] + 3.0 * pa_xz[j] * pc_xxzz[j] + 2.0 * pa_x[j] * pc_xzzz[j] * pb_x[j] + 3.0 * pc_xxxz[j] * pa_zz[j] + 6.0 * pc_xxzz[j] * pa_z[j] * pb_x[j] + pc_xzzz[j] * pb_xx[j]);

                t_xzzz_xx[j] += fl_s_0_0_5 * (-1.5 * pc_xzzz[j] * fl1_fx - 1.5 * pc_xxxz[j] * fl1_fx - pa_x[j] * pc_xxzzz[j] - 3.0 * pc_xxxzz[j] * pa_z[j] - 2.0 * pc_xxzzz[j] * pb_x[j]);

                t_xzzz_xx[j] += fl_s_0_0_6 * pc_xxxzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_55_56(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (55,56)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xzzz = paDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xzzz_xy = primBuffer.data(90 * idx + 55);

            // Batch of Integrals (55,56)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_xzzz, pa_z, pa_zz, pa_zzz, pb_x, pb_xy, pb_y, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, \
                                     pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, pc_z, \
                                     pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_xzzz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzzz_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * fl1_fx * pa_zzz[j] * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pb_xy[j] + pa_xzzz[j] * pb_xy[j]);

                t_xzzz_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_z[j] * pc_y[j] - 1.5 * fl2_fx * pa_z[j] * pb_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_zzz[j] * pc_y[j] - 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_y[j] - 0.5 * fl1_fx * pa_zzz[j] * pb_y[j] - 1.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_y[j] - 1.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_y[j] - 1.5 * pa_xz[j] * fl1_fx * pb_xy[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_xy[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_xy[j] - pa_xzzz[j] * pb_x[j] * pc_y[j] - pa_xzzz[j] * pc_x[j] * pb_y[j] - 3.0 * pa_xzz[j] * pc_z[j] * pb_xy[j] - pc_x[j] * pa_zzz[j] * pb_xy[j]);

                t_xzzz_xy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_z[j] * pc_y[j] + 0.75 * fl2_fx * pc_yz[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * fl1_fx * pa_zz[j] * pc_yz[j] + 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pa_zzz[j] * pc_y[j] + 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pc_xy[j] + 1.5 * pa_xz[j] * fl1_fx * pb_x[j] * pc_y[j] + 1.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_xy[j] + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_xx[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_xy[j] + 1.5 * pc_xz[j] * fl1_fx * pb_xy[j] + pa_xzzz[j] * pc_xy[j] + 3.0 * pa_xzz[j] * pc_yz[j] * pb_x[j] + 3.0 * pa_xzz[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_xz[j] * pc_zz[j] * pb_xy[j] + pc_xy[j] * pa_zzz[j] * pb_x[j] + pc_xx[j] * pa_zzz[j] * pb_y[j] + 3.0 * pc_xz[j] * pa_zz[j] * pb_xy[j]);

                t_xzzz_xy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_yz[j] - 0.75 * fl2_fx * pa_z[j] * pc_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * fl1_fx * pa_z[j] * pc_yzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] - 1.5 * fl1_fx * pa_zz[j] * pc_yz[j] - 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] - 1.5 * pa_xz[j] * fl1_fx * pc_xy[j] - 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_xx[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xz[j] * fl1_fx * pb_xy[j] - 3.0 * pa_xzz[j] * pc_xyz[j] - 3.0 * pa_xz[j] * pc_yzz[j] * pb_x[j] - 3.0 * pa_xz[j] * pc_xzz[j] * pb_y[j] - pa_x[j] * pc_zzz[j] * pb_xy[j] - pc_xxy[j] * pa_zzz[j] - 3.0 * pc_xyz[j] * pa_zz[j] * pb_x[j] - 3.0 * pc_xxz[j] * pa_zz[j] * pb_y[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_xy[j]);

                t_xzzz_xy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_yz[j] + 0.5 * fl1_fx * pc_yzzz[j] + 1.5 * fl1_fx * pa_z[j] * pc_yzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] + 1.5 * pa_x[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xxz[j] * fl1_fx * pb_y[j] + 3.0 * pa_xz[j] * pc_xyzz[j] + pa_x[j] * pc_yzzz[j] * pb_x[j] + pa_x[j] * pc_xzzz[j] * pb_y[j] + 3.0 * pc_xxyz[j] * pa_zz[j] + 3.0 * pc_xyzz[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xxzz[j] * pa_z[j] * pb_y[j] + pc_xzzz[j] * pb_xy[j]);

                t_xzzz_xy[j] += fl_s_0_0_5 * (-0.5 * fl1_fx * pc_yzzz[j] - 1.5 * pc_xxyz[j] * fl1_fx - pa_x[j] * pc_xyzzz[j] - 3.0 * pc_xxyzz[j] * pa_z[j] - pc_xyzzz[j] * pb_x[j] - pc_xxzzz[j] * pb_y[j]);

                t_xzzz_xy[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_56_57(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (56,57)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xzzz = paDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxzzzz = pcDistances.data(83 * idx + 69);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xzzz_xz = primBuffer.data(90 * idx + 56);

            // Batch of Integrals (56,57)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_xzzz, pa_z, pa_zz, pa_zzz, pb_x, pb_xz, pb_z, pc_x, \
                                     pc_xx, pc_xxz, pc_xxzz, pc_xxzzz, pc_xxzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_xzzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_xzzz_xz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * fl2_fx * pa_zz[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 1.5 * pa_xzz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pa_zzz[j] * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pb_xz[j] + pa_xzzz[j] * pb_xz[j]);

                t_xzzz_xz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * fl2_fx * pa_zz[j] - 2.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 1.5 * pa_x[j] * fl2_fx * pb_x[j] - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_xzz[j] * fl1_fx * pc_x[j] - 1.5 * pa_xzz[j] * fl1_fx * pb_x[j] - 4.5 * pa_xz[j] * pc_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_x[j] * pa_zz[j] * fl1_fx * pb_x[j] - 0.5 * fl1_fx * pa_zzz[j] * pc_z[j] - 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_zzz[j] * pb_z[j] - 1.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_z[j] - 1.5 * pa_xz[j] * fl1_fx * pb_xz[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_xz[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_xz[j] - pa_xzzz[j] * pb_x[j] * pc_z[j] - pa_xzzz[j] * pc_x[j] * pb_z[j] - 3.0 * pa_xzz[j] * pc_z[j] * pb_xz[j] - pc_x[j] * pa_zzz[j] * pb_xz[j]);

                t_xzzz_xz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 4.5 * fl2_fx * pa_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_zz[j] + 0.75 * fl2_fx * pa_zz[j] + 1.5 * pa_x[j] * fl2_fx * pc_x[j] + 0.75 * pa_x[j] * fl2_fx * pb_x[j] + 0.75 * pc_xx[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_x[j] + 1.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 1.5 * pa_xzz[j] * fl1_fx * pc_x[j] + 4.5 * pa_xz[j] * pc_xz[j] * fl1_fx + 4.5 * pa_xz[j] * pc_z[j] * fl1_fx * pb_x[j] + 3.0 * pa_x[j] * pc_zz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xx[j] * pa_zz[j] * fl1_fx + 1.5 * pc_x[j] * pa_zz[j] * fl1_fx * pb_x[j] + 4.5 * pc_xz[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * fl1_fx * pa_zz[j] * pc_zz[j] + 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pa_zzz[j] * pc_z[j] + 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_xz[j] + 1.5 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_xz[j] + 1.5 * pc_xz[j] * fl1_fx * pb_xz[j] + pa_xzzz[j] * pc_xz[j] + 3.0 * pa_xzz[j] * pc_zz[j] * pb_x[j] + 3.0 * pa_xzz[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_xz[j] * pc_zz[j] * pb_xz[j] + pc_xz[j] * pa_zzz[j] * pb_x[j] + pc_xx[j] * pa_zzz[j] * pb_z[j] + 3.0 * pc_xz[j] * pa_zz[j] * pb_xz[j]);

                t_xzzz_xz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * fl2_fx * pc_zz[j] - 2.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * pa_x[j] * fl2_fx * pc_x[j] - 1.5 * pc_xx[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 4.5 * pa_xz[j] * pc_xz[j] * fl1_fx - 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_zz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xx[j] * pa_zz[j] * fl1_fx - 4.5 * pc_xxz[j] * pa_z[j] * fl1_fx - 4.5 * pc_xz[j] * pa_z[j] * fl1_fx * pb_x[j] - 3.0 * pc_xzz[j] * fl1_fx * pb_x[j] - 1.5 * fl1_fx * pa_z[j] * pc_zzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_z[j] - 1.5 * fl1_fx * pa_zz[j] * pc_zz[j] - 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] - 1.5 * pa_x[j] * pc_xz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xx[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xxz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_xz[j] - 3.0 * pa_xzz[j] * pc_xzz[j] - 3.0 * pa_xz[j] * pc_zzz[j] * pb_x[j] - 3.0 * pa_xz[j] * pc_xzz[j] * pb_z[j] - pa_x[j] * pc_zzz[j] * pb_xz[j] - pc_xxz[j] * pa_zzz[j] - 3.0 * pc_xzz[j] * pa_zz[j] * pb_x[j] - 3.0 * pc_xxz[j] * pa_zz[j] * pb_z[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_xz[j]);

                t_xzzz_xz[j] += fl_s_0_0_4 * (1.5 * fl2_fx * pc_zz[j] + 0.75 * pc_xx[j] * fl2_fx + 3.0 * pa_x[j] * pc_xzz[j] * fl1_fx + 4.5 * pc_xxz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 3.0 * pc_xzz[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_zzzz[j] + 1.5 * fl1_fx * pa_z[j] * pc_zzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_z[j] + 1.5 * pc_xxz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xz[j] * pc_xzzz[j] + pa_x[j] * pc_zzzz[j] * pb_x[j] + pa_x[j] * pc_xzzz[j] * pb_z[j] + 3.0 * pc_xxzz[j] * pa_zz[j] + 3.0 * pc_xzzz[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xxzz[j] * pa_z[j] * pb_z[j] + pc_xzzz[j] * pb_xz[j]);

                t_xzzz_xz[j] += fl_s_0_0_5 * (-3.0 * pc_xxzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - pa_x[j] * pc_xzzzz[j] - 3.0 * pc_xxzzz[j] * pa_z[j] - pc_xzzzz[j] * pb_x[j] - pc_xxzzz[j] * pb_z[j]);

                t_xzzz_xz[j] += fl_s_0_0_6 * pc_xxzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_57_58(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (57,58)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xzzz = paDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xzzz_yy = primBuffer.data(90 * idx + 57);

            // Batch of Integrals (57,58)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_xzzz, pa_z, pa_zz, pa_zzz, pb_y, pb_yy, pc_x, pc_xy, \
                                     pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, \
                                     pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xzzz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzzz_yy[j] = fl_s_0_0_0 * (0.75 * pa_xz[j] * fl2_fx + 0.5 * pa_xzzz[j] * fl1_fx + 1.5 * pa_xz[j] * fl1_fx * pb_yy[j] + pa_xzzz[j] * pb_yy[j]);

                t_xzzz_yy[j] += fl_s_0_0_1 * (-1.5 * pa_xz[j] * fl2_fx - 0.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 0.5 * pa_xzzz[j] * fl1_fx - 1.5 * pa_xzz[j] * pc_z[j] * fl1_fx - 0.5 * pc_x[j] * pa_zzz[j] * fl1_fx - 3.0 * pa_xz[j] * fl1_fx * pb_y[j] * pc_y[j] - 1.5 * pa_xz[j] * fl1_fx * pb_yy[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yy[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yy[j] - 2.0 * pa_xzzz[j] * pb_y[j] * pc_y[j] - 3.0 * pa_xzz[j] * pc_z[j] * pb_yy[j] - pc_x[j] * pa_zzz[j] * pb_yy[j]);

                t_xzzz_yy[j] += fl_s_0_0_2 * (0.75 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * pc_z[j] * fl2_fx + 1.5 * pc_x[j] * pa_z[j] * fl2_fx + 0.75 * pc_xz[j] * fl2_fx + 1.5 * pa_xzz[j] * pc_z[j] * fl1_fx + 1.5 * pa_xz[j] * pc_zz[j] * fl1_fx + 0.5 * pc_x[j] * pa_zzz[j] * fl1_fx + 1.5 * pc_xz[j] * pa_zz[j] * fl1_fx + 1.5 * pa_xz[j] * fl1_fx * pc_yy[j] + 3.0 * pa_xz[j] * fl1_fx * pb_y[j] * pc_y[j] + 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yy[j] + 3.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yy[j] + 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] + pa_xzzz[j] * pc_yy[j] + 6.0 * pa_xzz[j] * pc_yz[j] * pb_y[j] + 3.0 * pa_xz[j] * pc_zz[j] * pb_yy[j] + 2.0 * pc_xy[j] * pa_zzz[j] * pb_y[j] + 3.0 * pc_xz[j] * pa_zz[j] * pb_yy[j]);

                t_xzzz_yy[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * pc_z[j] * fl2_fx - 0.75 * pc_x[j] * pa_z[j] * fl2_fx - 1.5 * pc_xz[j] * fl2_fx - 1.5 * pa_xz[j] * pc_zz[j] * fl1_fx - 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx - 1.5 * pc_xz[j] * pa_zz[j] * fl1_fx - 1.5 * pc_xzz[j] * pa_z[j] * fl1_fx - 1.5 * pa_xz[j] * fl1_fx * pc_yy[j] - 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yy[j] - 3.0 * pa_xzz[j] * pc_yyz[j] - 6.0 * pa_xz[j] * pc_yzz[j] * pb_y[j] - pa_x[j] * pc_zzz[j] * pb_yy[j] - pc_xyy[j] * pa_zzz[j] - 6.0 * pc_xyz[j] * pa_zz[j] * pb_y[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_yy[j]);

                t_xzzz_yy[j] += fl_s_0_0_4 * (0.75 * pc_xz[j] * fl2_fx + 0.5 * pa_x[j] * pc_zzz[j] * fl1_fx + 1.5 * pc_xzz[j] * pa_z[j] * fl1_fx + 0.5 * pc_xzzz[j] * fl1_fx + 1.5 * pa_x[j] * pc_yyz[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_xz[j] * pc_yyzz[j] + 2.0 * pa_x[j] * pc_yzzz[j] * pb_y[j] + 3.0 * pc_xyyz[j] * pa_zz[j] + 6.0 * pc_xyzz[j] * pa_z[j] * pb_y[j] + pc_xzzz[j] * pb_yy[j]);

                t_xzzz_yy[j] += fl_s_0_0_5 * (-0.5 * pc_xzzz[j] * fl1_fx - 1.5 * pc_xyyz[j] * fl1_fx - pa_x[j] * pc_yyzzz[j] - 3.0 * pc_xyyzz[j] * pa_z[j] - 2.0 * pc_xyzzz[j] * pb_y[j]);

                t_xzzz_yy[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_58_59(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (58,59)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xzzz = paDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xzzz_yz = primBuffer.data(90 * idx + 58);

            // Batch of Integrals (58,59)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_xzzz, pa_z, pa_zz, pa_zzz, pb_y, pb_yz, pb_z, pc_x, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_y, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xzzz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzzz_yz[j] = fl_s_0_0_0 * (0.75 * pa_x[j] * fl2_fx * pb_y[j] + 1.5 * pa_xzz[j] * fl1_fx * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pb_yz[j] + pa_xzzz[j] * pb_yz[j]);

                t_xzzz_yz[j] += fl_s_0_0_1 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pa_x[j] * fl2_fx * pb_y[j] - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 1.5 * pa_xzz[j] * fl1_fx * pc_y[j] - 1.5 * pa_xzz[j] * fl1_fx * pb_y[j] - 4.5 * pa_xz[j] * pc_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_x[j] * pa_zz[j] * fl1_fx * pb_y[j] - 1.5 * pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_xz[j] * fl1_fx * pb_yz[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yz[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yz[j] - pa_xzzz[j] * pb_y[j] * pc_z[j] - pa_xzzz[j] * pc_y[j] * pb_z[j] - 3.0 * pa_xzz[j] * pc_z[j] * pb_yz[j] - pc_x[j] * pa_zzz[j] * pb_yz[j]);

                t_xzzz_yz[j] += fl_s_0_0_2 * (1.5 * pa_x[j] * fl2_fx * pc_y[j] + 0.75 * pa_x[j] * fl2_fx * pb_y[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_x[j] * fl2_fx * pb_y[j] + 1.5 * pa_xzz[j] * fl1_fx * pc_y[j] + 4.5 * pa_xz[j] * pc_yz[j] * fl1_fx + 4.5 * pa_xz[j] * pc_z[j] * fl1_fx * pb_y[j] + 3.0 * pa_x[j] * pc_zz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx + 1.5 * pc_x[j] * pa_zz[j] * fl1_fx * pb_y[j] + 4.5 * pc_xz[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pa_xz[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_yz[j] + 1.5 * pc_xz[j] * fl1_fx * pb_yz[j] + pa_xzzz[j] * pc_yz[j] + 3.0 * pa_xzz[j] * pc_zz[j] * pb_y[j] + 3.0 * pa_xzz[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_xz[j] * pc_zz[j] * pb_yz[j] + pc_xz[j] * pa_zzz[j] * pb_y[j] + pc_xy[j] * pa_zzz[j] * pb_z[j] + 3.0 * pc_xz[j] * pa_zz[j] * pb_yz[j]);

                t_xzzz_yz[j] += fl_s_0_0_3 * (-0.75 * pa_x[j] * fl2_fx * pc_y[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_x[j] * fl2_fx * pb_y[j] - 4.5 * pa_xz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx - 3.0 * pa_x[j] * pc_zz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx - 4.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 4.5 * pc_xz[j] * pa_z[j] * fl1_fx * pb_y[j] - 3.0 * pc_xzz[j] * fl1_fx * pb_y[j] - 1.5 * pa_x[j] * pc_yz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_yz[j] - 3.0 * pa_xzz[j] * pc_yzz[j] - 3.0 * pa_xz[j] * pc_zzz[j] * pb_y[j] - 3.0 * pa_xz[j] * pc_yzz[j] * pb_z[j] - pa_x[j] * pc_zzz[j] * pb_yz[j] - pc_xyz[j] * pa_zzz[j] - 3.0 * pc_xzz[j] * pa_zz[j] * pb_y[j] - 3.0 * pc_xyz[j] * pa_zz[j] * pb_z[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_yz[j]);

                t_xzzz_yz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_x[j] * pc_yzz[j] * fl1_fx + 4.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xzz[j] * fl1_fx * pb_y[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xz[j] * pc_yzzz[j] + pa_x[j] * pc_zzzz[j] * pb_y[j] + pa_x[j] * pc_yzzz[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pa_zz[j] + 3.0 * pc_xzzz[j] * pa_z[j] * pb_y[j] + 3.0 * pc_xyzz[j] * pa_z[j] * pb_z[j] + pc_xzzz[j] * pb_yz[j]);

                t_xzzz_yz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - pa_x[j] * pc_yzzzz[j] - 3.0 * pc_xyzzz[j] * pa_z[j] - pc_xzzzz[j] * pb_y[j] - pc_xyzzz[j] * pb_z[j]);

                t_xzzz_yz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_59_60(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (59,60)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_x = paDistances.data(34 * idx);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_xz = paDistances.data(34 * idx + 5);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_xzz = paDistances.data(34 * idx + 14);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_xzzz = paDistances.data(34 * idx + 28);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xzzzzz = pcDistances.data(83 * idx + 75);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_xzzz_zz = primBuffer.data(90 * idx + 59);

            // Batch of Integrals (59,60)

            #pragma omp simd aligned(fx, pa_x, pa_xz, pa_xzz, pa_xzzz, pa_z, pa_zz, pa_zzz, pb_z, pb_zz, pc_x, pc_xz, \
                                     pc_xzz, pc_xzzz, pc_xzzzz, pc_xzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_xzzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_xzzz_zz[j] = fl_s_0_0_0 * (2.25 * pa_xz[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_z[j] + 0.5 * pa_xzzz[j] * fl1_fx + 3.0 * pa_xzz[j] * fl1_fx * pb_z[j] + 1.5 * pa_xz[j] * fl1_fx * pb_zz[j] + pa_xzzz[j] * pb_zz[j]);

                t_xzzz_zz[j] += fl_s_0_0_1 * (-4.5 * pa_xz[j] * fl2_fx - 3.75 * pa_x[j] * pc_z[j] * fl2_fx - 2.25 * pc_x[j] * pa_z[j] * fl2_fx - 3.0 * pa_x[j] * fl2_fx * pb_z[j] - 1.5 * pc_x[j] * fl2_fx * pb_z[j] - 0.5 * pa_xzzz[j] * fl1_fx - 4.5 * pa_xzz[j] * pc_z[j] * fl1_fx - 3.0 * pa_xzz[j] * fl1_fx * pb_z[j] - 9.0 * pa_xz[j] * pc_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_x[j] * pa_zzz[j] * fl1_fx - 3.0 * pc_x[j] * pa_zz[j] * fl1_fx * pb_z[j] - 1.5 * pa_xz[j] * fl1_fx * pb_zz[j] - 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_zz[j] - 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_xzzz[j] * pb_z[j] * pc_z[j] - 3.0 * pa_xzz[j] * pc_z[j] * pb_zz[j] - pc_x[j] * pa_zzz[j] * pb_zz[j]);

                t_xzzz_zz[j] += fl_s_0_0_2 * (2.25 * pa_xz[j] * fl2_fx + 7.5 * pa_x[j] * pc_z[j] * fl2_fx + 4.5 * pc_x[j] * pa_z[j] * fl2_fx + 3.75 * pc_xz[j] * fl2_fx + 1.5 * pa_x[j] * fl2_fx * pb_z[j] + 3.0 * pc_x[j] * fl2_fx * pb_z[j] + 4.5 * pa_xzz[j] * pc_z[j] * fl1_fx + 9.0 * pa_xz[j] * pc_zz[j] * fl1_fx + 9.0 * pa_xz[j] * pc_z[j] * fl1_fx * pb_z[j] + 6.0 * pa_x[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.5 * pc_x[j] * pa_zzz[j] * fl1_fx + 4.5 * pc_xz[j] * pa_zz[j] * fl1_fx + 3.0 * pc_x[j] * pa_zz[j] * fl1_fx * pb_z[j] + 9.0 * pc_xz[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pa_x[j] * pc_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_x[j] * pa_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] + pa_xzzz[j] * pc_zz[j] + 6.0 * pa_xzz[j] * pc_zz[j] * pb_z[j] + 3.0 * pa_xz[j] * pc_zz[j] * pb_zz[j] + 2.0 * pc_xz[j] * pa_zzz[j] * pb_z[j] + 3.0 * pc_xz[j] * pa_zz[j] * pb_zz[j]);

                t_xzzz_zz[j] += fl_s_0_0_3 * (-3.75 * pa_x[j] * pc_z[j] * fl2_fx - 2.25 * pc_x[j] * pa_z[j] * fl2_fx - 7.5 * pc_xz[j] * fl2_fx - 1.5 * pc_x[j] * fl2_fx * pb_z[j] - 9.0 * pa_xz[j] * pc_zz[j] * fl1_fx - 5.0 * pa_x[j] * pc_zzz[j] * fl1_fx - 6.0 * pa_x[j] * pc_zz[j] * fl1_fx * pb_z[j] - 4.5 * pc_xz[j] * pa_zz[j] * fl1_fx - 9.0 * pc_xzz[j] * pa_z[j] * fl1_fx - 9.0 * pc_xz[j] * pa_z[j] * fl1_fx * pb_z[j] - 6.0 * pc_xzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xz[j] * fl1_fx * pb_zz[j] - 3.0 * pa_xzz[j] * pc_zzz[j] - 6.0 * pa_xz[j] * pc_zzz[j] * pb_z[j] - pa_x[j] * pc_zzz[j] * pb_zz[j] - pc_xzz[j] * pa_zzz[j] - 6.0 * pc_xzz[j] * pa_zz[j] * pb_z[j] - 3.0 * pc_xzz[j] * pa_z[j] * pb_zz[j]);

                t_xzzz_zz[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 5.0 * pa_x[j] * pc_zzz[j] * fl1_fx + 9.0 * pc_xzz[j] * pa_z[j] * fl1_fx + 5.0 * pc_xzzz[j] * fl1_fx + 6.0 * pc_xzz[j] * fl1_fx * pb_z[j] + 3.0 * pa_xz[j] * pc_zzzz[j] + 2.0 * pa_x[j] * pc_zzzz[j] * pb_z[j] + 3.0 * pc_xzzz[j] * pa_zz[j] + 6.0 * pc_xzzz[j] * pa_z[j] * pb_z[j] + pc_xzzz[j] * pb_zz[j]);

                t_xzzz_zz[j] += fl_s_0_0_5 * (-5.0 * pc_xzzz[j] * fl1_fx - pa_x[j] * pc_zzzzz[j] - 3.0 * pc_xzzzz[j] * pa_z[j] - 2.0 * pc_xzzzz[j] * pb_z[j]);

                t_xzzz_zz[j] += fl_s_0_0_6 * pc_xzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_60_61(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (60,61)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyy = paDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyy = pcDistances.data(83 * idx + 65);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyy_xx = primBuffer.data(90 * idx + 60);

            // Batch of Integrals (60,61)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyy, pb_x, pb_xx, pc_x, pc_xx, pc_xxy, pc_xxyy, \
                                     pc_xxyyy, pc_xxyyyy, pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyy_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyyy_xx[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 1.5 * pa_yy[j] * fl2_fx + 0.5 * pa_yyyy[j] * fl1_fx + 0.75 * fl2_fx * pb_xx[j] + 3.0 * pa_yy[j] * fl1_fx * pb_xx[j] + pa_yyyy[j] * pb_xx[j]);

                t_yyyy_xx[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 3.0 * pa_yy[j] * fl2_fx - 3.0 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * pa_yyyy[j] * fl1_fx - 2.0 * pa_yyy[j] * pc_y[j] * fl1_fx - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 1.5 * fl2_fx * pb_xx[j] - 6.0 * pa_yy[j] * fl1_fx * pb_x[j] * pc_x[j] - 3.0 * pa_yy[j] * fl1_fx * pb_xx[j] - 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_xx[j] - 2.0 * pa_yyyy[j] * pb_x[j] * pc_x[j] - 4.0 * pa_yyy[j] * pc_y[j] * pb_xx[j]);

                t_yyyy_xx[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_yy[j] * fl2_fx + 6.0 * pa_y[j] * pc_y[j] * fl2_fx + 1.5 * pc_yy[j] * fl2_fx + 2.0 * pa_yyy[j] * pc_y[j] * fl1_fx + 3.0 * pa_yy[j] * pc_yy[j] * fl1_fx + 0.75 * fl2_fx * pc_xx[j] + 3.0 * fl2_fx * pb_x[j] * pc_x[j] + 0.75 * fl2_fx * pb_xx[j] + 3.0 * pa_yy[j] * fl1_fx * pc_xx[j] + 6.0 * pa_yy[j] * fl1_fx * pb_x[j] * pc_x[j] + 12.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_x[j] + 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_xx[j] + 3.0 * pc_yy[j] * fl1_fx * pb_xx[j] + pa_yyyy[j] * pc_xx[j] + 8.0 * pa_yyy[j] * pc_xy[j] * pb_x[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_xx[j]);

                t_yyyy_xx[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * pc_yy[j] * fl2_fx - 3.0 * pa_yy[j] * pc_yy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyy[j] * fl1_fx - 1.5 * fl2_fx * pc_xx[j] - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 3.0 * pa_yy[j] * fl1_fx * pc_xx[j] - 6.0 * pa_y[j] * pc_xxy[j] * fl1_fx - 12.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_x[j] - 6.0 * pc_xyy[j] * fl1_fx * pb_x[j] - 3.0 * pc_yy[j] * fl1_fx * pb_xx[j] - 4.0 * pa_yyy[j] * pc_xxy[j] - 12.0 * pa_yy[j] * pc_xyy[j] * pb_x[j] - 4.0 * pa_y[j] * pc_yyy[j] * pb_xx[j]);

                t_yyyy_xx[j] += fl_s_0_0_4 * (1.5 * pc_yy[j] * fl2_fx + 2.0 * pa_y[j] * pc_yyy[j] * fl1_fx + 0.5 * pc_yyyy[j] * fl1_fx + 0.75 * fl2_fx * pc_xx[j] + 6.0 * pa_y[j] * pc_xxy[j] * fl1_fx + 3.0 * pc_xxyy[j] * fl1_fx + 6.0 * pc_xyy[j] * fl1_fx * pb_x[j] + 6.0 * pa_yy[j] * pc_xxyy[j] + 8.0 * pa_y[j] * pc_xyyy[j] * pb_x[j] + pc_yyyy[j] * pb_xx[j]);

                t_yyyy_xx[j] += fl_s_0_0_5 * (-0.5 * pc_yyyy[j] * fl1_fx - 3.0 * pc_xxyy[j] * fl1_fx - 4.0 * pa_y[j] * pc_xxyyy[j] - 2.0 * pc_xyyyy[j] * pb_x[j]);

                t_yyyy_xx[j] += fl_s_0_0_6 * pc_xxyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_61_62(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (61,62)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyy = paDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyy = pcDistances.data(83 * idx + 70);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyy_xy = primBuffer.data(90 * idx + 61);

            // Batch of Integrals (61,62)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyy, pb_x, pb_xy, pb_y, pc_x, pc_xy, pc_xyy, pc_xyyy, \
                                     pc_xyyyy, pc_xyyyyy, pc_y, pc_yy, pc_yyy, pc_yyyy, pc_yyyyy, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyy_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyy_xy[j] = fl_s_0_0_0 * (3.0 * pa_y[j] * fl2_fx * pb_x[j] + 2.0 * pa_yyy[j] * fl1_fx * pb_x[j] + 0.75 * fl2_fx * pb_xy[j] + 3.0 * pa_yy[j] * fl1_fx * pb_xy[j] + pa_yyyy[j] * pb_xy[j]);

                t_yyyy_xy[j] += fl_s_0_0_1 * (-3.0 * pa_y[j] * fl2_fx * pc_x[j] - 6.0 * pa_y[j] * fl2_fx * pb_x[j] - 3.75 * pc_y[j] * fl2_fx * pb_x[j] - 2.0 * pa_yyy[j] * fl1_fx * pc_x[j] - 2.0 * pa_yyy[j] * fl1_fx * pb_x[j] - 9.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * fl2_fx * pb_xy[j] - 3.0 * pa_yy[j] * fl1_fx * pc_x[j] * pb_y[j] - 3.0 * pa_yy[j] * fl1_fx * pb_xy[j] - 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_xy[j] - pa_yyyy[j] * pb_x[j] * pc_y[j] - pa_yyyy[j] * pc_x[j] * pb_y[j] - 4.0 * pa_yyy[j] * pc_y[j] * pb_xy[j]);

                t_yyyy_xy[j] += fl_s_0_0_2 * (6.0 * pa_y[j] * fl2_fx * pc_x[j] + 3.0 * pa_y[j] * fl2_fx * pb_x[j] + 3.75 * pc_xy[j] * fl2_fx + 7.5 * pc_y[j] * fl2_fx * pb_x[j] + 2.0 * pa_yyy[j] * fl1_fx * pc_x[j] + 9.0 * pa_yy[j] * pc_xy[j] * fl1_fx + 9.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_x[j] + 12.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_x[j] + 1.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 3.0 * pa_yy[j] * fl1_fx * pc_x[j] * pb_y[j] + 6.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_y[j] + 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_xy[j] + 3.0 * pc_yy[j] * fl1_fx * pb_xy[j] + pa_yyyy[j] * pc_xy[j] + 4.0 * pa_yyy[j] * pc_yy[j] * pb_x[j] + 4.0 * pa_yyy[j] * pc_xy[j] * pb_y[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_xy[j]);

                t_yyyy_xy[j] += fl_s_0_0_3 * (-3.0 * pa_y[j] * fl2_fx * pc_x[j] - 7.5 * pc_xy[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx * pb_x[j] - 9.0 * pa_yy[j] * pc_xy[j] * fl1_fx - 12.0 * pa_y[j] * pc_xyy[j] * fl1_fx - 12.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_x[j] - 5.0 * pc_yyy[j] * fl1_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 6.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_y[j] - 3.0 * pc_xyy[j] * fl1_fx * pb_y[j] - 3.0 * pc_yy[j] * fl1_fx * pb_xy[j] - 4.0 * pa_yyy[j] * pc_xyy[j] - 6.0 * pa_yy[j] * pc_yyy[j] * pb_x[j] - 6.0 * pa_yy[j] * pc_xyy[j] * pb_y[j] - 4.0 * pa_y[j] * pc_yyy[j] * pb_xy[j]);

                t_yyyy_xy[j] += fl_s_0_0_4 * (3.75 * pc_xy[j] * fl2_fx + 12.0 * pa_y[j] * pc_xyy[j] * fl1_fx + 5.0 * pc_xyyy[j] * fl1_fx + 5.0 * pc_yyy[j] * fl1_fx * pb_x[j] + 3.0 * pc_xyy[j] * fl1_fx * pb_y[j] + 6.0 * pa_yy[j] * pc_xyyy[j] + 4.0 * pa_y[j] * pc_yyyy[j] * pb_x[j] + 4.0 * pa_y[j] * pc_xyyy[j] * pb_y[j] + pc_yyyy[j] * pb_xy[j]);

                t_yyyy_xy[j] += fl_s_0_0_5 * (-5.0 * pc_xyyy[j] * fl1_fx - 4.0 * pa_y[j] * pc_xyyyy[j] - pc_yyyyy[j] * pb_x[j] - pc_xyyyy[j] * pb_y[j]);

                t_yyyy_xy[j] += fl_s_0_0_6 * pc_xyyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_62_63(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (62,63)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyy = paDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyy_xz = primBuffer.data(90 * idx + 62);

            // Batch of Integrals (62,63)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyy, pb_x, pb_xz, pb_z, pc_x, pc_xy, pc_xyy, pc_xyyy, \
                                     pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_yyyy_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyy_xz[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xz[j] + 3.0 * pa_yy[j] * fl1_fx * pb_xz[j] + pa_yyyy[j] * pb_xz[j]);

                t_yyyy_xz[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * fl2_fx * pb_xz[j] - 3.0 * pa_yy[j] * fl1_fx * pb_x[j] * pc_z[j] - 3.0 * pa_yy[j] * fl1_fx * pc_x[j] * pb_z[j] - 3.0 * pa_yy[j] * fl1_fx * pb_xz[j] - 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_xz[j] - pa_yyyy[j] * pb_x[j] * pc_z[j] - pa_yyyy[j] * pc_x[j] * pb_z[j] - 4.0 * pa_yyy[j] * pc_y[j] * pb_xz[j]);

                t_yyyy_xz[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_xz[j] + 1.5 * fl2_fx * pb_x[j] * pc_z[j] + 1.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 3.0 * pa_yy[j] * fl1_fx * pc_xz[j] + 3.0 * pa_yy[j] * fl1_fx * pb_x[j] * pc_z[j] + 3.0 * pa_yy[j] * fl1_fx * pc_x[j] * pb_z[j] + 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] + 6.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] + 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_xz[j] + 3.0 * pc_yy[j] * fl1_fx * pb_xz[j] + pa_yyyy[j] * pc_xz[j] + 4.0 * pa_yyy[j] * pc_yz[j] * pb_x[j] + 4.0 * pa_yyy[j] * pc_xy[j] * pb_z[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_xz[j]);

                t_yyyy_xz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pb_x[j] * pc_z[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 3.0 * pa_yy[j] * fl1_fx * pc_xz[j] - 6.0 * pa_y[j] * pc_xyz[j] * fl1_fx - 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] - 6.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] - 3.0 * pc_yy[j] * fl1_fx * pb_xz[j] - 4.0 * pa_yyy[j] * pc_xyz[j] - 6.0 * pa_yy[j] * pc_yyz[j] * pb_x[j] - 6.0 * pa_yy[j] * pc_xyy[j] * pb_z[j] - 4.0 * pa_y[j] * pc_yyy[j] * pb_xz[j]);

                t_yyyy_xz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 6.0 * pa_y[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + 3.0 * pc_yyz[j] * fl1_fx * pb_x[j] + 3.0 * pc_xyy[j] * fl1_fx * pb_z[j] + 6.0 * pa_yy[j] * pc_xyyz[j] + 4.0 * pa_y[j] * pc_yyyz[j] * pb_x[j] + 4.0 * pa_y[j] * pc_xyyy[j] * pb_z[j] + pc_yyyy[j] * pb_xz[j]);

                t_yyyy_xz[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - 4.0 * pa_y[j] * pc_xyyyz[j] - pc_yyyyz[j] * pb_x[j] - pc_xyyyy[j] * pb_z[j]);

                t_yyyy_xz[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_63_64(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (63,64)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyy = paDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyyy = pcDistances.data(83 * idx + 76);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyy_yy = primBuffer.data(90 * idx + 63);

            // Batch of Integrals (63,64)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyy, pb_y, pb_yy, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyy, pc_yyyyyy, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yyyy_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyyy_yy[j] = fl_s_0_0_0 * (1.875 * fl3_fx + 4.5 * pa_yy[j] * fl2_fx + 6.0 * pa_y[j] * fl2_fx * pb_y[j] + 0.5 * pa_yyyy[j] * fl1_fx + 4.0 * pa_yyy[j] * fl1_fx * pb_y[j] + 0.75 * fl2_fx * pb_yy[j] + 3.0 * pa_yy[j] * fl1_fx * pb_yy[j] + pa_yyyy[j] * pb_yy[j]);

                t_yyyy_yy[j] += fl_s_0_0_1 * (-5.625 * fl3_fx - 9.0 * pa_yy[j] * fl2_fx - 15.0 * pa_y[j] * pc_y[j] * fl2_fx - 12.0 * pa_y[j] * fl2_fx * pb_y[j] - 7.5 * pc_y[j] * fl2_fx * pb_y[j] - 0.5 * pa_yyyy[j] * fl1_fx - 6.0 * pa_yyy[j] * pc_y[j] * fl1_fx - 4.0 * pa_yyy[j] * fl1_fx * pb_y[j] - 18.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_y[j] - 1.5 * fl2_fx * pb_yy[j] - 3.0 * pa_yy[j] * fl1_fx * pb_yy[j] - 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_yy[j] - 2.0 * pa_yyyy[j] * pb_y[j] * pc_y[j] - 4.0 * pa_yyy[j] * pc_y[j] * pb_yy[j]);

                t_yyyy_yy[j] += fl_s_0_0_2 * (5.625 * fl3_fx + 4.5 * pa_yy[j] * fl2_fx + 30.0 * pa_y[j] * pc_y[j] * fl2_fx + 11.25 * pc_yy[j] * fl2_fx + 6.0 * pa_y[j] * fl2_fx * pb_y[j] + 15.0 * pc_y[j] * fl2_fx * pb_y[j] + 6.0 * pa_yyy[j] * pc_y[j] * fl1_fx + 18.0 * pa_yy[j] * pc_yy[j] * fl1_fx + 18.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_y[j] + 24.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] + 0.75 * fl2_fx * pb_yy[j] + 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_yy[j] + 3.0 * pc_yy[j] * fl1_fx * pb_yy[j] + pa_yyyy[j] * pc_yy[j] + 8.0 * pa_yyy[j] * pc_yy[j] * pb_y[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_yy[j]);

                t_yyyy_yy[j] += fl_s_0_0_3 * (-1.875 * fl3_fx - 15.0 * pa_y[j] * pc_y[j] * fl2_fx - 22.5 * pc_yy[j] * fl2_fx - 7.5 * pc_y[j] * fl2_fx * pb_y[j] - 18.0 * pa_yy[j] * pc_yy[j] * fl1_fx - 20.0 * pa_y[j] * pc_yyy[j] * fl1_fx - 24.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] - 10.0 * pc_yyy[j] * fl1_fx * pb_y[j] - 3.0 * pc_yy[j] * fl1_fx * pb_yy[j] - 4.0 * pa_yyy[j] * pc_yyy[j] - 12.0 * pa_yy[j] * pc_yyy[j] * pb_y[j] - 4.0 * pa_y[j] * pc_yyy[j] * pb_yy[j]);

                t_yyyy_yy[j] += fl_s_0_0_4 * (11.25 * pc_yy[j] * fl2_fx + 20.0 * pa_y[j] * pc_yyy[j] * fl1_fx + 7.5 * pc_yyyy[j] * fl1_fx + 10.0 * pc_yyy[j] * fl1_fx * pb_y[j] + 6.0 * pa_yy[j] * pc_yyyy[j] + 8.0 * pa_y[j] * pc_yyyy[j] * pb_y[j] + pc_yyyy[j] * pb_yy[j]);

                t_yyyy_yy[j] += fl_s_0_0_5 * (-7.5 * pc_yyyy[j] * fl1_fx - 4.0 * pa_y[j] * pc_yyyyy[j] - 2.0 * pc_yyyyy[j] * pb_y[j]);

                t_yyyy_yy[j] += fl_s_0_0_6 * pc_yyyyyy[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_64_65(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (64,65)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyy = paDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyyz = pcDistances.data(83 * idx + 77);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyy_yz = primBuffer.data(90 * idx + 64);

            // Batch of Integrals (64,65)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyy, pb_y, pb_yz, pb_z, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyy, pc_yyyyyz, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyy_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyy_yz[j] = fl_s_0_0_0 * (3.0 * pa_y[j] * fl2_fx * pb_z[j] + 2.0 * pa_yyy[j] * fl1_fx * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 3.0 * pa_yy[j] * fl1_fx * pb_yz[j] + pa_yyyy[j] * pb_yz[j]);

                t_yyyy_yz[j] += fl_s_0_0_1 * (-3.0 * pa_y[j] * fl2_fx * pc_z[j] - 6.0 * pa_y[j] * fl2_fx * pb_z[j] - 3.75 * pc_y[j] * fl2_fx * pb_z[j] - 2.0 * pa_yyy[j] * fl1_fx * pc_z[j] - 2.0 * pa_yyy[j] * fl1_fx * pb_z[j] - 9.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 1.5 * fl2_fx * pb_yz[j] - 3.0 * pa_yy[j] * fl1_fx * pb_y[j] * pc_z[j] - 3.0 * pa_yy[j] * fl1_fx * pb_yz[j] - 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_yz[j] - pa_yyyy[j] * pb_y[j] * pc_z[j] - pa_yyyy[j] * pc_y[j] * pb_z[j] - 4.0 * pa_yyy[j] * pc_y[j] * pb_yz[j]);

                t_yyyy_yz[j] += fl_s_0_0_2 * (6.0 * pa_y[j] * fl2_fx * pc_z[j] + 3.0 * pa_y[j] * fl2_fx * pb_z[j] + 3.75 * pc_yz[j] * fl2_fx + 7.5 * pc_y[j] * fl2_fx * pb_z[j] + 2.0 * pa_yyy[j] * fl1_fx * pc_z[j] + 9.0 * pa_yy[j] * pc_yz[j] * fl1_fx + 9.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_z[j] + 12.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] + 1.5 * fl2_fx * pb_y[j] * pc_z[j] + 0.75 * fl2_fx * pb_yz[j] + 3.0 * pa_yy[j] * fl1_fx * pb_y[j] * pc_z[j] + 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] + 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_yz[j] + 3.0 * pc_yy[j] * fl1_fx * pb_yz[j] + pa_yyyy[j] * pc_yz[j] + 4.0 * pa_yyy[j] * pc_yz[j] * pb_y[j] + 4.0 * pa_yyy[j] * pc_yy[j] * pb_z[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_yz[j]);

                t_yyyy_yz[j] += fl_s_0_0_3 * (-3.0 * pa_y[j] * fl2_fx * pc_z[j] - 7.5 * pc_yz[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx * pb_z[j] - 9.0 * pa_yy[j] * pc_yz[j] * fl1_fx - 12.0 * pa_y[j] * pc_yyz[j] * fl1_fx - 12.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] - 5.0 * pc_yyy[j] * fl1_fx * pb_z[j] - 0.75 * fl2_fx * pb_y[j] * pc_z[j] - 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_y[j] - 3.0 * pc_yy[j] * fl1_fx * pb_yz[j] - 4.0 * pa_yyy[j] * pc_yyz[j] - 6.0 * pa_yy[j] * pc_yyz[j] * pb_y[j] - 6.0 * pa_yy[j] * pc_yyy[j] * pb_z[j] - 4.0 * pa_y[j] * pc_yyy[j] * pb_yz[j]);

                t_yyyy_yz[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 12.0 * pa_y[j] * pc_yyz[j] * fl1_fx + 5.0 * pc_yyyz[j] * fl1_fx + 5.0 * pc_yyy[j] * fl1_fx * pb_z[j] + 3.0 * pc_yyz[j] * fl1_fx * pb_y[j] + 6.0 * pa_yy[j] * pc_yyyz[j] + 4.0 * pa_y[j] * pc_yyyz[j] * pb_y[j] + 4.0 * pa_y[j] * pc_yyyy[j] * pb_z[j] + pc_yyyy[j] * pb_yz[j]);

                t_yyyy_yz[j] += fl_s_0_0_5 * (-5.0 * pc_yyyz[j] * fl1_fx - 4.0 * pa_y[j] * pc_yyyyz[j] - pc_yyyyz[j] * pb_y[j] - pc_yyyyy[j] * pb_z[j]);

                t_yyyy_yz[j] += fl_s_0_0_6 * pc_yyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_65_66(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (65,66)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyy = paDistances.data(34 * idx + 29);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyzz = pcDistances.data(83 * idx + 78);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyy_zz = primBuffer.data(90 * idx + 65);

            // Batch of Integrals (65,66)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyy, pb_z, pb_zz, pc_y, pc_yy, pc_yyy, pc_yyyy, \
                                     pc_yyyyz, pc_yyyyzz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyy_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyyy_zz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 1.5 * pa_yy[j] * fl2_fx + 0.5 * pa_yyyy[j] * fl1_fx + 0.75 * fl2_fx * pb_zz[j] + 3.0 * pa_yy[j] * fl1_fx * pb_zz[j] + pa_yyyy[j] * pb_zz[j]);

                t_yyyy_zz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 3.0 * pa_yy[j] * fl2_fx - 3.0 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * pa_yyyy[j] * fl1_fx - 2.0 * pa_yyy[j] * pc_y[j] * fl1_fx - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 1.5 * fl2_fx * pb_zz[j] - 6.0 * pa_yy[j] * fl1_fx * pb_z[j] * pc_z[j] - 3.0 * pa_yy[j] * fl1_fx * pb_zz[j] - 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] - 2.0 * pa_yyyy[j] * pb_z[j] * pc_z[j] - 4.0 * pa_yyy[j] * pc_y[j] * pb_zz[j]);

                t_yyyy_zz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_yy[j] * fl2_fx + 6.0 * pa_y[j] * pc_y[j] * fl2_fx + 1.5 * pc_yy[j] * fl2_fx + 2.0 * pa_yyy[j] * pc_y[j] * fl1_fx + 3.0 * pa_yy[j] * pc_yy[j] * fl1_fx + 0.75 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pb_z[j] * pc_z[j] + 0.75 * fl2_fx * pb_zz[j] + 3.0 * pa_yy[j] * fl1_fx * pc_zz[j] + 6.0 * pa_yy[j] * fl1_fx * pb_z[j] * pc_z[j] + 12.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 6.0 * pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] + 3.0 * pc_yy[j] * fl1_fx * pb_zz[j] + pa_yyyy[j] * pc_zz[j] + 8.0 * pa_yyy[j] * pc_yz[j] * pb_z[j] + 6.0 * pa_yy[j] * pc_yy[j] * pb_zz[j]);

                t_yyyy_zz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * pc_yy[j] * fl2_fx - 3.0 * pa_yy[j] * pc_yy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyy[j] * fl1_fx - 1.5 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pb_z[j] * pc_z[j] - 3.0 * pa_yy[j] * fl1_fx * pc_zz[j] - 6.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 12.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 6.0 * pc_yyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yy[j] * fl1_fx * pb_zz[j] - 4.0 * pa_yyy[j] * pc_yzz[j] - 12.0 * pa_yy[j] * pc_yyz[j] * pb_z[j] - 4.0 * pa_y[j] * pc_yyy[j] * pb_zz[j]);

                t_yyyy_zz[j] += fl_s_0_0_4 * (1.5 * pc_yy[j] * fl2_fx + 2.0 * pa_y[j] * pc_yyy[j] * fl1_fx + 0.5 * pc_yyyy[j] * fl1_fx + 0.75 * fl2_fx * pc_zz[j] + 6.0 * pa_y[j] * pc_yzz[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 6.0 * pc_yyz[j] * fl1_fx * pb_z[j] + 6.0 * pa_yy[j] * pc_yyzz[j] + 8.0 * pa_y[j] * pc_yyyz[j] * pb_z[j] + pc_yyyy[j] * pb_zz[j]);

                t_yyyy_zz[j] += fl_s_0_0_5 * (-0.5 * pc_yyyy[j] * fl1_fx - 3.0 * pc_yyzz[j] * fl1_fx - 4.0 * pa_y[j] * pc_yyyzz[j] - 2.0 * pc_yyyyz[j] * pb_z[j]);

                t_yyyy_zz[j] += fl_s_0_0_6 * pc_yyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_66_67(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (66,67)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyz = paDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyy = pcDistances.data(83 * idx + 40);

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyyz = pcDistances.data(83 * idx + 66);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyz_xx = primBuffer.data(90 * idx + 66);

            // Batch of Integrals (66,67)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyz, pa_yyz, pa_yz, pa_z, pb_x, pb_xx, pc_x, pc_xx, \
                                     pc_xxy, pc_xxyy, pc_xxyyy, pc_xxyyyz, pc_xxyyz, pc_xxyz, pc_xxz, pc_xy, pc_xyy, \
                                     pc_xyyy, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyz, pc_yz, \
                                     pc_z, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyz_xx[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 0.5 * pa_yyyz[j] * fl1_fx + 1.5 * pa_yz[j] * fl1_fx * pb_xx[j] + pa_yyyz[j] * pb_xx[j]);

                t_yyyz_xx[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * fl2_fx * pc_z[j] - 0.75 * pc_y[j] * fl2_fx * pa_z[j] - 0.5 * pa_yyyz[j] * fl1_fx - 0.5 * pa_yyy[j] * pc_z[j] * fl1_fx - 1.5 * pa_yyz[j] * pc_y[j] * fl1_fx - 3.0 * pa_yz[j] * fl1_fx * pb_x[j] * pc_x[j] - 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_xx[j] - 1.5 * pa_yz[j] * fl1_fx * pb_xx[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_xx[j] - 2.0 * pa_yyyz[j] * pb_x[j] * pc_x[j] - pa_yyy[j] * pc_z[j] * pb_xx[j] - 3.0 * pa_yyz[j] * pc_y[j] * pb_xx[j]);

                t_yyyz_xx[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl2_fx * pc_z[j] + 0.75 * pa_yz[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx * pa_z[j] + 0.75 * pc_yz[j] * fl2_fx + 0.5 * pa_yyy[j] * pc_z[j] * fl1_fx + 1.5 * pa_yyz[j] * pc_y[j] * fl1_fx + 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx + 1.5 * pa_yz[j] * pc_yy[j] * fl1_fx + 1.5 * pa_yz[j] * fl1_fx * pc_xx[j] + 3.0 * pa_y[j] * fl1_fx * pc_xz[j] * pb_x[j] + 3.0 * pa_yz[j] * fl1_fx * pb_x[j] * pc_x[j] + 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_xx[j] + 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_xx[j] + pa_yyyz[j] * pc_xx[j] + 2.0 * pa_yyy[j] * pc_xz[j] * pb_x[j] + 6.0 * pa_yyz[j] * pc_xy[j] * pb_x[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_xx[j] + 3.0 * pa_yz[j] * pc_yy[j] * pb_xx[j]);

                t_yyyz_xx[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * fl2_fx * pc_z[j] - 1.5 * pc_yz[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pa_z[j] - 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx - 1.5 * pa_yz[j] * pc_yy[j] * fl1_fx - 1.5 * pa_y[j] * pc_yyz[j] * fl1_fx - 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx - 1.5 * pa_y[j] * fl1_fx * pc_xxz[j] - 1.5 * pa_yz[j] * fl1_fx * pc_xx[j] - 3.0 * pa_y[j] * fl1_fx * pc_xz[j] * pb_x[j] - 1.5 * pc_xxy[j] * fl1_fx * pa_z[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xy[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] - pa_yyy[j] * pc_xxz[j] - 3.0 * pa_yyz[j] * pc_xxy[j] - 6.0 * pa_yy[j] * pc_xyz[j] * pb_x[j] - 6.0 * pa_yz[j] * pc_xyy[j] * pb_x[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_xx[j] - pc_yyy[j] * pa_z[j] * pb_xx[j]);

                t_yyyz_xx[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_yyz[j] * fl1_fx + 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx + 0.5 * pc_yyyz[j] * fl1_fx + 1.5 * pa_y[j] * fl1_fx * pc_xxz[j] + 1.5 * pc_xxyz[j] * fl1_fx + 1.5 * pc_xxy[j] * fl1_fx * pa_z[j] + 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] + 3.0 * pa_yy[j] * pc_xxyz[j] + 3.0 * pa_yz[j] * pc_xxyy[j] + 6.0 * pa_y[j] * pc_xyyz[j] * pb_x[j] + 2.0 * pc_xyyy[j] * pa_z[j] * pb_x[j] + pc_yyyz[j] * pb_xx[j]);

                t_yyyz_xx[j] += fl_s_0_0_5 * (-0.5 * pc_yyyz[j] * fl1_fx - 1.5 * pc_xxyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xxyyz[j] - pc_xxyyy[j] * pa_z[j] - 2.0 * pc_xyyyz[j] * pb_x[j]);

                t_yyyz_xx[j] += fl_s_0_0_6 * pc_xxyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_67_68(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (67,68)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyz = paDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyy = pcDistances.data(83 * idx + 44);

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyyz = pcDistances.data(83 * idx + 71);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyz_xy = primBuffer.data(90 * idx + 67);

            // Batch of Integrals (67,68)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyz, pa_yyz, pa_yz, pa_z, pb_x, pb_xy, pb_y, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyy, pc_xyyyyz, pc_xyyyz, pc_xyyz, pc_xyz, pc_xz, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyz_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_yyz[j] * fl1_fx * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pb_xy[j] + pa_yyyz[j] * pb_xy[j]);

                t_yyyz_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * fl2_fx * pa_z[j] * pb_x[j] - 1.5 * pa_yyz[j] * fl1_fx * pc_x[j] - 1.5 * pa_yy[j] * fl1_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yyz[j] * fl1_fx * pb_x[j] - 4.5 * pa_yz[j] * pc_y[j] * fl1_fx * pb_x[j] - 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_y[j] - 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_xy[j] - 1.5 * pa_yz[j] * fl1_fx * pb_xy[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_xy[j] - pa_yyyz[j] * pb_x[j] * pc_y[j] - pa_yyyz[j] * pc_x[j] * pb_y[j] - pa_yyy[j] * pc_z[j] * pb_xy[j] - 3.0 * pa_yyz[j] * pc_y[j] * pb_xy[j]);

                t_yyyz_xy[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_xz[j] + 1.5 * fl2_fx * pa_z[j] * pc_x[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * pa_yy[j] * fl1_fx * pc_xz[j] + 1.5 * pa_yyz[j] * fl1_fx * pc_x[j] + 1.5 * pa_yy[j] * fl1_fx * pc_z[j] * pb_x[j] + 4.5 * pa_yz[j] * pc_xy[j] * fl1_fx + 4.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] + 4.5 * pa_yz[j] * pc_y[j] * fl1_fx * pb_x[j] + 3.0 * pc_yy[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pa_y[j] * fl1_fx * pc_xz[j] * pb_y[j] + 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_xy[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xy[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_xy[j] + pa_yyyz[j] * pc_xy[j] + pa_yyy[j] * pc_yz[j] * pb_x[j] + pa_yyy[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_yyz[j] * pc_yy[j] * pb_x[j] + 3.0 * pa_yyz[j] * pc_xy[j] * pb_y[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_xy[j] + 3.0 * pa_yz[j] * pc_yy[j] * pb_xy[j]);

                t_yyyz_xy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yy[j] * fl1_fx * pc_xz[j] - 4.5 * pa_y[j] * pc_xyz[j] * fl1_fx - 4.5 * pa_yz[j] * pc_xy[j] * fl1_fx - 4.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyy[j] * fl1_fx * pa_z[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_x[j] - 3.0 * pc_yy[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pa_y[j] * fl1_fx * pc_xz[j] * pb_y[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xy[j] - pa_yyy[j] * pc_xyz[j] - 3.0 * pa_yyz[j] * pc_xyy[j] - 3.0 * pa_yy[j] * pc_yyz[j] * pb_x[j] - 3.0 * pa_yy[j] * pc_xyz[j] * pb_y[j] - 3.0 * pa_yz[j] * pc_yyy[j] * pb_x[j] - 3.0 * pa_yz[j] * pc_xyy[j] * pb_y[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_xy[j] - pc_yyy[j] * pa_z[j] * pb_xy[j]);

                t_yyyz_xy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 4.5 * pa_y[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xyyz[j] * fl1_fx + 3.0 * pc_xyy[j] * fl1_fx * pa_z[j] + 3.0 * pc_yyz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_yy[j] * pc_xyyz[j] + 3.0 * pa_yz[j] * pc_xyyy[j] + 3.0 * pa_y[j] * pc_yyyz[j] * pb_x[j] + 3.0 * pa_y[j] * pc_xyyz[j] * pb_y[j] + pc_yyyy[j] * pa_z[j] * pb_x[j] + pc_xyyy[j] * pa_z[j] * pb_y[j] + pc_yyyz[j] * pb_xy[j]);

                t_yyyz_xy[j] += fl_s_0_0_5 * (-3.0 * pc_xyyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyyyz[j] - pc_xyyyy[j] * pa_z[j] - pc_yyyyz[j] * pb_x[j] - pc_xyyyz[j] * pb_y[j]);

                t_yyyz_xy[j] += fl_s_0_0_6 * pc_xyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_68_69(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (68,69)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyz = paDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyz_xz = primBuffer.data(90 * idx + 68);

            // Batch of Integrals (68,69)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyz, pa_yyz, pa_yz, pa_z, pb_x, pb_xz, pb_z, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, \
                                     pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, pc_yzz, \
                                     pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yyyz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyz_xz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx * pb_x[j] + 0.5 * pa_yyy[j] * fl1_fx * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pb_xz[j] + pa_yyyz[j] * pb_xz[j]);

                t_yyyz_xz[j] += fl_s_0_0_1 * (-0.75 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pa_y[j] * fl2_fx * pb_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 0.5 * pa_yyy[j] * fl1_fx * pc_x[j] - 0.5 * pa_yyy[j] * fl1_fx * pb_x[j] - 1.5 * pa_yy[j] * pc_y[j] * fl1_fx * pb_x[j] - 1.5 * pa_yz[j] * fl1_fx * pb_x[j] * pc_z[j] - 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_z[j] - 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_xz[j] - 1.5 * pa_yz[j] * fl1_fx * pb_xz[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_xz[j] - pa_yyyz[j] * pb_x[j] * pc_z[j] - pa_yyyz[j] * pc_x[j] * pb_z[j] - pa_yyy[j] * pc_z[j] * pb_xz[j] - 3.0 * pa_yyz[j] * pc_y[j] * pb_xz[j]);

                t_yyyz_xz[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl2_fx * pc_x[j] + 0.75 * pa_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 0.5 * pa_yyy[j] * fl1_fx * pc_x[j] + 1.5 * pa_yy[j] * pc_xy[j] * fl1_fx + 1.5 * pa_yy[j] * pc_y[j] * fl1_fx * pb_x[j] + 1.5 * pa_y[j] * pc_yy[j] * fl1_fx * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pc_xz[j] + 1.5 * pa_y[j] * fl1_fx * pc_zz[j] * pb_x[j] + 1.5 * pa_y[j] * fl1_fx * pc_xz[j] * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pb_x[j] * pc_z[j] + 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_xz[j] + 1.5 * pc_yz[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xz[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_xz[j] + pa_yyyz[j] * pc_xz[j] + pa_yyy[j] * pc_zz[j] * pb_x[j] + pa_yyy[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_yyz[j] * pc_yz[j] * pb_x[j] + 3.0 * pa_yyz[j] * pc_xy[j] * pb_z[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_xz[j] + 3.0 * pa_yz[j] * pc_yy[j] * pb_xz[j]);

                t_yyyz_xz[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_yy[j] * pc_xy[j] * fl1_fx - 1.5 * pa_y[j] * pc_xyy[j] * fl1_fx - 1.5 * pa_y[j] * pc_yy[j] * fl1_fx * pb_x[j] - 0.5 * pc_yyy[j] * fl1_fx * pb_x[j] - 1.5 * pa_y[j] * fl1_fx * pc_xzz[j] - 1.5 * pa_yz[j] * fl1_fx * pc_xz[j] - 1.5 * pa_y[j] * fl1_fx * pc_zz[j] * pb_x[j] - 1.5 * pa_y[j] * fl1_fx * pc_xz[j] * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] - 1.5 * pc_yzz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pa_z[j] * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pa_z[j] * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xz[j] - pa_yyy[j] * pc_xzz[j] - 3.0 * pa_yyz[j] * pc_xyz[j] - 3.0 * pa_yy[j] * pc_yzz[j] * pb_x[j] - 3.0 * pa_yy[j] * pc_xyz[j] * pb_z[j] - 3.0 * pa_yz[j] * pc_yyz[j] * pb_x[j] - 3.0 * pa_yz[j] * pc_xyy[j] * pb_z[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_xz[j] - pc_yyy[j] * pa_z[j] * pb_xz[j]);

                t_yyyz_xz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 1.5 * pa_y[j] * pc_xyy[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + 0.5 * pc_yyy[j] * fl1_fx * pb_x[j] + 1.5 * pa_y[j] * fl1_fx * pc_xzz[j] + 1.5 * pc_xyzz[j] * fl1_fx + 1.5 * pc_xyz[j] * fl1_fx * pa_z[j] + 1.5 * pc_yzz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_yy[j] * pc_xyzz[j] + 3.0 * pa_yz[j] * pc_xyyz[j] + 3.0 * pa_y[j] * pc_yyzz[j] * pb_x[j] + 3.0 * pa_y[j] * pc_xyyz[j] * pb_z[j] + pc_yyyz[j] * pa_z[j] * pb_x[j] + pc_xyyy[j] * pa_z[j] * pb_z[j] + pc_yyyz[j] * pb_xz[j]);

                t_yyyz_xz[j] += fl_s_0_0_5 * (-0.5 * pc_xyyy[j] * fl1_fx - 1.5 * pc_xyzz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyyzz[j] - pc_xyyyz[j] * pa_z[j] - pc_yyyzz[j] * pb_x[j] - pc_xyyyz[j] * pb_z[j]);

                t_yyyz_xz[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_69_70(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (69,70)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyz = paDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyy = pcDistances.data(83 * idx + 49);

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyyz = pcDistances.data(83 * idx + 77);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyz_yy = primBuffer.data(90 * idx + 69);

            // Batch of Integrals (69,70)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyz, pa_yyz, pa_yz, pa_z, pb_y, pb_yy, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyy, pc_yyyyy, pc_yyyyyz, pc_yyyyz, pc_yyyz, pc_yyz, pc_yz, pc_z, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yyyz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyz_yy[j] = fl_s_0_0_0 * (2.25 * pa_yz[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * pa_yyyz[j] * fl1_fx + 3.0 * pa_yyz[j] * fl1_fx * pb_y[j] + 1.5 * pa_yz[j] * fl1_fx * pb_yy[j] + pa_yyyz[j] * pb_yy[j]);

                t_yyyz_yy[j] += fl_s_0_0_1 * (-2.25 * pa_y[j] * fl2_fx * pc_z[j] - 4.5 * pa_yz[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx * pa_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_y[j] - 3.0 * fl2_fx * pa_z[j] * pb_y[j] - 0.5 * pa_yyyz[j] * fl1_fx - 0.5 * pa_yyy[j] * pc_z[j] * fl1_fx - 4.5 * pa_yyz[j] * pc_y[j] * fl1_fx - 3.0 * pa_yy[j] * fl1_fx * pc_z[j] * pb_y[j] - 3.0 * pa_yyz[j] * fl1_fx * pb_y[j] - 9.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_y[j] - 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_yy[j] - 1.5 * pa_yz[j] * fl1_fx * pb_yy[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_yy[j] - 2.0 * pa_yyyz[j] * pb_y[j] * pc_y[j] - pa_yyy[j] * pc_z[j] * pb_yy[j] - 3.0 * pa_yyz[j] * pc_y[j] * pb_yy[j]);

                t_yyyz_yy[j] += fl_s_0_0_2 * (4.5 * pa_y[j] * fl2_fx * pc_z[j] + 2.25 * pa_yz[j] * fl2_fx + 3.75 * pc_yz[j] * fl2_fx + 7.5 * pc_y[j] * fl2_fx * pa_z[j] + 3.0 * fl2_fx * pc_z[j] * pb_y[j] + 1.5 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * pa_yyy[j] * pc_z[j] * fl1_fx + 4.5 * pa_yyz[j] * pc_y[j] * fl1_fx + 4.5 * pa_yy[j] * pc_yz[j] * fl1_fx + 3.0 * pa_yy[j] * fl1_fx * pc_z[j] * pb_y[j] + 9.0 * pa_yz[j] * pc_yy[j] * fl1_fx + 9.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] + 9.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_y[j] + 6.0 * pc_yy[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_yy[j] + 1.5 * pc_yz[j] * fl1_fx * pb_yy[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_yy[j] + pa_yyyz[j] * pc_yy[j] + 2.0 * pa_yyy[j] * pc_yz[j] * pb_y[j] + 6.0 * pa_yyz[j] * pc_yy[j] * pb_y[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_yy[j] + 3.0 * pa_yz[j] * pc_yy[j] * pb_yy[j]);

                t_yyyz_yy[j] += fl_s_0_0_3 * (-2.25 * pa_y[j] * fl2_fx * pc_z[j] - 7.5 * pc_yz[j] * fl2_fx - 3.75 * pc_y[j] * fl2_fx * pa_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_y[j] - 4.5 * pa_yy[j] * pc_yz[j] * fl1_fx - 9.0 * pa_yz[j] * pc_yy[j] * fl1_fx - 9.0 * pa_y[j] * pc_yyz[j] * fl1_fx - 9.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] - 5.0 * pc_yyy[j] * pa_z[j] * fl1_fx - 6.0 * pc_yyz[j] * fl1_fx * pb_y[j] - 6.0 * pc_yy[j] * fl1_fx * pa_z[j] * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_yy[j] - pa_yyy[j] * pc_yyz[j] - 3.0 * pa_yyz[j] * pc_yyy[j] - 6.0 * pa_yy[j] * pc_yyz[j] * pb_y[j] - 6.0 * pa_yz[j] * pc_yyy[j] * pb_y[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_yy[j] - pc_yyy[j] * pa_z[j] * pb_yy[j]);

                t_yyyz_yy[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 9.0 * pa_y[j] * pc_yyz[j] * fl1_fx + 5.0 * pc_yyy[j] * pa_z[j] * fl1_fx + 5.0 * pc_yyyz[j] * fl1_fx + 6.0 * pc_yyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_yy[j] * pc_yyyz[j] + 3.0 * pa_yz[j] * pc_yyyy[j] + 6.0 * pa_y[j] * pc_yyyz[j] * pb_y[j] + 2.0 * pc_yyyy[j] * pa_z[j] * pb_y[j] + pc_yyyz[j] * pb_yy[j]);

                t_yyyz_yy[j] += fl_s_0_0_5 * (-5.0 * pc_yyyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yyyyz[j] - pc_yyyyy[j] * pa_z[j] - 2.0 * pc_yyyyz[j] * pb_y[j]);

                t_yyyz_yy[j] += fl_s_0_0_6 * pc_yyyyyz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_70_71(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (70,71)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyz = paDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyzz = pcDistances.data(83 * idx + 78);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyz_yz = primBuffer.data(90 * idx + 70);

            // Batch of Integrals (70,71)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyz, pa_yyz, pa_yz, pa_z, pb_y, pb_yz, pb_z, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyyzz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yyyz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyyz_yz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_yyy[j] * fl1_fx * pb_y[j] + 1.5 * pa_yyz[j] * fl1_fx * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pb_yz[j] + pa_yyyz[j] * pb_yz[j]);

                t_yyyz_yz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_yy[j] * fl2_fx - 2.25 * pa_y[j] * pc_y[j] * fl2_fx - 1.5 * pa_y[j] * fl2_fx * pb_y[j] - 0.75 * pc_y[j] * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.5 * pa_yyy[j] * fl1_fx * pc_y[j] - 0.5 * pa_yyy[j] * fl1_fx * pb_y[j] - 1.5 * pa_yy[j] * pc_y[j] * fl1_fx * pb_y[j] - 1.5 * pa_yyz[j] * fl1_fx * pc_z[j] - 1.5 * pa_yy[j] * fl1_fx * pc_z[j] * pb_z[j] - 1.5 * pa_yyz[j] * fl1_fx * pb_z[j] - 4.5 * pa_yz[j] * pc_y[j] * fl1_fx * pb_z[j] - 1.5 * pa_yz[j] * fl1_fx * pb_y[j] * pc_z[j] - 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_yz[j] - 1.5 * pa_yz[j] * fl1_fx * pb_yz[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_yz[j] - pa_yyyz[j] * pb_y[j] * pc_z[j] - pa_yyyz[j] * pc_y[j] * pb_z[j] - pa_yyy[j] * pc_z[j] * pb_yz[j] - 3.0 * pa_yyz[j] * pc_y[j] * pb_yz[j]);

                t_yyyz_yz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 4.5 * pa_y[j] * pc_y[j] * fl2_fx + 1.5 * pc_yy[j] * fl2_fx + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 1.5 * pc_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pc_zz[j] + 1.5 * fl2_fx * pa_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_yyy[j] * fl1_fx * pc_y[j] + 1.5 * pa_yy[j] * pc_yy[j] * fl1_fx + 1.5 * pa_yy[j] * pc_y[j] * fl1_fx * pb_y[j] + 1.5 * pa_yy[j] * fl1_fx * pc_zz[j] + 1.5 * pa_yyz[j] * fl1_fx * pc_z[j] + 1.5 * pa_yy[j] * fl1_fx * pc_z[j] * pb_z[j] + 1.5 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] + 4.5 * pa_yz[j] * pc_yz[j] * fl1_fx + 4.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 4.5 * pa_yz[j] * pc_y[j] * fl1_fx * pb_z[j] + 3.0 * pc_yy[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pc_zz[j] * pb_y[j] + 1.5 * pa_yz[j] * fl1_fx * pb_y[j] * pc_z[j] + 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_yz[j] + 1.5 * pc_yz[j] * fl1_fx * pa_z[j] * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pb_yz[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_yz[j] + pa_yyyz[j] * pc_yz[j] + pa_yyy[j] * pc_zz[j] * pb_y[j] + pa_yyy[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_yyz[j] * pc_yz[j] * pb_y[j] + 3.0 * pa_yyz[j] * pc_yy[j] * pb_z[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_yz[j] + 3.0 * pa_yz[j] * pc_yy[j] * pb_yz[j]);

                t_yyyz_yz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 2.25 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * pc_yy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pc_zz[j] - 0.75 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_yy[j] * pc_yy[j] * fl1_fx - 1.5 * pa_yy[j] * fl1_fx * pc_zz[j] - 1.5 * pa_y[j] * pc_yyy[j] * fl1_fx - 1.5 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] - 4.5 * pa_y[j] * pc_yzz[j] * fl1_fx - 4.5 * pa_yz[j] * pc_yz[j] * fl1_fx - 4.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yyy[j] * fl1_fx * pb_y[j] - 3.0 * pc_yyz[j] * fl1_fx * pa_z[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yy[j] * fl1_fx * pa_z[j] * pb_z[j] - 1.5 * pa_y[j] * fl1_fx * pc_zz[j] * pb_y[j] - 1.5 * pc_yzz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pa_z[j] * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_yz[j] - pa_yyy[j] * pc_yzz[j] - 3.0 * pa_yyz[j] * pc_yyz[j] - 3.0 * pa_yy[j] * pc_yzz[j] * pb_y[j] - 3.0 * pa_yy[j] * pc_yyz[j] * pb_z[j] - 3.0 * pa_yz[j] * pc_yyz[j] * pb_y[j] - 3.0 * pa_yz[j] * pc_yyy[j] * pb_z[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_yz[j] - pc_yyy[j] * pa_z[j] * pb_yz[j]);

                t_yyyz_yz[j] += fl_s_0_0_4 * (1.5 * pc_yy[j] * fl2_fx + 0.75 * fl2_fx * pc_zz[j] + 1.5 * pa_y[j] * pc_yyy[j] * fl1_fx + 4.5 * pa_y[j] * pc_yzz[j] * fl1_fx + 0.5 * pc_yyyy[j] * fl1_fx + 0.5 * pc_yyy[j] * fl1_fx * pb_y[j] + 3.0 * pc_yyzz[j] * fl1_fx + 3.0 * pc_yyz[j] * fl1_fx * pa_z[j] + 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] + 1.5 * pc_yzz[j] * fl1_fx * pb_y[j] + 3.0 * pa_yy[j] * pc_yyzz[j] + 3.0 * pa_yz[j] * pc_yyyz[j] + 3.0 * pa_y[j] * pc_yyzz[j] * pb_y[j] + 3.0 * pa_y[j] * pc_yyyz[j] * pb_z[j] + pc_yyyz[j] * pa_z[j] * pb_y[j] + pc_yyyy[j] * pa_z[j] * pb_z[j] + pc_yyyz[j] * pb_yz[j]);

                t_yyyz_yz[j] += fl_s_0_0_5 * (-0.5 * pc_yyyy[j] * fl1_fx - 3.0 * pc_yyzz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yyyzz[j] - pc_yyyyz[j] * pa_z[j] - pc_yyyzz[j] * pb_y[j] - pc_yyyyz[j] * pb_z[j]);

                t_yyyz_yz[j] += fl_s_0_0_6 * pc_yyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_71_72(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (71,72)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyy = paDistances.data(34 * idx + 15);

            auto pa_yyz = paDistances.data(34 * idx + 16);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyyz = paDistances.data(34 * idx + 30);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyzzz = pcDistances.data(83 * idx + 79);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyyz_zz = primBuffer.data(90 * idx + 71);

            // Batch of Integrals (71,72)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyy, pa_yyyz, pa_yyz, pa_yz, pa_z, pb_z, pb_zz, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyyzz, pc_yyyzzz, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yyyz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyyz_zz[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.5 * pa_yyyz[j] * fl1_fx + pa_yyy[j] * fl1_fx * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pb_zz[j] + pa_yyyz[j] * pb_zz[j]);

                t_yyyz_zz[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 2.25 * pa_y[j] * fl2_fx * pc_z[j] - 3.0 * pa_y[j] * fl2_fx * pb_z[j] - 0.75 * pc_y[j] * fl2_fx * pa_z[j] - 1.5 * pc_y[j] * fl2_fx * pb_z[j] - 0.5 * pa_yyyz[j] * fl1_fx - 1.5 * pa_yyy[j] * pc_z[j] * fl1_fx - pa_yyy[j] * fl1_fx * pb_z[j] - 1.5 * pa_yyz[j] * pc_y[j] * fl1_fx - 3.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_z[j] - 3.0 * pa_yz[j] * fl1_fx * pb_z[j] * pc_z[j] - 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_zz[j] - 1.5 * pa_yz[j] * fl1_fx * pb_zz[j] - 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_zz[j] - 2.0 * pa_yyyz[j] * pb_z[j] * pc_z[j] - pa_yyy[j] * pc_z[j] * pb_zz[j] - 3.0 * pa_yyz[j] * pc_y[j] * pb_zz[j]);

                t_yyyz_zz[j] += fl_s_0_0_2 * (4.5 * pa_y[j] * fl2_fx * pc_z[j] + 0.75 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * fl2_fx * pb_z[j] + 1.5 * pc_y[j] * fl2_fx * pa_z[j] + 2.25 * pc_yz[j] * fl2_fx + 3.0 * pc_y[j] * fl2_fx * pb_z[j] + 1.5 * pa_yyy[j] * pc_z[j] * fl1_fx + 1.5 * pa_yyz[j] * pc_y[j] * fl1_fx + 4.5 * pa_yy[j] * pc_yz[j] * fl1_fx + 3.0 * pa_yy[j] * pc_y[j] * fl1_fx * pb_z[j] + 1.5 * pa_yz[j] * pc_yy[j] * fl1_fx + 3.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pc_zz[j] + 3.0 * pa_y[j] * fl1_fx * pc_zz[j] * pb_z[j] + 3.0 * pa_yz[j] * fl1_fx * pb_z[j] * pc_z[j] + 1.5 * pa_y[j] * fl1_fx * pc_z[j] * pb_zz[j] + 3.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_yz[j] * fl1_fx * pb_zz[j] + 1.5 * pc_y[j] * fl1_fx * pa_z[j] * pb_zz[j] + pa_yyyz[j] * pc_zz[j] + 2.0 * pa_yyy[j] * pc_zz[j] * pb_z[j] + 6.0 * pa_yyz[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_yy[j] * pc_yz[j] * pb_zz[j] + 3.0 * pa_yz[j] * pc_yy[j] * pb_zz[j]);

                t_yyyz_zz[j] += fl_s_0_0_3 * (-2.25 * pa_y[j] * fl2_fx * pc_z[j] - 4.5 * pc_yz[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pa_z[j] - 1.5 * pc_y[j] * fl2_fx * pb_z[j] - 4.5 * pa_yy[j] * pc_yz[j] * fl1_fx - 1.5 * pa_yz[j] * pc_yy[j] * fl1_fx - 4.5 * pa_y[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx - pc_yyy[j] * fl1_fx * pb_z[j] - 1.5 * pa_y[j] * fl1_fx * pc_zzz[j] - 1.5 * pa_yz[j] * fl1_fx * pc_zz[j] - 3.0 * pa_y[j] * fl1_fx * pc_zz[j] * pb_z[j] - 1.5 * pc_yzz[j] * fl1_fx * pa_z[j] - 3.0 * pc_yzz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_zz[j] - pa_yyy[j] * pc_zzz[j] - 3.0 * pa_yyz[j] * pc_yzz[j] - 6.0 * pa_yy[j] * pc_yzz[j] * pb_z[j] - 6.0 * pa_yz[j] * pc_yyz[j] * pb_z[j] - 3.0 * pa_y[j] * pc_yyz[j] * pb_zz[j] - pc_yyy[j] * pa_z[j] * pb_zz[j]);

                t_yyyz_zz[j] += fl_s_0_0_4 * (2.25 * pc_yz[j] * fl2_fx + 4.5 * pa_y[j] * pc_yyz[j] * fl1_fx + 0.5 * pc_yyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yyyz[j] * fl1_fx + pc_yyy[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * fl1_fx * pc_zzz[j] + 1.5 * pc_yzzz[j] * fl1_fx + 1.5 * pc_yzz[j] * fl1_fx * pa_z[j] + 3.0 * pc_yzz[j] * fl1_fx * pb_z[j] + 3.0 * pa_yy[j] * pc_yzzz[j] + 3.0 * pa_yz[j] * pc_yyzz[j] + 6.0 * pa_y[j] * pc_yyzz[j] * pb_z[j] + 2.0 * pc_yyyz[j] * pa_z[j] * pb_z[j] + pc_yyyz[j] * pb_zz[j]);

                t_yyyz_zz[j] += fl_s_0_0_5 * (-1.5 * pc_yyyz[j] * fl1_fx - 1.5 * pc_yzzz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yyzzz[j] - pc_yyyzz[j] * pa_z[j] - 2.0 * pc_yyyzz[j] * pb_z[j]);

                t_yyyz_zz[j] += fl_s_0_0_6 * pc_yyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_72_73(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (72,73)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(34 * idx + 16);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyzz = paDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyy = pcDistances.data(83 * idx + 22);

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyyz = pcDistances.data(83 * idx + 41);

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyyzz = pcDistances.data(83 * idx + 67);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyzz_xx = primBuffer.data(90 * idx + 72);

            // Batch of Integrals (72,73)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yyzz, pa_yz, pa_yzz, pa_z, pa_zz, pb_x, pb_xx, pc_x, \
                                     pc_xx, pc_xxy, pc_xxyy, pc_xxyyz, pc_xxyyzz, pc_xxyz, pc_xxyzz, pc_xxz, pc_xxzz, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyz, pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyz, \
                                     pc_yyzz, pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_yyzz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyzz_xx[j] = fl_s_0_0_0 * (0.125 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + 0.25 * fl2_fx * pa_zz[j] + 0.5 * pa_yyzz[j] * fl1_fx + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_yy[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pa_zz[j] * pb_xx[j] + pa_yyzz[j] * pb_xx[j]);

                t_yyzz_xx[j] += fl_s_0_0_1 * (-0.375 * fl3_fx - 0.5 * pa_yy[j] * fl2_fx - 0.5 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * fl2_fx * pa_zz[j] - 0.5 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * pa_yyzz[j] * fl1_fx - pa_yyz[j] * pc_z[j] * fl1_fx - pa_yzz[j] * pc_y[j] * fl1_fx - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * fl2_fx * pb_xx[j] - pa_yy[j] * fl1_fx * pb_x[j] * pc_x[j] - 0.5 * pa_yy[j] * fl1_fx * pb_xx[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_xx[j] - fl1_fx * pa_zz[j] * pb_x[j] * pc_x[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_xx[j] - 0.5 * fl1_fx * pa_zz[j] * pb_xx[j] - 2.0 * pa_yyzz[j] * pb_x[j] * pc_x[j] - 2.0 * pa_yyz[j] * pc_z[j] * pb_xx[j] - 2.0 * pa_yzz[j] * pc_y[j] * pb_xx[j]);

                t_yyzz_xx[j] += fl_s_0_0_2 * (0.375 * fl3_fx + 0.25 * pa_yy[j] * fl2_fx + pa_y[j] * pc_y[j] * fl2_fx + 0.25 * pc_yy[j] * fl2_fx + fl2_fx * pa_z[j] * pc_z[j] + 0.25 * fl2_fx * pc_zz[j] + 0.25 * fl2_fx * pa_zz[j] + pa_yyz[j] * pc_z[j] * fl1_fx + 0.5 * pa_yy[j] * pc_zz[j] * fl1_fx + pa_yzz[j] * pc_y[j] * fl1_fx + 2.0 * pa_yz[j] * pc_yz[j] * fl1_fx + 0.5 * pc_yy[j] * pa_zz[j] * fl1_fx + 0.25 * fl2_fx * pc_xx[j] + fl2_fx * pb_x[j] * pc_x[j] + 0.25 * fl2_fx * pb_xx[j] + 0.5 * pa_yy[j] * fl1_fx * pc_xx[j] + pa_yy[j] * fl1_fx * pb_x[j] * pc_x[j] + 2.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_x[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_xx[j] + 0.5 * pc_yy[j] * fl1_fx * pb_xx[j] + 0.5 * fl1_fx * pa_zz[j] * pc_xx[j] + 2.0 * fl1_fx * pa_z[j] * pc_xz[j] * pb_x[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xx[j] + fl1_fx * pa_zz[j] * pb_x[j] * pc_x[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_xx[j] + pa_yyzz[j] * pc_xx[j] + 4.0 * pa_yyz[j] * pc_xz[j] * pb_x[j] + pa_yy[j] * pc_zz[j] * pb_xx[j] + 4.0 * pa_yzz[j] * pc_xy[j] * pb_x[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_xx[j] + pc_yy[j] * pa_zz[j] * pb_xx[j]);

                t_yyzz_xx[j] += fl_s_0_0_3 * (-0.125 * fl3_fx - 0.5 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * pc_yy[j] * fl2_fx - 0.5 * fl2_fx * pc_zz[j] - 0.5 * fl2_fx * pa_z[j] * pc_z[j] - 0.5 * pa_yy[j] * pc_zz[j] * fl1_fx - 2.0 * pa_yz[j] * pc_yz[j] * fl1_fx - pa_y[j] * pc_yzz[j] * fl1_fx - 0.5 * pc_yy[j] * pa_zz[j] * fl1_fx - pc_yyz[j] * pa_z[j] * fl1_fx - 0.5 * fl2_fx * pc_xx[j] - 0.5 * fl2_fx * pb_x[j] * pc_x[j] - 0.5 * pa_yy[j] * fl1_fx * pc_xx[j] - pa_y[j] * pc_xxy[j] * fl1_fx - 2.0 * pa_y[j] * pc_xy[j] * fl1_fx * pb_x[j] - pc_xyy[j] * fl1_fx * pb_x[j] - 0.5 * pc_yy[j] * fl1_fx * pb_xx[j] - fl1_fx * pa_z[j] * pc_xxz[j] - fl1_fx * pc_xzz[j] * pb_x[j] - 0.5 * fl1_fx * pa_zz[j] * pc_xx[j] - 2.0 * fl1_fx * pa_z[j] * pc_xz[j] * pb_x[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xx[j] - 2.0 * pa_yyz[j] * pc_xxz[j] - 2.0 * pa_yy[j] * pc_xzz[j] * pb_x[j] - 2.0 * pa_yzz[j] * pc_xxy[j] - 8.0 * pa_yz[j] * pc_xyz[j] * pb_x[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xx[j] - 2.0 * pc_xyy[j] * pa_zz[j] * pb_x[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_xx[j]);

                t_yyzz_xx[j] += fl_s_0_0_4 * (0.25 * pc_yy[j] * fl2_fx + 0.25 * fl2_fx * pc_zz[j] + pa_y[j] * pc_yzz[j] * fl1_fx + pc_yyz[j] * pa_z[j] * fl1_fx + 0.5 * pc_yyzz[j] * fl1_fx + 0.25 * fl2_fx * pc_xx[j] + pa_y[j] * pc_xxy[j] * fl1_fx + 0.5 * pc_xxyy[j] * fl1_fx + pc_xyy[j] * fl1_fx * pb_x[j] + 0.5 * fl1_fx * pc_xxzz[j] + fl1_fx * pa_z[j] * pc_xxz[j] + fl1_fx * pc_xzz[j] * pb_x[j] + pa_yy[j] * pc_xxzz[j] + 4.0 * pa_yz[j] * pc_xxyz[j] + 4.0 * pa_y[j] * pc_xyzz[j] * pb_x[j] + pc_xxyy[j] * pa_zz[j] + 4.0 * pc_xyyz[j] * pa_z[j] * pb_x[j] + pc_yyzz[j] * pb_xx[j]);

                t_yyzz_xx[j] += fl_s_0_0_5 * (-0.5 * pc_yyzz[j] * fl1_fx - 0.5 * pc_xxyy[j] * fl1_fx - 0.5 * fl1_fx * pc_xxzz[j] - 2.0 * pa_y[j] * pc_xxyzz[j] - 2.0 * pc_xxyyz[j] * pa_z[j] - 2.0 * pc_xyyzz[j] * pb_x[j]);

                t_yyzz_xx[j] += fl_s_0_0_6 * pc_xxyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_73_74(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (73,74)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(34 * idx + 16);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyzz = paDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyy = pcDistances.data(83 * idx + 25);

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyyz = pcDistances.data(83 * idx + 45);

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyyzz = pcDistances.data(83 * idx + 72);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyzz_xy = primBuffer.data(90 * idx + 73);

            // Batch of Integrals (73,74)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yyzz, pa_yz, pa_yzz, pa_z, pa_zz, pb_x, pb_xy, pb_y, \
                                     pc_x, pc_xy, pc_xyy, pc_xyyy, pc_xyyyz, pc_xyyyzz, pc_xyyz, pc_xyyzz, pc_xyz, \
                                     pc_xyzz, pc_xz, pc_xzz, pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, pc_yz, \
                                     pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yyzz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyzz_xy[j] = fl_s_0_0_0 * (0.5 * pa_y[j] * fl2_fx * pb_x[j] + pa_yzz[j] * fl1_fx * pb_x[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_yy[j] * fl1_fx * pb_xy[j] + 0.5 * fl1_fx * pa_zz[j] * pb_xy[j] + pa_yyzz[j] * pb_xy[j]);

                t_yyzz_xy[j] += fl_s_0_0_1 * (-0.5 * pa_y[j] * fl2_fx * pc_x[j] - pa_y[j] * fl2_fx * pb_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - pa_yzz[j] * fl1_fx * pc_x[j] - 2.0 * pa_yz[j] * fl1_fx * pc_z[j] * pb_x[j] - pa_yzz[j] * fl1_fx * pb_x[j] - 1.5 * pc_y[j] * fl1_fx * pa_zz[j] * pb_x[j] - 0.25 * fl2_fx * pc_x[j] * pb_y[j] - 0.5 * fl2_fx * pb_xy[j] - 0.5 * pa_yy[j] * fl1_fx * pb_x[j] * pc_y[j] - 0.5 * pa_yy[j] * fl1_fx * pc_x[j] * pb_y[j] - 0.5 * pa_yy[j] * fl1_fx * pb_xy[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pa_zz[j] * pc_x[j] * pb_y[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_xy[j] - 0.5 * fl1_fx * pa_zz[j] * pb_xy[j] - pa_yyzz[j] * pb_x[j] * pc_y[j] - pa_yyzz[j] * pc_x[j] * pb_y[j] - 2.0 * pa_yyz[j] * pc_z[j] * pb_xy[j] - 2.0 * pa_yzz[j] * pc_y[j] * pb_xy[j]);

                t_yyzz_xy[j] += fl_s_0_0_2 * (pa_y[j] * fl2_fx * pc_x[j] + 0.5 * pa_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 2.0 * pa_yz[j] * fl1_fx * pc_xz[j] + pa_y[j] * fl1_fx * pc_zz[j] * pb_x[j] + pa_yzz[j] * fl1_fx * pc_x[j] + 2.0 * pa_yz[j] * fl1_fx * pc_z[j] * pb_x[j] + 1.5 * pc_xy[j] * fl1_fx * pa_zz[j] + 3.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_x[j] + 1.5 * pc_y[j] * fl1_fx * pa_zz[j] * pb_x[j] + 0.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.25 * fl2_fx * pb_xy[j] + 0.5 * pa_yy[j] * fl1_fx * pc_xy[j] + 0.5 * pa_yy[j] * fl1_fx * pb_x[j] * pc_y[j] + 0.5 * pa_yy[j] * fl1_fx * pc_x[j] * pb_y[j] + pa_y[j] * pc_yy[j] * fl1_fx * pb_x[j] + pa_y[j] * pc_xy[j] * fl1_fx * pb_y[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_xy[j] + 0.5 * pc_yy[j] * fl1_fx * pb_xy[j] + fl1_fx * pa_z[j] * pc_xz[j] * pb_y[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xy[j] + 0.5 * fl1_fx * pa_zz[j] * pc_x[j] * pb_y[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_xy[j] + pa_yyzz[j] * pc_xy[j] + 2.0 * pa_yyz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_yyz[j] * pc_xz[j] * pb_y[j] + pa_yy[j] * pc_zz[j] * pb_xy[j] + 2.0 * pa_yzz[j] * pc_yy[j] * pb_x[j] + 2.0 * pa_yzz[j] * pc_xy[j] * pb_y[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_xy[j] + pc_yy[j] * pa_zz[j] * pb_xy[j]);

                t_yyzz_xy[j] += fl_s_0_0_3 * (-0.5 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - pa_y[j] * fl1_fx * pc_xzz[j] - 2.0 * pa_yz[j] * fl1_fx * pc_xz[j] - pa_y[j] * fl1_fx * pc_zz[j] * pb_x[j] - 3.0 * pc_xyz[j] * fl1_fx * pa_z[j] - 1.5 * pc_yzz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * fl1_fx * pa_zz[j] - 3.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_x[j] - 0.25 * fl2_fx * pc_x[j] * pb_y[j] - 0.5 * pa_yy[j] * fl1_fx * pc_xy[j] - pa_y[j] * pc_xyy[j] * fl1_fx - pa_y[j] * pc_yy[j] * fl1_fx * pb_x[j] - pa_y[j] * pc_xy[j] * fl1_fx * pb_y[j] - 0.5 * pc_yyy[j] * fl1_fx * pb_x[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_y[j] - 0.5 * pc_yy[j] * fl1_fx * pb_xy[j] - 0.5 * fl1_fx * pc_xzz[j] * pb_y[j] - fl1_fx * pa_z[j] * pc_xz[j] * pb_y[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xy[j] - 2.0 * pa_yyz[j] * pc_xyz[j] - pa_yy[j] * pc_yzz[j] * pb_x[j] - pa_yy[j] * pc_xzz[j] * pb_y[j] - 2.0 * pa_yzz[j] * pc_xyy[j] - 4.0 * pa_yz[j] * pc_yyz[j] * pb_x[j] - 4.0 * pa_yz[j] * pc_xyz[j] * pb_y[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xy[j] - pc_yyy[j] * pa_zz[j] * pb_x[j] - pc_xyy[j] * pa_zz[j] * pb_y[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_xy[j]);

                t_yyzz_xy[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + pa_y[j] * fl1_fx * pc_xzz[j] + 1.5 * pc_xyzz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pa_z[j] + 1.5 * pc_yzz[j] * fl1_fx * pb_x[j] + pa_y[j] * pc_xyy[j] * fl1_fx + 0.5 * pc_xyyy[j] * fl1_fx + 0.5 * pc_yyy[j] * fl1_fx * pb_x[j] + 0.5 * pc_xyy[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_xzz[j] * pb_y[j] + pa_yy[j] * pc_xyzz[j] + 4.0 * pa_yz[j] * pc_xyyz[j] + 2.0 * pa_y[j] * pc_yyzz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xyzz[j] * pb_y[j] + pc_xyyy[j] * pa_zz[j] + 2.0 * pc_yyyz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_y[j] + pc_yyzz[j] * pb_xy[j]);

                t_yyzz_xy[j] += fl_s_0_0_5 * (-1.5 * pc_xyzz[j] * fl1_fx - 0.5 * pc_xyyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_xyyzz[j] - 2.0 * pc_xyyyz[j] * pa_z[j] - pc_yyyzz[j] * pb_x[j] - pc_xyyzz[j] * pb_y[j]);

                t_yyzz_xy[j] += fl_s_0_0_6 * pc_xyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_74_75(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (74,75)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(34 * idx + 16);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyzz = paDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyzz_xz = primBuffer.data(90 * idx + 74);

            // Batch of Integrals (74,75)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yyzz, pa_yz, pa_yzz, pa_z, pa_zz, pb_x, pb_xz, pb_z, \
                                     pc_x, pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, pc_xyzzz, \
                                     pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yyzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyzz_xz[j] = fl_s_0_0_0 * (0.5 * fl2_fx * pa_z[j] * pb_x[j] + pa_yyz[j] * fl1_fx * pb_x[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_yy[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_xz[j] + pa_yyzz[j] * pb_xz[j]);

                t_yyzz_xz[j] += fl_s_0_0_1 * (-0.5 * fl2_fx * pa_z[j] * pc_x[j] - fl2_fx * pa_z[j] * pb_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - pa_yyz[j] * fl1_fx * pc_x[j] - pa_yyz[j] * fl1_fx * pb_x[j] - 1.5 * pa_yy[j] * pc_z[j] * fl1_fx * pb_x[j] - 2.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_x[j] - 0.25 * fl2_fx * pc_x[j] * pb_z[j] - 0.5 * fl2_fx * pb_xz[j] - 0.5 * pa_yy[j] * fl1_fx * pc_x[j] * pb_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_xz[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_xz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_x[j] * pc_z[j] - 0.5 * fl1_fx * pa_zz[j] * pc_x[j] * pb_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_xz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_xz[j] - pa_yyzz[j] * pb_x[j] * pc_z[j] - pa_yyzz[j] * pc_x[j] * pb_z[j] - 2.0 * pa_yyz[j] * pc_z[j] * pb_xz[j] - 2.0 * pa_yzz[j] * pc_y[j] * pb_xz[j]);

                t_yyzz_xz[j] += fl_s_0_0_2 * (fl2_fx * pa_z[j] * pc_x[j] + 0.75 * fl2_fx * pc_xz[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.5 * fl2_fx * pa_z[j] * pb_x[j] + pa_yyz[j] * fl1_fx * pc_x[j] + 1.5 * pa_yy[j] * pc_xz[j] * fl1_fx + 1.5 * pa_yy[j] * pc_z[j] * fl1_fx * pb_x[j] + 2.0 * pa_yz[j] * pc_xy[j] * fl1_fx + 2.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_x[j] + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] + pc_yy[j] * pa_z[j] * fl1_fx * pb_x[j] + 0.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.25 * fl2_fx * pb_xz[j] + 0.5 * pa_yy[j] * fl1_fx * pc_x[j] * pb_z[j] + pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_xz[j] + 0.5 * pc_yy[j] * fl1_fx * pb_xz[j] + 0.5 * fl1_fx * pa_zz[j] * pc_xz[j] + fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] + fl1_fx * pa_z[j] * pc_xz[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_xz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_x[j] * pc_z[j] + 0.5 * fl1_fx * pa_zz[j] * pc_x[j] * pb_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_xz[j] + pa_yyzz[j] * pc_xz[j] + 2.0 * pa_yyz[j] * pc_zz[j] * pb_x[j] + 2.0 * pa_yyz[j] * pc_xz[j] * pb_z[j] + pa_yy[j] * pc_zz[j] * pb_xz[j] + 2.0 * pa_yzz[j] * pc_yz[j] * pb_x[j] + 2.0 * pa_yzz[j] * pc_xy[j] * pb_z[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_xz[j] + pc_yy[j] * pa_zz[j] * pb_xz[j]);

                t_yyzz_xz[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.5 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * pa_yy[j] * pc_xz[j] * fl1_fx - 2.0 * pa_yz[j] * pc_xy[j] * fl1_fx - 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] - pc_xyy[j] * pa_z[j] * fl1_fx - pc_yy[j] * pa_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_yyz[j] * fl1_fx * pb_x[j] - 0.25 * fl2_fx * pc_x[j] * pb_z[j] - pa_y[j] * pc_xy[j] * fl1_fx * pb_z[j] - 0.5 * pc_xyy[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * fl1_fx * pb_xz[j] - fl1_fx * pa_z[j] * pc_xzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] - 0.5 * fl1_fx * pc_xzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_zz[j] * pc_xz[j] - fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] - fl1_fx * pa_z[j] * pc_xz[j] * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_xz[j] - 2.0 * pa_yyz[j] * pc_xzz[j] - pa_yy[j] * pc_zzz[j] * pb_x[j] - pa_yy[j] * pc_xzz[j] * pb_z[j] - 2.0 * pa_yzz[j] * pc_xyz[j] - 4.0 * pa_yz[j] * pc_yzz[j] * pb_x[j] - 4.0 * pa_yz[j] * pc_xyz[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_xz[j] - pc_yyz[j] * pa_zz[j] * pb_x[j] - pc_xyy[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_xz[j]);

                t_yyzz_xz[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 3.0 * pa_y[j] * pc_xyz[j] * fl1_fx + pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_yyz[j] * fl1_fx * pb_x[j] + 0.5 * pc_xyy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_xzzz[j] + fl1_fx * pa_z[j] * pc_xzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] + 0.5 * fl1_fx * pc_xzz[j] * pb_z[j] + pa_yy[j] * pc_xzzz[j] + 4.0 * pa_yz[j] * pc_xyzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] * pb_x[j] + 2.0 * pa_y[j] * pc_xyzz[j] * pb_z[j] + pc_xyyz[j] * pa_zz[j] + 2.0 * pc_yyzz[j] * pa_z[j] * pb_x[j] + 2.0 * pc_xyyz[j] * pa_z[j] * pb_z[j] + pc_yyzz[j] * pb_xz[j]);

                t_yyzz_xz[j] += fl_s_0_0_5 * (-1.5 * pc_xyyz[j] * fl1_fx - 0.5 * fl1_fx * pc_xzzz[j] - 2.0 * pa_y[j] * pc_xyzzz[j] - 2.0 * pc_xyyzz[j] * pa_z[j] - pc_yyzzz[j] * pb_x[j] - pc_xyyzz[j] * pb_z[j]);

                t_yyzz_xz[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_75_76(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (75,76)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(34 * idx + 16);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyzz = paDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyy = pcDistances.data(83 * idx + 29);

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyyz = pcDistances.data(83 * idx + 50);

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyyzz = pcDistances.data(83 * idx + 78);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyzz_yy = primBuffer.data(90 * idx + 75);

            // Batch of Integrals (75,76)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yyzz, pa_yz, pa_yzz, pa_z, pa_zz, pb_y, pb_yy, pc_y, \
                                     pc_yy, pc_yyy, pc_yyyy, pc_yyyyz, pc_yyyyzz, pc_yyyz, pc_yyyzz, pc_yyz, pc_yyzz, \
                                     pc_yz, pc_yzz, pc_z, pc_zz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yyzz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyzz_yy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * fl2_fx * pa_zz[j] + 0.25 * pa_yy[j] * fl2_fx + pa_y[j] * fl2_fx * pb_y[j] + 0.5 * pa_yyzz[j] * fl1_fx + 2.0 * pa_yzz[j] * fl1_fx * pb_y[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_yy[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pa_zz[j] * pb_yy[j] + pa_yyzz[j] * pb_yy[j]);

                t_yyzz_yy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * fl2_fx * pa_zz[j] - 0.5 * pa_yy[j] * fl2_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 2.0 * pa_y[j] * fl2_fx * pb_y[j] - 1.5 * pc_y[j] * fl2_fx * pb_y[j] - 0.5 * pa_yyzz[j] * fl1_fx - pa_yyz[j] * pc_z[j] * fl1_fx - 3.0 * pa_yzz[j] * pc_y[j] * fl1_fx - 4.0 * pa_yz[j] * fl1_fx * pc_z[j] * pb_y[j] - 2.0 * pa_yzz[j] * fl1_fx * pb_y[j] - 3.0 * pc_y[j] * fl1_fx * pa_zz[j] * pb_y[j] - 0.5 * fl2_fx * pb_yy[j] - pa_yy[j] * fl1_fx * pb_y[j] * pc_y[j] - 0.5 * pa_yy[j] * fl1_fx * pb_yy[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_yy[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_yy[j] - 0.5 * fl1_fx * pa_zz[j] * pb_yy[j] - 2.0 * pa_yyzz[j] * pb_y[j] * pc_y[j] - 2.0 * pa_yyz[j] * pc_z[j] * pb_yy[j] - 2.0 * pa_yzz[j] * pc_y[j] * pb_yy[j]);

                t_yyzz_yy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pa_z[j] * pc_z[j] + 0.75 * fl2_fx * pa_zz[j] + 0.25 * pa_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl2_fx + pa_y[j] * fl2_fx * pb_y[j] + 1.5 * pc_yy[j] * fl2_fx + 3.0 * pc_y[j] * fl2_fx * pb_y[j] + pa_yyz[j] * pc_z[j] * fl1_fx + 0.5 * pa_yy[j] * pc_zz[j] * fl1_fx + 3.0 * pa_yzz[j] * pc_y[j] * fl1_fx + 6.0 * pa_yz[j] * pc_yz[j] * fl1_fx + 2.0 * pa_y[j] * fl1_fx * pc_zz[j] * pb_y[j] + 4.0 * pa_yz[j] * fl1_fx * pc_z[j] * pb_y[j] + 3.0 * pc_yy[j] * pa_zz[j] * fl1_fx + 6.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_y[j] + 3.0 * pc_y[j] * fl1_fx * pa_zz[j] * pb_y[j] + 0.25 * fl2_fx * pb_yy[j] + 0.5 * pa_yy[j] * fl1_fx * pc_yy[j] + pa_yy[j] * fl1_fx * pb_y[j] * pc_y[j] + 2.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_yy[j] + 0.5 * pc_yy[j] * fl1_fx * pb_yy[j] + 0.5 * fl1_fx * pc_zz[j] * pb_yy[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_yy[j] + pa_yyzz[j] * pc_yy[j] + 4.0 * pa_yyz[j] * pc_yz[j] * pb_y[j] + pa_yy[j] * pc_zz[j] * pb_yy[j] + 4.0 * pa_yzz[j] * pc_yy[j] * pb_y[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_yy[j] + pc_yy[j] * pa_zz[j] * pb_yy[j]);

                t_yyzz_yy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 3.0 * pc_yy[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pb_y[j] - 0.5 * pa_yy[j] * pc_zz[j] * fl1_fx - 6.0 * pa_yz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 2.0 * pa_y[j] * fl1_fx * pc_zz[j] * pb_y[j] - 3.0 * pc_yy[j] * pa_zz[j] * fl1_fx - 6.0 * pc_yyz[j] * pa_z[j] * fl1_fx - 3.0 * pc_yzz[j] * fl1_fx * pb_y[j] - 6.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_y[j] - 0.5 * pa_yy[j] * fl1_fx * pc_yy[j] - pa_y[j] * pc_yyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yy[j] * fl1_fx * pb_y[j] - pc_yyy[j] * fl1_fx * pb_y[j] - 0.5 * pc_yy[j] * fl1_fx * pb_yy[j] - 0.5 * fl1_fx * pc_zz[j] * pb_yy[j] - 2.0 * pa_yyz[j] * pc_yyz[j] - 2.0 * pa_yy[j] * pc_yzz[j] * pb_y[j] - 2.0 * pa_yzz[j] * pc_yyy[j] - 8.0 * pa_yz[j] * pc_yyz[j] * pb_y[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_yy[j] - 2.0 * pc_yyy[j] * pa_zz[j] * pb_y[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_yy[j]);

                t_yyzz_yy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_zz[j] + 1.5 * pc_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx + 6.0 * pc_yyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 3.0 * pc_yzz[j] * fl1_fx * pb_y[j] + pa_y[j] * pc_yyy[j] * fl1_fx + 0.5 * pc_yyyy[j] * fl1_fx + pc_yyy[j] * fl1_fx * pb_y[j] + pa_yy[j] * pc_yyzz[j] + 4.0 * pa_yz[j] * pc_yyyz[j] + 4.0 * pa_y[j] * pc_yyzz[j] * pb_y[j] + pc_yyyy[j] * pa_zz[j] + 4.0 * pc_yyyz[j] * pa_z[j] * pb_y[j] + pc_yyzz[j] * pb_yy[j]);

                t_yyzz_yy[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * pc_yyyy[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyyzz[j] - 2.0 * pc_yyyyz[j] * pa_z[j] - 2.0 * pc_yyyzz[j] * pb_y[j]);

                t_yyzz_yy[j] += fl_s_0_0_6 * pc_yyyyzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_76_77(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (76,77)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(34 * idx + 16);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyzz = paDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyzzz = pcDistances.data(83 * idx + 79);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyzz_yz = primBuffer.data(90 * idx + 76);

            // Batch of Integrals (76,77)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yyzz, pa_yz, pa_yzz, pa_z, pa_zz, pb_y, pb_yz, pb_z, \
                                     pc_y, pc_yy, pc_yyy, pc_yyyz, pc_yyyzz, pc_yyyzzz, pc_yyz, pc_yyzz, pc_yyzzz, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, \
                                     s_0_0_4, s_0_0_5, s_0_0_6, t_yyzz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yyzz_yz[j] = fl_s_0_0_0 * (pa_yz[j] * fl2_fx + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + pa_yyz[j] * fl1_fx * pb_y[j] + pa_yzz[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_yy[j] * fl1_fx * pb_yz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_yz[j] + pa_yyzz[j] * pb_yz[j]);

                t_yyzz_yz[j] += fl_s_0_0_1 * (-2.0 * pa_yz[j] * fl2_fx - 1.5 * pa_y[j] * fl2_fx * pc_z[j] - 1.5 * pc_y[j] * fl2_fx * pa_z[j] - pa_y[j] * fl2_fx * pb_z[j] - 0.75 * pc_y[j] * fl2_fx * pb_z[j] - fl2_fx * pa_z[j] * pb_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - pa_yyz[j] * fl1_fx * pc_y[j] - pa_yyz[j] * fl1_fx * pb_y[j] - 1.5 * pa_yy[j] * pc_z[j] * fl1_fx * pb_y[j] - 2.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_y[j] - pa_yzz[j] * fl1_fx * pc_z[j] - 2.0 * pa_yz[j] * fl1_fx * pc_z[j] * pb_z[j] - pa_yzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_y[j] * fl1_fx * pa_zz[j] * pb_z[j] - 0.5 * fl2_fx * pb_yz[j] - 0.5 * pa_yy[j] * fl1_fx * pc_y[j] * pb_z[j] - 0.5 * pa_yy[j] * fl1_fx * pb_yz[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_y[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_yz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_yz[j] - pa_yyzz[j] * pb_y[j] * pc_z[j] - pa_yyzz[j] * pc_y[j] * pb_z[j] - 2.0 * pa_yyz[j] * pc_z[j] * pb_yz[j] - 2.0 * pa_yzz[j] * pc_y[j] * pb_yz[j]);

                t_yyzz_yz[j] += fl_s_0_0_2 * (3.0 * pa_y[j] * fl2_fx * pc_z[j] + pa_yz[j] * fl2_fx + 3.0 * pc_y[j] * fl2_fx * pa_z[j] + 2.25 * pc_yz[j] * fl2_fx + 0.5 * pa_y[j] * fl2_fx * pb_z[j] + 1.5 * pc_y[j] * fl2_fx * pb_z[j] + 1.5 * fl2_fx * pc_z[j] * pb_y[j] + 0.5 * fl2_fx * pa_z[j] * pb_y[j] + pa_yyz[j] * fl1_fx * pc_y[j] + 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx + 1.5 * pa_yy[j] * pc_z[j] * fl1_fx * pb_y[j] + 2.0 * pa_yz[j] * pc_yy[j] * fl1_fx + 2.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_y[j] + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] + 2.0 * pa_yz[j] * fl1_fx * pc_zz[j] + pa_y[j] * fl1_fx * pc_zz[j] * pb_z[j] + pa_yzz[j] * fl1_fx * pc_z[j] + 2.0 * pa_yz[j] * fl1_fx * pc_z[j] * pb_z[j] + pc_yy[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_yz[j] * fl1_fx * pa_zz[j] + 3.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_z[j] + 1.5 * pc_y[j] * fl1_fx * pa_zz[j] * pb_z[j] + 0.25 * fl2_fx * pb_yz[j] + 0.5 * pa_yy[j] * fl1_fx * pc_y[j] * pb_z[j] + pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_yz[j] + 0.5 * pc_yy[j] * fl1_fx * pb_yz[j] + fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] + 0.5 * fl1_fx * pc_zz[j] * pb_yz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_y[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_yz[j] + pa_yyzz[j] * pc_yz[j] + 2.0 * pa_yyz[j] * pc_zz[j] * pb_y[j] + 2.0 * pa_yyz[j] * pc_yz[j] * pb_z[j] + pa_yy[j] * pc_zz[j] * pb_yz[j] + 2.0 * pa_yzz[j] * pc_yz[j] * pb_y[j] + 2.0 * pa_yzz[j] * pc_yy[j] * pb_z[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_yz[j] + pc_yy[j] * pa_zz[j] * pb_yz[j]);

                t_yyzz_yz[j] += fl_s_0_0_3 * (-1.5 * pa_y[j] * fl2_fx * pc_z[j] - 4.5 * pc_yz[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pa_z[j] - 0.75 * pc_y[j] * fl2_fx * pb_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_yy[j] * pc_yz[j] * fl1_fx - 2.0 * pa_yz[j] * pc_yy[j] * fl1_fx - 3.0 * pa_y[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] - pa_y[j] * fl1_fx * pc_zzz[j] - 2.0 * pa_yz[j] * fl1_fx * pc_zz[j] - pa_y[j] * fl1_fx * pc_zz[j] * pb_z[j] - pc_yyy[j] * pa_z[j] * fl1_fx - pc_yy[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_yyz[j] * fl1_fx * pb_y[j] - 3.0 * pc_yzz[j] * fl1_fx * pa_z[j] - 1.5 * pc_yzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pa_zz[j] - 3.0 * pc_yz[j] * fl1_fx * pa_z[j] * pb_z[j] - pa_y[j] * pc_yy[j] * fl1_fx * pb_z[j] - 0.5 * pc_yyy[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * fl1_fx * pb_yz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] - fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] - 0.5 * fl1_fx * pc_zz[j] * pb_yz[j] - 2.0 * pa_yyz[j] * pc_yzz[j] - pa_yy[j] * pc_zzz[j] * pb_y[j] - pa_yy[j] * pc_yzz[j] * pb_z[j] - 2.0 * pa_yzz[j] * pc_yyz[j] - 4.0 * pa_yz[j] * pc_yzz[j] * pb_y[j] - 4.0 * pa_yz[j] * pc_yyz[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_yz[j] - pc_yyz[j] * pa_zz[j] * pb_y[j] - pc_yyy[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_yz[j]);

                t_yyzz_yz[j] += fl_s_0_0_4 * (2.25 * pc_yz[j] * fl2_fx + 3.0 * pa_y[j] * pc_yyz[j] * fl1_fx + pa_y[j] * fl1_fx * pc_zzz[j] + pc_yyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yyyz[j] * fl1_fx + 1.5 * pc_yyz[j] * fl1_fx * pb_y[j] + 1.5 * pc_yzzz[j] * fl1_fx + 3.0 * pc_yzz[j] * fl1_fx * pa_z[j] + 1.5 * pc_yzz[j] * fl1_fx * pb_z[j] + 0.5 * pc_yyy[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_y[j] + pa_yy[j] * pc_yzzz[j] + 4.0 * pa_yz[j] * pc_yyzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] * pb_y[j] + 2.0 * pa_y[j] * pc_yyzz[j] * pb_z[j] + pc_yyyz[j] * pa_zz[j] + 2.0 * pc_yyzz[j] * pa_z[j] * pb_y[j] + 2.0 * pc_yyyz[j] * pa_z[j] * pb_z[j] + pc_yyzz[j] * pb_yz[j]);

                t_yyzz_yz[j] += fl_s_0_0_5 * (-1.5 * pc_yyyz[j] * fl1_fx - 1.5 * pc_yzzz[j] * fl1_fx - 2.0 * pa_y[j] * pc_yyzzz[j] - 2.0 * pc_yyyzz[j] * pa_z[j] - pc_yyzzz[j] * pb_y[j] - pc_yyyzz[j] * pb_z[j]);

                t_yyzz_yz[j] += fl_s_0_0_6 * pc_yyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_77_78(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (77,78)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yy = paDistances.data(34 * idx + 6);

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yyz = paDistances.data(34 * idx + 16);

            auto pa_yzz = paDistances.data(34 * idx + 17);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yyzz = paDistances.data(34 * idx + 31);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyzzzz = pcDistances.data(83 * idx + 80);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yyzz_zz = primBuffer.data(90 * idx + 77);

            // Batch of Integrals (77,78)

            #pragma omp simd aligned(fx, pa_y, pa_yy, pa_yyz, pa_yyzz, pa_yz, pa_yzz, pa_z, pa_zz, pb_z, pb_zz, pc_y, \
                                     pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yyzzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yyzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yyzz_zz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 0.25 * fl2_fx * pa_zz[j] + fl2_fx * pa_z[j] * pb_z[j] + 0.5 * pa_yyzz[j] * fl1_fx + 2.0 * pa_yyz[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_zz[j] + 0.5 * pa_yy[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pa_zz[j] * pb_zz[j] + pa_yyzz[j] * pb_zz[j]);

                t_yyzz_zz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * pa_yy[j] * fl2_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 0.5 * fl2_fx * pa_zz[j] - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 2.0 * fl2_fx * pa_z[j] * pb_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_z[j] - 0.5 * pa_yyzz[j] * fl1_fx - 3.0 * pa_yyz[j] * pc_z[j] * fl1_fx - 2.0 * pa_yyz[j] * fl1_fx * pb_z[j] - 3.0 * pa_yy[j] * pc_z[j] * fl1_fx * pb_z[j] - pa_yzz[j] * pc_y[j] * fl1_fx - 4.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_z[j] - 0.5 * fl2_fx * pb_zz[j] - 0.5 * pa_yy[j] * fl1_fx * pb_zz[j] - pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] - fl1_fx * pa_zz[j] * pb_z[j] * pc_z[j] - fl1_fx * pa_z[j] * pc_z[j] * pb_zz[j] - 0.5 * fl1_fx * pa_zz[j] * pb_zz[j] - 2.0 * pa_yyzz[j] * pb_z[j] * pc_z[j] - 2.0 * pa_yyz[j] * pc_z[j] * pb_zz[j] - 2.0 * pa_yzz[j] * pc_y[j] * pb_zz[j]);

                t_yyzz_zz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 0.75 * pa_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_y[j] * fl2_fx + 0.75 * pc_yy[j] * fl2_fx + 3.0 * fl2_fx * pa_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_zz[j] + 3.0 * fl2_fx * pc_z[j] * pb_z[j] + 0.25 * fl2_fx * pa_zz[j] + fl2_fx * pa_z[j] * pb_z[j] + 3.0 * pa_yyz[j] * pc_z[j] * fl1_fx + 3.0 * pa_yy[j] * pc_zz[j] * fl1_fx + 3.0 * pa_yy[j] * pc_z[j] * fl1_fx * pb_z[j] + pa_yzz[j] * pc_y[j] * fl1_fx + 6.0 * pa_yz[j] * pc_yz[j] * fl1_fx + 4.0 * pa_yz[j] * pc_y[j] * fl1_fx * pb_z[j] + 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 0.5 * pc_yy[j] * pa_zz[j] * fl1_fx + 2.0 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] + 0.25 * fl2_fx * pb_zz[j] + pa_y[j] * pc_y[j] * fl1_fx * pb_zz[j] + 0.5 * pc_yy[j] * fl1_fx * pb_zz[j] + 0.5 * fl1_fx * pa_zz[j] * pc_zz[j] + 2.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pc_zz[j] * pb_zz[j] + fl1_fx * pa_zz[j] * pb_z[j] * pc_z[j] + fl1_fx * pa_z[j] * pc_z[j] * pb_zz[j] + pa_yyzz[j] * pc_zz[j] + 4.0 * pa_yyz[j] * pc_zz[j] * pb_z[j] + pa_yy[j] * pc_zz[j] * pb_zz[j] + 4.0 * pa_yzz[j] * pc_yz[j] * pb_z[j] + 4.0 * pa_yz[j] * pc_yz[j] * pb_zz[j] + pc_yy[j] * pa_zz[j] * pb_zz[j]);

                t_yyzz_zz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 1.5 * pa_y[j] * pc_y[j] * fl2_fx - 1.5 * pc_yy[j] * fl2_fx - 3.0 * fl2_fx * pc_zz[j] - 1.5 * fl2_fx * pa_z[j] * pc_z[j] - 1.5 * fl2_fx * pc_z[j] * pb_z[j] - 3.0 * pa_yy[j] * pc_zz[j] * fl1_fx - 6.0 * pa_yz[j] * pc_yz[j] * fl1_fx - 6.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 6.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * pa_zz[j] * fl1_fx - 3.0 * pc_yyz[j] * pa_z[j] * fl1_fx - 2.0 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] - 0.5 * pc_yy[j] * fl1_fx * pb_zz[j] - fl1_fx * pa_z[j] * pc_zzz[j] - fl1_fx * pc_zzz[j] * pb_z[j] - 0.5 * fl1_fx * pa_zz[j] * pc_zz[j] - 2.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] - 0.5 * fl1_fx * pc_zz[j] * pb_zz[j] - 2.0 * pa_yyz[j] * pc_zzz[j] - 2.0 * pa_yy[j] * pc_zzz[j] * pb_z[j] - 2.0 * pa_yzz[j] * pc_yzz[j] - 8.0 * pa_yz[j] * pc_yzz[j] * pb_z[j] - 2.0 * pa_y[j] * pc_yzz[j] * pb_zz[j] - 2.0 * pc_yyz[j] * pa_zz[j] * pb_z[j] - 2.0 * pc_yyz[j] * pa_z[j] * pb_zz[j]);

                t_yyzz_zz[j] += fl_s_0_0_4 * (0.75 * pc_yy[j] * fl2_fx + 1.5 * fl2_fx * pc_zz[j] + 6.0 * pa_y[j] * pc_yzz[j] * fl1_fx + 3.0 * pc_yyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 3.0 * pc_yyz[j] * fl1_fx * pb_z[j] + 0.5 * fl1_fx * pc_zzzz[j] + fl1_fx * pa_z[j] * pc_zzz[j] + fl1_fx * pc_zzz[j] * pb_z[j] + pa_yy[j] * pc_zzzz[j] + 4.0 * pa_yz[j] * pc_yzzz[j] + 4.0 * pa_y[j] * pc_yzzz[j] * pb_z[j] + pc_yyzz[j] * pa_zz[j] + 4.0 * pc_yyzz[j] * pa_z[j] * pb_z[j] + pc_yyzz[j] * pb_zz[j]);

                t_yyzz_zz[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - 2.0 * pa_y[j] * pc_yzzzz[j] - 2.0 * pc_yyzzz[j] * pa_z[j] - 2.0 * pc_yyzzz[j] * pb_z[j]);

                t_yyzz_zz[j] += fl_s_0_0_6 * pc_yyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_78_79(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (78,79)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(34 * idx + 17);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yzzz = paDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxy = pcDistances.data(83 * idx + 10);

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxyz = pcDistances.data(83 * idx + 23);

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxyzz = pcDistances.data(83 * idx + 42);

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxyzzz = pcDistances.data(83 * idx + 68);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yzzz_xx = primBuffer.data(90 * idx + 78);

            // Batch of Integrals (78,79)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_yzzz, pa_z, pa_zz, pa_zzz, pb_x, pb_xx, pc_x, pc_xx, \
                                     pc_xxy, pc_xxyz, pc_xxyzz, pc_xxyzzz, pc_xxz, pc_xxzz, pc_xxzzz, pc_xy, pc_xyz, \
                                     pc_xyzz, pc_xyzzz, pc_xz, pc_xzz, pc_xzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, pc_z, pc_zz, \
                                     pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yzzz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzzz_xx[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 0.5 * pa_yzzz[j] * fl1_fx + 1.5 * pa_yz[j] * fl1_fx * pb_xx[j] + pa_yzzz[j] * pb_xx[j]);

                t_yzzz_xx[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 0.5 * pa_yzzz[j] * fl1_fx - 1.5 * pa_yzz[j] * pc_z[j] * fl1_fx - 0.5 * pc_y[j] * pa_zzz[j] * fl1_fx - 3.0 * pa_yz[j] * fl1_fx * pb_x[j] * pc_x[j] - 1.5 * pa_yz[j] * fl1_fx * pb_xx[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_xx[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_xx[j] - 2.0 * pa_yzzz[j] * pb_x[j] * pc_x[j] - 3.0 * pa_yzz[j] * pc_z[j] * pb_xx[j] - pc_y[j] * pa_zzz[j] * pb_xx[j]);

                t_yzzz_xx[j] += fl_s_0_0_2 * (0.75 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_z[j] * fl2_fx + 1.5 * pc_y[j] * pa_z[j] * fl2_fx + 0.75 * pc_yz[j] * fl2_fx + 1.5 * pa_yzz[j] * pc_z[j] * fl1_fx + 1.5 * pa_yz[j] * pc_zz[j] * fl1_fx + 0.5 * pc_y[j] * pa_zzz[j] * fl1_fx + 1.5 * pc_yz[j] * pa_zz[j] * fl1_fx + 1.5 * pa_yz[j] * fl1_fx * pc_xx[j] + 3.0 * pa_yz[j] * fl1_fx * pb_x[j] * pc_x[j] + 3.0 * pa_y[j] * pc_xz[j] * fl1_fx * pb_x[j] + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_xx[j] + 3.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_xx[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] + pa_yzzz[j] * pc_xx[j] + 6.0 * pa_yzz[j] * pc_xz[j] * pb_x[j] + 3.0 * pa_yz[j] * pc_zz[j] * pb_xx[j] + 2.0 * pc_xy[j] * pa_zzz[j] * pb_x[j] + 3.0 * pc_yz[j] * pa_zz[j] * pb_xx[j]);

                t_yzzz_xx[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * pc_z[j] * fl2_fx - 0.75 * pc_y[j] * pa_z[j] * fl2_fx - 1.5 * pc_yz[j] * fl2_fx - 1.5 * pa_yz[j] * pc_zz[j] * fl1_fx - 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx - 1.5 * pc_yz[j] * pa_zz[j] * fl1_fx - 1.5 * pc_yzz[j] * pa_z[j] * fl1_fx - 1.5 * pa_yz[j] * fl1_fx * pc_xx[j] - 1.5 * pa_y[j] * pc_xxz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx - 3.0 * pc_xy[j] * pa_z[j] * fl1_fx * pb_x[j] - 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xx[j] - 3.0 * pa_yzz[j] * pc_xxz[j] - 6.0 * pa_yz[j] * pc_xzz[j] * pb_x[j] - pa_y[j] * pc_zzz[j] * pb_xx[j] - pc_xxy[j] * pa_zzz[j] - 6.0 * pc_xyz[j] * pa_zz[j] * pb_x[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_xx[j]);

                t_yzzz_xx[j] += fl_s_0_0_4 * (0.75 * pc_yz[j] * fl2_fx + 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx + 1.5 * pc_yzz[j] * pa_z[j] * fl1_fx + 0.5 * pc_yzzz[j] * fl1_fx + 1.5 * pa_y[j] * pc_xxz[j] * fl1_fx + 1.5 * pc_xxy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xxyz[j] * fl1_fx + 3.0 * pc_xyz[j] * fl1_fx * pb_x[j] + 3.0 * pa_yz[j] * pc_xxzz[j] + 2.0 * pa_y[j] * pc_xzzz[j] * pb_x[j] + 3.0 * pc_xxyz[j] * pa_zz[j] + 6.0 * pc_xyzz[j] * pa_z[j] * pb_x[j] + pc_yzzz[j] * pb_xx[j]);

                t_yzzz_xx[j] += fl_s_0_0_5 * (-0.5 * pc_yzzz[j] * fl1_fx - 1.5 * pc_xxyz[j] * fl1_fx - pa_y[j] * pc_xxzzz[j] - 3.0 * pc_xxyzz[j] * pa_z[j] - 2.0 * pc_xyzzz[j] * pb_x[j]);

                t_yzzz_xx[j] += fl_s_0_0_6 * pc_xxyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_79_80(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (79,80)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(34 * idx + 17);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yzzz = paDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyy = pcDistances.data(83 * idx + 12);

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyyz = pcDistances.data(83 * idx + 26);

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyyzz = pcDistances.data(83 * idx + 46);

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyyzzz = pcDistances.data(83 * idx + 73);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yzzz_xy = primBuffer.data(90 * idx + 79);

            // Batch of Integrals (79,80)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_yzzz, pa_z, pa_zz, pa_zzz, pb_x, pb_xy, pb_y, pc_x, \
                                     pc_xy, pc_xyy, pc_xyyz, pc_xyyzz, pc_xyyzzz, pc_xyz, pc_xyzz, pc_xyzzz, pc_xz, \
                                     pc_xzz, pc_xzzz, pc_y, pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, pc_yzzz, pc_z, \
                                     pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_yzzz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzzz_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pa_z[j] * pb_x[j] + 0.5 * fl1_fx * pa_zzz[j] * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pb_xy[j] + pa_yzzz[j] * pb_xy[j]);

                t_yzzz_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pa_z[j] * pc_x[j] - 1.5 * fl2_fx * pa_z[j] * pb_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_zzz[j] * pc_x[j] - 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_x[j] - 0.5 * fl1_fx * pa_zzz[j] * pb_x[j] - 1.5 * pa_yz[j] * fl1_fx * pb_x[j] * pc_y[j] - 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_y[j] - 1.5 * pa_yz[j] * fl1_fx * pb_xy[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_xy[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_xy[j] - pa_yzzz[j] * pb_x[j] * pc_y[j] - pa_yzzz[j] * pc_x[j] * pb_y[j] - 3.0 * pa_yzz[j] * pc_z[j] * pb_xy[j] - pc_y[j] * pa_zzz[j] * pb_xy[j]);

                t_yzzz_xy[j] += fl_s_0_0_2 * (1.5 * fl2_fx * pa_z[j] * pc_x[j] + 0.75 * fl2_fx * pc_xz[j] + 1.5 * fl2_fx * pc_z[j] * pb_x[j] + 0.75 * fl2_fx * pa_z[j] * pb_x[j] + 1.5 * fl1_fx * pa_zz[j] * pc_xz[j] + 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] + 0.5 * fl1_fx * pa_zzz[j] * pc_x[j] + 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pc_xy[j] + 1.5 * pa_yz[j] * fl1_fx * pb_x[j] * pc_y[j] + 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_y[j] + 1.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_y[j] + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_xy[j] + 1.5 * pc_yy[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_xy[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xy[j] + pa_yzzz[j] * pc_xy[j] + 3.0 * pa_yzz[j] * pc_yz[j] * pb_x[j] + 3.0 * pa_yzz[j] * pc_xz[j] * pb_y[j] + 3.0 * pa_yz[j] * pc_zz[j] * pb_xy[j] + pc_yy[j] * pa_zzz[j] * pb_x[j] + pc_xy[j] * pa_zzz[j] * pb_y[j] + 3.0 * pc_yz[j] * pa_zz[j] * pb_xy[j]);

                t_yzzz_xy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xz[j] - 0.75 * fl2_fx * pa_z[j] * pc_x[j] - 0.75 * fl2_fx * pc_z[j] * pb_x[j] - 1.5 * fl1_fx * pa_z[j] * pc_xzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] - 1.5 * fl1_fx * pa_zz[j] * pc_xz[j] - 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_x[j] - 1.5 * pa_yz[j] * fl1_fx * pc_xy[j] - 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx - 1.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_x[j] - 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_y[j] - 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx - 1.5 * pc_yy[j] * pa_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_yyz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xy[j] - 3.0 * pa_yzz[j] * pc_xyz[j] - 3.0 * pa_yz[j] * pc_yzz[j] * pb_x[j] - 3.0 * pa_yz[j] * pc_xzz[j] * pb_y[j] - pa_y[j] * pc_zzz[j] * pb_xy[j] - pc_xyy[j] * pa_zzz[j] - 3.0 * pc_yyz[j] * pa_zz[j] * pb_x[j] - 3.0 * pc_xyz[j] * pa_zz[j] * pb_y[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_xy[j]);

                t_yzzz_xy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xz[j] + 0.5 * fl1_fx * pc_xzzz[j] + 1.5 * fl1_fx * pa_z[j] * pc_xzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_x[j] + 1.5 * pa_y[j] * pc_xyz[j] * fl1_fx + 1.5 * pc_xyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_xyyz[j] * fl1_fx + 1.5 * pc_yyz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_yz[j] * pc_xyzz[j] + pa_y[j] * pc_yzzz[j] * pb_x[j] + pa_y[j] * pc_xzzz[j] * pb_y[j] + 3.0 * pc_xyyz[j] * pa_zz[j] + 3.0 * pc_yyzz[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xyzz[j] * pa_z[j] * pb_y[j] + pc_yzzz[j] * pb_xy[j]);

                t_yzzz_xy[j] += fl_s_0_0_5 * (-0.5 * fl1_fx * pc_xzzz[j] - 1.5 * pc_xyyz[j] * fl1_fx - pa_y[j] * pc_xyzzz[j] - 3.0 * pc_xyyzz[j] * pa_z[j] - pc_yyzzz[j] * pb_x[j] - pc_xyzzz[j] * pb_y[j]);

                t_yzzz_xy[j] += fl_s_0_0_6 * pc_xyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_80_81(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (80,81)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(34 * idx + 17);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yzzz = paDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yzzz_xz = primBuffer.data(90 * idx + 80);

            // Batch of Integrals (80,81)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_yzzz, pa_z, pa_zz, pa_zzz, pb_x, pb_xz, pb_z, pc_x, \
                                     pc_xy, pc_xyz, pc_xyzz, pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_y, \
                                     pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, \
                                     s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yzzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzzz_xz[j] = fl_s_0_0_0 * (0.75 * pa_y[j] * fl2_fx * pb_x[j] + 1.5 * pa_yzz[j] * fl1_fx * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pb_xz[j] + pa_yzzz[j] * pb_xz[j]);

                t_yzzz_xz[j] += fl_s_0_0_1 * (-0.75 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pa_y[j] * fl2_fx * pb_x[j] - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 1.5 * pa_yzz[j] * fl1_fx * pc_x[j] - 1.5 * pa_yzz[j] * fl1_fx * pb_x[j] - 4.5 * pa_yz[j] * pc_z[j] * fl1_fx * pb_x[j] - 1.5 * pc_y[j] * pa_zz[j] * fl1_fx * pb_x[j] - 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_z[j] - 1.5 * pa_yz[j] * fl1_fx * pb_xz[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_xz[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_xz[j] - pa_yzzz[j] * pb_x[j] * pc_z[j] - pa_yzzz[j] * pc_x[j] * pb_z[j] - 3.0 * pa_yzz[j] * pc_z[j] * pb_xz[j] - pc_y[j] * pa_zzz[j] * pb_xz[j]);

                t_yzzz_xz[j] += fl_s_0_0_2 * (1.5 * pa_y[j] * fl2_fx * pc_x[j] + 0.75 * pa_y[j] * fl2_fx * pb_x[j] + 0.75 * pc_xy[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx * pb_x[j] + 1.5 * pa_yzz[j] * fl1_fx * pc_x[j] + 4.5 * pa_yz[j] * pc_xz[j] * fl1_fx + 4.5 * pa_yz[j] * pc_z[j] * fl1_fx * pb_x[j] + 3.0 * pa_y[j] * pc_zz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx + 1.5 * pc_y[j] * pa_zz[j] * fl1_fx * pb_x[j] + 4.5 * pc_yz[j] * pa_z[j] * fl1_fx * pb_x[j] + 1.5 * pa_yz[j] * fl1_fx * pc_x[j] * pb_z[j] + 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_xz[j] + 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_xz[j] + 1.5 * pc_yz[j] * fl1_fx * pb_xz[j] + pa_yzzz[j] * pc_xz[j] + 3.0 * pa_yzz[j] * pc_zz[j] * pb_x[j] + 3.0 * pa_yzz[j] * pc_xz[j] * pb_z[j] + 3.0 * pa_yz[j] * pc_zz[j] * pb_xz[j] + pc_yz[j] * pa_zzz[j] * pb_x[j] + pc_xy[j] * pa_zzz[j] * pb_z[j] + 3.0 * pc_yz[j] * pa_zz[j] * pb_xz[j]);

                t_yzzz_xz[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * fl2_fx * pc_x[j] - 1.5 * pc_xy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_x[j] - 4.5 * pa_yz[j] * pc_xz[j] * fl1_fx - 3.0 * pa_y[j] * pc_xzz[j] * fl1_fx - 3.0 * pa_y[j] * pc_zz[j] * fl1_fx * pb_x[j] - 1.5 * pc_xy[j] * pa_zz[j] * fl1_fx - 4.5 * pc_xyz[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pa_z[j] * fl1_fx * pb_x[j] - 3.0 * pc_yzz[j] * fl1_fx * pb_x[j] - 1.5 * pa_y[j] * pc_xz[j] * fl1_fx * pb_z[j] - 1.5 * pc_xy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_xz[j] - 3.0 * pa_yzz[j] * pc_xzz[j] - 3.0 * pa_yz[j] * pc_zzz[j] * pb_x[j] - 3.0 * pa_yz[j] * pc_xzz[j] * pb_z[j] - pa_y[j] * pc_zzz[j] * pb_xz[j] - pc_xyz[j] * pa_zzz[j] - 3.0 * pc_yzz[j] * pa_zz[j] * pb_x[j] - 3.0 * pc_xyz[j] * pa_zz[j] * pb_z[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_xz[j]);

                t_yzzz_xz[j] += fl_s_0_0_4 * (0.75 * pc_xy[j] * fl2_fx + 3.0 * pa_y[j] * pc_xzz[j] * fl1_fx + 4.5 * pc_xyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + 3.0 * pc_yzz[j] * fl1_fx * pb_x[j] + 1.5 * pc_xyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_yz[j] * pc_xzzz[j] + pa_y[j] * pc_zzzz[j] * pb_x[j] + pa_y[j] * pc_xzzz[j] * pb_z[j] + 3.0 * pc_xyzz[j] * pa_zz[j] + 3.0 * pc_yzzz[j] * pa_z[j] * pb_x[j] + 3.0 * pc_xyzz[j] * pa_z[j] * pb_z[j] + pc_yzzz[j] * pb_xz[j]);

                t_yzzz_xz[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - pa_y[j] * pc_xzzzz[j] - 3.0 * pc_xyzzz[j] * pa_z[j] - pc_yzzzz[j] * pb_x[j] - pc_xyzzz[j] * pb_z[j]);

                t_yzzz_xz[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_81_82(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (81,82)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(34 * idx + 17);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yzzz = paDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyy = pcDistances.data(83 * idx + 15);

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyyz = pcDistances.data(83 * idx + 30);

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyyzz = pcDistances.data(83 * idx + 51);

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyyzzz = pcDistances.data(83 * idx + 79);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yzzz_yy = primBuffer.data(90 * idx + 81);

            // Batch of Integrals (81,82)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_yzzz, pa_z, pa_zz, pa_zzz, pb_y, pb_yy, pc_y, pc_yy, \
                                     pc_yyy, pc_yyyz, pc_yyyzz, pc_yyyzzz, pc_yyz, pc_yyzz, pc_yyzzz, pc_yz, pc_yzz, \
                                     pc_yzzz, pc_z, pc_zz, pc_zzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yzzz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzzz_yy[j] = fl_s_0_0_0 * (0.75 * pa_yz[j] * fl2_fx + 1.5 * fl2_fx * pa_z[j] * pb_y[j] + 0.5 * pa_yzzz[j] * fl1_fx + fl1_fx * pa_zzz[j] * pb_y[j] + 1.5 * pa_yz[j] * fl1_fx * pb_yy[j] + pa_yzzz[j] * pb_yy[j]);

                t_yzzz_yy[j] += fl_s_0_0_1 * (-1.5 * pa_yz[j] * fl2_fx - 0.75 * pa_y[j] * pc_z[j] * fl2_fx - 2.25 * pc_y[j] * pa_z[j] * fl2_fx - 3.0 * fl2_fx * pa_z[j] * pb_y[j] - 1.5 * fl2_fx * pc_z[j] * pb_y[j] - 0.5 * pa_yzzz[j] * fl1_fx - 1.5 * pa_yzz[j] * pc_z[j] * fl1_fx - 1.5 * pc_y[j] * pa_zzz[j] * fl1_fx - 3.0 * fl1_fx * pa_zz[j] * pc_z[j] * pb_y[j] - fl1_fx * pa_zzz[j] * pb_y[j] - 3.0 * pa_yz[j] * fl1_fx * pb_y[j] * pc_y[j] - 1.5 * pa_yz[j] * fl1_fx * pb_yy[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yy[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yy[j] - 2.0 * pa_yzzz[j] * pb_y[j] * pc_y[j] - 3.0 * pa_yzz[j] * pc_z[j] * pb_yy[j] - pc_y[j] * pa_zzz[j] * pb_yy[j]);

                t_yzzz_yy[j] += fl_s_0_0_2 * (0.75 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * pc_z[j] * fl2_fx + 4.5 * pc_y[j] * pa_z[j] * fl2_fx + 2.25 * pc_yz[j] * fl2_fx + 3.0 * fl2_fx * pc_z[j] * pb_y[j] + 1.5 * fl2_fx * pa_z[j] * pb_y[j] + 1.5 * pa_yzz[j] * pc_z[j] * fl1_fx + 1.5 * pa_yz[j] * pc_zz[j] * fl1_fx + 1.5 * pc_y[j] * pa_zzz[j] * fl1_fx + 4.5 * pc_yz[j] * pa_zz[j] * fl1_fx + 3.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] + 3.0 * fl1_fx * pa_zz[j] * pc_z[j] * pb_y[j] + 1.5 * pa_yz[j] * fl1_fx * pc_yy[j] + 3.0 * pa_yz[j] * fl1_fx * pb_y[j] * pc_y[j] + 3.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yy[j] + 3.0 * pc_yy[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yy[j] + 1.5 * pc_yz[j] * fl1_fx * pb_yy[j] + pa_yzzz[j] * pc_yy[j] + 6.0 * pa_yzz[j] * pc_yz[j] * pb_y[j] + 3.0 * pa_yz[j] * pc_zz[j] * pb_yy[j] + 2.0 * pc_yy[j] * pa_zzz[j] * pb_y[j] + 3.0 * pc_yz[j] * pa_zz[j] * pb_yy[j]);

                t_yzzz_yy[j] += fl_s_0_0_3 * (-0.75 * pa_y[j] * pc_z[j] * fl2_fx - 2.25 * pc_y[j] * pa_z[j] * fl2_fx - 4.5 * pc_yz[j] * fl2_fx - 1.5 * fl2_fx * pc_z[j] * pb_y[j] - 1.5 * pa_yz[j] * pc_zz[j] * fl1_fx - 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx - 4.5 * pc_yz[j] * pa_zz[j] * fl1_fx - 4.5 * pc_yzz[j] * pa_z[j] * fl1_fx - fl1_fx * pc_zzz[j] * pb_y[j] - 3.0 * fl1_fx * pa_z[j] * pc_zz[j] * pb_y[j] - 1.5 * pa_yz[j] * fl1_fx * pc_yy[j] - 1.5 * pa_y[j] * pc_yyz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yyy[j] * pa_z[j] * fl1_fx - 3.0 * pc_yy[j] * pa_z[j] * fl1_fx * pb_y[j] - 3.0 * pc_yyz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yz[j] * fl1_fx * pb_yy[j] - 3.0 * pa_yzz[j] * pc_yyz[j] - 6.0 * pa_yz[j] * pc_yzz[j] * pb_y[j] - pa_y[j] * pc_zzz[j] * pb_yy[j] - pc_yyy[j] * pa_zzz[j] - 6.0 * pc_yyz[j] * pa_zz[j] * pb_y[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_yy[j]);

                t_yzzz_yy[j] += fl_s_0_0_4 * (2.25 * pc_yz[j] * fl2_fx + 0.5 * pa_y[j] * pc_zzz[j] * fl1_fx + 4.5 * pc_yzz[j] * pa_z[j] * fl1_fx + 1.5 * pc_yzzz[j] * fl1_fx + fl1_fx * pc_zzz[j] * pb_y[j] + 1.5 * pa_y[j] * pc_yyz[j] * fl1_fx + 1.5 * pc_yyy[j] * pa_z[j] * fl1_fx + 1.5 * pc_yyyz[j] * fl1_fx + 3.0 * pc_yyz[j] * fl1_fx * pb_y[j] + 3.0 * pa_yz[j] * pc_yyzz[j] + 2.0 * pa_y[j] * pc_yzzz[j] * pb_y[j] + 3.0 * pc_yyyz[j] * pa_zz[j] + 6.0 * pc_yyzz[j] * pa_z[j] * pb_y[j] + pc_yzzz[j] * pb_yy[j]);

                t_yzzz_yy[j] += fl_s_0_0_5 * (-1.5 * pc_yzzz[j] * fl1_fx - 1.5 * pc_yyyz[j] * fl1_fx - pa_y[j] * pc_yyzzz[j] - 3.0 * pc_yyyzz[j] * pa_z[j] - 2.0 * pc_yyzzz[j] * pb_y[j]);

                t_yzzz_yy[j] += fl_s_0_0_6 * pc_yyyzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_82_83(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (82,83)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(34 * idx + 17);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yzzz = paDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyzzzz = pcDistances.data(83 * idx + 80);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yzzz_yz = primBuffer.data(90 * idx + 82);

            // Batch of Integrals (82,83)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_yzzz, pa_z, pa_zz, pa_zzz, pb_y, pb_yz, pb_z, pc_y, \
                                     pc_yy, pc_yyz, pc_yyzz, pc_yyzzz, pc_yyzzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, \
                                     pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, \
                                     s_0_0_6, t_yzzz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_yzzz_yz[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 0.75 * fl2_fx * pa_zz[j] + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 1.5 * pa_yzz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pa_zzz[j] * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pb_yz[j] + pa_yzzz[j] * pb_yz[j]);

                t_yzzz_yz[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 1.5 * fl2_fx * pa_zz[j] - 2.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * pa_y[j] * fl2_fx * pc_y[j] - 1.5 * pa_y[j] * fl2_fx * pb_y[j] - 0.75 * pc_y[j] * fl2_fx * pb_y[j] - 1.5 * fl2_fx * pa_z[j] * pb_z[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 1.5 * pa_yzz[j] * fl1_fx * pc_y[j] - 1.5 * pa_yzz[j] * fl1_fx * pb_y[j] - 4.5 * pa_yz[j] * pc_z[j] * fl1_fx * pb_y[j] - 1.5 * pc_y[j] * pa_zz[j] * fl1_fx * pb_y[j] - 0.5 * fl1_fx * pa_zzz[j] * pc_z[j] - 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_z[j] - 0.5 * fl1_fx * pa_zzz[j] * pb_z[j] - 1.5 * pa_yz[j] * fl1_fx * pc_y[j] * pb_z[j] - 1.5 * pa_yz[j] * fl1_fx * pb_yz[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yz[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yz[j] - pa_yzzz[j] * pb_y[j] * pc_z[j] - pa_yzzz[j] * pc_y[j] * pb_z[j] - 3.0 * pa_yzz[j] * pc_z[j] * pb_yz[j] - pc_y[j] * pa_zzz[j] * pb_yz[j]);

                t_yzzz_yz[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 4.5 * fl2_fx * pa_z[j] * pc_z[j] + 1.5 * fl2_fx * pc_zz[j] + 0.75 * fl2_fx * pa_zz[j] + 1.5 * pa_y[j] * fl2_fx * pc_y[j] + 0.75 * pa_y[j] * fl2_fx * pb_y[j] + 0.75 * pc_yy[j] * fl2_fx + 1.5 * pc_y[j] * fl2_fx * pb_y[j] + 1.5 * fl2_fx * pc_z[j] * pb_z[j] + 0.75 * fl2_fx * pa_z[j] * pb_z[j] + 1.5 * pa_yzz[j] * fl1_fx * pc_y[j] + 4.5 * pa_yz[j] * pc_yz[j] * fl1_fx + 4.5 * pa_yz[j] * pc_z[j] * fl1_fx * pb_y[j] + 3.0 * pa_y[j] * pc_zz[j] * fl1_fx * pb_y[j] + 1.5 * pc_yy[j] * pa_zz[j] * fl1_fx + 1.5 * pc_y[j] * pa_zz[j] * fl1_fx * pb_y[j] + 4.5 * pc_yz[j] * pa_z[j] * fl1_fx * pb_y[j] + 1.5 * fl1_fx * pa_zz[j] * pc_zz[j] + 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] + 0.5 * fl1_fx * pa_zzz[j] * pc_z[j] + 1.5 * fl1_fx * pa_zz[j] * pc_z[j] * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pc_y[j] * pb_z[j] + 1.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_yz[j] + 1.5 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_yz[j] + 1.5 * pc_yz[j] * fl1_fx * pb_yz[j] + pa_yzzz[j] * pc_yz[j] + 3.0 * pa_yzz[j] * pc_zz[j] * pb_y[j] + 3.0 * pa_yzz[j] * pc_yz[j] * pb_z[j] + 3.0 * pa_yz[j] * pc_zz[j] * pb_yz[j] + pc_yz[j] * pa_zzz[j] * pb_y[j] + pc_yy[j] * pa_zzz[j] * pb_z[j] + 3.0 * pc_yz[j] * pa_zz[j] * pb_yz[j]);

                t_yzzz_yz[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * fl2_fx * pc_zz[j] - 2.25 * fl2_fx * pa_z[j] * pc_z[j] - 0.75 * pa_y[j] * fl2_fx * pc_y[j] - 1.5 * pc_yy[j] * fl2_fx - 0.75 * pc_y[j] * fl2_fx * pb_y[j] - 0.75 * fl2_fx * pc_z[j] * pb_z[j] - 4.5 * pa_yz[j] * pc_yz[j] * fl1_fx - 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx - 3.0 * pa_y[j] * pc_zz[j] * fl1_fx * pb_y[j] - 1.5 * pc_yy[j] * pa_zz[j] * fl1_fx - 4.5 * pc_yyz[j] * pa_z[j] * fl1_fx - 4.5 * pc_yz[j] * pa_z[j] * fl1_fx * pb_y[j] - 3.0 * pc_yzz[j] * fl1_fx * pb_y[j] - 1.5 * fl1_fx * pa_z[j] * pc_zzz[j] - 0.5 * fl1_fx * pc_zzz[j] * pb_z[j] - 1.5 * fl1_fx * pa_zz[j] * pc_zz[j] - 1.5 * fl1_fx * pa_z[j] * pc_zz[j] * pb_z[j] - 1.5 * pa_y[j] * pc_yz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yy[j] * pa_z[j] * fl1_fx * pb_z[j] - 1.5 * pc_yyz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_yz[j] - 3.0 * pa_yzz[j] * pc_yzz[j] - 3.0 * pa_yz[j] * pc_zzz[j] * pb_y[j] - 3.0 * pa_yz[j] * pc_yzz[j] * pb_z[j] - pa_y[j] * pc_zzz[j] * pb_yz[j] - pc_yyz[j] * pa_zzz[j] - 3.0 * pc_yzz[j] * pa_zz[j] * pb_y[j] - 3.0 * pc_yyz[j] * pa_zz[j] * pb_z[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_yz[j]);

                t_yzzz_yz[j] += fl_s_0_0_4 * (1.5 * fl2_fx * pc_zz[j] + 0.75 * pc_yy[j] * fl2_fx + 3.0 * pa_y[j] * pc_yzz[j] * fl1_fx + 4.5 * pc_yyz[j] * pa_z[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 3.0 * pc_yzz[j] * fl1_fx * pb_y[j] + 0.5 * fl1_fx * pc_zzzz[j] + 1.5 * fl1_fx * pa_z[j] * pc_zzz[j] + 0.5 * fl1_fx * pc_zzz[j] * pb_z[j] + 1.5 * pc_yyz[j] * fl1_fx * pb_z[j] + 3.0 * pa_yz[j] * pc_yzzz[j] + pa_y[j] * pc_zzzz[j] * pb_y[j] + pa_y[j] * pc_yzzz[j] * pb_z[j] + 3.0 * pc_yyzz[j] * pa_zz[j] + 3.0 * pc_yzzz[j] * pa_z[j] * pb_y[j] + 3.0 * pc_yyzz[j] * pa_z[j] * pb_z[j] + pc_yzzz[j] * pb_yz[j]);

                t_yzzz_yz[j] += fl_s_0_0_5 * (-3.0 * pc_yyzz[j] * fl1_fx - 0.5 * fl1_fx * pc_zzzz[j] - pa_y[j] * pc_yzzzz[j] - 3.0 * pc_yyzzz[j] * pa_z[j] - pc_yzzzz[j] * pb_y[j] - pc_yyzzz[j] * pb_z[j]);

                t_yzzz_yz[j] += fl_s_0_0_6 * pc_yyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_83_84(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (83,84)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_y = paDistances.data(34 * idx + 1);

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_yz = paDistances.data(34 * idx + 7);

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_yzz = paDistances.data(34 * idx + 17);

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_yzzz = paDistances.data(34 * idx + 32);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yzzzzz = pcDistances.data(83 * idx + 81);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_yzzz_zz = primBuffer.data(90 * idx + 83);

            // Batch of Integrals (83,84)

            #pragma omp simd aligned(fx, pa_y, pa_yz, pa_yzz, pa_yzzz, pa_z, pa_zz, pa_zzz, pb_z, pb_zz, pc_y, pc_yz, \
                                     pc_yzz, pc_yzzz, pc_yzzzz, pc_yzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_yzzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_yzzz_zz[j] = fl_s_0_0_0 * (2.25 * pa_yz[j] * fl2_fx + 1.5 * pa_y[j] * fl2_fx * pb_z[j] + 0.5 * pa_yzzz[j] * fl1_fx + 3.0 * pa_yzz[j] * fl1_fx * pb_z[j] + 1.5 * pa_yz[j] * fl1_fx * pb_zz[j] + pa_yzzz[j] * pb_zz[j]);

                t_yzzz_zz[j] += fl_s_0_0_1 * (-4.5 * pa_yz[j] * fl2_fx - 3.75 * pa_y[j] * pc_z[j] * fl2_fx - 2.25 * pc_y[j] * pa_z[j] * fl2_fx - 3.0 * pa_y[j] * fl2_fx * pb_z[j] - 1.5 * pc_y[j] * fl2_fx * pb_z[j] - 0.5 * pa_yzzz[j] * fl1_fx - 4.5 * pa_yzz[j] * pc_z[j] * fl1_fx - 3.0 * pa_yzz[j] * fl1_fx * pb_z[j] - 9.0 * pa_yz[j] * pc_z[j] * fl1_fx * pb_z[j] - 0.5 * pc_y[j] * pa_zzz[j] * fl1_fx - 3.0 * pc_y[j] * pa_zz[j] * fl1_fx * pb_z[j] - 1.5 * pa_yz[j] * fl1_fx * pb_zz[j] - 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_zz[j] - 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_yzzz[j] * pb_z[j] * pc_z[j] - 3.0 * pa_yzz[j] * pc_z[j] * pb_zz[j] - pc_y[j] * pa_zzz[j] * pb_zz[j]);

                t_yzzz_zz[j] += fl_s_0_0_2 * (2.25 * pa_yz[j] * fl2_fx + 7.5 * pa_y[j] * pc_z[j] * fl2_fx + 4.5 * pc_y[j] * pa_z[j] * fl2_fx + 3.75 * pc_yz[j] * fl2_fx + 1.5 * pa_y[j] * fl2_fx * pb_z[j] + 3.0 * pc_y[j] * fl2_fx * pb_z[j] + 4.5 * pa_yzz[j] * pc_z[j] * fl1_fx + 9.0 * pa_yz[j] * pc_zz[j] * fl1_fx + 9.0 * pa_yz[j] * pc_z[j] * fl1_fx * pb_z[j] + 6.0 * pa_y[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.5 * pc_y[j] * pa_zzz[j] * fl1_fx + 4.5 * pc_yz[j] * pa_zz[j] * fl1_fx + 3.0 * pc_y[j] * pa_zz[j] * fl1_fx * pb_z[j] + 9.0 * pc_yz[j] * pa_z[j] * fl1_fx * pb_z[j] + 1.5 * pa_y[j] * pc_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_y[j] * pa_z[j] * fl1_fx * pb_zz[j] + 1.5 * pc_yz[j] * fl1_fx * pb_zz[j] + pa_yzzz[j] * pc_zz[j] + 6.0 * pa_yzz[j] * pc_zz[j] * pb_z[j] + 3.0 * pa_yz[j] * pc_zz[j] * pb_zz[j] + 2.0 * pc_yz[j] * pa_zzz[j] * pb_z[j] + 3.0 * pc_yz[j] * pa_zz[j] * pb_zz[j]);

                t_yzzz_zz[j] += fl_s_0_0_3 * (-3.75 * pa_y[j] * pc_z[j] * fl2_fx - 2.25 * pc_y[j] * pa_z[j] * fl2_fx - 7.5 * pc_yz[j] * fl2_fx - 1.5 * pc_y[j] * fl2_fx * pb_z[j] - 9.0 * pa_yz[j] * pc_zz[j] * fl1_fx - 5.0 * pa_y[j] * pc_zzz[j] * fl1_fx - 6.0 * pa_y[j] * pc_zz[j] * fl1_fx * pb_z[j] - 4.5 * pc_yz[j] * pa_zz[j] * fl1_fx - 9.0 * pc_yzz[j] * pa_z[j] * fl1_fx - 9.0 * pc_yz[j] * pa_z[j] * fl1_fx * pb_z[j] - 6.0 * pc_yzz[j] * fl1_fx * pb_z[j] - 1.5 * pc_yz[j] * fl1_fx * pb_zz[j] - 3.0 * pa_yzz[j] * pc_zzz[j] - 6.0 * pa_yz[j] * pc_zzz[j] * pb_z[j] - pa_y[j] * pc_zzz[j] * pb_zz[j] - pc_yzz[j] * pa_zzz[j] - 6.0 * pc_yzz[j] * pa_zz[j] * pb_z[j] - 3.0 * pc_yzz[j] * pa_z[j] * pb_zz[j]);

                t_yzzz_zz[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 5.0 * pa_y[j] * pc_zzz[j] * fl1_fx + 9.0 * pc_yzz[j] * pa_z[j] * fl1_fx + 5.0 * pc_yzzz[j] * fl1_fx + 6.0 * pc_yzz[j] * fl1_fx * pb_z[j] + 3.0 * pa_yz[j] * pc_zzzz[j] + 2.0 * pa_y[j] * pc_zzzz[j] * pb_z[j] + 3.0 * pc_yzzz[j] * pa_zz[j] + 6.0 * pc_yzzz[j] * pa_z[j] * pb_z[j] + pc_yzzz[j] * pb_zz[j]);

                t_yzzz_zz[j] += fl_s_0_0_5 * (-5.0 * pc_yzzz[j] * fl1_fx - pa_y[j] * pc_zzzzz[j] - 3.0 * pc_yzzzz[j] * pa_z[j] - 2.0 * pc_yzzzz[j] * pb_z[j]);

                t_yzzz_zz[j] += fl_s_0_0_6 * pc_yzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_84_85(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (84,85)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_zzzz = paDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xx = pbDistances.data(9 * idx + 3);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xx = pcDistances.data(83 * idx + 3);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xxz = pcDistances.data(83 * idx + 11);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xxzz = pcDistances.data(83 * idx + 24);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xxzzz = pcDistances.data(83 * idx + 43);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xxzzzz = pcDistances.data(83 * idx + 69);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zzzz_xx = primBuffer.data(90 * idx + 84);

            // Batch of Integrals (84,85)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pa_zzzz, pb_x, pb_xx, pc_x, pc_xx, pc_xxz, pc_xxzz, \
                                     pc_xxzzz, pc_xxzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zzzz_xx: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zzzz_xx[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 1.5 * pa_zz[j] * fl2_fx + 0.5 * pa_zzzz[j] * fl1_fx + 0.75 * fl2_fx * pb_xx[j] + 3.0 * pa_zz[j] * fl1_fx * pb_xx[j] + pa_zzzz[j] * pb_xx[j]);

                t_zzzz_xx[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 3.0 * pa_zz[j] * fl2_fx - 3.0 * pa_z[j] * pc_z[j] * fl2_fx - 0.5 * pa_zzzz[j] * fl1_fx - 2.0 * pa_zzz[j] * pc_z[j] * fl1_fx - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 1.5 * fl2_fx * pb_xx[j] - 6.0 * pa_zz[j] * fl1_fx * pb_x[j] * pc_x[j] - 3.0 * pa_zz[j] * fl1_fx * pb_xx[j] - 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_xx[j] - 2.0 * pa_zzzz[j] * pb_x[j] * pc_x[j] - 4.0 * pa_zzz[j] * pc_z[j] * pb_xx[j]);

                t_zzzz_xx[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_zz[j] * fl2_fx + 6.0 * pa_z[j] * pc_z[j] * fl2_fx + 1.5 * pc_zz[j] * fl2_fx + 2.0 * pa_zzz[j] * pc_z[j] * fl1_fx + 3.0 * pa_zz[j] * pc_zz[j] * fl1_fx + 0.75 * fl2_fx * pc_xx[j] + 3.0 * fl2_fx * pb_x[j] * pc_x[j] + 0.75 * fl2_fx * pb_xx[j] + 3.0 * pa_zz[j] * fl1_fx * pc_xx[j] + 6.0 * pa_zz[j] * fl1_fx * pb_x[j] * pc_x[j] + 12.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_x[j] + 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_xx[j] + 3.0 * pc_zz[j] * fl1_fx * pb_xx[j] + pa_zzzz[j] * pc_xx[j] + 8.0 * pa_zzz[j] * pc_xz[j] * pb_x[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_xx[j]);

                t_zzzz_xx[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * pa_z[j] * pc_z[j] * fl2_fx - 3.0 * pc_zz[j] * fl2_fx - 3.0 * pa_zz[j] * pc_zz[j] * fl1_fx - 2.0 * pa_z[j] * pc_zzz[j] * fl1_fx - 1.5 * fl2_fx * pc_xx[j] - 1.5 * fl2_fx * pb_x[j] * pc_x[j] - 3.0 * pa_zz[j] * fl1_fx * pc_xx[j] - 6.0 * pa_z[j] * pc_xxz[j] * fl1_fx - 12.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_x[j] - 6.0 * pc_xzz[j] * fl1_fx * pb_x[j] - 3.0 * pc_zz[j] * fl1_fx * pb_xx[j] - 4.0 * pa_zzz[j] * pc_xxz[j] - 12.0 * pa_zz[j] * pc_xzz[j] * pb_x[j] - 4.0 * pa_z[j] * pc_zzz[j] * pb_xx[j]);

                t_zzzz_xx[j] += fl_s_0_0_4 * (1.5 * pc_zz[j] * fl2_fx + 2.0 * pa_z[j] * pc_zzz[j] * fl1_fx + 0.5 * pc_zzzz[j] * fl1_fx + 0.75 * fl2_fx * pc_xx[j] + 6.0 * pa_z[j] * pc_xxz[j] * fl1_fx + 3.0 * pc_xxzz[j] * fl1_fx + 6.0 * pc_xzz[j] * fl1_fx * pb_x[j] + 6.0 * pa_zz[j] * pc_xxzz[j] + 8.0 * pa_z[j] * pc_xzzz[j] * pb_x[j] + pc_zzzz[j] * pb_xx[j]);

                t_zzzz_xx[j] += fl_s_0_0_5 * (-0.5 * pc_zzzz[j] * fl1_fx - 3.0 * pc_xxzz[j] * fl1_fx - 4.0 * pa_z[j] * pc_xxzzz[j] - 2.0 * pc_xzzzz[j] * pb_x[j]);

                t_zzzz_xx[j] += fl_s_0_0_6 * pc_xxzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_85_86(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (85,86)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_zzzz = paDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xy = pbDistances.data(9 * idx + 4);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xy = pcDistances.data(83 * idx + 4);

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xyz = pcDistances.data(83 * idx + 13);

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xyzz = pcDistances.data(83 * idx + 27);

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xyzzz = pcDistances.data(83 * idx + 47);

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xyzzzz = pcDistances.data(83 * idx + 74);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zzzz_xy = primBuffer.data(90 * idx + 85);

            // Batch of Integrals (85,86)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pa_zzzz, pb_x, pb_xy, pb_y, pc_x, pc_xy, pc_xyz, pc_xyzz, \
                                     pc_xyzzz, pc_xyzzzz, pc_xz, pc_xzz, pc_xzzz, pc_xzzzz, pc_y, pc_yz, pc_yzz, pc_yzzz, \
                                     pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, \
                                     s_0_0_5, s_0_0_6, t_zzzz_xy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zzzz_xy[j] = fl_s_0_0_0 * (0.75 * fl2_fx * pb_xy[j] + 3.0 * pa_zz[j] * fl1_fx * pb_xy[j] + pa_zzzz[j] * pb_xy[j]);

                t_zzzz_xy[j] += fl_s_0_0_1 * (-0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 1.5 * fl2_fx * pb_xy[j] - 3.0 * pa_zz[j] * fl1_fx * pb_x[j] * pc_y[j] - 3.0 * pa_zz[j] * fl1_fx * pc_x[j] * pb_y[j] - 3.0 * pa_zz[j] * fl1_fx * pb_xy[j] - 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_xy[j] - pa_zzzz[j] * pb_x[j] * pc_y[j] - pa_zzzz[j] * pc_x[j] * pb_y[j] - 4.0 * pa_zzz[j] * pc_z[j] * pb_xy[j]);

                t_zzzz_xy[j] += fl_s_0_0_2 * (0.75 * fl2_fx * pc_xy[j] + 1.5 * fl2_fx * pb_x[j] * pc_y[j] + 1.5 * fl2_fx * pc_x[j] * pb_y[j] + 0.75 * fl2_fx * pb_xy[j] + 3.0 * pa_zz[j] * fl1_fx * pc_xy[j] + 3.0 * pa_zz[j] * fl1_fx * pb_x[j] * pc_y[j] + 3.0 * pa_zz[j] * fl1_fx * pc_x[j] * pb_y[j] + 6.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_x[j] + 6.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_y[j] + 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_xy[j] + 3.0 * pc_zz[j] * fl1_fx * pb_xy[j] + pa_zzzz[j] * pc_xy[j] + 4.0 * pa_zzz[j] * pc_yz[j] * pb_x[j] + 4.0 * pa_zzz[j] * pc_xz[j] * pb_y[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_xy[j]);

                t_zzzz_xy[j] += fl_s_0_0_3 * (-1.5 * fl2_fx * pc_xy[j] - 0.75 * fl2_fx * pb_x[j] * pc_y[j] - 0.75 * fl2_fx * pc_x[j] * pb_y[j] - 3.0 * pa_zz[j] * fl1_fx * pc_xy[j] - 6.0 * pa_z[j] * pc_xyz[j] * fl1_fx - 6.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_x[j] - 6.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_y[j] - 3.0 * pc_yzz[j] * fl1_fx * pb_x[j] - 3.0 * pc_xzz[j] * fl1_fx * pb_y[j] - 3.0 * pc_zz[j] * fl1_fx * pb_xy[j] - 4.0 * pa_zzz[j] * pc_xyz[j] - 6.0 * pa_zz[j] * pc_yzz[j] * pb_x[j] - 6.0 * pa_zz[j] * pc_xzz[j] * pb_y[j] - 4.0 * pa_z[j] * pc_zzz[j] * pb_xy[j]);

                t_zzzz_xy[j] += fl_s_0_0_4 * (0.75 * fl2_fx * pc_xy[j] + 6.0 * pa_z[j] * pc_xyz[j] * fl1_fx + 3.0 * pc_xyzz[j] * fl1_fx + 3.0 * pc_yzz[j] * fl1_fx * pb_x[j] + 3.0 * pc_xzz[j] * fl1_fx * pb_y[j] + 6.0 * pa_zz[j] * pc_xyzz[j] + 4.0 * pa_z[j] * pc_yzzz[j] * pb_x[j] + 4.0 * pa_z[j] * pc_xzzz[j] * pb_y[j] + pc_zzzz[j] * pb_xy[j]);

                t_zzzz_xy[j] += fl_s_0_0_5 * (-3.0 * pc_xyzz[j] * fl1_fx - 4.0 * pa_z[j] * pc_xyzzz[j] - pc_yzzzz[j] * pb_x[j] - pc_xzzzz[j] * pb_y[j]);

                t_zzzz_xy[j] += fl_s_0_0_6 * pc_xyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_86_87(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (86,87)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_zzzz = paDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_x = pbDistances.data(9 * idx);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_xz = pbDistances.data(9 * idx + 5);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_x = pcDistances.data(83 * idx);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_xz = pcDistances.data(83 * idx + 5);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_xzz = pcDistances.data(83 * idx + 14);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_xzzz = pcDistances.data(83 * idx + 28);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_xzzzz = pcDistances.data(83 * idx + 48);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_xzzzzz = pcDistances.data(83 * idx + 75);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zzzz_xz = primBuffer.data(90 * idx + 86);

            // Batch of Integrals (86,87)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pa_zzzz, pb_x, pb_xz, pb_z, pc_x, pc_xz, pc_xzz, pc_xzzz, \
                                     pc_xzzzz, pc_xzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zzzz_xz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zzzz_xz[j] = fl_s_0_0_0 * (3.0 * pa_z[j] * fl2_fx * pb_x[j] + 2.0 * pa_zzz[j] * fl1_fx * pb_x[j] + 0.75 * fl2_fx * pb_xz[j] + 3.0 * pa_zz[j] * fl1_fx * pb_xz[j] + pa_zzzz[j] * pb_xz[j]);

                t_zzzz_xz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx * pc_x[j] - 6.0 * pa_z[j] * fl2_fx * pb_x[j] - 3.75 * pc_z[j] * fl2_fx * pb_x[j] - 2.0 * pa_zzz[j] * fl1_fx * pc_x[j] - 2.0 * pa_zzz[j] * fl1_fx * pb_x[j] - 9.0 * pa_zz[j] * pc_z[j] * fl1_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 1.5 * fl2_fx * pb_xz[j] - 3.0 * pa_zz[j] * fl1_fx * pc_x[j] * pb_z[j] - 3.0 * pa_zz[j] * fl1_fx * pb_xz[j] - 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_xz[j] - pa_zzzz[j] * pb_x[j] * pc_z[j] - pa_zzzz[j] * pc_x[j] * pb_z[j] - 4.0 * pa_zzz[j] * pc_z[j] * pb_xz[j]);

                t_zzzz_xz[j] += fl_s_0_0_2 * (6.0 * pa_z[j] * fl2_fx * pc_x[j] + 3.0 * pa_z[j] * fl2_fx * pb_x[j] + 3.75 * pc_xz[j] * fl2_fx + 7.5 * pc_z[j] * fl2_fx * pb_x[j] + 2.0 * pa_zzz[j] * fl1_fx * pc_x[j] + 9.0 * pa_zz[j] * pc_xz[j] * fl1_fx + 9.0 * pa_zz[j] * pc_z[j] * fl1_fx * pb_x[j] + 12.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_x[j] + 1.5 * fl2_fx * pc_x[j] * pb_z[j] + 0.75 * fl2_fx * pb_xz[j] + 3.0 * pa_zz[j] * fl1_fx * pc_x[j] * pb_z[j] + 6.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_z[j] + 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_xz[j] + 3.0 * pc_zz[j] * fl1_fx * pb_xz[j] + pa_zzzz[j] * pc_xz[j] + 4.0 * pa_zzz[j] * pc_zz[j] * pb_x[j] + 4.0 * pa_zzz[j] * pc_xz[j] * pb_z[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_xz[j]);

                t_zzzz_xz[j] += fl_s_0_0_3 * (-3.0 * pa_z[j] * fl2_fx * pc_x[j] - 7.5 * pc_xz[j] * fl2_fx - 3.75 * pc_z[j] * fl2_fx * pb_x[j] - 9.0 * pa_zz[j] * pc_xz[j] * fl1_fx - 12.0 * pa_z[j] * pc_xzz[j] * fl1_fx - 12.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_x[j] - 5.0 * pc_zzz[j] * fl1_fx * pb_x[j] - 0.75 * fl2_fx * pc_x[j] * pb_z[j] - 6.0 * pa_z[j] * pc_xz[j] * fl1_fx * pb_z[j] - 3.0 * pc_xzz[j] * fl1_fx * pb_z[j] - 3.0 * pc_zz[j] * fl1_fx * pb_xz[j] - 4.0 * pa_zzz[j] * pc_xzz[j] - 6.0 * pa_zz[j] * pc_zzz[j] * pb_x[j] - 6.0 * pa_zz[j] * pc_xzz[j] * pb_z[j] - 4.0 * pa_z[j] * pc_zzz[j] * pb_xz[j]);

                t_zzzz_xz[j] += fl_s_0_0_4 * (3.75 * pc_xz[j] * fl2_fx + 12.0 * pa_z[j] * pc_xzz[j] * fl1_fx + 5.0 * pc_xzzz[j] * fl1_fx + 5.0 * pc_zzz[j] * fl1_fx * pb_x[j] + 3.0 * pc_xzz[j] * fl1_fx * pb_z[j] + 6.0 * pa_zz[j] * pc_xzzz[j] + 4.0 * pa_z[j] * pc_zzzz[j] * pb_x[j] + 4.0 * pa_z[j] * pc_xzzz[j] * pb_z[j] + pc_zzzz[j] * pb_xz[j]);

                t_zzzz_xz[j] += fl_s_0_0_5 * (-5.0 * pc_xzzz[j] * fl1_fx - 4.0 * pa_z[j] * pc_xzzzz[j] - pc_zzzzz[j] * pb_x[j] - pc_xzzzz[j] * pb_z[j]);

                t_zzzz_xz[j] += fl_s_0_0_6 * pc_xzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_87_88(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (87,88)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_zzzz = paDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yy = pbDistances.data(9 * idx + 6);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yy = pcDistances.data(83 * idx + 6);

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yyz = pcDistances.data(83 * idx + 16);

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yyzz = pcDistances.data(83 * idx + 31);

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yyzzz = pcDistances.data(83 * idx + 52);

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yyzzzz = pcDistances.data(83 * idx + 80);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zzzz_yy = primBuffer.data(90 * idx + 87);

            // Batch of Integrals (87,88)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pa_zzzz, pb_y, pb_yy, pc_y, pc_yy, pc_yyz, pc_yyzz, \
                                     pc_yyzzz, pc_yyzzzz, pc_yz, pc_yzz, pc_yzzz, pc_yzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zzzz_yy: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zzzz_yy[j] = fl_s_0_0_0 * (0.375 * fl3_fx + 1.5 * pa_zz[j] * fl2_fx + 0.5 * pa_zzzz[j] * fl1_fx + 0.75 * fl2_fx * pb_yy[j] + 3.0 * pa_zz[j] * fl1_fx * pb_yy[j] + pa_zzzz[j] * pb_yy[j]);

                t_zzzz_yy[j] += fl_s_0_0_1 * (-1.125 * fl3_fx - 3.0 * pa_zz[j] * fl2_fx - 3.0 * pa_z[j] * pc_z[j] * fl2_fx - 0.5 * pa_zzzz[j] * fl1_fx - 2.0 * pa_zzz[j] * pc_z[j] * fl1_fx - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 1.5 * fl2_fx * pb_yy[j] - 6.0 * pa_zz[j] * fl1_fx * pb_y[j] * pc_y[j] - 3.0 * pa_zz[j] * fl1_fx * pb_yy[j] - 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_yy[j] - 2.0 * pa_zzzz[j] * pb_y[j] * pc_y[j] - 4.0 * pa_zzz[j] * pc_z[j] * pb_yy[j]);

                t_zzzz_yy[j] += fl_s_0_0_2 * (1.125 * fl3_fx + 1.5 * pa_zz[j] * fl2_fx + 6.0 * pa_z[j] * pc_z[j] * fl2_fx + 1.5 * pc_zz[j] * fl2_fx + 2.0 * pa_zzz[j] * pc_z[j] * fl1_fx + 3.0 * pa_zz[j] * pc_zz[j] * fl1_fx + 0.75 * fl2_fx * pc_yy[j] + 3.0 * fl2_fx * pb_y[j] * pc_y[j] + 0.75 * fl2_fx * pb_yy[j] + 3.0 * pa_zz[j] * fl1_fx * pc_yy[j] + 6.0 * pa_zz[j] * fl1_fx * pb_y[j] * pc_y[j] + 12.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_y[j] + 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_yy[j] + 3.0 * pc_zz[j] * fl1_fx * pb_yy[j] + pa_zzzz[j] * pc_yy[j] + 8.0 * pa_zzz[j] * pc_yz[j] * pb_y[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_yy[j]);

                t_zzzz_yy[j] += fl_s_0_0_3 * (-0.375 * fl3_fx - 3.0 * pa_z[j] * pc_z[j] * fl2_fx - 3.0 * pc_zz[j] * fl2_fx - 3.0 * pa_zz[j] * pc_zz[j] * fl1_fx - 2.0 * pa_z[j] * pc_zzz[j] * fl1_fx - 1.5 * fl2_fx * pc_yy[j] - 1.5 * fl2_fx * pb_y[j] * pc_y[j] - 3.0 * pa_zz[j] * fl1_fx * pc_yy[j] - 6.0 * pa_z[j] * pc_yyz[j] * fl1_fx - 12.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_y[j] - 6.0 * pc_yzz[j] * fl1_fx * pb_y[j] - 3.0 * pc_zz[j] * fl1_fx * pb_yy[j] - 4.0 * pa_zzz[j] * pc_yyz[j] - 12.0 * pa_zz[j] * pc_yzz[j] * pb_y[j] - 4.0 * pa_z[j] * pc_zzz[j] * pb_yy[j]);

                t_zzzz_yy[j] += fl_s_0_0_4 * (1.5 * pc_zz[j] * fl2_fx + 2.0 * pa_z[j] * pc_zzz[j] * fl1_fx + 0.5 * pc_zzzz[j] * fl1_fx + 0.75 * fl2_fx * pc_yy[j] + 6.0 * pa_z[j] * pc_yyz[j] * fl1_fx + 3.0 * pc_yyzz[j] * fl1_fx + 6.0 * pc_yzz[j] * fl1_fx * pb_y[j] + 6.0 * pa_zz[j] * pc_yyzz[j] + 8.0 * pa_z[j] * pc_yzzz[j] * pb_y[j] + pc_zzzz[j] * pb_yy[j]);

                t_zzzz_yy[j] += fl_s_0_0_5 * (-0.5 * pc_zzzz[j] * fl1_fx - 3.0 * pc_yyzz[j] * fl1_fx - 4.0 * pa_z[j] * pc_yyzzz[j] - 2.0 * pc_yzzzz[j] * pb_y[j]);

                t_zzzz_yy[j] += fl_s_0_0_6 * pc_yyzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_88_89(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (88,89)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_zzzz = paDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_y = pbDistances.data(9 * idx + 1);

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_yz = pbDistances.data(9 * idx + 7);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_y = pcDistances.data(83 * idx + 1);

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_yz = pcDistances.data(83 * idx + 7);

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_yzz = pcDistances.data(83 * idx + 17);

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_yzzz = pcDistances.data(83 * idx + 32);

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_yzzzz = pcDistances.data(83 * idx + 53);

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_yzzzzz = pcDistances.data(83 * idx + 81);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zzzz_yz = primBuffer.data(90 * idx + 88);

            // Batch of Integrals (88,89)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pa_zzzz, pb_y, pb_yz, pb_z, pc_y, pc_yz, pc_yzz, pc_yzzz, \
                                     pc_yzzzz, pc_yzzzzz, pc_z, pc_zz, pc_zzz, pc_zzzz, pc_zzzzz, s_0_0_0, s_0_0_1, s_0_0_2, \
                                     s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, t_zzzz_yz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                t_zzzz_yz[j] = fl_s_0_0_0 * (3.0 * pa_z[j] * fl2_fx * pb_y[j] + 2.0 * pa_zzz[j] * fl1_fx * pb_y[j] + 0.75 * fl2_fx * pb_yz[j] + 3.0 * pa_zz[j] * fl1_fx * pb_yz[j] + pa_zzzz[j] * pb_yz[j]);

                t_zzzz_yz[j] += fl_s_0_0_1 * (-3.0 * pa_z[j] * fl2_fx * pc_y[j] - 6.0 * pa_z[j] * fl2_fx * pb_y[j] - 3.75 * pc_z[j] * fl2_fx * pb_y[j] - 2.0 * pa_zzz[j] * fl1_fx * pc_y[j] - 2.0 * pa_zzz[j] * fl1_fx * pb_y[j] - 9.0 * pa_zz[j] * pc_z[j] * fl1_fx * pb_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 1.5 * fl2_fx * pb_yz[j] - 3.0 * pa_zz[j] * fl1_fx * pc_y[j] * pb_z[j] - 3.0 * pa_zz[j] * fl1_fx * pb_yz[j] - 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_yz[j] - pa_zzzz[j] * pb_y[j] * pc_z[j] - pa_zzzz[j] * pc_y[j] * pb_z[j] - 4.0 * pa_zzz[j] * pc_z[j] * pb_yz[j]);

                t_zzzz_yz[j] += fl_s_0_0_2 * (6.0 * pa_z[j] * fl2_fx * pc_y[j] + 3.0 * pa_z[j] * fl2_fx * pb_y[j] + 3.75 * pc_yz[j] * fl2_fx + 7.5 * pc_z[j] * fl2_fx * pb_y[j] + 2.0 * pa_zzz[j] * fl1_fx * pc_y[j] + 9.0 * pa_zz[j] * pc_yz[j] * fl1_fx + 9.0 * pa_zz[j] * pc_z[j] * fl1_fx * pb_y[j] + 12.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_y[j] + 1.5 * fl2_fx * pc_y[j] * pb_z[j] + 0.75 * fl2_fx * pb_yz[j] + 3.0 * pa_zz[j] * fl1_fx * pc_y[j] * pb_z[j] + 6.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_z[j] + 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_yz[j] + 3.0 * pc_zz[j] * fl1_fx * pb_yz[j] + pa_zzzz[j] * pc_yz[j] + 4.0 * pa_zzz[j] * pc_zz[j] * pb_y[j] + 4.0 * pa_zzz[j] * pc_yz[j] * pb_z[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_yz[j]);

                t_zzzz_yz[j] += fl_s_0_0_3 * (-3.0 * pa_z[j] * fl2_fx * pc_y[j] - 7.5 * pc_yz[j] * fl2_fx - 3.75 * pc_z[j] * fl2_fx * pb_y[j] - 9.0 * pa_zz[j] * pc_yz[j] * fl1_fx - 12.0 * pa_z[j] * pc_yzz[j] * fl1_fx - 12.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_y[j] - 5.0 * pc_zzz[j] * fl1_fx * pb_y[j] - 0.75 * fl2_fx * pc_y[j] * pb_z[j] - 6.0 * pa_z[j] * pc_yz[j] * fl1_fx * pb_z[j] - 3.0 * pc_yzz[j] * fl1_fx * pb_z[j] - 3.0 * pc_zz[j] * fl1_fx * pb_yz[j] - 4.0 * pa_zzz[j] * pc_yzz[j] - 6.0 * pa_zz[j] * pc_zzz[j] * pb_y[j] - 6.0 * pa_zz[j] * pc_yzz[j] * pb_z[j] - 4.0 * pa_z[j] * pc_zzz[j] * pb_yz[j]);

                t_zzzz_yz[j] += fl_s_0_0_4 * (3.75 * pc_yz[j] * fl2_fx + 12.0 * pa_z[j] * pc_yzz[j] * fl1_fx + 5.0 * pc_yzzz[j] * fl1_fx + 5.0 * pc_zzz[j] * fl1_fx * pb_y[j] + 3.0 * pc_yzz[j] * fl1_fx * pb_z[j] + 6.0 * pa_zz[j] * pc_yzzz[j] + 4.0 * pa_z[j] * pc_zzzz[j] * pb_y[j] + 4.0 * pa_z[j] * pc_yzzz[j] * pb_z[j] + pc_zzzz[j] * pb_yz[j]);

                t_zzzz_yz[j] += fl_s_0_0_5 * (-5.0 * pc_yzzz[j] * fl1_fx - 4.0 * pa_z[j] * pc_yzzzz[j] - pc_zzzzz[j] * pb_y[j] - pc_yzzzz[j] * pb_z[j]);

                t_zzzz_yz[j] += fl_s_0_0_6 * pc_yzzzzz[j];
            }

            idx++;
        }
    }

    void
    compNuclearPotentialForGD_89_90(      CMemBlock2D<double>& primBuffer,
                                    const CMemBlock2D<double>& auxBuffer,
                                    const CMemBlock2D<double>& osFactors,
                                    const CMemBlock2D<double>& paDistances,
                                    const CMemBlock2D<double>& pbDistances,
                                    const CMemBlock2D<double>& pcDistances,
                                    const CGtoBlock&           braGtoBlock,
                                    const CGtoBlock&           ketGtoBlock,
                                    const int32_t              iContrGto)
    {
        // Batch of Integrals (89,90)

        // set up pointers to primitives data on bra side

        auto spos = braGtoBlock.getStartPositions();

        auto epos = braGtoBlock.getEndPositions();

        // set up pointers to primitives data on ket side

        auto nprim = ketGtoBlock.getNumberOfPrimGtos();

        // loop over contracted GTO on bra side

        int32_t idx = 0;

        for (int32_t i = spos[iContrGto]; i < epos[iContrGto]; i++)
        {
            // set up pointers to Obara-Saika factors

            auto fx = osFactors.data(3 * idx);

            // set up pointers to 1-th order tensor of distance R(PA)

            auto pa_z = paDistances.data(34 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PA)

            auto pa_zz = paDistances.data(34 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PA)

            auto pa_zzz = paDistances.data(34 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PA)

            auto pa_zzzz = paDistances.data(34 * idx + 33);

            // set up pointers to 1-th order tensor of distance R(PB)

            auto pb_z = pbDistances.data(9 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PB)

            auto pb_zz = pbDistances.data(9 * idx + 8);

            // set up pointers to 1-th order tensor of distance R(PC)

            auto pc_z = pcDistances.data(83 * idx + 2);

            // set up pointers to 2-th order tensor of distance R(PC)

            auto pc_zz = pcDistances.data(83 * idx + 8);

            // set up pointers to 3-th order tensor of distance R(PC)

            auto pc_zzz = pcDistances.data(83 * idx + 18);

            // set up pointers to 4-th order tensor of distance R(PC)

            auto pc_zzzz = pcDistances.data(83 * idx + 33);

            // set up pointers to 5-th order tensor of distance R(PC)

            auto pc_zzzzz = pcDistances.data(83 * idx + 54);

            // set up pointers to 6-th order tensor of distance R(PC)

            auto pc_zzzzzz = pcDistances.data(83 * idx + 82);

            // set up pointers to auxilary integrals

            auto s_0_0_0 = auxBuffer.data(7 * idx);

            auto s_0_0_1 = auxBuffer.data(7 * idx + 1);

            auto s_0_0_2 = auxBuffer.data(7 * idx + 2);

            auto s_0_0_3 = auxBuffer.data(7 * idx + 3);

            auto s_0_0_4 = auxBuffer.data(7 * idx + 4);

            auto s_0_0_5 = auxBuffer.data(7 * idx + 5);

            auto s_0_0_6 = auxBuffer.data(7 * idx + 6);

            // set up pointers to integrals

            auto t_zzzz_zz = primBuffer.data(90 * idx + 89);

            // Batch of Integrals (89,90)

            #pragma omp simd aligned(fx, pa_z, pa_zz, pa_zzz, pa_zzzz, pb_z, pb_zz, pc_z, pc_zz, pc_zzz, pc_zzzz, \
                                     pc_zzzzz, pc_zzzzzz, s_0_0_0, s_0_0_1, s_0_0_2, s_0_0_3, s_0_0_4, s_0_0_5, s_0_0_6, \
                                     t_zzzz_zz: VLX_ALIGN)
            for (int32_t j = 0; j < nprim; j++)
            {
                double fl_s_0_0_0 = s_0_0_0[j];

                double fl_s_0_0_1 = s_0_0_1[j];

                double fl_s_0_0_2 = s_0_0_2[j];

                double fl_s_0_0_3 = s_0_0_3[j];

                double fl_s_0_0_4 = s_0_0_4[j];

                double fl_s_0_0_5 = s_0_0_5[j];

                double fl_s_0_0_6 = s_0_0_6[j];

                double fl1_fx = fx[j];

                double fl2_fx = fx[j] * fx[j];

                double fl3_fx = fx[j] * fx[j] * fx[j];

                t_zzzz_zz[j] = fl_s_0_0_0 * (1.875 * fl3_fx + 4.5 * pa_zz[j] * fl2_fx + 6.0 * pa_z[j] * fl2_fx * pb_z[j] + 0.5 * pa_zzzz[j] * fl1_fx + 4.0 * pa_zzz[j] * fl1_fx * pb_z[j] + 0.75 * fl2_fx * pb_zz[j] + 3.0 * pa_zz[j] * fl1_fx * pb_zz[j] + pa_zzzz[j] * pb_zz[j]);

                t_zzzz_zz[j] += fl_s_0_0_1 * (-5.625 * fl3_fx - 9.0 * pa_zz[j] * fl2_fx - 15.0 * pa_z[j] * pc_z[j] * fl2_fx - 12.0 * pa_z[j] * fl2_fx * pb_z[j] - 7.5 * pc_z[j] * fl2_fx * pb_z[j] - 0.5 * pa_zzzz[j] * fl1_fx - 6.0 * pa_zzz[j] * pc_z[j] * fl1_fx - 4.0 * pa_zzz[j] * fl1_fx * pb_z[j] - 18.0 * pa_zz[j] * pc_z[j] * fl1_fx * pb_z[j] - 1.5 * fl2_fx * pb_zz[j] - 3.0 * pa_zz[j] * fl1_fx * pb_zz[j] - 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_zz[j] - 2.0 * pa_zzzz[j] * pb_z[j] * pc_z[j] - 4.0 * pa_zzz[j] * pc_z[j] * pb_zz[j]);

                t_zzzz_zz[j] += fl_s_0_0_2 * (5.625 * fl3_fx + 4.5 * pa_zz[j] * fl2_fx + 30.0 * pa_z[j] * pc_z[j] * fl2_fx + 11.25 * pc_zz[j] * fl2_fx + 6.0 * pa_z[j] * fl2_fx * pb_z[j] + 15.0 * pc_z[j] * fl2_fx * pb_z[j] + 6.0 * pa_zzz[j] * pc_z[j] * fl1_fx + 18.0 * pa_zz[j] * pc_zz[j] * fl1_fx + 18.0 * pa_zz[j] * pc_z[j] * fl1_fx * pb_z[j] + 24.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_z[j] + 0.75 * fl2_fx * pb_zz[j] + 6.0 * pa_z[j] * pc_z[j] * fl1_fx * pb_zz[j] + 3.0 * pc_zz[j] * fl1_fx * pb_zz[j] + pa_zzzz[j] * pc_zz[j] + 8.0 * pa_zzz[j] * pc_zz[j] * pb_z[j] + 6.0 * pa_zz[j] * pc_zz[j] * pb_zz[j]);

                t_zzzz_zz[j] += fl_s_0_0_3 * (-1.875 * fl3_fx - 15.0 * pa_z[j] * pc_z[j] * fl2_fx - 22.5 * pc_zz[j] * fl2_fx - 7.5 * pc_z[j] * fl2_fx * pb_z[j] - 18.0 * pa_zz[j] * pc_zz[j] * fl1_fx - 20.0 * pa_z[j] * pc_zzz[j] * fl1_fx - 24.0 * pa_z[j] * pc_zz[j] * fl1_fx * pb_z[j] - 10.0 * pc_zzz[j] * fl1_fx * pb_z[j] - 3.0 * pc_zz[j] * fl1_fx * pb_zz[j] - 4.0 * pa_zzz[j] * pc_zzz[j] - 12.0 * pa_zz[j] * pc_zzz[j] * pb_z[j] - 4.0 * pa_z[j] * pc_zzz[j] * pb_zz[j]);

                t_zzzz_zz[j] += fl_s_0_0_4 * (11.25 * pc_zz[j] * fl2_fx + 20.0 * pa_z[j] * pc_zzz[j] * fl1_fx + 7.5 * pc_zzzz[j] * fl1_fx + 10.0 * pc_zzz[j] * fl1_fx * pb_z[j] + 6.0 * pa_zz[j] * pc_zzzz[j] + 8.0 * pa_z[j] * pc_zzzz[j] * pb_z[j] + pc_zzzz[j] * pb_zz[j]);

                t_zzzz_zz[j] += fl_s_0_0_5 * (-7.5 * pc_zzzz[j] * fl1_fx - 4.0 * pa_z[j] * pc_zzzzz[j] - 2.0 * pc_zzzzz[j] * pb_z[j]);

                t_zzzz_zz[j] += fl_s_0_0_6 * pc_zzzzzz[j];
            }

            idx++;
        }
    }


} // npotrecfunc namespace

