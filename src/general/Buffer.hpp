//
//                           VELOXCHEM 1.0-RC2
//         ----------------------------------------------------
//                     An Electronic Structure Code
//
//  Copyright Â© 2018-2021 by VeloxChem developers. All rights reserved.
//  Contact: https://veloxchem.org/contact
//
//  SPDX-License-Identifier: LGPL-3.0-or-later
//
//  This file is part of VeloxChem.
//
//  VeloxChem is free software: you can redistribute it and/or modify it under
//  the terms of the GNU Lesser General Public License as published by the Free
//  Software Foundation, either version 3 of the License, or (at your option)
//  any later version.
//
//  VeloxChem is distributed in the hope that it will be useful, but WITHOUT
//  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
//  License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with VeloxChem. If not, see <https://www.gnu.org/licenses/>.

#ifndef Buffer_hpp
#define Buffer_hpp

#include "BufferImpl.hpp"
#include "BufferMacros.hpp"

/** This header file defines template aliases for the various practical
 *  instantiations of the `CBuffer` class.
 *  Many of these aliases are generated by preprocessor macros.
 *
 *  You should never need to use the `CBuffer` class *directly*
 *
 *  Buffers are handles to aligned memory, on the host or on the device.  Any
 *  buffer can be 1-dimensional or 2-dimensional, with one or both of its
 *  dimensions fixed at compile-time.  All buffers are implicitly convertible to
 *  `mdspan`, such that one can use these objects as inputs to functions.
 *
 *  The available buffers are named according to this convention:
 *
 *  - Buffer_Dimension_: 1- or 2- dimensional buffer, the type and backend are
 *    to be specified at instantiation. E.g. `BufferX<double, mem::Device>`.
 *  - Buffer_Backend__Dimension__: 1- or 2-dimensional buffer on the backend, the type is to be
 *    specified at instantiation. E.g. `BufferHostX<double>`.
 *  - Buffer_Dimension__Type__: 1- or 2-dimensional buffer of the given type, the backend is to be
 *    specified at instantiation. E.g. `BufferXd<mem::Device>`.
 *  - Buffer_Backend__Dimension__Type__: 1- or 2-dimensional buffer of the given
 *    type and on the backend, e.g. `BufferHostXd`.
 *
 *  Similarly, for the `mdspan` types we have:
 *
 *  - non-`const`:
 *
 *    * MDSpan_Dimension_
 *    * MDSpan_Backend__Dimension__
 *    * MDSpan_Dimension__Type__
 *    * MDSpan_Backend__Dimension__Type__
 *
 *  - `const`:
 *
 *    * ConstMDSpan_Dimension_
 *    * ConstMDSpan_Backend__Dimension__
 *    * ConstMDSpan_Dimension__Type__
 *    * ConstMDSpan_Backend__Dimension__Type__
 *
 *  The _Dimension_ naming bit can be:
 *
 *  - `X` for a 1-dimensional with run-time number of elements.
 *
 *    @code
 *    auto X = BufferX<double, mem::Device>(100);
 *    @endcode
 *
 *  - `N` for a 1-dimensional with compile-time number of elements.
 *
 *    @code
 *    auto N = BufferN<double, mem::Device, 100>();
 *    @endcode
 *
 *  - `XY` for a 2-dimensional with run-time numbers of rows and columns.
 *
 *    @code
 *    auto XY = BufferXY<double, mem::Device>(100, 1000);
 *    @endcode
 *
 *  - `MY` for a 2-dimensional with compile-time number of rows and run-time
 *    number of columns.
 *
 *    @code
 *    auto MY = BufferMY<double, mem::Device, 100>(1000);
 *    @endcode
 *
 *  - `XN` for a 2-dimensional with run-time number of rows and compile-time
 *    number of columns.
 *
 *    @code
 *    auto XN = BufferXN<double, mem::Device, 1000>(100);
 *    @endcode
 *
 *  - `MN` for a 2-dimensional with compile-time numbers of rows and columns.
 *
 *    @code
 *    auto MN = BufferMN<double, mem::Device, 100, 1000>();
 *    @endcode
 *
 *  The _Backend_ naming bit can be:
 *
 *  - `Host` for allocations on the host. These are aligned to `VLX_ALIGN` bytes.
 *  - `Device` for allocations on the device. The aligment for these allocations
 *    is controlled by the device allocation functions.
 *
 *  The _Type_ naming bit can be:
 *
 *  - `d` for double-precision floating point numbers.
 */

/** @{ 1-dimensional data buffers. */
/** 1D buffer with run-time number of elements.
 *
 * @tparam T scalar type.
 * @tparam B backend of allocation.
 *
 * Use this when the number of elements is not fixed and
 * known at compile-time.
 */
template <typename T, typename B>
using BufferX = buffer::CBuffer<T, B, 1, Dynamic>;

VLX_X_XY_DEFINE_BUFFERS_MDSPANS(X);

/** 1D buffer with compile-time number of elements.
 *
 * @tparam T scalar type.
 * @tparam NElements number of elements.
 * @tparam B backend of allocation.
 *
 * Use this when the number of elements is fixed and
 * known at compile-time.
 */
template <typename T, typename B, size_t NElements>
using BufferN = buffer::CBuffer<T, B, 1, NElements>;

VLX_N_MY_XN_DEFINE_BUFFERS_AND_MDSPANS(NElements, N);

/**@}*/

/** @{ 2-dimensional data buffers. */
/** 2D buffer with run-time number of rows and columns.
 *
 * @tparam T scalar type.
 * @tparam B backend of allocation.
 *
 * Use this when neither number of rows nor number of columns are fixed and
 * known at compile-time.
 */
template <typename T, typename B>
using BufferXY = buffer::CBuffer<T, B, Dynamic, Dynamic>;

VLX_X_XY_DEFINE_BUFFERS_MDSPANS(XY);

/** 2D buffer with compile-time number of rows.
 *
 * @tparam T scalar type.
 * @tparam MRows number of rows.
 * @tparam B backend of allocation.
 *
 * Use this when the number of rows is fixed and known at compile-time.
 */
template <typename T, typename B, size_t MRows>
using BufferMY = buffer::CBuffer<T, B, MRows, Dynamic>;

VLX_N_MY_XN_DEFINE_BUFFERS_AND_MDSPANS(MRows, MY);

/** 2D buffer with compile-time number of columns.
 *
 * @tparam T scalar type.
 * @tparam NCols number of columns.
 * @tparam B backend of allocation.
 *
 * Use this when the number of columns is fixed and known at compile-time.
 */
template <typename T, typename B, size_t NCols>
using BufferXN = buffer::CBuffer<T, B, Dynamic, NCols>;

VLX_N_MY_XN_DEFINE_BUFFERS_AND_MDSPANS(NCols, XN);

/** 2D buffer with compile-time numbers of rows and columns.
 *
 * @tparam T scalar type.
 * @tparam MRows number of rows.
 * @tparam NCols number of columns.
 * @tparam B backend of allocation.
 *
 * Use this when the numbers of rows and columns are fixed and known at compile-time.
 */
template <typename T, typename B, size_t MRows, size_t NCols>
using BufferMN = buffer::CBuffer<T, B, MRows, NCols>;

VLX_MN_DEFINE_BUFFERS_AND_MDSPANS();
/**@}*/

namespace buffer {
template <typename T, typename B, size_t NRows, size_t NCols, typename... Args>
[[nodiscard]] auto
factory(Args&&... args) -> buffer::CBuffer<T, B, NRows, NCols>
{
    return CBuffer<T, B, NRows, NCols>(std::forward<Args>(args)...);
}
}  // namespace buffer

#endif /* Buffer_hpp */
