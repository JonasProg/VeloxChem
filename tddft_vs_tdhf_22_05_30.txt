diff --git a/src/pymodule/__init__.py b/src/pymodule/__init__.py
index d3a9f6ef..b30391aa 100644
--- a/src/pymodule/__init__.py
+++ b/src/pymodule/__init__.py
@@ -120,10 +120,7 @@ from .hessiandriver import HessianDriver
 from .scfhessiandriver import ScfHessianDriver
 from .cphfsolver import CphfSolver
 from .tdhfhessiandriver import TdhfHessianDriver
-from .polarizabilitygradient import PolOrbitalResponse
-from .polarizabilitygradient import PolarizabilityGradient
-from .impes import ImpesCoordinates
-from .impes import ImpesDriver
+from .xtbhessiandriver import XTBHessianDriver
 from .orbitalviewer import OrbitalViewer
 from .numerovdriver import NumerovDriver
 
diff --git a/src/pymodule/cphfsolver.py b/src/pymodule/cphfsolver.py
index 3084f1e9..cfbdb163 100644
--- a/src/pymodule/cphfsolver.py
+++ b/src/pymodule/cphfsolver.py
@@ -128,7 +128,7 @@ class CphfSolver(LinearSolver):
 ##        parse_input(self, rsp_keywords, rsp_dict)
 
 
-    def compute(self, molecule, basis, scf_tensors, *args):
+    def compute(self, molecule, basis, scf_tensors):
         """
         Performs CPHF calculation for a molecule and a basis set.
 
@@ -138,8 +138,6 @@ class CphfSolver(LinearSolver):
             The AO basis set.
         :param scf_tensors:
             The dictionary of tensors from converged SCF wavefunction.
-        :param *args:
-            Additional arguments, same as in compute_rhs.
 
         :return:
             A dictionary containing the RHS and solution (ov block)
@@ -160,12 +158,12 @@ class CphfSolver(LinearSolver):
             self.print_cphf_header('Coupled-Perturbed Hartree-Fock Solver')
 
         if self.use_subspace_solver:
-            self.cphf_results = self.compute_subspace_solver(molecule, basis, scf_tensors, *args)
+            return self.compute_subspace_solver(molecule, basis, scf_tensors)
         else:
-            self.cphf_results = self.compute_conjugate_gradient(molecule, basis, scf_tensors, *args)
+            return self.compute_conjugate_gradient(molecule, basis, scf_tensors)
 
 
-    def compute_subspace_solver(self, molecule, basis, scf_tensors, *args):
+    def compute_subspace_solver(self, molecule, basis, scf_tensors):
         """
         Performs CPHF calculation for a molecule and a basis set.
 
@@ -209,21 +207,15 @@ class CphfSolver(LinearSolver):
         natm =  molecule.number_of_atoms()
         nvir = nmo - nocc
 
-        cphf_rhs_dict = self.compute_rhs(molecule, basis, scf_tensors, *args)
+        cphf_rhs_dict = self.compute_rhs(molecule, basis, scf_tensors)
 
         if self.rank == mpi_master():
-            # get rhs, find out how many degrees of freedom, and reshape
-            cphf_rhs = cphf_rhs_dict['cphf_rhs'] #.reshape(3*natm, nocc*nvir)
-            dof = cphf_rhs.shape[0]
-            cphf_rhs = cphf_rhs.reshape(dof, nocc * nvir)
-            #ovlp_deriv_oo = cphf_rhs_dict['ovlp_deriv_oo']
-            #fock_deriv_ao = cphf_rhs_dict['fock_deriv_ao']
-            #fock_uij_numpy = cphf_rhs_dict['fock_uij']
+            cphf_rhs = cphf_rhs_dict['cphf_rhs'].reshape(3*natm, nocc*nvir)
+            ovlp_deriv_oo = cphf_rhs_dict['ovlp_deriv_oo']
+            fock_deriv_ao = cphf_rhs_dict['fock_deriv_ao']
+            fock_uij_numpy = cphf_rhs_dict['fock_uij']
         else:
             cphf_rhs = None
-            dof = None
-
-        dof = self.comm.bcast(dof, root=mpi_master())
 
         self.profiler.stop_timer('CPHF RHS')
 
@@ -237,8 +229,8 @@ class CphfSolver(LinearSolver):
 
         # create list of distributed arrays for RHS
         dist_rhs = []
-        # TODO: are these loops over all degrees of freedom really efficient?
-        for k in range(dof):
+        # TODO: are these loops over 3*natm (all coordinates) really efficient?
+        for k in range(3 * natm):
             if self.rank == mpi_master():
                 cphf_rhs_k = cphf_rhs[k]
             else:
@@ -252,9 +244,9 @@ class CphfSolver(LinearSolver):
         self.build_sigmas(molecule, basis, scf_tensors, dist_trials)
 
         # lists that will hold the solutions and residuals
-        solutions = list(np.zeros((dof)))
-        residuals = list(np.zeros((dof)))
-        relative_residual_norm = np.ones((dof))
+        solutions = list(np.zeros((3*natm)))
+        residuals = list(np.zeros((3*natm)))
+        relative_residual_norm = np.ones((3*natm))
 
         # start iterations
         for iteration in range(self.max_iter):
@@ -269,7 +261,7 @@ class CphfSolver(LinearSolver):
             self.cur_iter = iteration
             num_vecs = self.dist_trials.shape(1)
 
-            for x in range(dof):
+            for x in range(3 * natm):
                 if (iteration > 0 and
                         relative_residual_norm[x] < self.conv_thresh):
                     continue
@@ -374,21 +366,21 @@ class CphfSolver(LinearSolver):
         # TODO: decide whether using Distributed arrays in
         # ScfHessianDriver is more convenient/efficient etc.
 
-            cphf_ov = np.zeros((dof, nocc, nvir))
+            cphf_ov = np.zeros((natm, 3, nocc, nvir))
 
-        for i in range(dof):
-            sol = solutions[i].get_full_vector(0)
-            if self.rank == mpi_master():
-                cphf_ov[i] = sol.reshape(nocc, nvir)
+        for i in range(natm):
+            for x in range(3):
+                sol = solutions[3*i+x].get_full_vector(0)
+                if self.rank == mpi_master():
+                    cphf_ov[i,x] = sol.reshape(nocc,nvir)
 
-        # merge the rhs dict with the solution
         if self.rank == mpi_master():
-            return {**cphf_rhs_dict,
+            return {
                 'cphf_ov': cphf_ov,
-                #'cphf_rhs': cphf_rhs.reshape(natm,3,nocc,nvir),
-                #'ovlp_deriv_oo': ovlp_deriv_oo,
-                #'fock_deriv_ao': fock_deriv_ao,
-                #'fock_uij': fock_uij_numpy,
+                'cphf_rhs': cphf_rhs.reshape(natm,3,nocc,nvir),
+                'ovlp_deriv_oo': ovlp_deriv_oo,
+                'fock_deriv_ao': fock_deriv_ao,
+                'fock_uij': fock_uij_numpy,
             }
         return None
 
@@ -607,7 +599,7 @@ class CphfSolver(LinearSolver):
                                             root=mpi_master())
 
 
-    def compute_conjugate_gradient(self, molecule, basis, scf_tensors, *args):
+    def compute_conjugate_gradient(self, molecule, basis, scf_tensors):
         """
         Computes the coupled-perturbed Hartree-Fock (CPHF) coefficients.
 
@@ -664,14 +656,13 @@ class CphfSolver(LinearSolver):
         natm =  molecule.number_of_atoms()
         nvir = nmo - nocc
 
-        cphf_rhs_dict = self.compute_rhs(molecule, basis, scf_tensors, *args)
+        cphf_rhs_dict = self.compute_rhs(molecule, basis, scf_tensors)
 
         if self.rank == mpi_master():
-            cphf_rhs = cphf_rhs_dict['cphf_rhs'] #.reshape(3*natm, nocc*nvir)
-            dof = cphf_rhs.shape[0]
-            #ovlp_deriv_oo = cphf_rhs_dict['ovlp_deriv_oo']
-            #fock_deriv_ao = cphf_rhs_dict['fock_deriv_ao']
-            #fock_uij_numpy = cphf_rhs_dict['fock_uij']
+            cphf_rhs = cphf_rhs_dict['cphf_rhs'].reshape(3*natm, nocc*nvir)
+            ovlp_deriv_oo = cphf_rhs_dict['ovlp_deriv_oo']
+            fock_deriv_ao = cphf_rhs_dict['fock_deriv_ao']
+            fock_uij_numpy = cphf_rhs_dict['fock_uij']
         else:
             cphf_rhs = None
 
@@ -679,12 +670,12 @@ class CphfSolver(LinearSolver):
 
         cphf_rhs = self.comm.bcast(cphf_rhs, root=mpi_master())
 
-        #cphf_ov = np.zeros((dof, nocc, nvir))
+        cphf_ov = np.zeros((natm, 3, nocc, nvir))
 
         # Solve the CPHF equations using conjugate gradient (cg)
         cphf_ov = self.solve_cphf_cg(molecule, basis, scf_tensors,
-                                  cphf_rhs #.reshape(3*natm, nocc, nvir), # TODO: possibly change the shape
-                                  )
+                                  cphf_rhs.reshape(3*natm, nocc, nvir), # TODO: possibly change the shape
+                                  dft_dict)
 
         self.profiler.stop_timer('Total CG')
         self.profiler.print_timing(self.ostream)
@@ -697,20 +688,18 @@ class CphfSolver(LinearSolver):
             self.ostream.print_blank()
             self.print_convergence('Coupled-Perturbed Hartree-Fock')
 
-            # merge the rhs dict with the solution
-            cphf_ov_dict = {**cphf_rhs_dict, 'cphf_ov': cphf_ov}
-
-            return cphf_ov_dict
-                #'cphf_ov': cphf_ov,
-                #'cphf_rhs': cphf_rhs.reshape(natm,3,nocc,nvir),
-                #'ovlp_deriv_oo': ovlp_deriv_oo,
-                #'fock_deriv_ao': fock_deriv_ao,
-                #'fock_uij': fock_uij_numpy,
+            return {
+                'cphf_ov': cphf_ov,
+                'cphf_rhs': cphf_rhs.reshape(natm,3,nocc,nvir),
+                'ovlp_deriv_oo': ovlp_deriv_oo,
+                'fock_deriv_ao': fock_deriv_ao,
+                'fock_uij': fock_uij_numpy,
+            }
 
         return None
 
 
-    def solve_cphf_cg(self, molecule, basis, scf_tensors, cphf_rhs):
+    def solve_cphf_cg(self, molecule, basis, scf_tensors, cphf_rhs, dft_dict):
         """
         Solves the CPHF equations using conjugate gradient
         for all atomic coordinates to obtain the ov block
@@ -724,6 +713,8 @@ class CphfSolver(LinearSolver):
             The tensors from the converged SCF calculation.
         :param cphf_rhs:
             The right-hand side of the CPHF equations for all atomic coordinates.
+        :param dft_dict:
+            The dictionary of DFT settings.
 
         :returns:
             The ov block of the CPHF coefficients.
@@ -740,8 +731,6 @@ class CphfSolver(LinearSolver):
 
         nocc = molecule.number_of_alpha_electrons()
         natm = molecule.number_of_atoms()
-        # degrees of freedom from rhs (can be different from number of atoms)
-        dof = cphf_rhs.shape[0]
 
         if self.rank == mpi_master():
             mo = scf_tensors['C']
@@ -768,7 +757,7 @@ class CphfSolver(LinearSolver):
         if self.rank == mpi_master():
             # Create AODensityMatrix object from CPHF guess in AO
             cphf_ao = np.einsum('mi,xia,na->xmn', mo_occ, cphf_guess, mo_vir)
-            cphf_ao_list = list([cphf_ao[x] for x in range(dof)])
+            cphf_ao_list = list([cphf_ao[x] for x in range(3*natm)])
             # create AODensityMatrix object
             ao_density_cphf = AODensityMatrix(cphf_ao_list, denmat.rest)
         else:
@@ -791,28 +780,28 @@ class CphfSolver(LinearSolver):
             # Create AODensityMatrix object from lambda in AO
             if self.rank == mpi_master():
                 cphf_ao = np.einsum('mi,xia,na->xmn', mo_occ,
-                                    v.reshape(dof, nocc, nvir), mo_vir)
-                cphf_ao_list = list([cphf_ao[x] for x in range(dof)])
+                                    v.reshape(3*natm, nocc, nvir), mo_vir)
+                cphf_ao_list = list([cphf_ao[x] for x in range(3*natm)])
                 ao_density_cphf = AODensityMatrix(cphf_ao_list, denmat.rest)
             else:
                 ao_density_cphf = AODensityMatrix()
             ao_density_cphf.broadcast(self.rank, self.comm)
 
             self.comp_lr_fock(fock_cphf, ao_density_cphf, molecule,
-                              basis, eri_dict, dft_dict, pe_dict, self.profiler)
+                              basis, eri_dict, dft_dict, pe_dict)
 
             # Transform to MO basis (symmetrized w.r.t. occ. and virt.)
             # and add diagonal part
             if self.rank == mpi_master():
-                fock_cphf_numpy = np.zeros((dof,nao,nao))
-                for i in range(dof):
+                fock_cphf_numpy = np.zeros((3*natm,nao,nao))
+                for i in range(3*natm):
                     fock_cphf_numpy[i] = fock_cphf.to_numpy(i)
 
                 cphf_mo = (-np.einsum('mi,xmn,na->xia', mo_occ,
                                       fock_cphf_numpy, mo_vir)
                           - np.einsum('ma,xmn,ni->xia', mo_vir,
                                       fock_cphf_numpy, mo_occ)
-                          + v.reshape(dof, nocc, nvir) * eov)
+                          + v.reshape(3*natm, nocc, nvir) * eov)
             else:
                 cphf_mo = None
 
@@ -830,12 +819,13 @@ class CphfSolver(LinearSolver):
 
             if self.rank == mpi_master():
                 if self.print_residuals:
-                    residual_norms = np.zeros(dof)
-                    for i in range(dof):
-                        residual_norms[i] = np.linalg.norm(cphf_mo[i] - cphf_rhs[i])
+                    residual_norms = np.zeros(3*natm)
+                    for i in range(natm):
+                        for x in range(3):
+                            residual_norms[3*i+x] = np.linalg.norm(cphf_mo[i,x] - cphf_rhs[i,x])
                     self.print_iteration(residual_norms, molecule)
 
-            return cphf_mo.reshape(dof * nocc * nvir)
+            return cphf_mo.reshape(3 * natm * nocc * nvir)
 
         # Matrix-vector product for preconditioner using the
         # inverse of the diagonal (i.e. eocc - evir)
@@ -845,21 +835,21 @@ class CphfSolver(LinearSolver):
             required by the pre-conditioner for the conjugate gradient.
             It is an approximation for the inverse of matrix A in Ax = b.
             """
-            current_v = v.reshape(dof, nocc, nvir)
+            current_v = v.reshape(3*natm, nocc, nvir)
             M_dot_v = current_v / eov
 
-            return M_dot_v.reshape(dof * nocc * nvir)
+            return M_dot_v.reshape(3 * natm * nocc * nvir)
 
         # 5) Define the linear operators and run conjugate gradient
-        LinOp = linalg.LinearOperator((dof * nocc * nvir,
-                                       dof * nocc * nvir),
+        LinOp = linalg.LinearOperator((3*natm * nocc * nvir,
+                                       3*natm * nocc * nvir),
                                        matvec=cphf_matvec)
-        PrecondOp = linalg.LinearOperator((dof * nocc * nvir,
-                                           dof * nocc * nvir),
+        PrecondOp = linalg.LinearOperator((3*natm * nocc * nvir,
+                                           3*natm * nocc * nvir),
                                            matvec=precond_matvec)
 
-        b = cphf_rhs.reshape(dof * nocc * nvir)
-        x0 = cphf_guess.reshape(dof * nocc * nvir)
+        b = cphf_rhs.reshape(3*natm * nocc * nvir)
+        x0 = cphf_guess.reshape(3*natm * nocc * nvir)
 
         cphf_coefficients_ov, cg_conv = linalg.cg(A=LinOp,
                                                 b=b,
@@ -871,7 +861,7 @@ class CphfSolver(LinearSolver):
 
         self.is_converged = (cg_conv == 0)
 
-        return cphf_coefficients_ov.reshape(dof, nocc, nvir)
+        return cphf_coefficients_ov.reshape(natm, 3, nocc, nvir)
 
 
 
@@ -968,7 +958,7 @@ class CphfSolver(LinearSolver):
         timing_dict = {}
 
         self.comp_lr_fock(fock_uij, ao_density_uij, molecule,
-                          basis, eri_dict, dft_dict, pe_dict, self.profiler)
+                          basis, eri_dict, dft_dict, pe_dict)
 
         if self.rank == mpi_master():
             # TODO: how can this be done better?
@@ -985,7 +975,7 @@ class CphfSolver(LinearSolver):
             cphf_rhs = (fock_deriv_ov - orben_ovlp_deriv_ov
                         + 2 * fock_uij_mo)
             return {
-                'cphf_rhs': cphf_rhs.reshape(3*natm, nocc, nvir),
+                'cphf_rhs': cphf_rhs,
                 'ovlp_deriv_oo': ovlp_deriv_oo,
                 'fock_deriv_ao': fock_deriv_ao,
                 'fock_uij': fock_uij_numpy,
diff --git a/src/pymodule/gradientdriver.py b/src/pymodule/gradientdriver.py
index f8c07d1f..72f3d8fb 100644
--- a/src/pymodule/gradientdriver.py
+++ b/src/pymodule/gradientdriver.py
@@ -127,14 +127,14 @@ class GradientDriver:
                                 'Gradient driver: Undefined XC functional')
 
         # TODO: Analytical DFT gradient is not implemented yet
-        #if self.dft and not self.numerical:
-        #    self.numerical = True
-        #    warn_msg = '*** Warning: Analytical DFT gradient is not yet implemented.'
-        #    self.ostream.print_blank()
-        #    self.ostream.print_header(warn_msg.ljust(56))
-        #    warn_msg = '              Gradient will be calculated numerically instead.'
-        #    self.ostream.print_header(warn_msg.ljust(56))
-        #    self.ostream.flush()
+        if self.dft and not self.numerical:
+            self.numerical = True
+            warn_msg = '*** Warning: Analytical DFT gradient is not yet implemented.'
+            self.ostream.print_blank()
+            self.ostream.print_header(warn_msg.ljust(56))
+            warn_msg = '              Gradient will be calculated numerically instead.'
+            self.ostream.print_header(warn_msg.ljust(56))
+            self.ostream.flush()
 
         # step size for finite differences
         if 'delta_h' in grad_dict:
@@ -167,7 +167,6 @@ class GradientDriver:
         """
 
         return
-
     def compute_numerical(self, molecule, *args):
         """
         Performs calculation of numerical gradient.
@@ -199,22 +198,14 @@ class GradientDriver:
                 new_mol = Molecule(labels, coords, units='au')
                 e_minus = self.compute_energy(new_mol, *args)
 
-                if self.do_four_point:
-                    coords[i, d] -= self.delta_h
-                    new_mol = Molecule(labels, coords, units='au')
-                    e_minus2 = self.compute_energy(new_mol, *args)
-                    coords[i, d] += 4.0 * self.delta_h
-                    new_mol = Molecule(labels, coords, units='au')
-                    e_plus2 = self.compute_energy(new_mol, *args)
-                    coords[i, d] -= 2.0 * self.delta_h
-                    self.gradient[i, d] = (e_minus2 - 8 * e_minus + 8 * e_plus - e_plus2) / (12.0 * self.delta_h)
-                else:
-                    coords[i, d] += self.delta_h
-                    self.gradient[i, d] = (e_plus - e_minus) / (2.0 * self.delta_h)
-                    
-        self.restore_drivers(molecule, ostream_state, *args)
+                coords[i, d] += self.delta_h
+                self.gradient[i, d] = (e_plus - e_minus) / (2.0 * self.delta_h)
+
         self.ostream.print_blank()
 
+        self.restore_drivers(molecule, ostream_state, *args)
+
+
     def init_drivers(self):
         """
         Silence the energy drivers and save the current ostream state.
@@ -513,7 +504,7 @@ class GradientDriver:
         self.ostream.print_header((len(self.flag) + 2) * '=')
         self.ostream.flush()
 
-        cur_str = 'Gradient Type               : '
+       	cur_str = 'Gradient Type               : '
 
         if self.numerical:
             cur_str += 'Numerical'
diff --git a/src/pymodule/hessiandriver.py b/src/pymodule/hessiandriver.py
index 4289b59c..9b75bedf 100644
--- a/src/pymodule/hessiandriver.py
+++ b/src/pymodule/hessiandriver.py
@@ -326,7 +326,6 @@ class HessianDriver:
 
             alpha_bar_sq = alpha_bar**2
 
-            # Calculate depolarization ratio from polarized (parallel) and depolarized (perpendicular) intensities
             if self.print_depolarization_ratio:
                 int_pol = 45 * alpha_bar_sq + 4 * gamma_bar_sq
                 int_depol = 3 * gamma_bar_sq
diff --git a/src/pymodule/impes.py b/src/pymodule/impes.py
deleted file mode 100644
index 4b50d553..00000000
--- a/src/pymodule/impes.py
+++ /dev/null
@@ -1,745 +0,0 @@
-#
-#                           VELOXCHEM 1.0-RC2
-#         ----------------------------------------------------
-#                     An Electronic Structure Code
-#
-#  Copyright © 2018-2021 by VeloxChem developers. All rights reserved.
-#  Contact: https://veloxchem.org/contact
-#
-#  SPDX-License-Identifier: LGPL-3.0-or-later
-#
-#  This file is part of VeloxChem.
-#
-#  VeloxChem is free software: you can redistribute it and/or modify it under
-#  the terms of the GNU Lesser General Public License as published by the Free
-#  Software Foundation, either version 3 of the License, or (at your option)
-#  any later version.
-#
-#  VeloxChem is distributed in the hope that it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
-#  License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with VeloxChem. If not, see <https://www.gnu.org/licenses/>.
-
-from mpi4py import MPI
-from .outputstream import OutputStream
-import numpy as np
-import sys
-import h5py
-import geometric
-
-def parse_z_matrix(input_z_matrix):
-    """
-    Parses the input Z-matrix to create a list of indices which define
-    bonds, bond angles and dihedrals.
-    
-    :param input_z_matrix:
-        The string containing the Z-matrix.
-
-    :return:
-        a list of bond, bond angle, and dihedral atomic indices.
-    """
-
-    z_matrix = []
-    for q_str in input_z_matrix.split(';'):
-        q = []
-        for ind in q_str.split(','):
-            q.append(int(ind))
-        z_matrix.append(q)
-
-    return z_matrix
-
-# TODO: add routines to read energy, gradient, Hessian in internal coordinates.
-class ImpesCoordinates:
-    """
-    Implements routines for the coordinates required for potential
-    energy surface interpolation.
-
-    :param comm:
-        The MPI communicator.
-    :param ostream:
-        The output stream.
-
-    Instance variables
-        - hessian: The Cartesian Hessian in Hartree per Bohr**2.
-        - gradient: The Cartesian gradient in Hartree per Bohr
-        - energy: the total energy of the groound or excited state in Hartree
-        - z_matrix: The Z-matrix (a list of coordinates which define bonds
-          bond angles and dihedral angles).
-        - internal_hessian: The Hessian in internal coordinates.
-        - internal_gradient: The gradient in internal coordinates.
-        - b_matrix: The Wilson B-matrix.
-        - b2_matrix: The matrix of second order deriatives of 
-          internal coordinates with respect to Cartesian coordinates
-          with respect to Cartesian coordinates.
-        - r_inverse: Flag for using the inverse bond length instead of the 
-          bond length.
-        - internal_coordinates: a list of geomeTRIC internal coordinates.
-    """
-
-    def __init__(self, comm=None, ostream=None):
-        """
-        Initializes the ImpesCoordinates object.
-        """
-
-        if comm is None:
-            comm = MPI.COMM_WORLD
-
-        if ostream is None:
-            ostream = OutputStream(sys.stdout)
-
-        # MPI information
-        self.comm = comm
-        self.rank = self.comm.Get_rank()
-        self.nodes = self.comm.Get_size()
-        self.ostream = ostream
-
-
-        self.hessian = None
-        self.gradient = None
-        self.z_matrix = None
-        self.internal_hessian = None
-        self.internal_gradient = None
-        self.b_matrix = None
-        self.b2_matrix = None
-        self.r_inverse = True
-        self.internal_coordinates = None
-        self.internal_coordinates_array = None
-        self.cartesian_coordinates = None
-        # TODO: add timing and profiling
-
-    def update_settings(self, impes_dict=None):
-        """
-        Updates settings in the ImpesDriver.
-
-        :param impes_dict:
-            The input dictionary of settings for IMPES.
-        """ 
-
-        if impes_dict is None:
-            impes_dict = {}
-
-        if 'r_inverse' in impes_dict:
-            key = impes_dict['r_inverse'].lower()
-            self.r_inverse = True if key in ['yes', 'y'] else False
-
-        if 'z_matrix' in impes_dict:
-            self.z_matrix = parse_z_matrix(impes_dict['z_matrix'])
-
-        if 'energy' in impes_dict:
-            self.energy = float(impes_dict['energy'])
-
-    def define_internal_coordinates(self, z_matrix=None):
-        """
-        Constructs the list of internal coordinates based on the Z-matrix.
-
-        :param z_matrix:
-            The list of bond, angle, and dihedral indices which define the 
-            Z-matrix.
-        """
-
-        if z_matrix is None and self.z_matrix is None:
-            raise ValueError("No Z-matrix defined.")
-        elif z_matrix is not None:
-            self.z_matrix = z_matrix
-
-        if self.internal_coordinates is None:
-            self.internal_coordinates = []
-
-        for z in self.z_matrix:
-            if len(z) == 2:
-                a = z[0]
-                b = z[1]
-                q = geometric.internal.Distance(a, b)
-            elif len(z) == 3:
-                a = z[0]
-                b = z[1]
-                c = z[2]
-                q = geometric.internal.Angle(a, b, c)
-            else:
-                a = z[0]
-                b = z[1]
-                c = z[2]
-                d = z[3]
-                q = geometric.internal.Dihedral(a, b, c, d)
-            self.internal_coordinates.append(q)
-
-    def calculate_b_matrix(self):
-        """
-        Calculates the Wilson B-matrix of first order derivatives of the 
-        internal coordinates with respect to Cartesian coordinates.
-        """
-
-        if self.internal_coordinates is None:
-            raise ValueError("No internal coordinates are defined.")
-
-        if self.cartesian_coordinates is None:
-            raise ValueError("No cartesian coordinates are defined.")
-
-        n_atoms = self.cartesian_coordinates.shape[0]
-        coords = self.cartesian_coordinates.reshape((3*n_atoms))
-
-        if self.b_matrix is None:
-            self.b_matrix = np.zeros((len(self.z_matrix), 3*n_atoms))
-
-        for i in range(len(self.z_matrix)):
-            z = self.z_matrix[i]
-            q = self.internal_coordinates[i]
-            derivative = q.derivative(coords)
-            for a in z:
-                self.b_matrix[i,3*a:3*a+3] = derivative[a]
-
-    def calculate_b2_matrix(self):
-        """
-        Calculates the B2-matrix of second order derivatives of the 
-        internal coordinates with respect to Cartesian coordinates.
-        """
-
-        if self.internal_coordinates is None:
-            raise ValueError("No internal coordinates are defined.")
-        if self.cartesian_coordinates is None:
-            raise ValueError("No cartesian coordinates are defined.")
-
-        n_atoms = self.cartesian_coordinates.shape[0]
-        coords = self.cartesian_coordinates.reshape((3*n_atoms))
-
-        if self.b2_matrix is None:
-            self.b2_matrix = np.zeros((len(self.z_matrix), 3*n_atoms, 3*n_atoms))
-
-        for i in range(len(self.z_matrix)):
-            z = self.z_matrix[i]
-            q = self.internal_coordinates[i]
-            second_derivative = q.second_derivative(coords)
-            for m in z:
-                for n in z:
-                    self.b2_matrix[i,3*m:3*m+3,3*n:3*n+3] = (
-                                        second_derivative[m, :, n, :])
-
-    def transform_gradient_to_internal_coordinates(self, tol=1e-7):
-        """
-        Transforms the gradient from Cartesian to internal coordinates.
-
-        :param tol:
-            The tolerance of comparison for inversion.
-        """
-        if self.b_matrix is None:
-            self.calculate_b_matrix()
-
-        n_atoms = self.cartesian_coordinates.shape[0]
-        g_matrix = np.matmul(self.b_matrix, self.b_matrix.T)
-        gval, gvec = np.linalg.eig(g_matrix)
-
-        # TODO: is there a better way of selecting out the non-zero eigenvalues
-        # and computing g_minus?
-        gval_inverse = []
-        for g in gval:
-            if abs(g) > tol:
-                gval_inverse.append(1.0/g)
-            else:
-                gval_inverse.append(0.0)
-
-        gval_inverse_matrix = np.diag(np.array(gval_inverse))
-        self.g_minus_matrix = (
-                np.linalg.multi_dot([gvec, gval_inverse_matrix, gvec.T]) )
-        gradient = self.gradient.reshape((3*n_atoms))
-        self.internal_gradient = (np.linalg.multi_dot(
-                    [self.g_minus_matrix, self.b_matrix, gradient]) )
-
-    def transform_hessian_to_internal_coordinates(self):
-        """
-        Transforms the Hessian from Cartesian to internal coordinates.
-
-        """
-
-        if self.internal_gradient is None:
-            self.transform_gradient_to_internal_coordinates()
-        if self.b2_matrix is None:
-            self.calculate_b2_matrix()
-
-        b2_gradient = np.einsum("qxy,q->xy", self.b2_matrix,
-                                self.internal_gradient)
-        self.internal_hessian = (
-                np.linalg.multi_dot([self.g_minus_matrix, self.b_matrix,
-                                     self.hessian - b2_gradient,
-                                     self.b_matrix.T, self.g_minus_matrix.T])
-                                )
-
-    def symmetrize_hessian(self):
-        """
-        Symmetrizes the Hessian in internal coordinates.
-        """
-        n = self.internal_hessian.shape[0]
-        for i in range(n):
-            for j in range(i+1, n):
-                avg = 0.5 * (  self.internal_hessian[i,j]
-                             + self.internal_hessian[j,i]
-                                )
-                self.internal_hessian[i,j] = avg
-                self.internal_hessian[j,i] = avg
-
-    def transform_to_r_inverse(self):
-        """
-        Transforms the gradient and Hessian from using the bond length R, to 
-        using the inverse bond length 1/R.
-
-        """
-        if self.internal_coordinates is None:
-            raise ValueError("No internal coordinates are defined.")
-        if self.cartesian_coordinates is None:
-            raise ValueError("No cartesian coordinates are defined.")
-
-        n_atoms = self.cartesian_coordinates.shape[0]
-        coords = self.cartesian_coordinates.reshape((3*n_atoms))
-
-        i = 0
-        for z in self.z_matrix:
-            j = 0
-            if len(z) == 2:
-                r = self.internal_coordinates[i].value(coords)
-                self.internal_gradient[i] *= -r**2
-            for t in self.z_matrix:
-                if len(z) == 2:
-                    r = self.internal_coordinates[i].value(coords)
-                    self.internal_hessian[i, j] *= -r**2
-                if len(t) == 2:
-                    r = self.internal_coordinates[j].value(coords)
-                    self.internal_hessian[i, j] *= -r**2
-                if i == j and len(z) == 2:
-                    r = self.internal_coordinates[j].value(coords)
-                    self.internal_hessian[i, j] += (
-                                        - 2.0 * r * self.internal_gradient[i]
-                                        )
-                j += 1
-            i += 1
-
-    def transform_gradient_and_hessian(self, z_matrix=None):
-        """
-        Performs all steps required to transform from Cartesian coordinates
-        to the internal coordinates defined in the Z-matrix.
-
-        :param z_matrix:
-            The Z-matrix - a list of indices which define the bonds, angles,
-            and dihedrals of interest.
-        """
-
-        # Create the internal coordinates through geomeTRIC
-        if self.internal_coordinates is None:
-            self.define_internal_coordinates(z_matrix)
-
-        # Transform the gradient and Hessian to internal coordinates
-        self.transform_gradient_to_internal_coordinates()
-        self.transform_hessian_to_internal_coordinates()
-
-        # Symmetrize the Hessian matrix
-        self.symmetrize_hessian()
-
-        # Transform the gradient and Hessian to use 1/R
-        if self.r_inverse:
-            self.transform_to_r_inverse()
-
-        # Save the values of the internal coordinates as a numpy array
-        self.compute_internal_coordinates()
-
-    # TODO: is it a good idea to do it this way??
-    def reset(self):
-        """
-        Resets some variables to be able to reuse the object.
-        """
-        self.internal_gradient = None
-        self.internal_hessian = None
-        self.internal_coordinates_array = None
-        self.b_matrix = None
-        self.b2_matrix = None
-        self.g_minus = None
-
-    def compute_internal_coordinates(self):
-        """
-        Creats an array with the internal coordinates.
-
-        """
-        if self.internal_coordinates is None:
-            raise ValueError("No internal coordinates are defined.")
-        if self.cartesian_coordinates is None:
-            raise ValueError("No cartesian coordinates are defined.")
-
-        n_atoms = self.cartesian_coordinates.shape[0]
-        coords = self.cartesian_coordinates.reshape((3*n_atoms))
-
-        int_coords = []
-        for q in self.internal_coordinates:
-            if isinstance(q, geometric.internal.Distance) and self.r_inverse:
-                int_coords.append(1.0/q.value(coords))
-            else:
-                int_coords.append(q.value(coords))
-
-        self.internal_coordinates_array = np.array(int_coords)
-
-    def get_z_matrix_as_np_array(self):
-        """
-        Returns an array with the Z-matrix
-        """
-        if self.z_matrix is None:
-            raise ValueError("No Z-matrix is defined.")
-
-        return np.array(self.z_matrix)
-
-    def write_hdf5(self, fname, label, write_zmat=False):
-        """
-        Writes the energy, internal coordinates, internal gradient, and
-        internal Hessian to a checkpoint file.
-
-        :param fname:
-            Name of the checkpoint file to be written.
-        :param label:
-            A string describing the coordinate.
-        :param write_zmat:
-            flag to determine if the Z-matrix should be writen to the
-            checkpoint file. False by default.
-        """
-        valid_checkpoint = (fname and isinstance(fname, str))
-
-        if not valid_checkpoint:
-            return False
-        try:
-            h5f = h5py.File(fname, 'a')
-        except IOError:
-            return False
- 
-        if self.r_inverse:
-            label += "_rinv"
-
-        if self.energy is None:
-            return False
-        else:
-            # energy
-            full_label = label + "_energy"
-            h5f.create_dataset(full_label, data=self.energy)
-        
-        if self.internal_gradient is None:
-            return False
-        else:
-            # gradient in internal coordinates
-            full_label = label + "_gradient"
-            h5f.create_dataset(full_label, data=self.internal_gradient,
-                               compression='gzip')
-
-        if self.internal_hessian is None:
-            return False
-        else:
-            # Hessian in internal coordinates
-            full_label = label + "_hessian"
-            h5f.create_dataset(full_label, data=self.internal_hessian,
-                               compression='gzip')
-
-        if self.internal_coordinates is None:
-            return False
-        else:
-            # internal coordinates
-            full_label = label + "_internal_coordinates"
-            self.compute_internal_coordinates()
-            h5f.create_dataset(full_label, data=self.internal_coordinates_array,
-                               compression='gzip')
-
-        if write_zmat:
-            if self.z_matrix is None:
-                return False
-            else:
-                # internal coordinates
-                full_label = label + "_z_matrix"
-                zmat = self.get_z_matrix_as_np_array()
-                h5f.create_dataset(full_label, zmat, compression='gzip')
-
-        h5f.close()
-        return True
-
-
-    # TODO: complpete
-    def read_hdf5(self, fname, label):
-        """
-        Reads the energy, internal coordinates, gradient, and Hessian from
-        a checkpoint file,
-
-        :param fname:
-            Name of the checkpoint file.
-            The file must exist before calling this routine.
-        :param label:
-            The label of the selected coordinates.
-        """
-        valid_checkpoint = (fname and isinstance(fname, str))
-
-        if not valid_checkpoint:
-            raise ValueError("Not a valid checkpoint file.")
-
-        try:
-            h5f = h5py.File(fname, 'r')
-        except IOError:
-            raise ValueError("Could not open checkpoint file.")
-
-        if self.r_inverse:
-            label += "_rinv"
-        energy_label = label + "_energy"
-        gradient_label = label + "_gradient"
-        hessian_label = label + "_hessian"
-        coords_label = label + "_internal_coordinates"
-        self.energy = np.array(h5f.get(energy_label))
-        self.internal_gradient = np.array(h5f.get(gradient_label))
-        self.internal_hessian = np.array(h5f.get(hessian_label))
-        self.internal_coordinates_array = np.array(h5f.get(coords_label))
-
-        h5f.close()
-
-
-    def read_cartesian_coords_energy_gradient_hessian(self, fname, label):
-        """
-        Reads the energy, Cartesian gradient, and Hessian from checkpoint file.
-
-        :param fname:
-            Name of the checkpoint file.
-            The file must exist before calling this routine.
-        :param label:
-            The label of the selected coordinates.
-        """
-
-        valid_checkpoint = (fname and isinstance(fname, str))
-
-        if not valid_checkpoint:
-            raise ValueError("Not a valid checkpoint file.")
-
-        try:
-            h5f = h5py.File(fname, 'r')
-        except IOError:
-            raise ValueError("Could not open checkpoint file.")
-
-        energy_label = label + "_energy"
-        gradient_label = label + "_gradient"
-        hessian_label = label + "_hessian"
-        coords_label = label + "_coordinates"
-        self.energy = np.array(h5f.get(energy_label))
-        self.gradient = np.array(h5f.get(gradient_label))
-        self.hessian = np.array(h5f.get(hessian_label))
-        self.cartesian_coordinates = np.array(h5f.get(coords_label))
-
-        h5f.close() 
-
-class ImpesDriver():
-    """
-    Implements the potential energy surface interpolation driver
-
-    :param comm:
-        The MPI communicator.
-    :param ostream:
-        The output stream.
-
-    Instance variables
-        - list_of_points: a list of impes coordinates?
-        - z_matrix: the Z-matrix of indices defining the internal
-          coordinates.
-        - r_inv: flag which determines if to use 1/R.
-        - impes_coordinate: the new molecular geometry at which the energy
-          is to be calculated by interpolation.
-        - energy: the energy determined by interpolation.
-        - exponent_p: exponent required in the interpolation procedure (both
-          simple and Shepard interpolation).
-        - exponent_q: exponent required in the Shepard interpolation procedure.
-        - confidence_radius: confidence radius required by the Shepard 
-          interpolation procedure.
-    """
-
-    def __init__(self, comm=None, ostream=None):
-        """
-        Initializes the IMPES driver.
-        """
-
-        if comm is None:
-            comm = MPI.COMM_WORLD
-
-        if ostream is None:
-            ostream = OutputStream(sys.stdout)
-
-        # MPI information
-        self.comm = comm
-        self.rank = self.comm.Get_rank()
-        self.nodes = self.comm.Get_size()
-        self.ostream = ostream
-
-        # TODO: add timing and profiling
-
-        # Z-matrix, energy and coordinate
-        self.z_matrix = None
-        self.energy = None
-        self.impes_coordinate = None
-
-        # r_inv: if to use 1/R instead of R
-        self.r_inv = True
-        
-        # simple or Shepard interpolation
-        self.interpolation_type = 'shepard'
-        self.exponent_p = None
-        self.exponent_q = None
-        self.confidence_radius = None
-
-    def update_settings(self, impes_dict=None):
-        """
-        Updates settings in the ImpesDriver.
-
-        :param impes_dict:
-            The input dictionary of settings for IMPES.
-        """ 
-
-        if impes_dict is None:
-            impes_dict = {}
-
-        if 'z_matrix' in impes_dict:
-            self.z_matrix = parse_z_matrix(impes_dict['z_matrix'])
-
-        if 'r_inverse' in impes_dict:
-            key = impes_dict['r_inverse'].lower()
-            self.r_inverse = True if key in ['yes', 'y'] else False
-
-        if 'interpolation_type' in impes_dict:
-            key = impes_dict['interpolation_type'].lower()
-            if key in ['simple', 'shepard']:
-                self.interpolation_type = key
-
-        if 'exponent_p' in impes_dict:
-            # 2p, JCTC 12, 5235 (2016)
-            self.exponent_p = 2*float(impes_dict['exponent_p'])
-        if 'exponent_q' in impes_dict:
-            # 2q, JCTC 12, 5235 (2016)
-            self.exponent_q = 2*float(impes_dict['exponent_q'])
-
-        if self.interpolation_type == 'shepard' and self.exponent_q is None:
-            self.exponent_q = self.exponent_p / 2.0
-
-        if 'confidence_radius' in impes_dict:
-            self.confidence_radius = float(impes_dict['confidence_radius'])
-
-        self.impes_dict = dict(impes_dict)
-
-    def define_impes_coordinate(self, coordinates):
-        """Defines the current coordinate based on the molecule object.
-           The energy of this molecular geometry is to  be determined by
-           interpolation.
-
-            :param coordinates:
-                a numpy array of Cartesian coordinates.
-        """
-        self.impes_coordinate = ImpesCoordinates(self.comm, self.ostream)
-        self.impes_coordinate.update_settings(self.impes_dict)
-        self.impes_coordinate.cartesian_coordinates = coordinates
-        self.impes_coordinate.define_internal_coordinates()
-        self.impes_coordinate.compute_internal_coordinates()
-
-    def compute(self, coordinates, fname, labels):
-        """Computes the energy by interpolation between pre-defined points.
-
-            :param coordinates:
-                a numpy array of Cartesian coordinates.
-            :param fname:
-                the name of the checkpoint file  containing the pre-defined
-                data points.
-            :param labels:
-                a list of data point labels.
-        """
-
-        self.define_impes_coordinate(coordinates)
-
-        if self.interpolation_type == 'simple':
-            self.simple_interpolation(fname, labels)
-        elif self.interpolation_type == 'shepard':
-            self.shepard_interpolation(fname, labels)
-        else:
-            errtxt = "Unrecognized interpolation type: "
-            errtxt += self.interpolation_type
-            raise ValueError(errtxt)
-
-    def simple_interpolation(self, fname, labels):
-        """Performs a simple interpolation.
-
-        :param fname:
-            The name of the checkpoint file  containing the pre-defined
-            data points.
-        :param labels:
-            A list of data point labels.
-        """
-        n_points = len(labels)
-        data_point = ImpesCoordinates(self.comm, self.ostream)
-        data_point.update_settings(self.impes_dict)
-        sum_weights = 0.0
-        potentials = []
-        weights = []
-        # Determine weights and energy values for interpolation
-        for label in labels:
-            data_point.read_hdf5(fname, label)
-            distance = np.linalg.norm( 
-                            self.impes_coordinate.internal_coordinates_array
-                          - data_point.internal_coordinates_array )
-            weight = 1.0 / (distance**self.exponent_p)
-            sum_weights += weight
-            potential = self.compute_potential(data_point)
-            potentials.append(potential)
-            weights.append(weight)
-
-        # Perform the interpolation and save the result in self.energy
-        self.energy = 0
-        weights /= sum_weights
-        for i in range(n_points):
-            self.energy += weights[i] * potentials[i]
-
-    def shepard_interpolation(self, fname, labels):
-        """Performs a simple interpolation.
-
-        :param fname:
-            The name of the checkpoint file  containing the pre-defined
-            data points.
-        :param labels:
-            A list of data point labels.
-        """
-        n_points = len(labels)
-        data_point = ImpesCoordinates(self.comm, self.ostream)
-        data_point.update_settings(self.impes_dict)
-        sum_weights = 0.0
-        potentials = []
-        weights = []
-        # Determine weights and potential energy surface values for interpolation
-        for label in labels:
-            data_point.read_hdf5(fname, label)
-            distance = np.linalg.norm(
-                            self.impes_coordinate.internal_coordinates_array 
-                          - data_point.internal_coordinates_array )
-            denominator = ( 
-                    ( distance / self.confidence_radius )**self.exponent_p
-                  + ( distance / self.confidence_radius )**self.exponent_q )
-            weight = 1.0 / denominator
-            sum_weights += weight
-            potential = self.compute_potential(data_point)
-            potentials.append(potential)
-            weights.append(weight)
-
-        # Perform the interpolation and save the result in self.energy
-        self.energy = 0
-        weights /= sum_weights
-        for i in range(n_points):
-            self.energy += weights[i] * potentials[i]
-
-    def compute_potential(self, data_point):
-        """Calculated the potential energy surface at self.impes_coordinate
-           based on the energy, gradient and Hessian of data_point.
-
-            :param data_point:
-                ImpesCoordinates object.
-        """
-
-        energy = data_point.energy
-        grad = data_point.internal_gradient
-        hessian = data_point.internal_hessian
-        dist = (   self.impes_coordinate.internal_coordinates_array 
-                 - data_point.internal_coordinates_array )
-
-        pes = (   energy + np.matmul(dist.T, grad) 
-                + 0.5 * np.linalg.multi_dot([dist.T, hessian, dist]) 
-                )
-
-        return pes
diff --git a/src/pymodule/import_from_pyscf.py b/src/pymodule/import_from_pyscf.py
index bff177ec..511a9dbd 100644
--- a/src/pymodule/import_from_pyscf.py
+++ b/src/pymodule/import_from_pyscf.py
@@ -14,7 +14,6 @@ try:
     import pyscf
     from pyscf import grad
     from pyscf import hessian
-    from pyscf.grad import rks as pyscf_rks_grad
 except ImportError:
     errtxt = "Please install pyscf.\n"
     errtxt += "$pip3 install pyscf"
@@ -30,62 +29,9 @@ def translate_to_pyscf(label):
         return "6-31+G(d,p)"
     elif label == "6-311++G_D,P_":
         return "6-311++G(d,p)"
-    elif label == "blyp":
-        return "b88,lyp"
     else:
         return label
 
-def get_pyscf_integral_type(int_type):
-    """
-    Translates the integral type to pyscf moleintor format.
-    """
-    # TODO: routine which returns all the available integral types.
-    int_dict = {
-            "overlap"                                       : "int1e_ovlp",
-            "kinetic_energy"                                : "int1e_kin",
-            "nuclear_attraction"                            : "int1e_nuc",
-            "electric_dipole"                               : "int1e_r",
-            "electron_repulsion"                            : "int2e",
-            "electron_repulsion_erf"                        : "int2e", #_coulerf
-            "overlap_derivative"                            : "int1e_ipovlp",
-            "kinetic_energy_derivative"                     : "int1e_ipkin",
-            "nuclear_attraction_derivative_operator"        : "int1e_iprinv",
-            "nuclear_attraction_derivative_orbitals"        : "int1e_ipnuc",
-            # electric dipole deriv. calculated numerically
-            "numerical_electric_dipole_derivative"          : "int1e",
-            "electric_dipole_derivative"                    : "int1e_irp",
-            "electron_repulsion_derivative"                 : "int2e_ip1",
-            "overlap_second_derivative_2_0"                 : "int1e_ipipovlp",
-            "overlap_second_derivative_1_1"                 : "int1e_ipovlpip",
-            "kinetic_energy_second_derivative_2_0"          : "int1e_ipipkin",
-            "kinetic_energy_second_derivative_1_1"          : "int1e_ipkinip",
-            "nuclear_attraction_second_derivative_orbs_2_0" : "int1e_ipipnuc",
-            "nuclear_attraction_second_derivative_orbs_1_1" : "int1e_ipnucip",
-            "nuclear_attraction_second_derivative_op_2_0"   : "int1e_ipiprinv",
-            "nuclear_attraction_second_derivative_op_1_1"   : "int1e_iprinvip",
-            "electron_repulsion_second_derivative_2_0_0_0"  : "int2e_ipip1",
-            "electron_repulsion_second_derivative_1_1_0_0"  : "int2e_ipvip1",
-            "electron_repulsion_second_derivative_1_0_1_0"  : "int2e_ip1ip2",
-        }
-    if int_type not in int_dict.keys():
-        error_text = "Unrecognized integral type: " + int_type +". "
-        error_text += "Please use one of the following:"
-        raise ValueError(error_text, int_dict.keys())
-    else:
-        return int_dict[int_type]
-
-def get_sign(pyscf_int_type):
-    """
-    Returns the sign of the pyscf integrals which corresponds
-    to the veloxchem standard. 
-    """
-    if pyscf_int_type in ["int1e_nuc", "int1e_ipovlp", "int1e_ipkin",
-                          "int1e_ipnuc", "int1e_iprinv", "int2e_ip1",
-                          "int1e_irp"]:
-        return -1
-    else:
-        return 1
-
 def get_molecule_string(molecule):
     mol_string = ""
     for i in range(molecule.number_of_atoms()):
@@ -97,7 +43,7 @@ def get_molecule_string(molecule):
 
     return mol_string
 
-def write_2d_array_hdf5(fname, arrays, labels=[], atom_index=None):
+def write_2d_array_hdf5(fname, arrays, labels='xyz', atom_index=0):
     """
     Writes the one-electron integral derivatives to the checkpoint file. 
 
@@ -128,1301 +74,11 @@ def write_2d_array_hdf5(fname, arrays, labels=[], atom_index=None):
         return False
 
     for label, array in zip(labels, arrays):
-        if atom_index is not None:
-            full_label= str(atom_index) + label
-        else:
-            full_label = label
+        full_label= str(atom_index) + label
         hf.create_dataset(full_label, data=array, compression='gzip')
     hf.close()
     return True
 
-def import_integral(molecule, basis, int_type, atom1, shell1,
-                    atom2, shell2, atom3=None, shell3=None,
-                    atom4=None, shell4=None, xi1=None, xi2=None,
-                    chk_file=None, return_block=True, full_deriv=False,
-                    delta_h=1e-5, omega=None):
-    """
-    Imports integrals and integral derivatives from pyscf and converts 
-    them to veloxchem format.
-    Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of integral, or integral derivative 
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param atom3:
-        index of the third atom of interest (for 2e integrals)
-    :param shell3:
-        list of atomic shells of interest for atom 3 (for 2e integrals)
-    :param atom4:
-        index of the fourth atom of interest (for 2e integrals)
-    :param shell4:
-        list of atomic shells of interest for atom 4 (for 2e integrals)
-    :param xi1:
-        index of the atom with respect to which derivatives are taken
-        (for first and second order derivatives)
-    :param xi2:
-        index of the second atom with respect to which derivatives are taken
-        (for second order derivatives)
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param return_block:
-        return the matrix block, or the full matrix
-    :param full_deriv:
-        return the full integral derivative (for first and second order
-        derivatives)
-    :param delta_h:
-        step for numerical derivative (required by the electric dipole
-        derivatives).
-
-
-    :return:
-        a numpy array corresponding to a specified block of 
-        the selected integral or integral derivative matrix.
-    """
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-
-    if 'int2e' in pyscf_int_type:
-        if (atom3 is None) or (shell3 is None) or (atom4 is None) or (shell4 is None):
-            errtxt = "Not enough shells defined for a two-electron integral. "
-            errtxt += "Please define atom3, shell3, atom4, shell4."
-            raise ValueError(errtxt, atom3, shell3, atom4, shell4)
-
-    if 'derivative' in int_type and xi1 is None:
-        errtxt = "Please set the index of the atom (xi1) with respect to which"
-        errtxt += " the derivative should be taken. "
-        raise ValueError(errtxt, xi1)
-
-    if 'second' in int_type:
-        if '2_0' not in int_type and xi2 is None:
-            errtxt = "Please set the index of the second atom (xi2)"
-            errtxt += " with respect to which the derivative should be taken."
-            raise ValueError(errtxt, xi2)
-
-    if 'derivative' in int_type:
-        if 'second' in int_type:
-            if '2_0' in int_type:
-                if 'int2e' in pyscf_int_type:
-                    return import_2e_integral_derivative(molecule, basis,
-                        int_type, atomi=xi1, atom1=atom1, shell1=shell1,
-                        atom2=atom2, shell2=shell2, atom3=atom3, shell3=shell3,
-                        atom4=atom4, shell4=shell4, chk_file=chk_file,
-                        return_block=return_block, full_deriv=full_deriv)
-                else:
-                    return import_1e_integral_derivative(molecule, basis,
-                        int_type, atomi=xi1, atom1=atom1, shell1=shell1,
-                        atom2=atom2, shell2=shell2, chk_file=chk_file,
-                        return_block=return_block, full_deriv=full_deriv)
-            else:
-                if 'int2e' in pyscf_int_type:
-                    return import_2e_second_order_integral_derivative(molecule,
-                        basis, int_type, atomi=xi1, atomj=xi2, atom1=atom1,
-                        shell1=shell1, atom2=atom2, shell2=shell2, atom3=atom3,
-                        shell3=shell3, atom4=atom4, shell4=shell4,
-                        chk_file=chk_file, return_block=return_block,
-                        full_deriv=full_deriv)
-                else:
-                    return import_1e_second_order_integral_derivative(molecule,
-                        basis, int_type, atomi=xi1, atomj=xi2, atom1=atom1,
-                        shell1=shell1, atom2=atom2, shell2=shell2,
-                        chk_file=chk_file, return_block=return_block,
-                        full_deriv=full_deriv)
-
-        else:
-            if 'int2e' in pyscf_int_type:
-                return import_2e_integral_derivative(molecule, basis, int_type,
-                        atomi=xi1, atom1=atom1, shell1=shell1, atom2=atom2,
-                        shell2=shell2, atom3=atom3, shell3=shell3, atom4=atom4,
-                        shell4=shell4, chk_file=chk_file,
-                        return_block=return_block, full_deriv=full_deriv)
-            else:
-                if int_type == "numerical_electric_dipole_derivative":
-                    return numerical_electric_dipole_derivatives(molecule,
-                        basis, int_type, atomi=xi1, atom1=atom1, shell1=shell1,
-                        atom2=atom2, shell2=shell2, delta_h=delta_h,
-                        chk_file=chk_file, return_block=return_block) 
-                else:
-                    return import_1e_integral_derivative(molecule, basis,
-                        int_type, 
-                        atomi=xi1, atom1=atom1, shell1=shell1,
-                        atom2=atom2, shell2=shell2, chk_file=chk_file,
-                        return_block=return_block, full_deriv=full_deriv)
-    else:
-        if 'int2e' in pyscf_int_type:
-            return import_2e_integral(molecule, basis, int_type, atom1=atom1,
-                       shell1=shell1, atom2=atom2, shell2=shell2, atom3=atom3,
-                       shell3=shell3, atom4=atom4, shell4=shell4,
-                       chk_file=chk_file, return_block=return_block, omega=omega)
-        else:
-            return import_1e_integral(molecule, basis, int_type, atom1=atom1,
-                       shell1=shell1, atom2=atom2, shell2=shell2,
-                       chk_file=chk_file, return_block=return_block)
-
-
-def import_1e_integral(molecule, basis, int_type, atom1=1, shell1=None,
-                       atom2=1, shell2=None, chk_file=None,
-                       unit="au", return_block=True):
-    """
-    Imports one electron integrals from pyscf and converts to veloxchem format.
-    Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of one-electron integral: overlap, kinetic_energy,
-                                           nuclear_attraction 
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-    :param return_block:
-        return the matrix block, or the full matrix.
-
-
-    :return:
-        a numpy array corresponding to a specified block of 
-        the selected 1e integral matrix.
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-    sign = get_sign(pyscf_int_type)
-
-    pyscf_int = sign * pyscf_molecule.intor(pyscf_int_type, aosym='s1')
-
-    # Transform integral to veloxchem format
-    if pyscf_int_type in ["int1e_r"]:
-        vlx_int = np.zeros_like(pyscf_int) 
-        for x in range(3):
-            vlx_int[x] = ao_matrix_to_veloxchem(
-                                 DenseMatrix(pyscf_int[x]),
-                                 basis, molecule).to_numpy()
-    else:
-        vlx_int = ao_matrix_to_veloxchem(
-                                 DenseMatrix(pyscf_int),
-                                 basis, molecule).to_numpy()
-
-    ao_basis_map = basis.get_ao_basis_map(molecule)
-    rows = []
-    columns = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        rows.append(k)
-            else:
-                rows.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        columns.append(k)
-            else:
-                columns.append(k)
-        k += 1
-    if rows == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if columns == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    
-
-    if pyscf_int_type in ["int1e_r"]:
-        vlx_int_block = np.zeros((3, len(rows), len(columns)))
-    else:
-        vlx_int_block = np.zeros((len(rows), len(columns)))
-    
-    for i in range(len(rows)):
-        for j in range(len(columns)):
-            if pyscf_int_type in ["int1e_r"]:
-                vlx_int_block[:,i,j] = vlx_int[:, rows[i], columns[j]] 
-            else:
-                vlx_int_block[i,j] = vlx_int[rows[i], columns[j]]
-   
-    label = int_type+'_atom%d' % (atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    print(label) 
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int
-
-
-def import_2e_integral(molecule, basis, int_type, atom1=1, shell1=None,
-                       atom2=1, shell2=None, atom3=1, shell3=None,
-                       atom4=1, shell4=None, chk_file=None,
-                       unit="au", return_block=True, omega=None):
-    """
-    Imports two electron integrals from pyscf and converts to veloxchem format.
-    Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of one-electron integral: overlap, kinetic_energy,
-                                           nuclear_attraction 
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param atom3:
-        index of the third atom of interest
-    :param shell3:
-        list of atomic shells of interest for atom 3
-    :param atom4:
-        index of the fourth atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 4
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-    :param return_block:
-        return the matrix block, or the full matrix.
-    :param omega:
-        Error function parameter for range-separated Coulomb integrals.
-
-
-    :return:
-        a numpy array corresponding to a specified block of
-        the selected two electron integral
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-    sign = get_sign(pyscf_int_type)
-    if 'erf' in int_type:
-        with pyscf_molecule.with_range_coulomb(omega):
-            pyscf_int = sign * pyscf_molecule.intor(pyscf_int_type, aosym='s1')
-    else:
-        pyscf_int = sign * pyscf_molecule.intor(pyscf_int_type, aosym='s1')
-
-    nao = pyscf_molecule.nao
-
-    # Transform integral to veloxchem format
-    vlx_int = np.zeros_like(pyscf_int)
-
-    basis_set_map = basis.get_index_map(molecule)
-    for m in range(nao):
-        for n in range(nao):
-            for t in range(nao):
-                for p in range(nao):
-                    vm = basis_set_map[m]
-                    vn = basis_set_map[n]
-                    vt = basis_set_map[t]
-                    vp = basis_set_map[p]
-                    vlx_int[vm,vn,vt,vp] = pyscf_int[m,n,t,p]
-
-    ao_basis_map = basis.get_ao_basis_map(molecule)
-    index1 = []
-    index2 = []
-    index3 = []
-    index4 = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        index1.append(k)
-            else:
-                index1.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        index2.append(k)
-            else:
-                index2.append(k)
-        if atom3 == atom:
-            if shell3 is not None:
-                for s in shell3:
-                    if s in shell:
-                        index3.append(k)
-            else:
-                index3.append(k)
-        if atom4 == atom:
-            if shell4 is not None:
-                for s in shell4:
-                    if s in shell:
-                        index4.append(k)
-            else:
-                index4.append(k)
-        k += 1
-    if index1 == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if index2 == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    if index3 == []:
-        raise ValueError("Atom or shell(s) not found.", atom3, shell3)
-    if index4 == []:
-        raise ValueError("Atom or shell(s) not found.", atom4, shell4)
-    
-    vlx_int_block = np.zeros((len(index1), len(index2),
-                              len(index3), len(index4)))
-    
-    for i in range(len(index1)):
-        for j in range(len(index2)):
-            for k in range(len(index3)):
-                for l in range(len(index4)):
-                    vlx_int_block[i,j,k,l] = vlx_int[index1[i], index2[j],
-                                                     index3[k], index4[l]]
-   
-    label = int_type+'_atom%d' % (atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    label += "_atom%d" % (atom3)
-    if shell3 is not None:
-        for s3 in shell3:
-            label += "_%s" % (s3)
-
-    label += "_atom%d" % (atom4)
-    if shell4 is not None:
-        for s4 in shell4:
-            label += "_%s" % (s4)
-
-    print(label) 
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int
-
-def import_1e_integral_derivative(molecule, basis, int_type, atomi=1, atom1=1,
-                                  shell1=None, atom2=1, shell2=None,
-                                  chk_file=None, unit="au", return_block=True,
-                                  full_deriv=False):
-    """
-    Imports one electron integral derivatives from pyscf and converts
-    to veloxchem format. Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of one-electron integral: overlap, kinetic_energy,
-                                           nuclear_attraction 
-    :param atomi:
-        the index of the atom with respect to which the derivatives
-        are taken (indexing starts at 1)
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-    :param return_block:
-        return the matrix block, or the full matrix
-    :param full_deriv:
-        if to calculate the full derivative
-        (nabla m | operator | n) + (m | operator | nabla n) (for debugging).
-
-
-    :return:
-        a numpy array corresponding to a specified block of 
-        the selected 1e integral derivative matrix.
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-
-    # Get the AO indeces corresponding to atom i
-    i = atomi - 1 # to use pyscf indexing
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-    sign = get_sign(pyscf_int_type)
-    if pyscf_int_type in ["int1e_iprinv", "int1e_ipiprinv", "int1e_iprinvip"]:
-        # TODO: check if Zilvinas wants it this way
-        sign *= molecule.elem_ids_to_numpy()[i] # Z-number
-        # (m | nabla_i operator | n)
-        with pyscf_molecule.with_rinv_at_nucleus(i): 
-            pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type,
-                                                          aosym='s1')
-    else:
-        pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type,
-                                                      aosym='s1')
-
-
-    #print("Integral type and sign", sign, pyscf_int_type)
-    
-    ao_slices = pyscf_molecule.aoslice_by_atom()
-
-    ki, kf = ao_slices[i, 2:]
-
-    pyscf_int_deriv_atom_i = np.zeros(pyscf_int_deriv.shape)
-
-    if pyscf_int_type in ["int1e_iprinv"]:
-        # (m | nabla_i operator | n)
-        pyscf_int_deriv_atom_i = pyscf_int_deriv
-    elif pyscf_int_type in ["int1e_iprinvip"]:
-        pyscf_int_deriv_atom_i = -pyscf_int_deriv
-        pyscf_int_deriv_atom_i[:,ki:kf] += pyscf_int_deriv[:,ki:kf]
-        pyscf_int_deriv_atom_i[:,:,ki:kf] += pyscf_int_deriv[:,:,ki:kf]
-    elif pyscf_int_type in ["int1e_ipiprinv"]:
-        pyscf_int_deriv_atom_i = -pyscf_int_deriv
-        pyscf_int_deriv_atom_i[:,ki:kf] += pyscf_int_deriv[:,ki:kf]
-        pyscf_int_deriv_atom_i[:,:,ki:kf] += pyscf_int_deriv[:,ki:kf].transpose(0,2,1)
-    elif pyscf_int_type in ["int1e_irp"]:
-        pyscf_int_deriv_atom_i[:,:,ki:kf] = pyscf_int_deriv[:,:,ki:kf]
-    else:
-        pyscf_int_deriv_atom_i[:,ki:kf] = pyscf_int_deriv[:,ki:kf]
-
-
-    # (nabla m | operator | n) + (m | operator | nabla n)
-    # TODO: remove
-    if full_deriv:
-        pyscf_int_deriv_atom_i += pyscf_int_deriv_atom_i.transpose(0,2,1)
-
-    # Transform integral to veloxchem format
-    vlx_int_deriv = np.zeros_like(pyscf_int_deriv_atom_i)
-
-    # number of derivatives (3)
-    n_deriv = pyscf_int_deriv_atom_i.shape[0]
-    for x in range(n_deriv):
-        vlx_int_deriv[x] = ao_matrix_to_veloxchem(
-                                 DenseMatrix(pyscf_int_deriv_atom_i[x]),
-                                 basis, molecule).to_numpy()
-
-    ao_basis_map = basis.get_ao_basis_map(molecule)
-    rows = []
-    columns = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        rows.append(k)
-            else:
-                rows.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        columns.append(k)
-            else:
-                columns.append(k)
-        k += 1
-    if rows == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if columns == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    
-
-    vlx_int_block = np.zeros((vlx_int_deriv.shape[0], len(rows), len(columns)))
-
-    for k in range(len(rows)):
-        for l in range(len(columns)):
-            vlx_int_block[:, k, l] = vlx_int_deriv[:, rows[k], columns[l]]
-   
-    label = int_type+'_wrt_atom%d_shells_atom%d' % (atomi, atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int_deriv
-
-def numerical_electric_dipole_derivatives(molecule, ao_basis, int_type,
-                                          atomi=1, atom1=1, shell1=None,
-                                          atom2=1, shell2=None, delta_h=1e-5,
-                                          chk_file=None, return_block=True,
-                                          unit="au"):
-    """
-    Computes numerical derivatives of the electric dipole integrals.
-
-    :param molecule:
-        The molecule.
-    :param ao_basis:
-        The AO basis set.
-    :param int_type:
-        The integral type (electric_dipole_derivative)
-    :param atomi:
-        The atom with respect to which the derivatives are taken
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param delta_h:
-        The step for the numerical derivative.
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param return_block:
-        return the matrix block, or the full matrix
-     :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-
-    :return:
-        The selected block of the electric dipole integral derivatives.
-    """
-
-    i = atomi - 1
-    # atom labels
-    labels = molecule.get_labels()
-
-    # number of atoms
-    natm = molecule.number_of_atoms()
-
-    # atom coordinates (nx3)
-    coords = molecule.get_coordinates()
-
-    # number of atomic orbitals
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = ao_basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-    nao = pyscf_molecule.nao
-
-    # Dipole integrals driver
-    dipole_drv = ElectricDipoleIntegralsDriver()
-
-    # 3 dipole components x 3 atomic coordinates
-    # x No. basis x No. basis
-    dipole_integrals_gradient = np.zeros((3, 3, nao, nao))
-
-    for d in range(3):
-        coords[i, d] += delta_h
-        new_mol = Molecule(labels, coords, units='au')
-
-        dipole_mats_p = dipole_drv.compute(new_mol, ao_basis)
-        dipole_ints_p = (dipole_mats_p.x_to_numpy(), 
-                         dipole_mats_p.y_to_numpy(),
-                         dipole_mats_p.z_to_numpy())
-
-        coords[i, d] -= 2.0 * delta_h
-        new_mol = Molecule(labels, coords, units='au')
-
-        dipole_mats_m = dipole_drv.compute(new_mol, ao_basis)
-        dipole_ints_m = (dipole_mats_m.x_to_numpy(),
-                         dipole_mats_m.y_to_numpy(),
-                         dipole_mats_m.z_to_numpy())
-
-        for c in range(3):
-            dipole_integrals_gradient[c, d] = (
-                ( dipole_ints_p[c] - dipole_ints_m[c] ) / (2.0 * delta_h)
-            )
-
-    vlx_int_deriv = dipole_integrals_gradient.reshape(3*3,nao,nao)
-
-    ao_basis_map = ao_basis.get_ao_basis_map(molecule)
-    rows = []
-    columns = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        rows.append(k)
-            else:
-                rows.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        columns.append(k)
-            else:
-                columns.append(k)
-        k += 1
-    if rows == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if columns == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    
-
-    vlx_int_block = np.zeros((vlx_int_deriv.shape[0], len(rows), len(columns)))
-
-    for k in range(len(rows)):
-        for l in range(len(columns)):
-            vlx_int_block[:, k, l] = vlx_int_deriv[:, rows[k], columns[l]]
-   
-    label = int_type+'_wrt_atom%d_shells_atom%d' % (atomi, atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int_deriv
-
-
-def import_1e_second_order_integral_derivative(molecule, basis, int_type,
-                                  atomi, atomj, atom1=1, shell1=None,
-                                  atom2=1, shell2=None, chk_file=None,
-                                  unit="au", return_block=True,
-                                  full_deriv=False):
-    """
-    Imports one electron integral derivatives from pyscf and converts
-    to veloxchem format. Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of one-electron integral: overlap, kinetic_energy,
-                                           nuclear_attraction 
-    :param atomi:
-        the index of the atom with respect to which the derivatives
-        are taken (indexing starts at 1)
-    :param atomj:
-        the index of the second atom with respect to which the derivatives
-        are taken (indexing starts at 1)
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-    :param return_block:
-        return the matrix block, or the full matrix
-    :param full_deriv:
-        if to calculate the full derivative
-        (nabla m | operator | n) + (m | operator | nabla n) (for debugging).
-
-
-    :return:
-        a numpy array corresponding to a specified block of 
-        the selected 1e integral derivative matrix.
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-
-    # Get the AO indeces corresponding to atom i
-    i = atomi - 1 # to use pyscf indexing
-    j = atomj - 1
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-    sign = get_sign(pyscf_int_type)
-
-    # TODO: modify to include all rinv-related integral derivatives
-    if pyscf_int_type in ["int1e_iprinvip", "int1e_ipiprinv"]:
-        # TODO: check if Zilvinas wants it this way
-        sign *= molecule.elem_ids_to_numpy()[j] # Z-number
-        # (nabla_i m | nabla_j operator | n)
-        with pyscf_molecule.with_rinv_at_nucleus(j): 
-            pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type,
-                                                          aosym='s1')
-    else:
-        pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type,
-                                                      aosym='s1')
-
-
-    #print("Integral type and sign", sign, pyscf_int_type)
-    
-    ao_slices = pyscf_molecule.aoslice_by_atom()
-
-    ki, kf = ao_slices[i, 2:]
-    kj, kg = ao_slices[j, 2:]
-
-    pyscf_int_deriv_atoms_ij = np.zeros(pyscf_int_deriv.shape)
-
-    if pyscf_int_type in ["int1e_iprinvip", "int1e_ipiprinv"]:
-        # (nabla_i m | nabla_j operator | n)
-        pyscf_int_deriv_atoms_ij[:,ki:kf,:] = pyscf_int_deriv[:,ki:kf,:]
-    else:
-        pyscf_int_deriv_atoms_ij[:,ki:kf,kj:kg] = pyscf_int_deriv[:,ki:kf,kj:kg]
-
-
-    # (nabla**2 m | operator | n) + (m | operator | nabla**2 n)
-    # or (nabla m | operator | nabla n) + (nabla n | operator | nabla m)
-    # TODO: remove
-    nao = pyscf_molecule.nao
-    if full_deriv:
-        pyscf_int_deriv_atoms_ij += pyscf_int_deriv_atoms_ij.transpose(0,2,1)
-        if pyscf_int_type in ["int1e_iprinvip"]:
-            sign = get_sign(pyscf_int_type) * molecule.elem_ids_to_numpy()[i]
-            # (nabla_j m | nabla_i operator | n)
-            with pyscf_molecule.with_rinv_at_nucleus(i): 
-                new_pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type,
-                                                aosym='s1').reshape((3,3,nao,nao))
-            transposed_new_pyscf_int_deriv = new_pyscf_int_deriv.transpose(1,0,2,3)
-            reshaped_new_pyscf_int_deriv = transposed_new_pyscf_int_deriv.reshape((3*3,nao,nao))
-            new_pyscf_int_deriv_atoms_ij = np.zeros(pyscf_int_deriv.shape)
-            new_pyscf_int_deriv_atoms_ij[:,kj:kg] += reshaped_new_pyscf_int_deriv[:,kj:kg]
-            new_pyscf_int_deriv_atoms_ij += new_pyscf_int_deriv_atoms_ij.transpose(0,2,1)
-            pyscf_int_deriv_atoms_ij += new_pyscf_int_deriv_atoms_ij
-        elif pyscf_int_type in ["int1e_ipiprinv"]:
-            sign = get_sign(pyscf_int_type) * molecule.elem_ids_to_numpy()[i]
-            # (nabla_j m | nabla_i operator | n)
-            with pyscf_molecule.with_rinv_at_nucleus(i): 
-                new_pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type,
-                                                aosym='s1')
-            new_pyscf_int_deriv_atoms_ij = np.zeros(pyscf_int_deriv.shape)
-            new_pyscf_int_deriv_atoms_ij[:,kj:kg] += new_pyscf_int_deriv[:,kj:kg]
-            new_pyscf_int_deriv_atoms_ij += new_pyscf_int_deriv_atoms_ij.transpose(0,2,1)
-            pyscf_int_deriv_atoms_ij += new_pyscf_int_deriv_atoms_ij
-
-    # Transform integral to veloxchem format
-    vlx_int_deriv = np.zeros_like(pyscf_int_deriv_atoms_ij)
-
-    # number of derivatives (3)
-    n_deriv = pyscf_int_deriv_atoms_ij.shape[0]
-    for x in range(n_deriv):
-        vlx_int_deriv[x] = ao_matrix_to_veloxchem(
-                                 DenseMatrix(pyscf_int_deriv_atoms_ij[x]),
-                                 basis, molecule).to_numpy()
-
-    ao_basis_map = basis.get_ao_basis_map(molecule)
-    rows = []
-    columns = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        rows.append(k)
-            else:
-                rows.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        columns.append(k)
-            else:
-                columns.append(k)
-        k += 1
-    if rows == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if columns == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    
-
-    vlx_int_block = np.zeros((n_deriv, len(rows), len(columns)))
-
-    for k in range(len(rows)):
-        for l in range(len(columns)):
-            vlx_int_block[:, k, l] = vlx_int_deriv[:, rows[k], columns[l]]
-   
-    label = int_type+'_wrt_atom%d_atom%d_shells_atom%d' % (atomi, atomj, atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int_deriv
-
-def import_2e_integral_derivative(molecule, basis, int_type, atomi, atom1=1,
-                        shell1=None, atom2=1, shell2=None, atom3=1, shell3=None,
-                        atom4=1, shell4=None, chk_file=None,
-                        unit="au", return_block=True, full_deriv=False):
-    """
-    Imports two electron integral derivatives from pyscf and converts 
-    them to veloxchem format.
-    Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of one-electron integral: overlap, kinetic_energy,
-                                           nuclear_attraction
-    :param atomi:
-        the index of the atom with respect to which the derivatives
-        are taken (indexing starts at 1) 
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param atom3:
-        index of the third atom of interest
-    :param shell3:
-        list of atomic shells of interest for atom 3
-    :param atom4:
-        index of the fourth atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 4
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-    :param return_block:
-        return the matrix block, or the full matrix.
-
-
-    :return:
-        a numpy array corresponding to a specified block of 
-        the selected two electron integral derivative matrix.
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-
-    # Get the AO indeces corresponding to atom i
-    i = atomi - 1 # to use pyscf indexing
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-    sign = get_sign(pyscf_int_type)
-    pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type, aosym='s1')
-
-    nao = pyscf_molecule.nao
-
-    ao_slices = pyscf_molecule.aoslice_by_atom()
-
-    # Get the AO indeces corresponding to atom i
-    ki, kf = ao_slices[i, 2:]
-
-    pyscf_int_deriv_atom_i = np.zeros(pyscf_int_deriv.shape)
-
-    pyscf_int_deriv_atom_i[:, ki:kf] = pyscf_int_deriv[:, ki:kf]
-
-    if full_deriv:
-        #   (nabla m n | t p) + ( m nabla n | t p)
-        # + (m n | nabla t p) + (m n | t nabla p)
-        pyscf_int_deriv_atom_i += ( pyscf_int_deriv_atom_i.transpose(0,2,1,4,3)
-                             + pyscf_int_deriv_atom_i.transpose(0,3,4,1,2)
-                             + pyscf_int_deriv_atom_i.transpose(0,4,3,2,1) )
-
-    # Transform integral to veloxchem format
-    vlx_int_deriv = np.zeros_like(pyscf_int_deriv_atom_i)
-
-    basis_set_map = basis.get_index_map(molecule)
-    for m in range(nao):
-        for n in range(nao):
-            for t in range(nao):
-                for p in range(nao):
-                    vm = basis_set_map[m]
-                    vn = basis_set_map[n]
-                    vt = basis_set_map[t]
-                    vp = basis_set_map[p]
-                    vlx_int_deriv[:,vm,vn,vt,vp] = (
-                                    pyscf_int_deriv_atom_i[:,m,n,t,p] )
-
-    ao_basis_map = basis.get_ao_basis_map(molecule)
-    index1 = []
-    index2 = []
-    index3 = []
-    index4 = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        index1.append(k)
-            else:
-                index1.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        index2.append(k)
-            else:
-                index2.append(k)
-        if atom3 == atom:
-            if shell3 is not None:
-                for s in shell3:
-                    if s in shell:
-                        index3.append(k)
-            else:
-                index3.append(k)
-        if atom4 == atom:
-            if shell4 is not None:
-                for s in shell4:
-                    if s in shell:
-                        index4.append(k)
-            else:
-                index4.append(k)
-        k += 1
-    if index1 == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if index2 == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    if index3 == []:
-        raise ValueError("Atom or shell(s) not found.", atom3, shell3)
-    if index4 == []:
-        raise ValueError("Atom or shell(s) not found.", atom4, shell4)
-   
-    n_deriv = pyscf_int_deriv_atom_i.shape[0]
-    vlx_int_block = np.zeros((n_deriv, len(index1), len(index2),
-                              len(index3), len(index4)))
-    
-    for k in range(len(index1)):
-        for l in range(len(index2)):
-            for m in range(len(index3)):
-                for n in range(len(index4)):
-                    vlx_int_block[:,k,l,m,n] = vlx_int_deriv[:,index1[k],
-                                                       index2[l], index3[m],
-                                                       index4[n]]
-   
-    label = int_type+'_atom%d_shells_atom%d' % (atomi, atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    label += "_atom%d" % (atom3)
-    if shell3 is not None:
-        for s3 in shell3:
-            label += "_%s" % (s3)
-
-    label += "_atom%d" % (atom4)
-    if shell4 is not None:
-        for s4 in shell4:
-            label += "_%s" % (s4)
-
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int_deriv
-
-def import_2e_second_order_integral_derivative(molecule, basis, int_type,
-                        atomi, atomj, atom1=1, shell1=None, atom2=1,
-                        shell2=None, atom3=1, shell3=None, atom4=1,
-                        shell4=None, chk_file=None, unit="au",
-                        return_block=True, full_deriv=False):
-    """
-    Imports two electron integral derivatives from pyscf and converts 
-    them to veloxchem format.
-    Specific atoms and shells can be selected.
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param int_type:
-        the type of one-electron integral: overlap, kinetic_energy,
-                                           nuclear_attraction
-    :param atomi:
-        the index of the first atom with respect to which the derivatives
-        are taken (indexing starts at 1)
-    :param atomj:
-        the index of the second atom with respect to which the derivatives
-        are taken (indexing starts at 1) 
-    :param atom1:
-        index of the first atom of interest
-    :param shell1:
-        list of atomic shells of interest for atom 1
-    :param atom2:
-        index of the second atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 2
-    :param atom3:
-        index of the third atom of interest
-    :param shell3:
-        list of atomic shells of interest for atom 3
-    :param atom4:
-        index of the fourth atom of interest
-    :param shell2:
-        list of atomic shells of interest for atom 4
-    :param chk_file:
-        the hdf5 checkpoint file name
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-    :param return_block:
-        return the matrix block, or the full matrix.
-
-
-    :return:
-        a numpy array corresponding to a specified block of 
-        the selected two electron integral derivative matrix.
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-
-    # Get the indices corresponding to atom i, j
-    i = atomi - 1 # to use pyscf indexing
-    j = atomj - 1
-
-    pyscf_int_type = get_pyscf_integral_type(int_type)
-    sign = get_sign(pyscf_int_type)
-
-    pyscf_int_deriv = sign * pyscf_molecule.intor(pyscf_int_type, aosym='s1')
-
-    nao = pyscf_molecule.nao
-
-    ao_slices = pyscf_molecule.aoslice_by_atom()
-
-    # Get the AO indeces corresponding to atom i
-    ki, kf = ao_slices[i, 2:]
-    kj, kg = ao_slices[j, 2:]
-
-    pyscf_int_deriv_atoms_ij = np.zeros(pyscf_int_deriv.shape)
-
-    if pyscf_int_type in ["int2e_ipvip1"]:
-        # ( nabla m nabla n | p q ) 
-        pyscf_int_deriv_atoms_ij[:, ki:kf, kj:kg] = pyscf_int_deriv[:, ki:kf, kj:kg]
-    else:
-        # ( nabla m n | nabla p q )
-        pyscf_int_deriv_atoms_ij[:, ki:kf, :, kj:kg] = pyscf_int_deriv[:, ki:kf, :, kj:kg]
-
-    if full_deriv:
-        if pyscf_int_type in ["int2e_ipvip1"]:
-            #   (nabla_i m nabla_j n | p t ) + ( nabla_j m nabla_i n | p t )
-            # + (m n | nabla_i p  nabla_j t) + ( m n | nabla_j p nabla_i t)
-            pyscf_int_deriv_atoms_ij += ( pyscf_int_deriv_atoms_ij.transpose(0,2,1,4,3)
-                             + pyscf_int_deriv_atoms_ij.transpose(0,3,4,1,2)
-                             + pyscf_int_deriv_atoms_ij.transpose(0,4,3,2,1) )
-
-        elif pyscf_int_type in ["int2e_ip1ip2"]:
-            #   (nabla_i m n | nabla_j p t ) + ( m nabla_i n | nabla_j p t )
-            # + (nabla_i m n | p  nabla_j t) + ( m nabla_i n | p nabla_j t)
-            #   (nabla_j m n | nabla_i p t ) + ( m nabla_j n | nabla_i p t )
-            # + (nabla_j m n | p  nabla_i t) + ( m nabla_j n | p nabla_i t)
-            pyscf_int_deriv_atoms_ij += ( pyscf_int_deriv_atoms_ij.transpose(0,2,1,3,4)
-                         + pyscf_int_deriv_atoms_ij.transpose(0,1,2,4,3)
-                         + pyscf_int_deriv_atoms_ij.transpose(0,2,1,4,3)
-                         + pyscf_int_deriv_atoms_ij.transpose(0,3,4,1,2)
-                         + pyscf_int_deriv_atoms_ij.transpose(0,4,3,1,2)
-                         + pyscf_int_deriv_atoms_ij.transpose(0,3,4,2,1)
-                         + pyscf_int_deriv_atoms_ij.transpose(0,4,3,2,1) )
-
-    # Transform integral to veloxchem format
-    vlx_int_deriv = np.zeros_like(pyscf_int_deriv_atoms_ij)
-
-    basis_set_map = basis.get_index_map(molecule)
-    for m in range(nao):
-        for n in range(nao):
-            for t in range(nao):
-                for p in range(nao):
-                    vm = basis_set_map[m]
-                    vn = basis_set_map[n]
-                    vt = basis_set_map[t]
-                    vp = basis_set_map[p]
-                    vlx_int_deriv[:,vm,vn,vt,vp] = (
-                                    pyscf_int_deriv_atoms_ij[:,m,n,t,p] )
-
-    ao_basis_map = basis.get_ao_basis_map(molecule)
-    index1 = []
-    index2 = []
-    index3 = []
-    index4 = []
-    k = 0
-    for ao in ao_basis_map:
-        parts = ao.split()
-        atom = int(parts[0])
-        shell = parts[2]
-        if atom1 == atom:
-            if shell1 is not None:
-                for s in shell1:
-                    if s in shell:
-                        index1.append(k)
-            else:
-                index1.append(k)
-        if atom2 == atom:
-            if shell2 is not None:
-                for s in shell2:
-                    if s in shell:
-                        index2.append(k)
-            else:
-                index2.append(k)
-        if atom3 == atom:
-            if shell3 is not None:
-                for s in shell3:
-                    if s in shell:
-                        index3.append(k)
-            else:
-                index3.append(k)
-        if atom4 == atom:
-            if shell4 is not None:
-                for s in shell4:
-                    if s in shell:
-                        index4.append(k)
-            else:
-                index4.append(k)
-        k += 1
-    if index1 == []:
-        raise ValueError("Atom or shell(s) not found.", atom1, shell1)
-    if index2 == []:
-        raise ValueError("Atom or shell(s) not found.", atom2, shell2)
-    if index3 == []:
-        raise ValueError("Atom or shell(s) not found.", atom3, shell3)
-    if index4 == []:
-        raise ValueError("Atom or shell(s) not found.", atom4, shell4)
-   
-    n_deriv = pyscf_int_deriv_atoms_ij.shape[0]
-    vlx_int_block = np.zeros((n_deriv, len(index1), len(index2),
-                              len(index3), len(index4)))
-    
-    for k in range(len(index1)):
-        for l in range(len(index2)):
-            for m in range(len(index3)):
-                for n in range(len(index4)):
-                    vlx_int_block[:,k,l,m,n] = vlx_int_deriv[:,index1[k],
-                                                       index2[l], index3[m],
-                                                       index4[n]]
-   
-    label = int_type+'_atom%d_atom%d_shells_atom%d' % (atomi, atomj, atom1)
-    if shell1 is not None:
-        for s1 in shell1:
-            label += "_%s" % (s1)
-
-    label += "_atom%d" % (atom2)
-    if shell2 is not None:
-        for s2 in shell2:
-            label += "_%s" % (s2)
-
-    label += "_atom%d" % (atom3)
-    if shell3 is not None:
-        for s3 in shell3:
-            label += "_%s" % (s3)
-
-    label += "_atom%d" % (atom4)
-    if shell4 is not None:
-        for s4 in shell4:
-            label += "_%s" % (s4)
-
-    if chk_file is not None:
-        write_2d_array_hdf5(chk_file, [vlx_int_block], labels=[label])
-
-    if return_block:
-        return vlx_int_block
-    else:
-        return vlx_int_deriv
-
 
 def overlap_deriv(molecule, basis, i=0, full_deriv=True, unit="au",
                   chk_file=None):
@@ -1503,8 +159,7 @@ def overlap_deriv(molecule, basis, i=0, full_deriv=True, unit="au",
                                 )
 
     if chk_file is not None:
-        write_2d_array_hdf5(chk_file, vlx_ovlp_deriv_atom_i,
-                            labels=['overlap_x', 'overlap_y', 'overlap_z'],
+        write_2d_array_hdf5(chk_file, vlx_ovlp_deriv_atom_i, labels='xyz',
                             atom_index=i)
 
     return vlx_ovlp_deriv_atom_i
@@ -1956,103 +611,6 @@ def fock_deriv(molecule, basis, density, i=0, unit="au"):
     return vlx_fock_deriv_atom_i
 
 
-def vxc_deriv(molecule, basis, density, xcfun, i=0, unit="au"):
-    """
-    Imports the derivatives of the Vxc matrix
-    from pyscf and converts it to veloxchem format
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param density:
-        the SCF density matrix (alpha part) in AO basis
-    :param xcfun:
-        the label of the exchange-correlation functional
-    :param i:
-        the index of the atom for which the derivatives
-        are computed.
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-
-    :return:
-        a numpy array of shape 3 x nao x nao
-        (nao = number of atomic orbitals)
-        corresponding to the derivative of the Fock matrix
-        with respect to the x, y and z coords. of atom i.
-    """
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-    pyscf_scf = pyscf.scf.RKS(pyscf_molecule)
-
-    # TODO: some functional are parametrized differently in PYSCF
-    # TODO: adjust the grid level -- default used right now.
-    pyscf_scf.xc = translate_to_pyscf(xcfun)
-    #pyscf_scf.kernel()
-    #nocc = pyscf_molecule.nelec[0]
-    gs_dm = ao_matrix_to_dalton(DenseMatrix(density), basis, molecule).to_numpy()
-    #gs_dm = np.einsum('mi,ni->mn', pyscf_scf.mo_coeff[:,:nocc],
-    #                   pyscf_scf.mo_coeff[:,:nocc])
-    nao = density.shape[0]
-    
-    if nao != pyscf_molecule.nao:
-        error_text = "vlx and pyscf number of atomic orbitals are different!"
-        error_text +="\nCheck if the basis sets are defined the same way."
-        raise ValueError(error_text)    
-
-    pyscf_grad = pyscf_scf.Gradients()
-    pyscf_mf = pyscf_grad.base 
-    pyscf_ni = pyscf_mf._numint # Pyscf object for numerical integration
-    if pyscf_grad.grids is not None:
-        pyscf_grids = pyscf_grad.grids
-    else:
-        pyscf_grids = pyscf_mf.grids
-    if pyscf_grids.coords is None:
-        pyscf_grids.build(with_non0tab=True)
-
-    pyscf_exc, pyscf_vxc_deriv = pyscf_rks_grad.get_vxc(pyscf_ni,
-                                             pyscf_molecule,
-                                             pyscf_grids, pyscf_mf.xc,
-                                             2*gs_dm)
-
-    ao_slices = pyscf_molecule.aoslice_by_atom()
-
-    # Get the AO indices corresponding to atom i
-    ki, kf = ao_slices[i, 2:]
-
-    vxc_deriv_atom_i = np.zeros((3,nao,nao))
-
-    vxc_deriv_atom_i[:,ki:kf] = pyscf_vxc_deriv[:,ki:kf]
-
-    # (nabla m | vxc | n) + (m | vxc |nabla n)
-    vxc_deriv_atom_i += vxc_deriv_atom_i.transpose(0,2,1)
-
-    vlx_vxc_deriv_atom_i = np.zeros(vxc_deriv_atom_i.shape)
-
-
-    # Transform each compnent (x,y,z) to veloxchem format
-    vlx_vxc_deriv_atom_i[0] = ( ao_matrix_to_veloxchem(
-                                 DenseMatrix(vxc_deriv_atom_i[0]),
-                                 basis, molecule).to_numpy()
-                                )
-
-    vlx_vxc_deriv_atom_i[1] = ( ao_matrix_to_veloxchem(
-                                 DenseMatrix(vxc_deriv_atom_i[1]),
-                                 basis, molecule).to_numpy()
-                                )
-
-    vlx_vxc_deriv_atom_i[2] = ( ao_matrix_to_veloxchem(
-                                 DenseMatrix(vxc_deriv_atom_i[2]),
-                                 basis, molecule).to_numpy()
-                                )
-
-    return vlx_vxc_deriv_atom_i
-
-
 def eri_deriv(molecule, basis, i=0, full_deriv=True, unit="au",
               chk_file=None):
     """
@@ -2127,63 +685,66 @@ def eri_deriv(molecule, basis, i=0, full_deriv=True, unit="au",
 
     return vlx_eri_deriv_atom_i
 
-def dipole_deriv(molecule, basis, i=0, unit="au"):
-    """
-    Imports the derivatives of the dipole moment integrals
-    from pyscf and converts it to veloxchem format
-
-    :param molecule:
-        the vlx molecule object
-    :param basis:
-        the vlx basis object
-    :param i:
-        the index of the atom for which the derivatives
-        are computed.
-    :param unit:
-        the units to be used for the molecular geometry;
-        possible values: "au" (default), "Angstrom"
-
-    :return:
-        a numpy array of shape 3 x 3 x nao x nao
-        (nao = number of atomic orbitals)
-        corresponding to the derivative of the x, y, and z
-        coordinates of the dipole moment integrals
-        with respect to the x, y and z coords. of atom i.
-    """
-
-    molecule_string = get_molecule_string(molecule)
-    basis_set_label = basis.get_label()
-    pyscf_basis = translate_to_pyscf(basis_set_label)
-    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
-                                 basis=pyscf_basis, unit=unit)
-    nao = pyscf_molecule.nao
-
-
-    pyscf_dipole_deriv = -pyscf_molecule.intor('int1e_irp', aosym='s1').reshape(3, 3, nao, nao)
-    ao_slices = pyscf_molecule.aoslice_by_atom()
-
-    # Get the AO indeces corresponding to atom i
-    ki, kf = ao_slices[i, 2:]
-
-    dipole_deriv_atom_i = np.zeros(pyscf_dipole_deriv.shape)
-
-    dipole_deriv_atom_i[:,:,:,ki:kf] = pyscf_dipole_deriv[:,:,:,ki:kf]
-
-    # (nabla m | n) + (m | nabla n)
-    dipole_deriv_atom_i += dipole_deriv_atom_i.transpose(0,1,3,2)
-
-    vlx_dipole_deriv_atom_i = np.zeros(dipole_deriv_atom_i.shape)
-
-
-    # Transform each component to veloxchem format
-    for c in range(3):
-        for x in range(3):
-            vlx_dipole_deriv_atom_i[c,x] = ( ao_matrix_to_veloxchem(
-                                         DenseMatrix(dipole_deriv_atom_i[c,x]),
-                                         basis, molecule).to_numpy()
-                                         )
-
-    return vlx_dipole_deriv_atom_i
+## Not working correctly
+##def dipole_deriv(molecule, basis, i=0, unit="au"):
+##    """
+##    Imports the derivatives of the dipole moment integrals
+##    from pyscf and converts it to veloxchem format
+##
+##    :param molecule:
+##        the vlx molecule object
+##    :param basis:
+##        the vlx basis object
+##    :param i:
+##        the index of the atom for which the derivatives
+##        are computed.
+##    :param unit:
+##        the units to be used for the molecular geometry;
+##        possible values: "au" (default), "Angstrom"
+##
+##    :return:
+##        a numpy array of shape 3 x 3 x nao x nao
+##        (nao = number of atomic orbitals)
+##        corresponding to the derivative of the x, y, and z
+##        coordinates of the dipole moment integrals
+##        with respect to the x, y and z coords. of atom i.
+##    """
+##
+##    molecule_string = get_molecule_string(molecule)
+##    basis_set_label = basis.get_label()
+##    pyscf_basis = translate_to_pyscf(basis_set_label)
+##    pyscf_molecule = pyscf.gto.M(atom=molecule_string,
+##                                 basis=pyscf_basis, unit=unit)
+##    nao = pyscf_molecule.nao
+##
+##
+##    pyscf_dipole_deriv = pyscf_molecule.intor('int1e_irp', aosym='s1').reshape(3, 3, nao, nao)
+##    ao_slices = pyscf_molecule.aoslice_by_atom()
+##
+##    # Get the AO indeces corresponding to atom i
+##    #ki, kf = ao_slices[i, 2:]
+##
+##    dipole_deriv_atom_i = np.zeros(pyscf_dipole_deriv.shape)
+##
+##    #dipole_deriv_atom_i[:,:,ki:kf] = pyscf_dipole_deriv[:,:,ki:kf]
+##    dipole_deriv_atom_i = pyscf_dipole_deriv
+##
+##    # (nabla m | n) + (m | nabla n)
+##    dipole_deriv_atom_i += dipole_deriv_atom_i.transpose(1,0,3,2)
+##
+##    #vlx_dipole_deriv_atom_i = np.zeros_like(dipole_deriv_atom_i.reshape(3,3,nao,nao))
+##    vlx_dipole_deriv_atom_i = np.zeros(dipole_deriv_atom_i.shape)
+##
+##
+##    # Transform each component to veloxchem format
+##    for c in range(3):
+##        for x in range(3):
+##            vlx_dipole_deriv_atom_i[c,x] = ( ao_matrix_to_veloxchem(
+##                                         DenseMatrix(dipole_deriv_atom_i[c,x]),
+##                                         basis, molecule).to_numpy()
+##                                         )
+##
+##    return vlx_dipole_deriv_atom_i
 
 
 ### Second derivatives
diff --git a/src/pymodule/main.py b/src/pymodule/main.py
index 37ce03ba..d8313bbf 100644
--- a/src/pymodule/main.py
+++ b/src/pymodule/main.py
@@ -31,7 +31,6 @@ from .mpitask import MpiTask
 from .scfrestdriver import ScfRestrictedDriver
 from .scfunrestdriver import ScfUnrestrictedDriver
 from .scfrestopendriver import ScfRestrictedOpenDriver
-from .firstorderprop import FirstOrderProperties
 from .respchargesdriver import RespChargesDriver
 from .excitondriver import ExcitonModelDriver
 from .numerovdriver import NumerovDriver
@@ -47,6 +46,7 @@ from .rspcdspec import CircularDichroismSpectrum
 from .rspc6 import C6
 from .rspshg import SHG
 from .rsptpa import TPA
+from .firstorderprop import FirstOrderProperties
 from .scfgradientdriver import ScfGradientDriver
 from .tdhfgradientdriver import TdhfGradientDriver
 from .scfhessiandriver import ScfHessianDriver
diff --git a/src/pymodule/orbitalresponse.py b/src/pymodule/orbitalresponse.py
index 4b19d6ab..2961e7ad 100644
--- a/src/pymodule/orbitalresponse.py
+++ b/src/pymodule/orbitalresponse.py
@@ -287,7 +287,6 @@ class OrbitalResponse:
             dm_vv = rhs_results['dm_vv']
             unrel_dm_ao = rhs_results['unrel_dm_ao']
             fock_ao_rhs = rhs_results['fock_ao_rhs']
-            fock_gxc_ao = rhs_results['fock_gxc_ao']
         else:
             rhs_mo = None
 
@@ -318,9 +317,6 @@ class OrbitalResponse:
                  np.matmul(eo_diag, 0.5 * dm_oo) + eo_diag, mo_occ.T])
             epsilon_dm_ao += np.linalg.multi_dot(
                 [mo_vir, np.matmul(ev_diag, 0.5 * dm_vv), mo_vir.T])
-
-            # TODO: assign different variable to this expression, then add it
-			#	and its	transpose to epsilon_dm_ao
             epsilon_dm_ao += np.linalg.multi_dot(
                 [mo_occ,
                  np.matmul(eo_diag, lambda_multipliers), mo_vir.T])
@@ -382,7 +378,7 @@ class OrbitalResponse:
             else:
                 # This is the routine for excited states
                 omega_ao = self.compute_omega(ovlp, mo_occ, mo_vir, epsilon_dm_ao,
-                                              rsp_results, fock_ao_rhs, fock_lambda, fock_gxc_ao)
+                                              rsp_results, fock_ao_rhs, fock_lambda)
 
         self.ostream.print_blank()
         self.ostream.flush()
diff --git a/src/pymodule/polarizabilitygradient.py b/src/pymodule/polarizabilitygradient.py
deleted file mode 100644
index e0c1ab93..00000000
--- a/src/pymodule/polarizabilitygradient.py
+++ /dev/null
@@ -1,816 +0,0 @@
-import numpy as np
-import sys
-from mpi4py import MPI
-
-from .veloxchemlib import ElectronRepulsionIntegralsDriver
-from .veloxchemlib import ElectricDipoleIntegralsDriver
-from .veloxchemlib import AODensityMatrix
-from .veloxchemlib import AOFockMatrix
-from .veloxchemlib import mpi_master
-from .veloxchemlib import denmat
-from .veloxchemlib import fockmat
-from .veloxchemlib import XCIntegrator
-from .veloxchemlib import XCFunctional
-from .veloxchemlib import MolecularGrid
-#from .orbitalresponse import OrbitalResponse
-from .cphfsolver import CphfSolver
-from .outputstream import OutputStream
-from .qqscheme import get_qq_scheme
-
-# For PySCF integral derivatives
-from .import_from_pyscf import overlap_deriv
-from .import_from_pyscf import fock_deriv
-from .import_from_pyscf import eri_deriv
-from .import_from_pyscf import dipole_deriv
-
-class PolarizabilityGradient():
-    """
-    Implements the (analytical) gradient of the dipole polarizability
-    needed for the calculation of vibrational Raman intensities.
-    """
-
-    def __init__(self, comm=None, ostream=None):
-        """
-        Initializes polarizability gradient driver to default setup.
-
-        :param comm:
-            The MPI communicator.
-        :param ostream:
-            The output stream.
-        """
-
-        if comm is None:
-            comm = MPI.COMM_WORLD
-
-        if ostream is None:
-            ostream = OutputStream(sys.stdout)
-
-        # MPI information
-        self.comm = comm
-        self.rank = self.comm.Get_rank()
-        self.nodes = self.comm.Get_size()
-
-        self.ostream = ostream
-
-        self.gradient = None
-        self.flag = "Polarizability Gradient"
-        # self.numerical = False
-        # # flag for two-point or four-point approximation
-        # self.do_four_point = False
-
-        # DFT information
-        self.dft = False
-        self.grid_level = 4
-        self.xcfun = XCFunctional()
-
-        # Polarizability information
-        self.frequency = 0.0
-        self.vector_components = 'xyz'
-
-    def update_settings(self, grad_dict, orbrsp_dict=None, method_dict=None):
-        """
-        Updates response and method settings in orbital response computation
-        driver.
-
-        :param grad_dict:
-            The input dictionary of gradient settings group.
-        :param orbrsp_dict:
-            The dictionary of orbital response settings.
-        :param method_dict:
-            The dictionary of method settings.
-        """
-
-        if method_dict is None:
-            method_dict = {}
-        if orbrsp_dict is None:
-            orbrsp_dict = {}
-
-        if 'frequency' in grad_dict:
-            self.frequency = float(grad_dict['frequency'])
-            if 'frequency' not in orbrsp_dict:
-                orbrsp_dict['frequency'] = grad_dict['frequency']
-
-        if 'vector_components' in grad_dict:
-            self.vector_components = grad_dict['vector_components']
-            if 'vector_components' not in orbrsp_dict:
-                orbrsp_dict['vector_components'] = grad_dict['vector_components']
-
-        self.method_dict = dict(method_dict)
-        self.orbrsp_dict = dict(orbrsp_dict)
-
-    def compute(self, molecule, basis, scf_tensors, lr_results):
-        """
-        Performs calculation of analytical polarizability gradient.
-
-        :param molecule:
-            The molecule.
-        :param basis:
-            The AO basis set.
-        :param scf_tensors:
-            The tensors from the converged SCF calculation.
-        :param lr_results:
-            The results of the linear response calculation.
-        """
-
-        # orbital response driver
-        orbrsp_drv = PolOrbitalResponse(self.comm, self.ostream)
-
-        # compute orbital response
-        orbrsp_drv.update_settings(self.orbrsp_dict, self.method_dict)
-        orbrsp_drv.compute(molecule, basis, scf_tensors, lr_results)
-        orbrsp_drv.compute_omega(molecule, basis, scf_tensors, lr_results)
-        orbrsp_results = orbrsp_drv.cphf_results
-
-        if self.rank == mpi_master():
-            mo = scf_tensors['C'] # only alpha part
-            nao = mo.shape[0]
-            nocc = molecule.number_of_alpha_electrons()
-            mo_occ = mo[:, :nocc].copy()
-            mo_vir = mo[:, nocc:].copy()
-            nvir = mo_vir.shape[1]
-            natm = molecule.number_of_atoms()
-
-            # TODO: the following is available on the master node only
-            # only alpha part:
-            gs_dm = scf_tensors['D_alpha']
-            lambda_mo = orbrsp_results['cphf_ov']
-            # spin summation already included:
-            xpy = orbrsp_results['xpy_ao']
-            xmy = orbrsp_results['xmy_ao']
-            dof = xpy.shape[0] # Number of vector components
-            omega_ao = orbrsp_results['omega_ao'].reshape(dof, dof, nao, nao)
-
-
-            # transform lambda multipliers to AO basis and calculate relaxed density matrix
-            lambda_ao = np.einsum('mi,xia,na->xmn', mo_occ, lambda_mo,
-                                  mo_vir).reshape(dof, dof, nao, nao) # occ-vir
-            lambda_ao += lambda_ao.transpose(0,1,3,2) # vir-occ
-            rel_dm_ao = orbrsp_results['unrel_dm_ao'] + lambda_ao
-
-            # analytical polarizability gradient
-            pol_gradient = np.zeros((dof, dof, natm, 3))
-            # dictionary to translate from numbers to operator components 'xyz'
-            component_dict = {0: 'x', 1: 'y', 2: 'z'}
-
-            # loop over atoms and contract integral derivatives with density matrices
-            # add the corresponding contribution to the gradient
-            for i in range(natm):
-                # taking integral derivatives from pyscf
-                d_ovlp = overlap_deriv(molecule, basis, i)
-                d_fock = fock_deriv(molecule, basis, gs_dm, i)
-                d_eri = eri_deriv(molecule, basis, i)
-                d_dipole = dipole_deriv(molecule, basis, i)
-
-# NOTES:
-#  - Calculate omega in MO basis (do we get the same result?)
-#  - Do we have symmetrization, signs, and prefactors correct (compared to TDHF)?
-#  - Can we isolate the term with omega and overlap matrix a bit more? Is there a numerical way to get them?
-                pol_gradient[:, :, i] += ( np.einsum('xymn,amn->xya', 2.0 * rel_dm_ao, d_fock)
-                                 +1.0 * np.einsum('xymn,amn->xya', 2.0 * omega_ao, d_ovlp)
-                                 +1.0 * (
-                                 +1.0 * np.einsum('xmn,ypt,atpmn->xya', xpy, xpy - xpy.transpose(0,2,1), d_eri)
-                                 -0.5 * np.einsum('xmn,ypt,atnmp->xya', xpy, xpy - xpy.transpose(0,2,1), d_eri)
-                                 +1.0 * np.einsum('xmn,ypt,atpmn->xya', xmy, xmy + xmy.transpose(0,2,1), d_eri)
-                                 -0.5 * np.einsum('xmn,ypt,atnmp->xya', xmy, xmy + xmy.transpose(0,2,1), d_eri)
-                                 +1.0 * np.einsum('xmn,ypt,atpmn->yxa', xpy, xpy - xpy.transpose(0,2,1), d_eri)
-                                 -0.5 * np.einsum('xmn,ypt,atnmp->yxa', xpy, xpy - xpy.transpose(0,2,1), d_eri)
-                                 +1.0 * np.einsum('xmn,ypt,atpmn->yxa', xmy, xmy + xmy.transpose(0,2,1), d_eri)
-                                 -0.5 * np.einsum('xmn,ypt,atnmp->yxa', xmy, xmy + xmy.transpose(0,2,1), d_eri)
-                                 )
-                                 -2.0 * np.einsum('xmn,yamn->xya', xmy, d_dipole)
-                                 -2.0 * np.einsum('xmn,yamn->yxa', xmy, d_dipole)
-                                )
-
-            self.pol_gradient = pol_gradient.reshape(dof, dof, 3 * natm)
-
-    def init_dft(self, molecule, scf_tensors):
-        """
-        Initializes DFT.
-
-        :param molecule:
-            The molecule.
-        :param scf_tensors:
-            The dictionary of tensors from converged SCF wavefunction.
-
-        :return:
-            The dictionary of DFT information.
-        """
-
-        # generate integration grid
-        if self.dft:
-            grid_drv = GridDriver(self.comm)
-            grid_drv.set_level(self.grid_level)
-
-            grid_t0 = tm.time()
-            molgrid = grid_drv.generate(molecule)
-
-            n_grid_points = molgrid.number_of_points()
-            self.ostream.print_info(
-                'Molecular grid with {0:d} points generated in {1:.2f} sec.'.
-                format(n_grid_points,
-                       tm.time() - grid_t0))
-            self.ostream.print_blank()
-
-            if self.rank == mpi_master():
-                gs_density = AODensityMatrix([scf_tensors['D_alpha']],
-                                             denmat.rest)
-            else:
-                gs_density = AODensityMatrix()
-            gs_density.broadcast(self.rank, self.comm)
-            molgrid.broadcast(self.rank, self.comm) # TODO duble check
-
-            dft_func_label = self.xcfun.get_func_label().upper()
-        else:
-            molgrid = MolecularGrid()
-            gs_density = AODensityMatrix()
-            dft_func_label = 'HF'
-
-        return {
-            'molgrid': molgrid,
-            'gs_density': gs_density,
-            'dft_func_label': dft_func_label,
-        }
-
-
-class PolOrbitalResponse(CphfSolver):
-    """
-    Implements orbital response Lagrange multipliers computation
-    for the polarizability gradient.
-
-    Instance variables
-        - frequency: The frequency for which the polarizability
-            gradient is computed.
-        - vector_components: The components of the response vectors
-            corresponding to the operator components in linear response.
-    """
-
-    def __init__(self, comm=None, ostream=None):
-        """
-        Initializes orbital response computation driver to default setup.
-
-        :param comm:
-            The MPI communicator.
-        :param ostream:
-            The output stream.
-        """
-
-        super().__init__(comm, ostream)
-
-        self.frequency = 0.0
-        self.vector_components = 'xyz'
-        self.cphf_results = None
-
-    def update_settings(self, orbrsp_dict, method_dict=None):
-        """
-        Updates response and method settings in orbital response computation
-        driver.
-
-        :param orbrsp_dict:
-            The dictionary of orbital response settings.
-        :param method_dict:
-            The dictionary of method settings.
-        """
-
-        super().update_settings(orbrsp_dict, method_dict)
-
-        if 'frequency' in orbrsp_dict:
-            self.frequency = float(orbrsp_dict['frequency'])
-
-        if 'vector_components' in orbrsp_dict:
-            self.vector_components = orbrsp_dict['vector_components']
-
-    def compute_rhs(self, molecule, basis, scf_tensors, lr_results):
-        """
-        Computes the right-hand side (RHS) of the polarizability orbital response equation
-        including the necessary density matrices using molecular data.
-
-        :param molecule:
-            The molecule.
-        :param basis:
-            The AO basis set.
-        :param scf_tensors:
-            The dictionary of tensors from converged SCF calculation.
-        :param lr_results:
-            The results from converged linear response calculation.
-
-        :return:
-            A dictionary containing the orbital-response RHS and
-            unrelaxed one-particle density.
-        """
-
-        # DFT information
-        dft_dict = self.init_dft(molecule, scf_tensors)
-
-        self.profiler.start_timer('RHS')
-
-        # Workflow:
-        # 1) Construct the necessary density matrices
-        # 2) Construct the RHS
-        # 3) Construct the initial guess => in parent class
-        # 4) Run the solver => in parent class
-
-        if self.rank == mpi_master():
-
-            # 1) Calculate unrelaxed one-particle and transition density matrix
-            ovlp = scf_tensors['S']
-            mo = scf_tensors['C'] # only alpha part
-
-            nao = mo.shape[0]
-            nocc = molecule.number_of_alpha_electrons()
-            mo_occ = mo[:, :nocc].copy()
-            mo_vir = mo[:, nocc:].copy()
-            nvir = mo_vir.shape[1]
-
-            # TODO: do we keep this factor like that?
-            sqrt2 = np.sqrt(2.0)
-
-            # Check if response vectors exist for desired frequency of gradient
-            if (self.vector_components[0], self.frequency) not in lr_results['solutions'].keys():
-                raise ValueError("Frequency for gradient not found in linear response results.")
-
-            # Take response vectors and convert to matrix form
-            exc_vec = 1/sqrt2 * np.array([lr_results['solutions'][x,
-                                self.frequency][:nocc * nvir].reshape(nocc, nvir)
-                                for x in self.vector_components])
-            deexc_vec = 1/sqrt2 * np.array([lr_results['solutions'][x,
-                                self.frequency][nocc * nvir:].reshape(nocc, nvir)
-                                for x in self.vector_components])
-
-            # Number of vector components
-            dof = exc_vec.shape[0]
-
-            # Construct plus/minus combinations of excitation and de-excitation part
-            xpy = exc_vec + deexc_vec
-            xmy = exc_vec - deexc_vec
-
-            # Transform the vectors to the AO basis
-            xpy_ao = np.einsum('mi,xia,na->xmn', mo_occ, xpy, mo_vir)
-            xmy_ao = np.einsum('mi,xia,na->xmn', mo_occ, xmy, mo_vir)
-
-            # Turn them into a list (for AODensityMatrix)
-            xpmy_ao_list = list(xpy_ao) + list(xmy_ao)
-
-            # Calcuate the symmetrized unrelaxed one-particle density matrix in MO basis
-            dm_oo = -0.25 * ( np.einsum('xja,yia->xyij', xpy, xpy) + np.einsum('xja,yia->xyij', xmy, xmy)
-                             +np.einsum('yja,xia->xyij', xpy, xpy) + np.einsum('yja,xia->xyij', xmy, xmy)
-                            )
-
-            dm_vv = 0.25 * ( np.einsum('xib,yia->xyab', xpy, xpy) + np.einsum('xib,yia->xyab', xmy, xmy)
-                            +np.einsum('yib,xia->xyab', xpy, xpy) + np.einsum('yib,xia->xyab', xmy, xmy)
-                           )
-
-            # Transform unrelaxed one-particle density matrix to the AO basis and to list
-            unrel_dm_ao = np.einsum('mi,xyij,nj->xymn', mo_occ, dm_oo, mo_occ) + np.einsum('ma,xyab,nb->xymn', mo_vir, dm_vv, mo_vir)
-            dm_ao_list = list(unrel_dm_ao.reshape(dof**2, nao, nao))
-
-            # 2) Construct the right-hand side
-            dm_ao_rhs = AODensityMatrix(dm_ao_list + xpmy_ao_list, denmat.rest)
-
-            if self.dft:
-                # 3) Construct density matrices for E[3] term:
-                # XCIntegrator expects a DM with real and imaginary part,
-                # so we set the imaginary part to zero.
-                # Create lists with the corresponding vector components
-                perturbed_dm_ao_list = []
-                zero_dm_ao_list = []
-                for x in range(dof):
-                    for y in range(dof): # TODO: only upper triangular matrix and transpose?
-                        perturbed_dm_ao_list.extend([xmy_ao[x], 0*xpy_ao[x], xmy_ao[y], 0*xpy_ao[y]])
-                        zero_dm_ao_list.extend([0*xpy_ao[x], 0*xpy_ao[y]])
-
-                perturbed_dm_ao = AODensityMatrix(perturbed_dm_ao_list, denmat.rest)
-
-                # corresponds to rho^{omega_b,omega_c} in quadratic response,
-                # which is zero for orbital response
-                zero_dm_ao = AODensityMatrix(zero_dm_ao_list, denmat.rest)
-        else:
-            dm_ao_rhs = AODensityMatrix()
-            if self.dft:
-                perturbed_dm_ao = AODensityMatrix()
-                zero_dm_ao =  AODensityMatrix()
-
-        dm_ao_rhs.broadcast(self.rank, self.comm)
-
-        molgrid = dft_dict['molgrid']
-        gs_density = dft_dict['gs_density']
-
-        # Fock matrices with corresponding type
-        fock_ao_rhs = AOFockMatrix(dm_ao_rhs)
-        # Set the vector-related components to general Fock matrix (not 1PDM part)
-        for ifock in range(dof**2, dof**2 + 2 * dof):
-            fock_ao_rhs.set_fock_type(fockmat.rgenjk, ifock)
-        if self.dft:
-            perturbed_dm_ao.broadcast(self.rank, self.comm)
-            zero_dm_ao.broadcast(self.rank, self.comm)
-            # Fock matrix for computing the DFT E[3] term g^xc
-            fock_gxc_ao = AOFockMatrix(zero_dm_ao)
-            if self.xcfun.is_hybrid():
-                fact_xc = self.xcfun.get_frac_exact_exchange()
-                for ifock in range(fock_ao_rhs.number_of_fock_matrices()):
-                    fock_ao_rhs.set_scale_factor(fact_xc, ifock)
-                for ifock in range(fock_gxc_ao.number_of_fock_matrices()):
-                    fock_gxc_ao.set_scale_factor(fact_xc, ifock)
-                    fock_gxc_ao.set_fock_type(fockmat.rgenjkx, ifock)
-                for ifock in range(dof**2):
-                    fock_ao_rhs.set_fock_type(fockmat.restjkx, ifock)
-                for ifock in range(dof**2, dof**2 + 2 * dof):
-                    fock_ao_rhs.set_fock_type(fockmat.rgenjkx, ifock)
-            else:
-                for ifock in range(dof**2):
-                    fock_ao_rhs.set_fock_type(fockmat.restj, ifock)
-                for ifock in range(dof**2, dof**2 + 2 * dof):
-                    fock_ao_rhs.set_fock_type(fockmat.rgenj, ifock)
-                for ifock in range(fock_gxc_ao.number_of_fock_matrices()):
-                    fock_gxc_ao.set_fock_type(fockmat.rgenj, ifock)
-        else:
-            fock_gxc_ao = None # None if not DFT
-
-        eri_drv = ElectronRepulsionIntegralsDriver(self.comm)
-        screening = eri_drv.compute(get_qq_scheme(self.qq_type),
-                                    self.eri_thresh, molecule, basis)
-
-        eri_drv.compute(fock_ao_rhs, dm_ao_rhs, molecule, basis, screening)
-        if self.dft:
-            if not self.xcfun.is_hybrid():
-                for ifock in range(fock_ao_rhs.number_of_fock_matrices()):
-                    fock_ao_rhs.scale(2.0, ifock)
-                for ifock in range(fock_gxc_ao.number_of_fock_matrices()):
-                    fock_gxc_ao.scale(2.0, ifock)
-            xc_drv = XCIntegrator(self.comm)
-            molgrid.distribute(self.rank, self.nodes, self.comm)
-            # Linear response routine for f^xc
-            xc_drv.integrate(fock_ao_rhs, dm_ao_rhs, gs_density,
-                             molecule, basis, molgrid, self.xcfun.get_func_label())
-            # Quadratic response routine for TDDFT E[3] term g^xc
-            xc_drv.integrate(fock_gxc_ao, perturbed_dm_ao, zero_dm_ao,
-                             gs_density, molecule, basis, molgrid,
-                             self.xcfun.get_func_label(), "quadratic")
-
-            fock_gxc_ao.reduce_sum(self.rank, self.nodes, self.comm)
-
-        fock_ao_rhs.reduce_sum(self.rank, self.nodes, self.comm)
-
-        # Calculate the RHS and transform it to the MO basis
-        if self.rank == mpi_master():
-            # extract the 1PDM contributions
-            fock_ao_rhs_1dm = np.zeros((dof**2, nao, nao))
-            for i in range(dof**2):
-                fock_ao_rhs_1dm[i] = fock_ao_rhs.alpha_to_numpy(i)
-
-            # Transform to MO basis
-            fock_mo_rhs_1dm = np.einsum('mi,xmn,na->xia', mo_occ, fock_ao_rhs_1dm, mo_vir)
-
-            # extract the xpy and xmy contributions
-            fock_ao_rhs_xpy = np.zeros((dof, nao, nao))
-            fock_ao_rhs_xmy = np.zeros((dof, nao, nao))
-            for i in range(dof):
-                fock_ao_rhs_xpy[i] = fock_ao_rhs.alpha_to_numpy(dof**2 + i)
-                fock_ao_rhs_xmy[i] = fock_ao_rhs.alpha_to_numpy(dof**2 + dof + i)
-
-            # Contract with the second vector
-            sdp_pds = 0.5 * (
-                     np.einsum('mr,xrp,ypz->xymz', ovlp, xpy_ao, fock_ao_rhs_xpy)
-                    +np.einsum('mr,xrp,ypz->xymz', ovlp, xmy_ao, fock_ao_rhs_xmy)
-                    -np.einsum('rz,xpr,ypm->xymz', ovlp, xpy_ao, fock_ao_rhs_xpy)
-                    -np.einsum('rz,xpr,ypm->xymz', ovlp, xmy_ao, fock_ao_rhs_xmy)
-                    -np.einsum('mr,xrp,yzp->xymz', ovlp, xpy_ao, fock_ao_rhs_xpy)
-                    +np.einsum('mr,xrp,yzp->xymz', ovlp, xmy_ao, fock_ao_rhs_xmy)
-                    +np.einsum('rz,xpr,ymp->xymz', ovlp, xpy_ao, fock_ao_rhs_xpy)
-                    -np.einsum('rz,xpr,ymp->xymz', ovlp, xmy_ao, fock_ao_rhs_xmy)
-                )
-
-            # Symmetrize wrt. Cartesian components
-            sdp_pds_sym = 0.5 * (sdp_pds + sdp_pds.transpose(1,0,2,3))
-
-            # Transform 2PDM contributions to MO basis
-            fock_mo_rhs_2dm = np.einsum('mi,xymn,na->xyia', mo_occ, sdp_pds_sym, mo_vir).reshape(dof**2, nocc, nvir)
-
-            # Calculate the dipole contributions to the RHS:
-            # Dipole integrals in AO basis
-            dipole_drv = ElectricDipoleIntegralsDriver(self.comm)
-            dipole_mats = dipole_drv.compute(molecule, basis)
-            dipole_ints_ao = np.zeros((dof, nao, nao))
-            k = 0
-            if 'x' in self.vector_components:
-                dipole_ints_ao[k] = dipole_mats.x_to_numpy()
-                k += 1
-            if 'y' in self.vector_components:
-                dipole_ints_ao[k] = dipole_mats.y_to_numpy()
-                k += 1
-            if 'z' in self.vector_components:
-                dipole_ints_ao[k] = dipole_mats.z_to_numpy()
-
-            # Transform them to MO basis (oo and vv blocks only)
-            dipole_ints_oo = np.array([np.linalg.multi_dot([mo_occ.T, dipole_ints_ao[x], mo_occ]) for x in range(dof)])
-            dipole_ints_vv = np.array([np.linalg.multi_dot([mo_vir.T, dipole_ints_ao[x], mo_vir]) for x in range(dof)])
-
-            # Contract with vectors to get dipole contribution to the RHS
-            rhs_dipole_contrib = 0.5 * ( np.einsum('xja,yji->xyia', xmy, dipole_ints_oo)
-                                        +np.einsum('yja,xji->xyia', xmy, dipole_ints_oo)
-                                        -np.einsum('xib,yab->xyia', xmy, dipole_ints_vv)
-                                        -np.einsum('yib,xab->xyia', xmy, dipole_ints_vv)
-                                       ).reshape(dof**2, nocc, nvir)
-
-            rhs_mo = fock_mo_rhs_1dm + fock_mo_rhs_2dm + rhs_dipole_contrib
-
-            # Add DFT E[3] contribution to the RHS:
-            if self.dft:
-                gxc_ao = np.zeros((dof**2, nao, nao))
-
-                for i in range(dof**2):
-                    gxc_ao[i] = fock_gxc_ao.alpha_to_numpy(2*i)
-
-                gxc_mo = np.einsum('mi,xmn,na->xia', mo_occ, gxc_ao, mo_vir)
-                # different factor compared to TDDFT orbital response because here vectors are scaled by 1/sqrt(2)
-                rhs_mo += 0.5 * gxc_mo
-
-        self.profiler.stop_timer('RHS')
-
-        if self.rank == mpi_master():
-            return {
-                'cphf_rhs': rhs_mo,
-                'dm_oo': dm_oo,
-                'dm_vv': dm_vv,
-                'xpy_ao': xpy_ao,
-                'xmy_ao': xmy_ao,
-                'unrel_dm_ao': unrel_dm_ao,
-                'fock_ao_rhs': fock_ao_rhs,
-                'fock_gxc_ao': fock_gxc_ao, # None if not DFT
-            }
-        else:
-            return {}
-
-    # NOTES:
-    #   - epsilon_dm_ao not returned from cphfsolver, to be calculated inside compute_omega
-    #   - fock_ao_rhs and fock_gxc_ao come from cphfsolver dictionary
-    #   - fock_lambda not returned yet, put in dictionary from cphfsolver (otherwise needs to be recalculated)
-    def compute_omega(self, molecule, basis, scf_tensors, lr_results):
-        """
-        Calculates the polarizability Lagrange multipliers for the overlap matrix.
-
-        :param molecule:
-            The molecule.
-        :param basis:
-            The AO basis set.
-        :param scf_tensors:
-            The tensors from the converged SCF calculation.
-        :param lr_results:
-            The results from the linear response calculation.
-        """
-
-        # ERI information
-        eri_dict = self.init_eri(molecule, basis)
-        # DFT information
-        dft_dict = self.init_dft(molecule, scf_tensors)
-        # PE information
-        pe_dict = self.init_pe(molecule, basis)
-
-        if self.rank == mpi_master():
-
-            # Get overlap, MO coefficients from scf_tensors
-            ovlp = scf_tensors['S']
-            nocc = molecule.number_of_alpha_electrons()
-            mo = scf_tensors['C']
-            mo_occ = mo[:, :nocc]
-            mo_vir = mo[:, nocc:]
-            nocc = mo_occ.shape[1]
-            nvir = mo_vir.shape[1]
-            nao = mo_occ.shape[0]
-
-            mo_energies = scf_tensors['E']
-            eocc = mo_energies[:nocc]
-            evir = mo_energies[nocc:]
-            eo_diag = np.diag(eocc)
-            ev_diag = np.diag(evir)
-
-            # Get fock matrices from cphf_results
-            fock_ao_rhs = self.cphf_results['fock_ao_rhs']
-            dm_oo = self.cphf_results['dm_oo']
-            dm_vv = self.cphf_results['dm_vv']
-            cphf_ov = self.cphf_results['cphf_ov']
-
-            # TODO: do we keep this factor like that?
-            sqrt2 = np.sqrt(2.0)
-
-            # Take response vectors and convert to matrix form
-            exc_vec = 1/sqrt2 * np.array([lr_results['solutions'][x,
-                                    self.frequency][:nocc * nvir].reshape(nocc, nvir)
-                                    for x in self.vector_components])
-            deexc_vec = 1/sqrt2 * np.array([lr_results['solutions'][x,
-                                    self.frequency][nocc * nvir:].reshape(nocc, nvir)
-                                    for x in self.vector_components])
-
-            # Number of vector components
-            dof = exc_vec.shape[0]
-
-            xpy = exc_vec + deexc_vec
-            xmy = exc_vec - deexc_vec
-
-
-            # Get dipole moment integrals and transform to MO
-            dipole_drv = ElectricDipoleIntegralsDriver(self.comm)
-            dipole_mats = dipole_drv.compute(molecule, basis)
-            dipole_ints_ao = np.zeros((dof, nao, nao))
-            k = 0
-            if 'x' in self.vector_components:
-                dipole_ints_ao[k] = dipole_mats.x_to_numpy()
-                k += 1
-            if 'y' in self.vector_components:
-                dipole_ints_ao[k] = dipole_mats.y_to_numpy()
-                k += 1
-            if 'z' in self.vector_components:
-                dipole_ints_ao[k] = dipole_mats.z_to_numpy()
-
-                # Transform them to MO basis (oo and ov blocks only)
-            dipole_ints_oo = np.array([np.linalg.multi_dot([mo_occ.T, dipole_ints_ao[x], mo_occ]) for x in range(dof)])
-            dipole_ints_ov = np.array([np.linalg.multi_dot([mo_occ.T, dipole_ints_ao[x], mo_vir]) for x in range(dof)])
-
-
-            # TODO: remove commented out code
-            #exc_vec = rpa_results['eigenvectors'][:nocc * nvir, self.state_deriv_index]
-            #deexc_vec = rpa_results['eigenvectors'][nocc * nvir:,
-            #                                        self.state_deriv_index]
-            #exc_vec = exc_vec.reshape(nocc, nvir).copy()
-            #deexc_vec = deexc_vec.reshape(nocc, nvir).copy()
-
-            # Calculate the dipole moment integrals' contribution to omega
-            dipole_ints_contrib_oo = -0.5 * ( np.einsum('xjc,yic->xyij',
-                                                xmy, dipole_ints_ov)
-                                            +  np.einsum('yjc,xic->xyij',
-                                                xmy, dipole_ints_ov)
-                                            )
-            dipole_ints_contrib_ov = -0.5 * ( np.einsum('xka,yki->xyia',
-                                                xmy, dipole_ints_oo)
-                                            +  np.einsum('yka,xki->xyia',
-                                                xmy, dipole_ints_oo)
-                                            )
-
-            dipole_ints_contrib_vv = -0.5 * ( np.einsum('xkb,yka->xyab',
-                                                xmy, dipole_ints_ov)
-                                            +  np.einsum('ykb,xka->xyab',
-                                                xmy, dipole_ints_ov)
-                                            )
-            dipole_ints_contrib_ao = ( np.einsum('mi,xyij,nj->xymn', mo_occ,
-                                                 dipole_ints_contrib_oo, mo_occ)
-                                     + np.einsum('mi,xyia,na->xymn', mo_occ,
-                                                 dipole_ints_contrib_ov, mo_vir)
-                                     + np.einsum('mi,xyia,na->xymn', mo_occ,
-                                                 dipole_ints_contrib_ov, mo_vir).transpose(0,1,3,2)
-                                     + np.einsum('ma,xyab,nb->xymn', mo_vir,
-                                                 dipole_ints_contrib_vv, mo_vir)
-                                     )
-
-            # TODO: remove commented out code
-            #xpy_ao = np.linalg.multi_dot([mo_occ, xpy, mo_vir.T])
-            #xmy_ao = np.linalg.multi_dot([mo_occ, xmy, mo_vir.T])
-
-            # Transform the vectors to the AO basis
-            xpy_ao = np.einsum('mi,xia,na->xmn', mo_occ, xpy, mo_vir)
-            xmy_ao = np.einsum('mi,xia,na->xmn', mo_occ, xmy, mo_vir)
-
-            # The density matrix; only alpha block;
-            # Only works for the restricted case
-            # (since scf_tensors['C'] only gives alpha block...)
-            D_occ = np.matmul(mo_occ, mo_occ.T)
-            D_vir = np.matmul(mo_vir, mo_vir.T)
-
-            # Construct fock_lambda (or fock_cphf)
-            cphf_ao = np.einsum('mi,xia,na->xmn', mo_occ, cphf_ov, mo_vir)
-            cphf_ao_list = list([cphf_ao[x] for x in range(dof**2)])
-            ao_density_cphf = AODensityMatrix(cphf_ao_list, denmat.rest)
-            fock_cphf = AOFockMatrix(ao_density_cphf)
-		# TODO: what has to be on MPI master and what not?
-        self.comp_lr_fock(fock_cphf, ao_density_cphf, molecule,
-                          basis, eri_dict, dft_dict, pe_dict, self.profiler)
-
-        # TODO: replace for-loops with np.einsum
-        # For now we:
-        # - loop over indices m and n
-        # - select component m or n in xpy, xmy, fock_ao_rhs and fock_lambda
-        # - symmetrize with respect to m and n (only 2PDM?)
-        # Notes: fock_ao_rhs is a list with dof**2 matrices corresponding to
-        # the contraction of the 1PDMs with eris; dof matrices corresponding
-        # to the contraction of xpy; and other dof matrices corresponding to
-        # the contraction of xmy.
-
-        # TODO: what shape should we use: (dof**2, nao, nao) or (dof, dof, nao, nao)?
-        omega = np.zeros((dof*dof, nao, nao))
-        omega_epsilon_dm = np.zeros((dof, dof, nao, nao))
-        omega_pdms = np.zeros((dof, dof, nao, nao))
-
-        for m in range(dof):
-            for n in range(dof):
-                # Construct epsilon_dm_ao
-                epsilon_dm_ao = np.linalg.multi_dot(
-                    [mo_occ,
-                     np.matmul(eo_diag, 0.5 * dm_oo[m,n]), mo_occ.T])
-                epsilon_dm_ao += np.linalg.multi_dot(
-                    [mo_vir, np.matmul(ev_diag, 0.5 * dm_vv[m,n]), mo_vir.T])
-
-                epsilon_cphf_ao = np.linalg.multi_dot(
-                    [mo_occ,
-                     np.matmul(eo_diag, cphf_ov[dof*m+n]), mo_vir.T])
-                epsilon_dm_ao += epsilon_cphf_ao + epsilon_cphf_ao.T
-
-                # Because the excitation vector is not symmetric,
-                # we need both the matrix (OO block in omega, and probably VO)
-                # and its transpose (VV, OV blocks)
-                # this comes from the transformation of the 2PDM contribution
-                # from MO to AO basis
-                fock_ao_rhs_1_m = fock_ao_rhs.alpha_to_numpy(dof**2+m)  # xpy
-                fock_ao_rhs_2_m = fock_ao_rhs.alpha_to_numpy(dof**2+dof+m)  # xmy
-
-                fock_ao_rhs_1_n = fock_ao_rhs.alpha_to_numpy(dof**2+n)  # xpy
-                fock_ao_rhs_2_n = fock_ao_rhs.alpha_to_numpy(dof**2+dof+n)  # xmy
-
-                Fp1_vv = 0.25 * (  np.linalg.multi_dot([ fock_ao_rhs_1_m.T, xpy_ao[n], ovlp.T])
-                                 + np.linalg.multi_dot([ fock_ao_rhs_1_n.T, xpy_ao[m], ovlp.T]) )
-
-                Fm1_vv = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_2_m.T, xmy_ao[n], ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_2_n.T, xmy_ao[m], ovlp.T]) )
-
-
-                Fp2_vv = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_1_m, xpy_ao[n], ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_1_n, xpy_ao[m], ovlp.T]) )
-
-                Fm2_vv = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_2_m, xmy_ao[n], ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_2_n, xmy_ao[m], ovlp.T]) )
-
-
-                # Fp1_ov = np.linalg.multi_dot([0.5 * fock_ao_rhs_1.T, xpy_ao, ovlp.T])
-                # Fm1_ov = np.linalg.multi_dot([0.5 * fock_ao_rhs_2.T, xmy_ao, ovlp.T])
-                # Fp2_ov = np.linalg.multi_dot([0.5 * fock_ao_rhs_1, xpy_ao, ovlp.T])
-                # Fm2_ov = np.linalg.multi_dot([0.5 * fock_ao_rhs_2, xmy_ao, ovlp.T])
-
-                Fp1_oo = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_1_m, xpy_ao[n].T, ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_1_n, xpy_ao[m].T, ovlp.T]) )
-
-                Fm1_oo = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_2_m, xmy_ao[n].T, ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_2_n, xmy_ao[m].T, ovlp.T]) )
-
-                Fp2_oo = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_1_m.T, xpy_ao[n].T, ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_1_n.T, xpy_ao[m].T, ovlp.T]) )
-
-                Fm2_oo = 0.25 * ( np.linalg.multi_dot([fock_ao_rhs_2_m.T, xmy_ao[n].T, ovlp.T])
-                                + np.linalg.multi_dot([fock_ao_rhs_2_n.T, xmy_ao[m].T, ovlp.T]) )
-                # We see that:
-                # Fp1_vv = Fp1_ov and Fm1_vv = Fm1_ov
-                # Fp2_vv = Fp2_ov and Fm2_vv = Fm2_ov
-
-                # Compute the contributions from the 2PDM and the relaxed 1PDM
-                # to the omega Lagrange multipliers:
-                fmat = (fock_cphf.alpha_to_numpy(m*dof+n) +
-                        fock_cphf.alpha_to_numpy(m*dof+n).T +
-                        0.5 * fock_ao_rhs.alpha_to_numpy(m*dof+n))
-                # dof=3  (0,0), (0,1), (0,2); (1,0), (1,1), (1,2), (2,0), (2,1), (2,2) * dof gamma_{zx} =
-
-                omega_1pdm_2pdm_contribs = 1.0 * ( 0.5 *(
-                    np.linalg.multi_dot([D_vir, Fp1_vv + Fm1_vv - Fp2_vv + Fm2_vv, D_vir])
-                  + np.linalg.multi_dot([D_occ, Fp1_vv + Fm1_vv - Fp2_vv + Fm2_vv, D_vir])
-                  + np.linalg.multi_dot([D_occ, Fp1_vv + Fm1_vv - Fp2_vv + Fm2_vv, D_vir]).T
-                  + np.linalg.multi_dot([D_occ, Fp1_oo + Fm1_oo - Fp2_oo + Fm2_oo, D_occ]))
-                  + 1 * np.linalg.multi_dot([D_occ, fmat, D_occ]))
-
-                omega_epsilon_dm[m,n] = -2.0 * epsilon_dm_ao
-                omega_pdms[m,n] = - 2.0 * omega_1pdm_2pdm_contribs
-                omega[m*dof+n] = - 1.0 * epsilon_dm_ao - 1.0 * omega_1pdm_2pdm_contribs + 1.0 * dipole_ints_contrib_ao[m,n]
-
-        self.cphf_results['omega_epsilon_dm'] = omega_epsilon_dm
-        self.cphf_results['omega_pdms'] = omega_pdms
-        self.cphf_results['omega_dipole_contrib'] = -1.0 * dipole_ints_contrib_ao
-        self.cphf_results['dipole_ints_contrib_oo'] = dipole_ints_contrib_oo
-        self.cphf_results['dipole_ints_contrib_ov'] = dipole_ints_contrib_ov
-        self.cphf_results['dipole_ints_contrib_vv'] = dipole_ints_contrib_vv
-        # add omega multipliers in AO basis to cphf_results dictionary
-        self.cphf_results['omega_ao'] = 1*omega
-
-    def print_cphf_header(self, title):
-        self.ostream.print_blank()
-        self.ostream.print_header('{:s} Setup'.format(title))
-        self.ostream.print_header('=' * (len(title) + 8))
-        self.ostream.print_blank()
-
-        str_width = 70
-
-        # print general info
-        cur_str = 'Solver Type                     : '
-        if self.use_subspace_solver:
-            cur_str += 'Iterative Subspace Algorithm'
-        else:
-            cur_str += 'Conjugate Gradient'
-        self.ostream.print_header(cur_str.ljust(str_width))
-
-        cur_str = 'Max. Number of Iterations       : ' + str(self.max_iter)
-        self.ostream.print_header(cur_str.ljust(str_width))
-        cur_str = 'Convergence Threshold           : {:.1e}'.format(
-            self.conv_thresh)
-        self.ostream.print_header(cur_str.ljust(str_width))
-
-        cur_str = 'Frequency                       : {:.5f}'.format(self.frequency)
-        self.ostream.print_header(cur_str.ljust(str_width))
-
-        cur_str = 'Vector components               : ' + self.vector_components
-        self.ostream.print_header(cur_str.ljust(str_width))
-
-        self.ostream.print_blank()
-        self.ostream.flush()
diff --git a/src/pymodule/rpaorbitalresponse.py b/src/pymodule/rpaorbitalresponse.py
index e61061c3..0e1f3ca4 100644
--- a/src/pymodule/rpaorbitalresponse.py
+++ b/src/pymodule/rpaorbitalresponse.py
@@ -115,22 +115,8 @@ class RpaOrbitalResponse(OrbitalResponse):
             # 2) Construct the right-hand side
             dm_ao_rhs = AODensityMatrix([unrel_dm_ao, xpy_ao, xmy_ao],
                                         denmat.rest)
-            if self.dft:
-                # 3) Construct density matrices for E[3] term:
-                # XCIntegrator expects a DM with real and imaginary part,
-                # so we set the imaginary part to zero.
-                perturbed_dm_ao = AODensityMatrix([xmy_ao, 0*xpy_ao, xmy_ao, 0*xmy_ao],
-                                                   denmat.rest)
-
-                # corresponds to rho^{omega_b,omega_c} in quadratic response,
-                # which is zero for TDDFT orbital response
-                zero_dm_ao = AODensityMatrix([0*xpy_ao, 0*xpy_ao],
-                                              denmat.rest)
         else:
             dm_ao_rhs = AODensityMatrix()
-            if self.dft:
-                perturbed_dm_ao = AODensityMatrix()
-                zero_dm_ao =  AODensityMatrix()
 
         dm_ao_rhs.broadcast(self.rank, self.comm)
 
@@ -139,32 +125,21 @@ class RpaOrbitalResponse(OrbitalResponse):
 
         # Fock matrices with corresponding type
         fock_ao_rhs = AOFockMatrix(dm_ao_rhs)
+		# TODO: these types probably need to be changed for DFT
         fock_ao_rhs.set_fock_type(fockmat.rgenjk, 1)
         fock_ao_rhs.set_fock_type(fockmat.rgenjk, 2)
         if self.dft:
-            perturbed_dm_ao.broadcast(self.rank, self.comm)
-            zero_dm_ao.broadcast(self.rank, self.comm)
-            # Fock matrix for computing the TDDFT E[3] term g^xc
-            fock_gxc_ao = AOFockMatrix(zero_dm_ao)
             if self.xcfun.is_hybrid():
                 fact_xc = self.xcfun.get_frac_exact_exchange()
                 for ifock in range(fock_ao_rhs.number_of_fock_matrices()):
                     fock_ao_rhs.set_scale_factor(fact_xc, ifock)
-                for ifock in range(fock_gxc_ao.number_of_fock_matrices()):
-                    fock_gxc_ao.set_scale_factor(fact_xc, ifock)
                 fock_ao_rhs.set_fock_type(fockmat.restjkx, 0)
                 fock_ao_rhs.set_fock_type(fockmat.rgenjkx, 1)
                 fock_ao_rhs.set_fock_type(fockmat.rgenjkx, 2)
-                fock_gxc_ao.set_fock_type(fockmat.rgenjkx, 0)
-                fock_gxc_ao.set_fock_type(fockmat.rgenjkx, 1)
             else:
                 fock_ao_rhs.set_fock_type(fockmat.restj, 0)
                 fock_ao_rhs.set_fock_type(fockmat.rgenj, 1)
                 fock_ao_rhs.set_fock_type(fockmat.rgenj, 2)
-                fock_gxc_ao.set_fock_type(fockmat.rgenj, 0)
-                fock_gxc_ao.set_fock_type(fockmat.rgenj, 1)
-        else:
-            fock_gxc_ao = None # None if not DFT
 
         eri_drv = ElectronRepulsionIntegralsDriver(self.comm)
         screening = eri_drv.compute(get_qq_scheme(self.qq_type),
@@ -172,22 +147,18 @@ class RpaOrbitalResponse(OrbitalResponse):
 
         eri_drv.compute(fock_ao_rhs, dm_ao_rhs, molecule, basis, screening)
         if self.dft:
+            #t0 = tm.time()
             if not self.xcfun.is_hybrid():
                 for ifock in range(fock_ao_rhs.number_of_fock_matrices()):
                     fock_ao_rhs.scale(2.0, ifock)
-                for ifock in range(fock_gxc_ao.number_of_fock_matrices()):
-                    fock_gxc_ao.scale(2.0, ifock)
             xc_drv = XCIntegrator(self.comm)
             molgrid.distribute(self.rank, self.nodes, self.comm)
-            # Linear response routine for f^xc
             xc_drv.integrate(fock_ao_rhs, dm_ao_rhs, gs_density,
                              molecule, basis, molgrid, self.xcfun.get_func_label())
-            # Quadratic response routine for TDDFT E[3] term g^xc
-            xc_drv.integrate(fock_gxc_ao, perturbed_dm_ao, zero_dm_ao,
-                             gs_density, molecule, basis, molgrid,
-                             self.xcfun.get_func_label(), "quadratic")
+            #if timing_dict is not None:
+            #    timing_dict['DFT'] = tm.time() - t0
 
-            fock_gxc_ao.reduce_sum(self.rank, self.nodes, self.comm)
+		    # TODO: The DFT E[3] term is missing here!!
 
         fock_ao_rhs.reduce_sum(self.rank, self.nodes, self.comm)
 
@@ -214,12 +185,6 @@ class RpaOrbitalResponse(OrbitalResponse):
             rhs_mo = fmo_rhs_1dm + np.linalg.multi_dot(
                 [mo_occ.T, sdp_pds, mo_vir])
 
-            # Add TDDFT E[3] contribution to the RHS:
-            if self.dft:
-                gxc_ao = fock_gxc_ao.alpha_to_numpy(0)
-                gxc_mo = np.linalg.multi_dot([mo_occ.T, gxc_ao, mo_vir])
-                rhs_mo += 0.25 * gxc_mo
-
         profiler.stop_timer('RHS')
 
         if self.rank == mpi_master():
@@ -231,13 +196,12 @@ class RpaOrbitalResponse(OrbitalResponse):
                 'xmy_ao': xmy_ao,
                 'unrel_dm_ao': unrel_dm_ao,
                 'fock_ao_rhs': fock_ao_rhs,
-                'fock_gxc_ao': fock_gxc_ao, # None if not DFT
             }
         else:
             return {}
 
     def compute_omega(self, ovlp, mo_occ, mo_vir, epsilon_dm_ao, rpa_results,
-                      fock_ao_rhs, fock_lambda, fock_gxc_ao):
+                      fock_ao_rhs, fock_lambda):
         """
         Calculates the RPA Lagrange multipliers for the overlap matrix.
 
@@ -255,8 +219,6 @@ class RpaOrbitalResponse(OrbitalResponse):
             The AOFockMatrix from the right-hand side of the orbital response eq.
         :param fock_lambda:
             The Fock matrix from Lagrange multipliers.
-        :param fock_gxc_ao:
-            The AOFockMatrix from the E[3] xc contribution (None if not DFT).
 
         :return:
             a numpy array containing the Lagrange multipliers in AO basis.
diff --git a/src/pymodule/scfdriver.py b/src/pymodule/scfdriver.py
index cd877fc5..5b5935c8 100644
--- a/src/pymodule/scfdriver.py
+++ b/src/pymodule/scfdriver.py
@@ -832,10 +832,8 @@ class ScfDriver:
             # the numerical gradient.
             if self.dft:
                 xc_energy = vxc_mat.get_energy()
-                #vxc_mat_np = vxc_mat #.alpha_to_numpy(0)
             else:
                 xc_energy = 0
-                vxc_mat = None
 
             self.scf_tensors = {
                 'C': C_alpha,
@@ -852,7 +850,6 @@ class ScfDriver:
                 'F_alpha': F_alpha,
                 'F_beta': F_beta,
                 'xc_energy': xc_energy, # TODO: remove after analytical xc derivative works.
-                'vxc_mat': vxc_mat, # TODO: remove after analytical xc derivatives work.
             }
 
             if self.is_converged:
diff --git a/src/pymodule/scfgradientdriver.py b/src/pymodule/scfgradientdriver.py
index 877c9b38..99915e51 100644
--- a/src/pymodule/scfgradientdriver.py
+++ b/src/pymodule/scfgradientdriver.py
@@ -1,3 +1,4 @@
+
 #
 #                           VELOXCHEM 1.0-RC2
 #         ----------------------------------------------------
@@ -38,8 +39,7 @@ from .veloxchemlib import mpi_master
 from .import_from_pyscf import overlap_deriv
 from .import_from_pyscf import fock_deriv
 from .import_from_pyscf import eri_deriv
-from .import_from_pyscf import hcore_deriv
-from .import_from_pyscf import vxc_deriv
+
 
 class ScfGradientDriver(GradientDriver):
     """
@@ -75,8 +75,8 @@ class ScfGradientDriver(GradientDriver):
         self.delta_h = 0.001
 
         # Flag for numerical derivative of dipole moment
-        # self.dipole_deriv = False
-        # self.dipole_gradient = None
+        self.dipole_deriv = False
+        self.dipole_gradient = None
 
     def update_settings(self, grad_dict, method_dict):
         """
@@ -103,8 +103,7 @@ class ScfGradientDriver(GradientDriver):
         :param min_basis:
             The minimal AO basis set.
         """
-        if self.rank == mpi_master():
-            self.print_header()
+        self.print_header()
 
         start_time = tm.time()
 
@@ -147,39 +146,22 @@ class ScfGradientDriver(GradientDriver):
 
             # analytical gradient
             self.gradient = np.zeros((natm, 3))
-            # exc_gradient = np.zeros((natm, 3))
 
             for i in range(natm):
                 d_ovlp = overlap_deriv(molecule, ao_basis, i)
-                #d_fock = fock_deriv(molecule, ao_basis, one_pdm_ao, i) #TODO: remove
-                d_hcore = hcore_deriv(molecule, ao_basis, i)
+                d_fock = fock_deriv(molecule, ao_basis, one_pdm_ao, i)
                 d_eri = eri_deriv(molecule, ao_basis, i)
 
-                self.gradient[i] = ( 2.0 * np.einsum('mn,xmn->x', one_pdm_ao, d_hcore)
-                                + 2.0 * np.einsum('mn,xmn->x', epsilon_dm_ao, d_ovlp)
-                                )
-                if self.dft:
-                    d_vxc = vxc_deriv(molecule, ao_basis, one_pdm_ao,
-                                      self.xcfun.get_func_label(), i)
-                    if self.xcfun.is_hybrid():
-                        fact_xc = self.xcfun.get_frac_exact_exchange()
-                    else:
-                        fact_xc = 0
-                    self.gradient[i] += (
-                                + 2.0 * np.einsum('mt,np,xmtnp->x', one_pdm_ao, one_pdm_ao, d_eri)
-                                - fact_xc * np.einsum('mt,np,xmnpt->x', one_pdm_ao, one_pdm_ao, d_eri)
-                                )
-                    self.gradient[i] += 2.0 * np.einsum('mn,xmn->x', one_pdm_ao, d_vxc)
-                else:
-                    self.gradient[i] += (
-                                + 2.0 * np.einsum('mt,np,xmtnp->x', one_pdm_ao, one_pdm_ao, d_eri)
-                                - 1.0 * np.einsum('mt,np,xmnpt->x', one_pdm_ao, one_pdm_ao, d_eri)
+                self.gradient[i] += ( 2.0*np.einsum('mn,xmn->x', one_pdm_ao, d_fock)
+                                +2.0*np.einsum('mn,xmn->x', epsilon_dm_ao, d_ovlp)
+                                -2.0*np.einsum('mt,np,xmtnp->x', one_pdm_ao, one_pdm_ao, d_eri)
+                                +1.0*np.einsum('mt,np,xmnpt->x', one_pdm_ao, one_pdm_ao, d_eri)
                                 )
 
             self.gradient += self.grad_nuc_contrib(molecule)
             self.omega_ao = epsilon_dm_ao #TODO remove again
 
-# TODO: delete commented out code; numerical gradient is now included
+# TODO: delete commeneted out code; numerical gradient is now included
 # in gradientdriver.
 #    def compute_numerical(self, molecule, ao_basis, min_basis=None):
 #        """
@@ -203,16 +185,12 @@ class ScfGradientDriver(GradientDriver):
 #        coords = molecule.get_coordinates()
 #        # the number of atoms
 #        natm = molecule.number_of_atoms()
-#        # the number of atomic orbitals
-#        # nao = self.scf_drv.scf_tensors["D_alpha"].shape[0]
 #
 #        self.gradient = np.zeros((natm, 3))
 #
 #        # Gradient of the exchange and correlation energy
-#        # TODO: remove vxc numerical gradient
 #        if self.dft:
 #            self.xc_gradient = np.zeros((natm, 3))
-#            # self.vxc_gradient = np.zeros((natm, 3, nao, nao))
 #
 #        # First-order properties for gradient of dipole moment
 #        if self.dipole_deriv:
@@ -231,7 +209,6 @@ class ScfGradientDriver(GradientDriver):
 #                    # remove when analytical derivative is working.
 #                    if self.dft:
 #                        xc_plus = self.scf_drv.scf_tensors['xc_energy']
-#                        # vxc_plus = self.scf_drv.scf_tensors['vxc_mat'].get_matrix().to_numpy()
 #
 #                    if self.dipole_deriv:
 #                        prop.compute_scf_prop(new_mol, ao_basis, self.scf_drv.scf_tensors)
@@ -245,7 +222,6 @@ class ScfGradientDriver(GradientDriver):
 #                    # remove when analytical derivative is working.
 #                    if self.dft:
 #                        xc_minus = self.scf_drv.scf_tensors['xc_energy']
-#                        # vxc_minus = self.scf_drv.scf_tensors['vxc_mat'].get_matrix().to_numpy()
 #
 #                    if self.dipole_deriv:
 #                        prop.compute_scf_prop(new_mol, ao_basis, self.scf_drv.scf_tensors)
@@ -260,7 +236,6 @@ class ScfGradientDriver(GradientDriver):
 #                    # remove when analytical derivative is working.
 #                    if self.dft:
 #                        self.xc_gradient[i, d] = (xc_plus - xc_minus) / (2.0 * self.delta_h)
-#                        # self.vxc_gradient[i, d] = (vxc_plus - vxc_minus) / (2.0 * self.delta_h)
 #        else:
 #            # Four-point numerical derivative approximation
 #            # for debugging of analytical gradient:
@@ -318,7 +293,6 @@ class ScfGradientDriver(GradientDriver):
 #        self.scf_drv.compute(molecule, ao_basis, min_basis)
 #        self.scf_drv.ostream.state = scf_ostream_state
 
-
     def init_drivers(self):
         """
         Silence the energy drivers and save the current ostream state.
diff --git a/src/pymodule/scfhessiandriver.py b/src/pymodule/scfhessiandriver.py
index 545a29c4..42741547 100644
--- a/src/pymodule/scfhessiandriver.py
+++ b/src/pymodule/scfhessiandriver.py
@@ -54,7 +54,6 @@ from .import_from_pyscf import eri_deriv
 from .import_from_pyscf import overlap_second_deriv
 from .import_from_pyscf import hcore_second_deriv
 from .import_from_pyscf import eri_second_deriv
-from .import_from_pyscf import dipole_deriv
 
 
 class ScfHessianDriver(HessianDriver):
@@ -72,8 +71,6 @@ class ScfHessianDriver(HessianDriver):
         - scf_drv: The SCF driver.
         - do_raman: Additionally calculate Raman intensities
                 (at significantly higher computational cost).
-        - pople_hessian: Evaluate the Hessian the Pople or
-                the Ahlrichs/Furche way.
     """
 
     def __init__(self, scf_drv, comm=None, ostream=None):
@@ -86,7 +83,7 @@ class ScfHessianDriver(HessianDriver):
         self.flag = 'SCF Hessian Driver'
         self.scf_drv = scf_drv
         self.do_raman = False
-        self.pople_hessian = False
+        self.pople = False
 
         # Solver setup
         self.conv_thresh = 1.0e-4
@@ -121,11 +118,7 @@ class ScfHessianDriver(HessianDriver):
             self.conv_thresh = float(cphf_dict['conv_thresh'])
 
         if 'max_iter' in cphf_dict:
-            self.max_iter = int(cphf_dict['max_iter'])
-
-        if 'pople_hessian' in freq_dict:
-            key = freq_dict['pople_hessian'].lower()
-            self.pople_hessian = True if key in ['yes', 'y'] else False
+            self.max_iter = int(cphf_dict['max_iter']) 
 
         # check if Raman intensities are to be calculated (numerically)
         if 'do_raman' in freq_dict:
@@ -199,7 +192,6 @@ class ScfHessianDriver(HessianDriver):
         nocc = molecule.number_of_alpha_electrons()
         mo_occ = mo[:, :nocc]
         mo_vir = mo[:, nocc:]
-        nvir = mo_vir.shape[1]
         mo_energies = scf_tensors['E']
         eocc = mo_energies[:nocc]
         eoo = eocc.reshape(-1, 1) + eocc #ei+ej
@@ -212,7 +204,7 @@ class ScfHessianDriver(HessianDriver):
 
         # Solve the CPHF equations
         cphf_solution_dict = cphf_solver.compute(molecule, ao_basis, scf_tensors)
-        cphf_ov = cphf_solution_dict['cphf_ov'].reshape(natm, 3, nocc, nvir)
+        cphf_ov = cphf_solution_dict['cphf_ov']
         ovlp_deriv_oo = cphf_solution_dict['ovlp_deriv_oo']
 
         # Calculate the perturbed density matrix
@@ -226,7 +218,7 @@ class ScfHessianDriver(HessianDriver):
                             )
 
         # Parts related to first-order integral derivatives
-        if self.pople_hessian:
+        if self.pople:
             fock_uij = cphf_solution_dict['fock_uij']
             fock_deriv_ao = cphf_solution_dict['fock_deriv_ao']
             fock_deriv_oo = np.einsum('mi,xymn,nj->xyij', mo_occ, fock_deriv_ao, mo_occ)
@@ -237,7 +229,7 @@ class ScfHessianDriver(HessianDriver):
                                               fock_deriv_oo, orben_ovlp_deriv_oo, perturbed_density,
                                               profiler)
         else:
-            cphf_rhs = cphf_solution_dict['cphf_rhs'].reshape(natm, 3, nocc, nvir)
+            cphf_rhs = cphf_solution_dict['cphf_rhs']
             hessian_first_order_derivatives = self.compute_furche(molecule, ao_basis,
                                                          cphf_rhs, -0.5 * ovlp_deriv_oo, cphf_ov,
                                                          profiler)
@@ -1098,19 +1090,45 @@ class ScfHessianDriver(HessianDriver):
             The dipole integral derivatives.
         """
 
+        # atom labels
+        labels = molecule.get_labels()
+
         # number of atoms
         natm = molecule.number_of_atoms()
 
+        # atom coordinates (nx3)
+        coords = molecule.get_coordinates()
+
         # number of atomic orbitals
         nao = self.scf_drv.scf_tensors['D_alpha'].shape[0]
 
+        # Dipole integrals driver
+        dipole_drv = ElectricDipoleIntegralsDriver(self.comm)
+
         # 3 dipole components x No. atoms x 3 atomic coordinates x No. basis x No. basis
         dipole_integrals_gradient = np.zeros((3, natm, 3, nao, nao))
 
+        # smaller delta_h values can be used here
+        local_delta_h = 0.01 * self.delta_h
+
         for i in range(natm):
-            dipole_integrals_gradient[:,i,:,:,:] = (
-                                dipole_deriv(molecule, ao_basis, i)
-                                )
+            for d in range(3):
+                coords[i, d] += local_delta_h
+                new_mol = Molecule(labels, coords, units='au')
+
+                dipole_mats_p = dipole_drv.compute(new_mol, ao_basis)
+                dipole_ints_p = (dipole_mats_p.x_to_numpy(), dipole_mats_p.y_to_numpy(),
+                               dipole_mats_p.z_to_numpy())
+
+                coords[i, d] -= 2.0 * local_delta_h
+                new_mol = Molecule(labels, coords, units='au')
+
+                dipole_mats_m = dipole_drv.compute(new_mol, ao_basis)
+                dipole_ints_m = (dipole_mats_m.x_to_numpy(), dipole_mats_m.y_to_numpy(),
+                               dipole_mats_m.z_to_numpy())
+
+                for c in range(3):
+                    dipole_integrals_gradient[c, i, d] = ( dipole_ints_p[c] - dipole_ints_m[c] ) / (2.0 * local_delta_h)
 
         return dipole_integrals_gradient
 
diff --git a/src/pymodule/shgdriver.py b/src/pymodule/shgdriver.py
index aac826d7..1a45ada0 100644
--- a/src/pymodule/shgdriver.py
+++ b/src/pymodule/shgdriver.py
@@ -39,14 +39,8 @@ from .nonlinearsolver import NonLinearSolver
 from .distributedarray import DistributedArray
 from .firstorderprop import FirstOrderProperties
 from .errorhandler import assert_msg_critical
-from .checkpoint import check_distributed_focks
-from .checkpoint import read_distributed_focks
-from .checkpoint import write_distributed_focks
-from .inputparser import parse_input
-from pathlib import Path
-from .veloxchemlib import XCFunctional
-from .veloxchemlib import XCIntegrator
-from .veloxchemlib import parse_xc_func
+from .checkpoint import (check_distributed_focks, read_distributed_focks,
+                         write_distributed_focks)
 
 
 class SHGDriver(NonLinearSolver):
diff --git a/src/pymodule/tdaorbitalresponse.py b/src/pymodule/tdaorbitalresponse.py
index 5264362e..60c87773 100644
--- a/src/pymodule/tdaorbitalresponse.py
+++ b/src/pymodule/tdaorbitalresponse.py
@@ -105,23 +105,8 @@ class TdaOrbitalResponse(OrbitalResponse):
 
             # 2) Construct the right-hand side
             dm_ao_rhs = AODensityMatrix([unrel_dm_ao, exc_vec_ao], denmat.rest)
-
-            if self.dft:
-                # 3) Construct density matrices for E[3] term:
-                # XCIntegrator expects a DM with real and imaginary part,
-                # so we set the imaginary part to zero.
-                perturbed_dm_ao = AODensityMatrix([exc_vec_ao, 0*exc_vec_ao, exc_vec_ao, 0*exc_vec_ao],
-                                                   denmat.rest)
-
-                # corresponds to rho^{omega_b,omega_c} in quadratic response,
-                # which is zero for TDDFT orbital response
-                zero_dm_ao = AODensityMatrix([0*exc_vec_ao, 0*exc_vec_ao],
-                                              denmat.rest)
         else:
             dm_ao_rhs = AODensityMatrix()
-            if self.dft:
-                perturbed_dm_ao = AODensityMatrix()
-                zero_dm_ao =  AODensityMatrix()
 
         dm_ao_rhs.broadcast(self.rank, self.comm)
 
@@ -131,30 +116,16 @@ class TdaOrbitalResponse(OrbitalResponse):
         # Fock matrices with corresponding type
         fock_ao_rhs = AOFockMatrix(dm_ao_rhs)
         fock_ao_rhs.set_fock_type(fockmat.rgenjk, 1)
-
         if self.dft:
-            perturbed_dm_ao.broadcast(self.rank, self.comm)
-            zero_dm_ao.broadcast(self.rank, self.comm)
-            # Fock matrix for computing gxc
-            fock_gxc_ao = AOFockMatrix(zero_dm_ao)
             if self.xcfun.is_hybrid():
                 fact_xc = self.xcfun.get_frac_exact_exchange()
                 for ifock in range(fock_ao_rhs.number_of_fock_matrices()):
                     fock_ao_rhs.set_scale_factor(fact_xc, ifock)
-                for ifock in range(fock_gxc_ao.number_of_fock_matrices()):
-                    fock_gxc_ao.set_scale_factor(fact_xc, ifock)
                 fock_ao_rhs.set_fock_type(fockmat.restjkx, 0)
                 fock_ao_rhs.set_fock_type(fockmat.rgenjkx, 1)
-                fock_gxc_ao.set_fock_type(fockmat.rgenjkx, 0)
-                fock_gxc_ao.set_fock_type(fockmat.rgenjkx, 1)
             else:
                 fock_ao_rhs.set_fock_type(fockmat.restj, 0)
                 fock_ao_rhs.set_fock_type(fockmat.rgenj, 1)
-                fock_gxc_ao.set_fock_type(fockmat.rgenj, 0)
-                fock_gxc_ao.set_fock_type(fockmat.rgenj, 1)
-        else:
-            fock_gxc_ao = None
-
 
 
         eri_drv = ElectronRepulsionIntegralsDriver(self.comm)
@@ -163,22 +134,18 @@ class TdaOrbitalResponse(OrbitalResponse):
 
         eri_drv.compute(fock_ao_rhs, dm_ao_rhs, molecule, basis, screening)
         if self.dft:
+            #t0 = tm.time()
             if not self.xcfun.is_hybrid():
                 fock_ao_rhs.scale(2.0, 0)
                 fock_ao_rhs.scale(2.0, 1)
-                fock_gxc_ao.scale(2.0, 0)
             xc_drv = XCIntegrator(self.comm)
             molgrid.distribute(self.rank, self.nodes, self.comm)
-            # Linear response routine for f^xc
             xc_drv.integrate(fock_ao_rhs, dm_ao_rhs, gs_density,
-                             molecule, basis, molgrid,
-                             self.xcfun.get_func_label())
-            # Quadratic response routine for TDDFT E[3] term g^xc
-            xc_drv.integrate(fock_gxc_ao, perturbed_dm_ao, zero_dm_ao,
-                             gs_density, molecule, basis, molgrid,
-                             self.xcfun.get_func_label(), "quadratic")
+                             molecule, basis, molgrid, self.xcfun.get_func_label())
+            #if timing_dict is not None:
+            #    timing_dict['DFT'] = tm.time() - t0
 
-            fock_gxc_ao.reduce_sum(self.rank, self.nodes, self.comm)
+		    # TODO: The DFT E[3] term is missing here!!
 
         fock_ao_rhs.reduce_sum(self.rank, self.nodes, self.comm)
 
@@ -197,13 +164,6 @@ class TdaOrbitalResponse(OrbitalResponse):
             rhs_mo = fmo_rhs_0 + np.linalg.multi_dot(
                 [mo_occ.T, sdp_pds, mo_vir])
 
-            # Add DFT E[3] contribution to the RHS:
-            if self.dft:
-                gxc_ao = fock_gxc_ao.alpha_to_numpy(0)
-                gxc_mo = np.linalg.multi_dot([mo_occ.T, gxc_ao, mo_vir])
-                rhs_mo += 0.25 * gxc_mo
-
-
         profiler.stop_timer('RHS')
 
         if self.rank == mpi_master():
@@ -215,13 +175,12 @@ class TdaOrbitalResponse(OrbitalResponse):
                 'xmy_ao': exc_vec_ao,
                 'unrel_dm_ao': unrel_dm_ao,
                 'fock_ao_rhs': fock_ao_rhs,
-                'fock_gxc_ao': fock_gxc_ao, # None if not DFT
             }
         else:
             return {}
 
     def compute_omega(self, ovlp, mo_occ, mo_vir, epsilon_dm_ao, tda_results,
-                      fock_ao_rhs, fock_lambda, fock_gxc_ao):
+                      fock_ao_rhs, fock_lambda):
         """
         Calculates the TDA Lagrange multipliers for the overlap matrix.
 
@@ -239,8 +198,6 @@ class TdaOrbitalResponse(OrbitalResponse):
             The AOFockMatrix from the right-hand side of the orbital response eq.
         :param fock_lambda:
             The Fock matrix from Lagrange multipliers.
-        :param fock_gxc_ao:
-            The AOFockMatrix from the E[3] xc contribution (None if not DFT).
 
         :return:
             a numpy array containing the Lagrange multipliers in AO basis.
@@ -267,7 +224,7 @@ class TdaOrbitalResponse(OrbitalResponse):
         Ft = np.linalg.multi_dot([0.5 * fock_ao_rhs_1.T, exc_vec_ao, ovlp])
         F = np.linalg.multi_dot([0.5 * fock_ao_rhs_1, exc_vec_ao.T, ovlp.T])
 
-        # Compute the contributions from the relaxed 1PDM
+        # Compute the contributions from the 2PDM and the relaxed 1PDM
         # to the omega Lagrange multipliers:
         fmat = (fock_lambda.alpha_to_numpy(0) +
                 fock_lambda.alpha_to_numpy(0).T +
@@ -281,8 +238,4 @@ class TdaOrbitalResponse(OrbitalResponse):
 
         omega = -epsilon_dm_ao - omega_1pdm_2pdm_contribs
 
-        if fock_gxc_ao is not None:
-            factor = -0.25
-            omega += factor * np.linalg.multi_dot([D_occ, fock_gxc_ao.alpha_to_numpy(0), D_occ])
-
         return omega
diff --git a/src/pymodule/tdhfgradientdriver.py b/src/pymodule/tdhfgradientdriver.py
index 88c77201..f3fc55f3 100644
--- a/src/pymodule/tdhfgradientdriver.py
+++ b/src/pymodule/tdhfgradientdriver.py
@@ -86,7 +86,7 @@ class TdhfGradientDriver(GradientDriver):
 
         :param grad_dict:
             The input dictionary of gradient settings group.
-        :param orbrsp_dict:
+        :param orbrsp_dict: 
             The input dictionary of orbital response settings group.
         :param rsp_dict:
             The input dictionary of response settings  group.
@@ -122,7 +122,6 @@ class TdhfGradientDriver(GradientDriver):
         self.method_dict = dict(method_dict)
         self.orbrsp_dict = dict(orbrsp_dict)
 
-    # TODO: add min_basis here??
     def compute(self, molecule, basis, rsp_drv, rsp_results, min_basis=None):
         """
         Performs calculation of analytical or numerical gradient.
@@ -135,6 +134,8 @@ class TdhfGradientDriver(GradientDriver):
             The RPA or TDA driver.
         :param rsp_results:
             The results from the RPA or TDA calculation.
+        :param min_basis:
+            The minimal basis set.
         """
 
         # sanity check for number of state
@@ -156,7 +157,7 @@ class TdhfGradientDriver(GradientDriver):
             # print gradient
             self.print_geometry(molecule)
             self.print_gradient(molecule)
-
+    
             valstr = '*** Time spent in gradient calculation: '
             valstr += '{:.2f} sec ***'.format(tm.time() - start_time)
             self.ostream.print_header(valstr)
@@ -205,8 +206,8 @@ class TdhfGradientDriver(GradientDriver):
             rel_dm_ao = orbrsp_results['relaxed_density_ao']
 
             # analytical gradient
-            self.gradient = np.zeros((natm, 3))
-            # self.gradient = self.grad_nuc_contrib(molecule)
+            # self.gradient = np.zeros((natm, 3))
+            self.gradient = self.grad_nuc_contrib(molecule)
 
             # loop over atoms and contract integral derivatives with density matrices
             # add the corresponding contribution to the gradient
@@ -216,14 +217,14 @@ class TdhfGradientDriver(GradientDriver):
                 d_fock = fock_deriv(molecule, basis, gs_dm, i)
                 d_eri = eri_deriv(molecule, basis, i)
 
-                self.gradient[i] += ( #np.einsum('mn,xmn->x', 2.0 * gs_dm + rel_dm_ao, d_fock)
+                self.gradient[i] += ( np.einsum('mn,xmn->x', 2.0 * gs_dm + rel_dm_ao, d_fock)
                                  +1.0 * np.einsum('mn,xmn->x', 2.0 * omega_ao, d_ovlp)
-                                 #-2.0 * np.einsum('mt,np,xmtnp->x', gs_dm, gs_dm, d_eri)
-                                 #+1.0 * np.einsum('mt,np,xmnpt->x', gs_dm, gs_dm, d_eri)
-                                 #+1.0 * np.einsum('mn,pt,xtpmn->x', xpy, xpy - xpy.T, d_eri)
-                                 #-0.5 * np.einsum('mn,pt,xtnmp->x', xpy, xpy - xpy.T, d_eri)
-                                 #+1.0 * np.einsum('mn,pt,xtpmn->x', xmy, xmy + xmy.T, d_eri)
-                                 #-0.5 * np.einsum('mn,pt,xtnmp->x', xmy, xmy + xmy.T, d_eri)
+                                 -2.0 * np.einsum('mt,np,xmtnp->x', gs_dm, gs_dm, d_eri)
+                                 +1.0 * np.einsum('mt,np,xmnpt->x', gs_dm, gs_dm, d_eri)
+                                 +1.0 * np.einsum('mn,pt,xtpmn->x', xpy, xpy - xpy.T, d_eri)
+                                 -0.5 * np.einsum('mn,pt,xtnmp->x', xpy, xpy - xpy.T, d_eri)
+                                 +1.0 * np.einsum('mn,pt,xtpmn->x', xmy, xmy + xmy.T, d_eri)
+                                 -0.5 * np.einsum('mn,pt,xtnmp->x', xmy, xmy + xmy.T, d_eri)
                                 )
 
 
@@ -246,7 +247,7 @@ class TdhfGradientDriver(GradientDriver):
             if 'relaxed_density_ao' in orbrsp_results:
                 rel_density = (scf_tensors['D'][0] + scf_tensors['D'][1] +
                                orbrsp_results['relaxed_density_ao'])
-                # TODO: consider computing the relaxed dipole moment in parallel?
+                # TODO: consider computing the relaxed dipole moment in parallel? 
                 firstorderprop.compute(molecule, basis, rel_density)
                 self.relaxed_dipole_moment = firstorderprop.get_property('dipole moment')
 
@@ -298,8 +299,6 @@ class TdhfGradientDriver(GradientDriver):
             exc_en = None
         exc_en = self.comm.bcast(exc_en, root=mpi_master())
     
-        #print("Compute energy: \n", scf_tensors)
-
         return self.scf_drv.get_scf_energy() + exc_en
 
     def restore_drivers(self, molecule, ostream_state, basis, rsp_drv,
@@ -312,128 +311,128 @@ class TdhfGradientDriver(GradientDriver):
         self.scf_drv.compute(molecule, basis, min_basis)
         self.scf_drv.ostream.state = ostream_state
 
-# TODO: delete the commented out code; numerical gradient is now included
-# in gradientdriver
-#    def compute_numerical(self, molecule, ao_basis, rsp_drv, min_basis=None):
-#        """
-#        Performs calculation of numerical gradient at RPA or TDA level.
-#
-#        :param molecule:
-#            The molecule.
-#        :param ao_basis:
-#            The AO basis set.
-#        :param rsp_drv:
-#            The RPA or TDA driver.
-#        :param min_basis:
-#            The minimal AO basis set.
-#        """
-#
-#        # self.scf_drv = scf_drv
-#        scf_ostream_state = self.scf_drv.ostream.state
-#        self.scf_drv.ostream.state = False
-#
-#        # atom labels
-#        labels = molecule.get_labels()
-#
-#        # atom coordinates (nx3)
-#        coords = molecule.get_coordinates()
-#
-#        # number of atoms
-#        natm = molecule.number_of_atoms()
-#
-#        if self.rank == mpi_master():
-#            # numerical gradient
-#            self.gradient = np.zeros((natm, 3))
-#        else:
-#            self.gradient = None
-#
-#        if not self.do_four_point:
-#            for i in range(natm):
-#                for d in range(3):
-#                    coords[i, d] += self.delta_h
-#                    new_mol = Molecule(labels, coords, units='au')
-#                    self.scf_drv.compute(new_mol, ao_basis, min_basis)
-#                    scf_tensors = self.scf_drv.scf_tensors
-#                    rsp_drv.is_converged = False  # only needed for RPA
-#                    rsp_results = rsp_drv.compute(new_mol, ao_basis,
-#                                                       scf_tensors)
-#                    if self.rank == mpi_master():
-#                        exc_en_plus = rsp_results['eigenvalues'][self.state_deriv_index]
-#                        e_plus = self.scf_drv.get_scf_energy() + exc_en_plus
-#
-#                    coords[i, d] -= 2.0 * self.delta_h
-#                    new_mol = Molecule(labels, coords, units='au')
-#                    self.scf_drv.compute(new_mol, ao_basis, min_basis)
-#                    rsp_drv.is_converged = False
-#                    rsp_results = rsp_drv.compute(new_mol, ao_basis,
-#                                                       self.scf_drv.scf_tensors)
-#                    if self.rank == mpi_master():
-#                        exc_en_minus = rsp_results['eigenvalues'][self.state_deriv_index]
-#                        e_minus = self.scf_drv.get_scf_energy() + exc_en_minus
-#
-#                        self.gradient[i, d] = (e_plus - e_minus) / (2.0 * self.delta_h)
-#
-#                    coords[i, d] += self.delta_h
-#
-#        else:
-#            # Four-point numerical derivative approximation
-#            # for debugging of analytical gradient:
-#            # [ f(x - 2h) - 8 f(x - h) + 8 f(x + h) - f(x + 2h) ] / ( 12h )
-#            for i in range(natm):
-#                for d in range(3):
-#                    coords[i, d] += self.delta_h
-#                    new_mol = Molecule(labels, coords, units='au')
-#                    self.scf_drv.compute(new_mol, ao_basis, min_basis)
-#                    scf_tensors = self.scf_drv.scf_tensors
-#                    rsp_drv.is_converged = False  # only needed for RPA
-#                    rsp_results = rsp_drv.compute(new_mol, ao_basis,
-#                                                       scf_tensors)
-#                    if self.rank == mpi_master():
-#                        exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
-#                        e_plus1 = self.scf_drv.get_scf_energy() + exc_en
-#
-#                    coords[i, d] += self.delta_h
-#                    new_mol = Molecule(labels, coords, units='au')
-#                    self.scf_drv.compute(new_mol, ao_basis, min_basis)
-#                    scf_tensors = self.scf_drv.scf_tensors
-#                    rsp_drv.is_converged = False  # only needed for RPA
-#                    rsp_results = rsp_drv.compute(new_mol, ao_basis,
-#                                                       scf_tensors)
-#                    if self.rank == mpi_master():
-#                        exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
-#                        e_plus2 = self.scf_drv.get_scf_energy() + exc_en
-#
-#                    coords[i, d] -= 3.0 * self.delta_h
-#                    new_mol = Molecule(labels, coords, units='au')
-#                    self.scf_drv.compute(new_mol, ao_basis, min_basis)
-#                    rsp_drv.is_converged = False
-#                    rsp_results = rsp_drv.compute(new_mol, ao_basis,
-#                                                       self.scf_drv.scf_tensors)
-#                    if self.rank == mpi_master():
-#                        exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
-#                        e_minus1 = self.scf_drv.get_scf_energy() + exc_en
-#
-#                    coords[i, d] -= self.delta_h
-#                    new_mol = Molecule(labels, coords, units='au')
-#                    self.scf_drv.compute(new_mol, ao_basis, min_basis)
-#                    rsp_drv.is_converged = False
-#                    rsp_results = rsp_drv.compute(new_mol, ao_basis,
-#                                                       self.scf_drv.scf_tensors)
-#                    if self.rank == mpi_master():
-#                        exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
-#                        e_minus2 = self.scf_drv.get_scf_energy() + exc_en
-#
-#                        # f'(x) ~ [ f(x - 2h) - 8 f(x - h) + 8 f(x + h) - f(x + 2h) ] / ( 12h )
-#                        self.gradient[i, d] = (e_minus2 - 8.0 * e_minus1
-#                                               + 8.0 * e_plus1 - e_plus2) / (12.0 * self.delta_h)
-#
-#                    coords[i, d] += 2.0 * self.delta_h
-#
-#
-#        self.ostream.print_blank()
-#
-#        self.scf_drv.compute(molecule, ao_basis, min_basis)
-#        self.scf_drv.ostream.state = scf_ostream_state
+    # TODO: delete commented out code; numerical gradient is included in
+    # gradientdriver.
+    #def compute_numerical(self, molecule, ao_basis, rsp_drv, min_basis=None):
+    #    """
+    #    Performs calculation of numerical gradient at RPA or TDA level.
+
+    #    :param molecule:
+    #        The molecule.
+    #    :param ao_basis:
+    #        The AO basis set.
+    #    :param rsp_drv:
+    #        The RPA or TDA driver.
+    #    :param min_basis:
+    #        The minimal AO basis set.
+    #    """
+
+    #    # self.scf_drv = scf_drv
+    #    scf_ostream_state = self.scf_drv.ostream.state
+    #    self.scf_drv.ostream.state = False
+
+    #    # atom labels
+    #    labels = molecule.get_labels()
+
+    #    # atom coordinates (nx3)
+    #    coords = molecule.get_coordinates()
+
+    #    # number of atoms
+    #    natm = molecule.number_of_atoms()
+
+    #    if self.rank == mpi_master():
+    #        # numerical gradient
+    #        self.gradient = np.zeros((natm, 3))
+    #    else:
+    #        self.gradient = None
+
+    #    if not self.do_four_point:
+    #        for i in range(natm):
+    #            for d in range(3):
+    #                coords[i, d] += self.delta_h
+    #                new_mol = Molecule(labels, coords, units='au')
+    #                self.scf_drv.compute(new_mol, ao_basis, min_basis)
+    #                scf_tensors = self.scf_drv.scf_tensors
+    #                rsp_drv.is_converged = False  # only needed for RPA
+    #                rsp_results = rsp_drv.compute(new_mol, ao_basis,
+    #                                                   scf_tensors)
+    #                if self.rank == mpi_master():
+    #                    exc_en_plus = rsp_results['eigenvalues'][self.state_deriv_index]
+    #                    e_plus = self.scf_drv.get_scf_energy() + exc_en_plus
+
+    #                coords[i, d] -= 2.0 * self.delta_h
+    #                new_mol = Molecule(labels, coords, units='au')
+    #                self.scf_drv.compute(new_mol, ao_basis, min_basis)
+    #                rsp_drv.is_converged = False
+    #                rsp_results = rsp_drv.compute(new_mol, ao_basis,
+    #                                                   self.scf_drv.scf_tensors)
+    #                if self.rank == mpi_master():
+    #                    exc_en_minus = rsp_results['eigenvalues'][self.state_deriv_index]
+    #                    e_minus = self.scf_drv.get_scf_energy() + exc_en_minus
+
+    #                    self.gradient[i, d] = (e_plus - e_minus) / (2.0 * self.delta_h)
+
+    #                coords[i, d] += self.delta_h
+
+    #    else:
+    #        # Four-point numerical derivative approximation
+    #        # for debugging of analytical gradient:
+    #        # [ f(x - 2h) - 8 f(x - h) + 8 f(x + h) - f(x + 2h) ] / ( 12h )
+    #        for i in range(natm):
+    #            for d in range(3):
+    #                coords[i, d] += self.delta_h
+    #                new_mol = Molecule(labels, coords, units='au')
+    #                self.scf_drv.compute(new_mol, ao_basis, min_basis)
+    #                scf_tensors = self.scf_drv.scf_tensors
+    #                rsp_drv.is_converged = False  # only needed for RPA
+    #                rsp_results = rsp_drv.compute(new_mol, ao_basis,
+    #                                                   scf_tensors)
+    #                if self.rank == mpi_master():
+    #                    exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
+    #                    e_plus1 = self.scf_drv.get_scf_energy() + exc_en
+
+    #                coords[i, d] += self.delta_h
+    #                new_mol = Molecule(labels, coords, units='au')
+    #                self.scf_drv.compute(new_mol, ao_basis, min_basis)
+    #                scf_tensors = self.scf_drv.scf_tensors
+    #                rsp_drv.is_converged = False  # only needed for RPA
+    #                rsp_results = rsp_drv.compute(new_mol, ao_basis,
+    #                                                   scf_tensors)
+    #                if self.rank == mpi_master():
+    #                    exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
+    #                    e_plus2 = self.scf_drv.get_scf_energy() + exc_en
+
+    #                coords[i, d] -= 3.0 * self.delta_h
+    #                new_mol = Molecule(labels, coords, units='au')
+    #                self.scf_drv.compute(new_mol, ao_basis, min_basis)
+    #                rsp_drv.is_converged = False
+    #                rsp_results = rsp_drv.compute(new_mol, ao_basis,
+    #                                                   self.scf_drv.scf_tensors)
+    #                if self.rank == mpi_master():
+    #                    exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
+    #                    e_minus1 = self.scf_drv.get_scf_energy() + exc_en
+
+    #                coords[i, d] -= self.delta_h
+    #                new_mol = Molecule(labels, coords, units='au')
+    #                self.scf_drv.compute(new_mol, ao_basis, min_basis)
+    #                rsp_drv.is_converged = False
+    #                rsp_results = rsp_drv.compute(new_mol, ao_basis,
+    #                                                   self.scf_drv.scf_tensors)
+    #                if self.rank == mpi_master():
+    #                    exc_en = rsp_results['eigenvalues'][self.state_deriv_index]
+    #                    e_minus2 = self.scf_drv.get_scf_energy() + exc_en
+
+    #                    # f'(x) ~ [ f(x - 2h) - 8 f(x - h) + 8 f(x + h) - f(x + 2h) ] / ( 12h )
+    #                    self.gradient[i, d] = (e_minus2 - 8.0 * e_minus1
+    #                                           + 8.0 * e_plus1 - e_plus2) / (12.0 * self.delta_h)
+
+    #                coords[i, d] += 2.0 * self.delta_h
+
+
+    #    self.ostream.print_blank()
+
+    #    self.scf_drv.compute(molecule, ao_basis, min_basis)
+    #    self.scf_drv.ostream.state = scf_ostream_state
 
     def compute_numerical_dipole(self, molecule, ao_basis, rsp_drv,
                                  field_strength=1e-5, min_basis=None):
diff --git a/src/pymodule/xtbhessiandriver.py b/src/pymodule/xtbhessiandriver.py
index cfd7e9dc..70e08426 100644
--- a/src/pymodule/xtbhessiandriver.py
+++ b/src/pymodule/xtbhessiandriver.py
@@ -131,9 +131,6 @@ class XTBHessianDriver(HessianDriver):
             The minimal AO basis set.
         """
 
-        # settings dictionary for gradient driver
-        grad_dict = dict(self.freq_dict)
-
         #TODO -- check if working
         xtb_ostream_state = self.ostream.state
         self.ostream.state = False
@@ -209,7 +206,7 @@ class XTBHessianDriver(HessianDriver):
                     new_mol = Molecule(labels, coords, units='au')
                     xtb_drv = XTBDriver(self.comm)
                     xtb_drv.compute(new_mol, self.ostream)
- 
+
                     grad_minus1 = xtb_drv.get_gradient()
 
                     mu_minus1 = xtb_drv.get_dipole()
