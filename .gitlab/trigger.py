#!/usr/bin/env python3

import argparse
import hashlib
import json
import os
import re
from datetime import datetime
from pathlib import Path
from subprocess import PIPE, run

from requests import post


def main():

    parser = argparse.ArgumentParser(
        description="Prepare JSON payload for HTTP request."
    )

    parser.add_argument(
        "--tarball",
        dest="tarball",
        action="store",
        type=str,
        required=True,
        help="location of tarball",
    )
    parser.add_argument(
        "--url",
        dest="url",
        action="store",
        type=str,
        required=True,
        help="URL of tarball",
    )
    # the commit description defaults to CI_COMMIT_DESCRIPTION
    parser.add_argument(
        "--commit",
        dest="commit",
        action="store",
        type=str,
        default=os.getenv("CI_COMMIT_DESCRIPTION", ""),
        help="commit description",
    )
    # the location of the file containing __version__ defaults to src/pymodule/__init__.py
    parser.add_argument(
        "--version_file",
        dest="vfile",
        action="store",
        type=Path,
        default=(Path(__file__).parents[1] / "src/pymodule/__init__.py").resolve(),
        help="absolute path to the file where __version__ is defined",
    )
    # the location of the Python modules in the project defaults to src/pymodule
    parser.add_argument(
        "--pymodules",
        dest="pymods",
        action="store",
        type=Path,
        default=(Path(__file__).parents[1] / "src/pymodule").resolve(),
        help="absolute path to the folder containing the Python modules in the project",
    )

    args = parser.parse_args()

    tarball = Path(args.tarball).resolve()

    # get recipe name from tarball
    recipe = tarball.name.split(".")[0]

    # get sha256 of tarball
    # we read the tarball in as binary in chunks of 8192 bytes
    with tarball.open("rb") as fh:
        algo = hashlib.sha256()
        chunk = fh.read(8192)
        while chunk:
            algo.update(chunk)
            chunk = fh.read(8192)

    sha256 = algo.hexdigest()
    print(f"Tarball {tarball} with sha256 checksum {sha256}")

    # parse commit message, the configuration is expected in dict-like format
    msg = re.search(
        r"package\s*=\s*{(?P<content>.*)}", args.commit, re.MULTILINE | re.DOTALL
    )
    known_keys = ["channel", "label", "build", "version"]
    # create configuration dictionary, filter out unknown keys
    conf = (
        {
            m.group("key"): str(m.group("value"))
            for m in re.finditer(
                r"[\"\'](?P<key>\S+)[\"\']\s*:\s*[\"\'](?P<value>\S+)[\"\']",
                msg.group("content"),
                re.MULTILINE | re.DOTALL,
            )
            if m.group("key") in known_keys
        }
        if msg is not None
        else {}
    )
    if conf:
        print(f"Additional configuration from commit description:\n {conf}")
    else:
        print(f"No additional configuration from commit description")

    # read contents of file where __version__ is defined
    vfile = args.vfile
    with vfile.open("r") as f:
        contents = f.read()

    version = ""
    regex = r"(?P<pre>__version__ = [\"\'])(?P<version>.*)(?P<post>[\"\'])"
    if "version" not in conf.keys():
        # get version from __init__.py
        ret = re.search(regex, contents)
        if ret is not None:
            # get predefined version
            version = ret.group("version")
    else:
        # we generate a patch to be applied before building the recipe
        # to fix the version of the package
        with vfile.open("w") as f:
            f.write(re.sub(regex, f"\\g<pre>{conf['version']}\\g<post>", contents))

    # build number as string
    build_number = str(0)
    if "build" in conf.keys():
        build_number = conf["build"]

    # append dictionary with information on deployment
    deploy = {
        "timestamp": datetime.now().astimezone().strftime("%A %Y-%m-%d %H:%M:%S %Z"),
        "author": os.getenv("GITLAB_USER_NAME", ""),
        "commit": os.getenv("CI_COMMIT_SHA", ""),
        "build": build_number,
    }
    with vfile.open("a") as f:
        f.write(
            f"\n# autogenerated information on deployment\n__deployed__ = {json.dumps(deploy, indent=2, sort_keys=True)}\n"
        )

    # set permissions to 644 for all Python files in project
    _ = [
        _.chmod(0o644)
        for _ in args.pymods.iterdir()
        if (_.is_file() and _.suffix == ".py")
    ]

    # call git diff
    p = run(
        ["git", "diff", str(vfile)],
        stdout=PIPE,
        stderr=PIPE,
        check=True,
        encoding="ascii",
    )
    # the patch is in the stdout
    version_patch = p.stdout

    # inputs with defaults
    inputs = {
        "recipe": recipe,
        "url": args.url,
        "sha256": sha256,
        "version": version,
        "build": build_number,
        "channel": "veloxchem",
        "label": os.getenv("CI_COMMIT_BRANCH"),
        "patch": version_patch,
    }
    # update inputs with configuration from commit message
    inputs.update(conf)

    # prepare payload
    payload = {
        "ref": "refs/heads/main",
        "inputs": inputs,
    }

    # get GitHub PAT
    gh_pat = os.getenv("GITHUB_PAT")
    r = post(
        "https://api.github.com/repos/ENCCS/meta-vlx/actions/workflows/deploy-cxx.yml/dispatches",
        auth=("robertodr", gh_pat),
        headers={"Accept": "application/vnd.github.v3+json"},
        data=json.dumps(payload),
    )

    print(f"POST request payload\n{payload}")
    if r.status_code == 204:
        print(f"POST request SUCCEEDED!")
    else:
        raise RuntimeError(f"POST request FAILED!\n{r.text}")


if __name__ == "__main__":
    main()
